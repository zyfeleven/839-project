{
    "name": "doccano-master",
    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master",
    "is_dir": true,
    "code_elements": [],
    "code": "",
    "summary": "The ExportedBoundingBox class is a proxy model that allows for the conversion of bounding box annotations into dictionary and tuple formats.",
    "code_element_summaries": [],
    "children": [
        {
            "name": "backend",
            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend",
            "is_dir": true,
            "code_elements": [],
            "code": "",
            "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that enables the conversion of bounding box annotations into dictionary and tuple formats.",
            "code_element_summaries": [],
            "children": [
                {
                    "name": "api",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox with functions to convert bounding box annotations into dictionary and tuple forms.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ApiConfig`\nCode:\nclass ApiConfig(AppConfig):\n    name = \"api\"\n    verbose_name = \"Api\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass ApiConfig(AppConfig):\n    name = \"api\"\n    verbose_name = \"Api\"\n",
                            "summary": "Class ApiConfig: A configuration class for the \"api\" app with a verbose name of \"Api\".",
                            "code_element_summaries": [
                                "Class ApiConfig: A configuration class for the \"api\" app with a verbose name of \"Api\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "management",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Command: A subclass of createsuperuser.Command that enables non-interactive creation of admin users with password validation and customization options, as well as functions for handling user input.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "commands",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management\\commands",
                                    "is_dir": true,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "Class Command: A subclass of createsuperuser.Command that allows for non-interactive creation of admin users with password validation and customization options, along with functions for handling user input. \n\nClass Command: A custom management command for checking database availability with specified polling intervals and maximum retry attempts, including functions for adding command line arguments and handling database connection attempts.",
                                    "code_element_summaries": [],
                                    "children": [
                                        {
                                            "name": "create_admin.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management\\commands\\create_admin.py",
                                            "is_dir": false,
                                            "code_elements": [
                                                "Class `Command`\nCode:\nclass Command(createsuperuser.Command):\n    help = \"Non-interactively create an admin user\"\n\n    def add_arguments(self, parser):\n        super().add_arguments(parser)\n        parser.add_argument(\"--password\", default=None, help=\"The password for the admin.\")\n\n    def handle(self, *args, **options):\n        password = options.get(\"password\")\n        username = options.get(\"username\")\n\n        if not username:\n            self.stderr.write(\"Error: Blank username isn't allowed.\")\n            raise CommandError(\"--username is required if specifying --password\")\n\n        if not password:\n            self.stderr.write(\"Error: Blank password isn't allowed.\")\n            raise CommandError(\"--password is required\")\n\n        if password == \"password\":\n            self.stdout.write(self.style.WARNING(\"Warning: You should change the default password.\"))\n\n        try:\n            super().handle(*args, **options)\n        except Exception as err:\n            if \"is already taken\" in str(err):\n                self.stderr.write(f\"User {username} already exists.\")\n            else:\n                raise\n\n        database = options.get(\"database\")\n        db = self.UserModel._default_manager.db_manager(database)\n        user = db.get(username=username)\n        user.set_password(password)\n        message = f\"Setting password for User {username}.\"\n        self.stdout.write(self.style.SUCCESS(message))\n        user.save()",
                                                "Function `add_arguments`\nCode:\n    def add_arguments(self, parser):\n        super().add_arguments(parser)\n        parser.add_argument(\"--password\", default=None, help=\"The password for the admin.\")",
                                                "Function `handle`\nCode:\n    def handle(self, *args, **options):\n        password = options.get(\"password\")\n        username = options.get(\"username\")\n\n        if not username:\n            self.stderr.write(\"Error: Blank username isn't allowed.\")\n            raise CommandError(\"--username is required if specifying --password\")\n\n        if not password:\n            self.stderr.write(\"Error: Blank password isn't allowed.\")\n            raise CommandError(\"--password is required\")\n\n        if password == \"password\":\n            self.stdout.write(self.style.WARNING(\"Warning: You should change the default password.\"))\n\n        try:\n            super().handle(*args, **options)\n        except Exception as err:\n            if \"is already taken\" in str(err):\n                self.stderr.write(f\"User {username} already exists.\")\n            else:\n                raise\n\n        database = options.get(\"database\")\n        db = self.UserModel._default_manager.db_manager(database)\n        user = db.get(username=username)\n        user.set_password(password)\n        message = f\"Setting password for User {username}.\"\n        self.stdout.write(self.style.SUCCESS(message))\n        user.save()"
                                            ],
                                            "code": "from django.contrib.auth.management.commands import createsuperuser\nfrom django.core.management import CommandError\n\n\nclass Command(createsuperuser.Command):\n    help = \"Non-interactively create an admin user\"\n\n    def add_arguments(self, parser):\n        super().add_arguments(parser)\n        parser.add_argument(\"--password\", default=None, help=\"The password for the admin.\")\n\n    def handle(self, *args, **options):\n        password = options.get(\"password\")\n        username = options.get(\"username\")\n\n        if not username:\n            self.stderr.write(\"Error: Blank username isn't allowed.\")\n            raise CommandError(\"--username is required if specifying --password\")\n\n        if not password:\n            self.stderr.write(\"Error: Blank password isn't allowed.\")\n            raise CommandError(\"--password is required\")\n\n        if password == \"password\":\n            self.stdout.write(self.style.WARNING(\"Warning: You should change the default password.\"))\n\n        try:\n            super().handle(*args, **options)\n        except Exception as err:\n            if \"is already taken\" in str(err):\n                self.stderr.write(f\"User {username} already exists.\")\n            else:\n                raise\n\n        database = options.get(\"database\")\n        db = self.UserModel._default_manager.db_manager(database)\n        user = db.get(username=username)\n        user.set_password(password)\n        message = f\"Setting password for User {username}.\"\n        self.stdout.write(self.style.SUCCESS(message))\n        user.save()\n",
                                            "summary": "Class Command: A subclass of createsuperuser.Command that enables non-interactive creation of admin users with password validation and customization options, with functions for adding arguments and handling user input.",
                                            "code_element_summaries": [
                                                "Class Command: A subclass of createsuperuser.Command that allows for non-interactive creation of an admin user with password validation and customization options.",
                                                "Function `add_arguments`: Adds an argument for the admin password to the parser.",
                                                "Function `handle`: A method that handles user input for username and password, performs validations, and sets a new password for a specified user in the database."
                                            ],
                                            "children": []
                                        },
                                        {
                                            "name": "wait_for_db.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management\\commands\\wait_for_db.py",
                                            "is_dir": false,
                                            "code_elements": [
                                                "Class `Command`\nCode:\nclass Command(BaseCommand):\n    help = \"Blocks until the database is available\"\n\n    def add_arguments(self, parser):\n        parser.add_argument(\"--poll_seconds\", type=float, default=3)\n        parser.add_argument(\"--max_retries\", type=int, default=60)\n\n    def handle(self, *args, **options):\n        max_retries = options[\"max_retries\"]\n        poll_seconds = options[\"poll_seconds\"]\n\n        for retry in range(max_retries):\n            try:\n                connection.ensure_connection()\n            except OperationalError as ex:\n                self.stdout.write(\n                    \"Database unavailable on attempt {attempt}/{max_retries}:\"\n                    \" {error}\".format(attempt=retry + 1, max_retries=max_retries, error=ex)\n                )\n                time.sleep(poll_seconds)\n            else:\n                break\n        else:\n            self.stdout.write(self.style.ERROR(\"Database unavailable\"))\n            sys.exit(1)",
                                                "Function `add_arguments`\nCode:\n    def add_arguments(self, parser):\n        parser.add_argument(\"--poll_seconds\", type=float, default=3)\n        parser.add_argument(\"--max_retries\", type=int, default=60)",
                                                "Function `handle`\nCode:\n    def handle(self, *args, **options):\n        max_retries = options[\"max_retries\"]\n        poll_seconds = options[\"poll_seconds\"]\n\n        for retry in range(max_retries):\n            try:\n                connection.ensure_connection()\n            except OperationalError as ex:\n                self.stdout.write(\n                    \"Database unavailable on attempt {attempt}/{max_retries}:\"\n                    \" {error}\".format(attempt=retry + 1, max_retries=max_retries, error=ex)\n                )\n                time.sleep(poll_seconds)\n            else:\n                break\n        else:\n            self.stdout.write(self.style.ERROR(\"Database unavailable\"))\n            sys.exit(1)"
                                            ],
                                            "code": "import sys\nimport time\n\nfrom django.core.management.base import BaseCommand\nfrom django.db import connection\nfrom django.db.utils import OperationalError\n\n\nclass Command(BaseCommand):\n    help = \"Blocks until the database is available\"\n\n    def add_arguments(self, parser):\n        parser.add_argument(\"--poll_seconds\", type=float, default=3)\n        parser.add_argument(\"--max_retries\", type=int, default=60)\n\n    def handle(self, *args, **options):\n        max_retries = options[\"max_retries\"]\n        poll_seconds = options[\"poll_seconds\"]\n\n        for retry in range(max_retries):\n            try:\n                connection.ensure_connection()\n            except OperationalError as ex:\n                self.stdout.write(\n                    \"Database unavailable on attempt {attempt}/{max_retries}:\"\n                    \" {error}\".format(attempt=retry + 1, max_retries=max_retries, error=ex)\n                )\n                time.sleep(poll_seconds)\n            else:\n                break\n        else:\n            self.stdout.write(self.style.ERROR(\"Database unavailable\"))\n            sys.exit(1)\n",
                                            "summary": "Class Command: A custom management command for checking database availability with specified polling intervals and maximum retry attempts, including functions for adding command line arguments and handling database connection attempts.",
                                            "code_element_summaries": [
                                                "Class `Command`: A custom management command that continuously checks for database availability with specified polling intervals and maximum retry attempts.",
                                                "Function `add_arguments`: Adds command line arguments for polling frequency and maximum number of retries with default values.",
                                                "Function `handle`: A function that attempts to establish a database connection with a specified number of retries and polling intervals."
                                            ],
                                            "children": []
                                        },
                                        {
                                            "name": "__init__.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management\\commands\\__init__.py",
                                            "is_dir": false,
                                            "code_elements": [],
                                            "code": "",
                                            "summary": "The content provides a proxy model ExportedBoundingBox with methods to convert bounding box annotations into dictionary and tuple forms.",
                                            "code_element_summaries": [],
                                            "children": []
                                        }
                                    ]
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a proxy model called ExportedBoundingBox that represents bounding box annotations in dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "middleware.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\middleware.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RangesMiddleware`: Quick solution. See:\nCode:\nclass RangesMiddleware(MiddlewareMixin):\n    \"\"\"Quick solution. See:\n    https://stackoverflow.com/questions/14324250/byte-ranges-in-django/35928017#35928017\n    \"\"\"\n\n    def process_response(self, request, response):\n        if response.status_code != 200 or not hasattr(response, \"file_to_stream\"):\n            return response\n        http_range = request.META.get(\"HTTP_RANGE\")\n        if not (http_range and http_range.startswith(\"bytes=\") and http_range.count(\"-\") == 1):\n            return response\n        if_range = request.META.get(\"HTTP_IF_RANGE\")\n        if if_range and if_range != response.get(\"Last-Modified\") and if_range != response.get(\"ETag\"):\n            return response\n        f = response.file_to_stream\n        statobj = os.fstat(f.fileno())\n        start, end = http_range.split(\"=\")[1].split(\"-\")\n        if not start:  # requesting the last N bytes\n            start = max(0, statobj.st_size - int(end))\n            end = \"\"\n        start, end = int(start or 0), int(end or statobj.st_size - 1)\n        assert 0 <= start < statobj.st_size, (start, statobj.st_size)\n        end = min(end, statobj.st_size - 1)\n        f.seek(start)\n        old_read = f.read\n        f.read = lambda n: old_read(min(n, end + 1 - f.tell()))\n        response.status_code = 206\n        response[\"Content-Length\"] = end + 1 - start\n        response[\"Content-Range\"] = \"bytes %d-%d/%d\" % (start, end, statobj.st_size)\n        return response",
                                "Function `process_response`\nCode:\n    def process_response(self, request, response):\n        if response.status_code != 200 or not hasattr(response, \"file_to_stream\"):\n            return response\n        http_range = request.META.get(\"HTTP_RANGE\")\n        if not (http_range and http_range.startswith(\"bytes=\") and http_range.count(\"-\") == 1):\n            return response\n        if_range = request.META.get(\"HTTP_IF_RANGE\")\n        if if_range and if_range != response.get(\"Last-Modified\") and if_range != response.get(\"ETag\"):\n            return response\n        f = response.file_to_stream\n        statobj = os.fstat(f.fileno())\n        start, end = http_range.split(\"=\")[1].split(\"-\")\n        if not start:  # requesting the last N bytes\n            start = max(0, statobj.st_size - int(end))\n            end = \"\"\n        start, end = int(start or 0), int(end or statobj.st_size - 1)\n        assert 0 <= start < statobj.st_size, (start, statobj.st_size)\n        end = min(end, statobj.st_size - 1)\n        f.seek(start)\n        old_read = f.read\n        f.read = lambda n: old_read(min(n, end + 1 - f.tell()))\n        response.status_code = 206\n        response[\"Content-Length\"] = end + 1 - start\n        response[\"Content-Range\"] = \"bytes %d-%d/%d\" % (start, end, statobj.st_size)\n        return response",
                                "Function `to_django_header`\nCode:\ndef to_django_header(header):\n    return f\"HTTP_{header.replace('-', '_').upper()}\"",
                                "Class `HeaderAuthMiddleware`\nCode:\nclass HeaderAuthMiddleware(RemoteUserMiddleware):\n    header = to_django_header(settings.HEADER_AUTH_USER_NAME)\n\n    def process_request(self, request):\n        if request.user.is_authenticated:\n            return\n\n        username = request.META.get(self.header)\n        if not username:\n            return\n\n        super().process_request(request)\n        self.process_user_groups(request.user, request.META)\n\n    @classmethod\n    def process_user_groups(cls, user, headers):\n        if not user.is_authenticated:\n            return\n\n        groups = cls.parse_user_groups_from_header(headers)\n\n        is_superuser = settings.HEADER_AUTH_ADMIN_GROUP_NAME in groups\n        if user.is_superuser != is_superuser:\n            user.is_superuser = is_superuser\n            user.save()\n\n    @classmethod\n    def parse_user_groups_from_header(cls, headers):\n        try:\n            groups_header = headers[to_django_header(settings.HEADER_AUTH_USER_GROUPS)]\n        except KeyError:\n            return []\n        else:\n            return groups_header.split(settings.HEADER_AUTH_GROUPS_SEPERATOR)",
                                "Function `process_request`\nCode:\n    def process_request(self, request):\n        if request.user.is_authenticated:\n            return\n\n        username = request.META.get(self.header)\n        if not username:\n            return\n\n        super().process_request(request)\n        self.process_user_groups(request.user, request.META)",
                                "Function `process_user_groups`\nCode:\n    def process_user_groups(cls, user, headers):\n        if not user.is_authenticated:\n            return\n\n        groups = cls.parse_user_groups_from_header(headers)\n\n        is_superuser = settings.HEADER_AUTH_ADMIN_GROUP_NAME in groups\n        if user.is_superuser != is_superuser:\n            user.is_superuser = is_superuser\n            user.save()",
                                "Function `parse_user_groups_from_header`\nCode:\n    def parse_user_groups_from_header(cls, headers):\n        try:\n            groups_header = headers[to_django_header(settings.HEADER_AUTH_USER_GROUPS)]\n        except KeyError:\n            return []\n        else:\n            return groups_header.split(settings.HEADER_AUTH_GROUPS_SEPERATOR)"
                            ],
                            "code": "import os\n\nfrom django.conf import settings\nfrom django.contrib.auth.middleware import RemoteUserMiddleware\nfrom django.utils.deprecation import MiddlewareMixin\n\n\nclass RangesMiddleware(MiddlewareMixin):\n    \"\"\"Quick solution. See:\n    https://stackoverflow.com/questions/14324250/byte-ranges-in-django/35928017#35928017\n    \"\"\"\n\n    def process_response(self, request, response):\n        if response.status_code != 200 or not hasattr(response, \"file_to_stream\"):\n            return response\n        http_range = request.META.get(\"HTTP_RANGE\")\n        if not (http_range and http_range.startswith(\"bytes=\") and http_range.count(\"-\") == 1):\n            return response\n        if_range = request.META.get(\"HTTP_IF_RANGE\")\n        if if_range and if_range != response.get(\"Last-Modified\") and if_range != response.get(\"ETag\"):\n            return response\n        f = response.file_to_stream\n        statobj = os.fstat(f.fileno())\n        start, end = http_range.split(\"=\")[1].split(\"-\")\n        if not start:  # requesting the last N bytes\n            start = max(0, statobj.st_size - int(end))\n            end = \"\"\n        start, end = int(start or 0), int(end or statobj.st_size - 1)\n        assert 0 <= start < statobj.st_size, (start, statobj.st_size)\n        end = min(end, statobj.st_size - 1)\n        f.seek(start)\n        old_read = f.read\n        f.read = lambda n: old_read(min(n, end + 1 - f.tell()))\n        response.status_code = 206\n        response[\"Content-Length\"] = end + 1 - start\n        response[\"Content-Range\"] = \"bytes %d-%d/%d\" % (start, end, statobj.st_size)\n        return response\n\n\ndef to_django_header(header):\n    return f\"HTTP_{header.replace('-', '_').upper()}\"\n\n\nclass HeaderAuthMiddleware(RemoteUserMiddleware):\n    header = to_django_header(settings.HEADER_AUTH_USER_NAME)\n\n    def process_request(self, request):\n        if request.user.is_authenticated:\n            return\n\n        username = request.META.get(self.header)\n        if not username:\n            return\n\n        super().process_request(request)\n        self.process_user_groups(request.user, request.META)\n\n    @classmethod\n    def process_user_groups(cls, user, headers):\n        if not user.is_authenticated:\n            return\n\n        groups = cls.parse_user_groups_from_header(headers)\n\n        is_superuser = settings.HEADER_AUTH_ADMIN_GROUP_NAME in groups\n        if user.is_superuser != is_superuser:\n            user.is_superuser = is_superuser\n            user.save()\n\n    @classmethod\n    def parse_user_groups_from_header(cls, headers):\n        try:\n            groups_header = headers[to_django_header(settings.HEADER_AUTH_USER_GROUPS)]\n        except KeyError:\n            return []\n        else:\n            return groups_header.split(settings.HEADER_AUTH_GROUPS_SEPERATOR)\n",
                            "summary": "Class `RangesMiddleware`, `HeaderAuthMiddleware`: Middleware classes that handle byte range requests and authentication based on header values in Django, respectively, with methods for efficient processing and user permission updates.",
                            "code_element_summaries": [
                                "Class `RangesMiddleware`: A middleware class that handles byte range requests in Django with a quick solution.",
                                "Function `process_response`: A method that processes HTTP responses to handle partial content requests efficiently.",
                                "Function `to_django_header`: Converts a header string to a Django-friendly format for HTTP headers.",
                                "Class `HeaderAuthMiddleware`: Middleware class that handles authentication based on header values and updates user permissions accordingly.",
                                "Function `process_request`: A method that processes incoming requests, checks user authentication, and extracts username information from request headers.",
                                "Function `process_user_groups`: Updates the user's superuser status based on the groups parsed from headers if the user is authenticated.",
                                "Function `parse_user_groups_from_header`: Parses user groups from headers and returns them as a list."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content introduces a proxy model ExportedBoundingBox with functions to convert bounding box annotations into dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Document\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\"meta\", models.TextField(default=\"{}\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"annotations_approved_by\",\n                    models.ForeignKey(\n                        null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"DocumentAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"doc_annotations\", to=\"api.Document\"\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Label\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=\"#209cee\", max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Project\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.CharField(max_length=100)),\n                (\"description\", models.TextField(default=\"\")),\n                (\"guideline\", models.TextField(default=\"\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"project_type\",\n                    models.CharField(\n                        choices=[\n                            (\"DocumentClassification\", \"document classification\"),\n                            (\"SequenceLabeling\", \"sequence labeling\"),\n                            (\"Seq2seq\", \"sequence to sequence\"),\n                        ],\n                        max_length=30,\n                    ),\n                ),\n                (\"randomize_document_order\", models.BooleanField(default=False)),\n                (\"collaborative_annotation\", models.BooleanField(default=False)),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n        ),\n        migrations.CreateModel(\n            name=\"Role\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.CharField(max_length=100, unique=True)),\n                (\"description\", models.TextField(default=\"\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"RoleMapping\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Seq2seqAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.CharField(max_length=500)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"seq2seq_annotations\",\n                        to=\"api.Document\",\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"SequenceAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"start_offset\", models.IntegerField()),\n                (\"end_offset\", models.IntegerField()),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"seq_annotations\", to=\"api.Document\"\n                    ),\n                ),\n                (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Label\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Seq2seqProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"SequenceLabelingProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"TextClassificationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"role\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Role\"),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"user\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=settings.AUTH_USER_MODEL\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"polymorphic_ctype\",\n            field=models.ForeignKey(\n                editable=False,\n                null=True,\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"polymorphic_api.project_set+\",\n                to=\"contenttypes.ContentType\",\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"users\",\n            field=models.ManyToManyField(related_name=\"projects\", to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"label\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"labels\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"documentannotation\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Label\"),\n        ),\n        migrations.AddField(\n            model_name=\"documentannotation\",\n            name=\"user\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"document\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"documents\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"sequenceannotation\",\n            unique_together={(\"document\", \"user\", \"label\", \"start_offset\", \"end_offset\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"seq2seqannotation\",\n            unique_together={(\"document\", \"user\", \"text\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"rolemapping\",\n            unique_together={(\"user\", \"project\", \"role\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"label\",\n            unique_together={(\"project\", \"text\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"documentannotation\",\n            unique_together={(\"document\", \"user\", \"label\")},\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 2.1.7 on 2019-10-25 16:26\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Document\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\"meta\", models.TextField(default=\"{}\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"annotations_approved_by\",\n                    models.ForeignKey(\n                        null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"DocumentAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"doc_annotations\", to=\"api.Document\"\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Label\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=\"#209cee\", max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Project\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.CharField(max_length=100)),\n                (\"description\", models.TextField(default=\"\")),\n                (\"guideline\", models.TextField(default=\"\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"project_type\",\n                    models.CharField(\n                        choices=[\n                            (\"DocumentClassification\", \"document classification\"),\n                            (\"SequenceLabeling\", \"sequence labeling\"),\n                            (\"Seq2seq\", \"sequence to sequence\"),\n                        ],\n                        max_length=30,\n                    ),\n                ),\n                (\"randomize_document_order\", models.BooleanField(default=False)),\n                (\"collaborative_annotation\", models.BooleanField(default=False)),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n        ),\n        migrations.CreateModel(\n            name=\"Role\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.CharField(max_length=100, unique=True)),\n                (\"description\", models.TextField(default=\"\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"RoleMapping\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Seq2seqAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.CharField(max_length=500)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"seq2seq_annotations\",\n                        to=\"api.Document\",\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"SequenceAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"start_offset\", models.IntegerField()),\n                (\"end_offset\", models.IntegerField()),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"seq_annotations\", to=\"api.Document\"\n                    ),\n                ),\n                (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Label\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Seq2seqProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"SequenceLabelingProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"TextClassificationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"role\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Role\"),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"user\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=settings.AUTH_USER_MODEL\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"polymorphic_ctype\",\n            field=models.ForeignKey(\n                editable=False,\n                null=True,\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"polymorphic_api.project_set+\",\n                to=\"contenttypes.ContentType\",\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"users\",\n            field=models.ManyToManyField(related_name=\"projects\", to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"label\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"labels\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"documentannotation\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Label\"),\n        ),\n        migrations.AddField(\n            model_name=\"documentannotation\",\n            name=\"user\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"document\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"documents\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"sequenceannotation\",\n            unique_together={(\"document\", \"user\", \"label\", \"start_offset\", \"end_offset\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"seq2seqannotation\",\n            unique_together={(\"document\", \"user\", \"text\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"rolemapping\",\n            unique_together={(\"user\", \"project\", \"role\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"label\",\n            unique_together={(\"project\", \"text\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"documentannotation\",\n            unique_together={(\"document\", \"user\", \"label\")},\n        ),\n    ]\n",
                                    "summary": "The content defines a class ExportedBoundingBox that serves as a proxy model of BoundingBox, providing methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "0002_comment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0002_comment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Comment\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"comments\", to=\"api.Document\"\n                    ),\n                ),\n                (\n                    \"user\",\n                    models.ForeignKey(\n                        null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 2.1.11 on 2019-12-12 19:11\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Comment\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"comments\", to=\"api.Document\"\n                    ),\n                ),\n                (\n                    \"user\",\n                    models.ForeignKey(\n                        null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a new model \"Comment\" with specified fields and references.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a new model \"Comment\" with fields for text, creation and update timestamps, document and user references."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_project_single_class_classification.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0002_project_single_class_classification.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"single_class_classification\",\n            field=models.BooleanField(default=False),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 2.1.11 on 2019-12-06 08:36\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"single_class_classification\",\n            field=models.BooleanField(default=False),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class adding a boolean field for single class classification to the project model.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that adds a boolean field for single class classification to the project model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_speech2text.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0002_speech2text.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Speech2textAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.TextField()),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"speech2text_annotations\",\n                        to=\"api.Document\",\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Speech2textProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"Speech2text\", \"speech to text\"),\n                ],\n                max_length=30,\n            ),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"speech2textannotation\",\n            unique_together={(\"document\", \"user\")},\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 2.1.11 on 2019-12-11 22:11\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Speech2textAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.TextField()),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"speech2text_annotations\",\n                        to=\"api.Document\",\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Speech2textProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"Speech2text\", \"speech to text\"),\n                ],\n                max_length=30,\n            ),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"speech2textannotation\",\n            unique_together={(\"document\", \"user\")},\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class defining migration dependencies and operations for creating models related to speech-to-text annotations and projects.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that defines the dependencies and operations for creating models related to speech-to-text annotations and projects."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_merge_20200612_0205.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0003_merge_20200612_0205.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0002_speech2text\"),\n        (\"api\", \"0002_project_single_class_classification\"),\n    ]\n\n    operations = []"
                                    ],
                                    "code": "# Generated by Django 2.1.7 on 2020-06-12 02:05\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0002_speech2text\"),\n        (\"api\", \"0002_project_single_class_classification\"),\n    ]\n\n    operations = []\n",
                                    "summary": "Class Migration: Represents a migration process with dependencies on specific database changes and operations to be performed.",
                                    "code_element_summaries": [
                                        "Class Migration: Represents a migration process with dependencies on specific database changes and operations to be performed."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_merge_20210114_1117.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0004_merge_20210114_1117.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0002_comment\"),\n        (\"api\", \"0003_merge_20200612_0205\"),\n    ]\n\n    operations = []"
                                    ],
                                    "code": "# Generated by Django 3.1.5 on 2021-01-14 11:17\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0002_comment\"),\n        (\"api\", \"0003_merge_20200612_0205\"),\n    ]\n\n    operations = []\n",
                                    "summary": "Class Migration: Represents a migration operation with defined dependencies and operations.",
                                    "code_element_summaries": [
                                        "Class `Migration`: Represents a migration operation with specified dependencies and operations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_auto_20210120_1730.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0005_auto_20210120_1730.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0004_merge_20210114_1117\"),\n    ]\n\n    operations = [\n        migrations.AlterModelOptions(\n            name=\"comment\",\n            options={\"ordering\": (\"-created_at\",)},\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"suffix_key\",\n            field=models.CharField(\n                blank=True,\n                choices=[\n                    (\"0\", \"0\"),\n                    (\"1\", \"1\"),\n                    (\"2\", \"2\"),\n                    (\"3\", \"3\"),\n                    (\"4\", \"4\"),\n                    (\"5\", \"5\"),\n                    (\"6\", \"6\"),\n                    (\"7\", \"7\"),\n                    (\"8\", \"8\"),\n                    (\"9\", \"9\"),\n                    (\"a\", \"a\"),\n                    (\"b\", \"b\"),\n                    (\"c\", \"c\"),\n                    (\"d\", \"d\"),\n                    (\"e\", \"e\"),\n                    (\"f\", \"f\"),\n                    (\"g\", \"g\"),\n                    (\"h\", \"h\"),\n                    (\"i\", \"i\"),\n                    (\"j\", \"j\"),\n                    (\"k\", \"k\"),\n                    (\"l\", \"l\"),\n                    (\"m\", \"m\"),\n                    (\"n\", \"n\"),\n                    (\"o\", \"o\"),\n                    (\"p\", \"p\"),\n                    (\"q\", \"q\"),\n                    (\"r\", \"r\"),\n                    (\"s\", \"s\"),\n                    (\"t\", \"t\"),\n                    (\"u\", \"u\"),\n                    (\"v\", \"v\"),\n                    (\"w\", \"w\"),\n                    (\"x\", \"x\"),\n                    (\"y\", \"y\"),\n                    (\"z\", \"z\"),\n                ],\n                max_length=1,\n                null=True,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 2.2.13 on 2021-01-20 17:30\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0004_merge_20210114_1117\"),\n    ]\n\n    operations = [\n        migrations.AlterModelOptions(\n            name=\"comment\",\n            options={\"ordering\": (\"-created_at\",)},\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"suffix_key\",\n            field=models.CharField(\n                blank=True,\n                choices=[\n                    (\"0\", \"0\"),\n                    (\"1\", \"1\"),\n                    (\"2\", \"2\"),\n                    (\"3\", \"3\"),\n                    (\"4\", \"4\"),\n                    (\"5\", \"5\"),\n                    (\"6\", \"6\"),\n                    (\"7\", \"7\"),\n                    (\"8\", \"8\"),\n                    (\"9\", \"9\"),\n                    (\"a\", \"a\"),\n                    (\"b\", \"b\"),\n                    (\"c\", \"c\"),\n                    (\"d\", \"d\"),\n                    (\"e\", \"e\"),\n                    (\"f\", \"f\"),\n                    (\"g\", \"g\"),\n                    (\"h\", \"h\"),\n                    (\"i\", \"i\"),\n                    (\"j\", \"j\"),\n                    (\"k\", \"k\"),\n                    (\"l\", \"l\"),\n                    (\"m\", \"m\"),\n                    (\"n\", \"n\"),\n                    (\"o\", \"o\"),\n                    (\"p\", \"p\"),\n                    (\"q\", \"q\"),\n                    (\"r\", \"r\"),\n                    (\"s\", \"s\"),\n                    (\"t\", \"t\"),\n                    (\"u\", \"u\"),\n                    (\"v\", \"v\"),\n                    (\"w\", \"w\"),\n                    (\"x\", \"x\"),\n                    (\"y\", \"y\"),\n                    (\"z\", \"z\"),\n                ],\n                max_length=1,\n                null=True,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A script that modifies the model options and fields of the 'Comment' and 'Label' models in the API app.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration script that alters the model options and field of the 'Comment' and 'Label' models in the API app."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_auto_20210201_0603.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0005_auto_20210201_0603.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0004_merge_20210114_1117\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"suffix_key\",\n            field=models.CharField(\n                blank=True,\n                choices=[\n                    (\"0\", \"0\"),\n                    (\"1\", \"1\"),\n                    (\"2\", \"2\"),\n                    (\"3\", \"3\"),\n                    (\"4\", \"4\"),\n                    (\"5\", \"5\"),\n                    (\"6\", \"6\"),\n                    (\"7\", \"7\"),\n                    (\"8\", \"8\"),\n                    (\"9\", \"9\"),\n                    (\"a\", \"a\"),\n                    (\"b\", \"b\"),\n                    (\"c\", \"c\"),\n                    (\"d\", \"d\"),\n                    (\"e\", \"e\"),\n                    (\"f\", \"f\"),\n                    (\"g\", \"g\"),\n                    (\"h\", \"h\"),\n                    (\"i\", \"i\"),\n                    (\"j\", \"j\"),\n                    (\"k\", \"k\"),\n                    (\"l\", \"l\"),\n                    (\"m\", \"m\"),\n                    (\"n\", \"n\"),\n                    (\"o\", \"o\"),\n                    (\"p\", \"p\"),\n                    (\"q\", \"q\"),\n                    (\"r\", \"r\"),\n                    (\"s\", \"s\"),\n                    (\"t\", \"t\"),\n                    (\"u\", \"u\"),\n                    (\"v\", \"v\"),\n                    (\"w\", \"w\"),\n                    (\"x\", \"x\"),\n                    (\"y\", \"y\"),\n                    (\"z\", \"z\"),\n                ],\n                max_length=1,\n                null=True,\n            ),\n        ),\n        migrations.CreateModel(\n            name=\"AutoLabelingConfig\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"model_name\", models.CharField(max_length=100)),\n                (\"model_attrs\", models.JSONField(default=dict)),\n                (\"template\", models.TextField(default=\"\")),\n                (\"label_mapping\", models.JSONField(default=dict)),\n                (\"default\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"auto_labeling_config\",\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.5 on 2021-02-01 06:03\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0004_merge_20210114_1117\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"suffix_key\",\n            field=models.CharField(\n                blank=True,\n                choices=[\n                    (\"0\", \"0\"),\n                    (\"1\", \"1\"),\n                    (\"2\", \"2\"),\n                    (\"3\", \"3\"),\n                    (\"4\", \"4\"),\n                    (\"5\", \"5\"),\n                    (\"6\", \"6\"),\n                    (\"7\", \"7\"),\n                    (\"8\", \"8\"),\n                    (\"9\", \"9\"),\n                    (\"a\", \"a\"),\n                    (\"b\", \"b\"),\n                    (\"c\", \"c\"),\n                    (\"d\", \"d\"),\n                    (\"e\", \"e\"),\n                    (\"f\", \"f\"),\n                    (\"g\", \"g\"),\n                    (\"h\", \"h\"),\n                    (\"i\", \"i\"),\n                    (\"j\", \"j\"),\n                    (\"k\", \"k\"),\n                    (\"l\", \"l\"),\n                    (\"m\", \"m\"),\n                    (\"n\", \"n\"),\n                    (\"o\", \"o\"),\n                    (\"p\", \"p\"),\n                    (\"q\", \"q\"),\n                    (\"r\", \"r\"),\n                    (\"s\", \"s\"),\n                    (\"t\", \"t\"),\n                    (\"u\", \"u\"),\n                    (\"v\", \"v\"),\n                    (\"w\", \"w\"),\n                    (\"x\", \"x\"),\n                    (\"y\", \"y\"),\n                    (\"z\", \"z\"),\n                ],\n                max_length=1,\n                null=True,\n            ),\n        ),\n        migrations.CreateModel(\n            name=\"AutoLabelingConfig\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"model_name\", models.CharField(max_length=100)),\n                (\"model_attrs\", models.JSONField(default=dict)),\n                (\"template\", models.TextField(default=\"\")),\n                (\"label_mapping\", models.JSONField(default=dict)),\n                (\"default\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"auto_labeling_config\",\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class for handling database migrations and auto-labeling configuration in a Django project.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that alters the field of a model and creates a new model for auto-labeling configuration in a Django project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0006_merge_20210221_1258.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0006_merge_20210221_1258.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0005_auto_20210201_0603\"),\n        (\"api\", \"0005_auto_20210120_1730\"),\n    ]\n\n    operations = []"
                                    ],
                                    "code": "# Generated by Django 3.1.6 on 2021-02-21 12:58\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0005_auto_20210201_0603\"),\n        (\"api\", \"0005_auto_20210120_1730\"),\n    ]\n\n    operations = []\n",
                                    "summary": "Class Migration: A class that defines dependencies and operations for database schema changes during migration.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that specifies dependencies and operations for database schema changes."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0007_auto_20210301_0302.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0007_auto_20210301_0302.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0006_merge_20210221_1258\"),\n    ]\n\n    operations = [\n        migrations.AlterUniqueTogether(\n            name=\"rolemapping\",\n            unique_together={(\"user\", \"project\")},\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.6 on 2021-03-01 03:02\n\nfrom django.conf import settings\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0006_merge_20210221_1258\"),\n    ]\n\n    operations = [\n        migrations.AlterUniqueTogether(\n            name=\"rolemapping\",\n            unique_together={(\"user\", \"project\")},\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class modifying the unique together constraint for the RoleMapping model.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that alters the unique together constraint for the RoleMapping model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0008_auto_20210302_1013.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0008_auto_20210302_1013.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0007_auto_20210301_0302\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"guideline\",\n            field=models.TextField(blank=True, default=\"\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.6 on 2021-03-02 10:13\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0007_auto_20210301_0302\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"guideline\",\n            field=models.TextField(blank=True, default=\"\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: Represents a migration operation to alter a specific field in a model with specified dependencies.",
                                    "code_element_summaries": [
                                        "Class Migration: Represents a migration operation to alter the \"guideline\" field in the \"project\" model with specified dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0009_annotations_relations_20210421_1445.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0009_annotations_relations_20210421_1445.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(  # id_autogen, annotation_id_1, annotation_id_2, type, author, timestamp\n            name=\"RelationTypes\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.TextField(max_length=50)),\n                (\"color\", models.TextField(max_length=20)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"relation_types\", to=\"api.Project\"\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(  # id_autogen, annotation_id_1, annotation_id_2, type, author, timestamp\n            name=\"AnnotationRelations\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"annotation_id_1\", models.IntegerField()),\n                (\"annotation_id_2\", models.IntegerField()),\n                (\"type\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.RelationTypes\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n                (\"timestamp\", models.DateTimeField(auto_now_add=True)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.6 on 2021-03-02 10:13\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(  # id_autogen, annotation_id_1, annotation_id_2, type, author, timestamp\n            name=\"RelationTypes\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.TextField(max_length=50)),\n                (\"color\", models.TextField(max_length=20)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"relation_types\", to=\"api.Project\"\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(  # id_autogen, annotation_id_1, annotation_id_2, type, author, timestamp\n            name=\"AnnotationRelations\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"annotation_id_1\", models.IntegerField()),\n                (\"annotation_id_2\", models.IntegerField()),\n                (\"type\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.RelationTypes\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n                (\"timestamp\", models.DateTimeField(auto_now_add=True)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration class creating models for RelationTypes and AnnotationRelations with defined fields and dependencies.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A Django migration class that creates models for RelationTypes and AnnotationRelations with specific fields and dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0009_auto_20210411_2330.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0009_auto_20210411_2330.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"document\",\n            name=\"meta\",\n            field=models.JSONField(default=dict),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.7 on 2021-04-11 23:30\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"document\",\n            name=\"meta\",\n            field=models.JSONField(default=dict),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that modifies the \"meta\" field in the \"Document\" model to be a JSONField with an initial value of an empty dictionary.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that alters the field \"meta\" in the \"Document\" model to be a JSONField with a default value of an empty dictionary."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0009_tag.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0009_tag.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Tag\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"tags\", to=\"api.project\"\n                    ),\n                ),\n            ],\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2 on 2021-04-13 16:50\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Tag\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"tags\", to=\"api.project\"\n                    ),\n                ),\n            ],\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a Tag model with specific fields for ID, text, and project ForeignKey.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that creates a Tag model with fields for ID, text, and project ForeignKey."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0010_auto_20210413_0249.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0010_auto_20210413_0249.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0009_auto_20210411_2330\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"document\",\n            name=\"filename\",\n            field=models.FilePathField(default=\"\"),\n        ),\n        migrations.AlterField(\n            model_name=\"document\",\n            name=\"annotations_approved_by\",\n            field=models.ForeignKey(\n                blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.7 on 2021-04-13 02:49\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0009_auto_20210411_2330\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"document\",\n            name=\"filename\",\n            field=models.FilePathField(default=\"\"),\n        ),\n        migrations.AlterField(\n            model_name=\"document\",\n            name=\"annotations_approved_by\",\n            field=models.ForeignKey(\n                blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: Represents a migration with dependencies and operations for altering fields in the database schema.",
                                    "code_element_summaries": [
                                        "Class `Migration`: Represents a migration with dependencies and operations for altering fields in the database schema."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0011_merge_0009_tag_0010_auto_20210413_0249.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0011_merge_0009_tag_0010_auto_20210413_0249.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0009_tag\"),\n        (\"api\", \"0010_auto_20210413_0249\"),\n    ]\n\n    operations = []"
                                    ],
                                    "code": "# Generated by Django 3.2 on 2021-04-20 22:33\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0009_tag\"),\n        (\"api\", \"0010_auto_20210413_0249\"),\n    ]\n\n    operations = []\n",
                                    "summary": "Class Migration: A class that handles database schema changes and dependencies in migrations.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that manages database schema changes and dependencies between different migrations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0012_auto_20210514_0654.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0012_auto_20210514_0654.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0011_merge_0009_tag_0010_auto_20210413_0249\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Category\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Example\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"meta\", models.JSONField(default=dict)),\n                (\"filename\", models.FileField(default=\".\", upload_to=\"\")),\n                (\"text\", models.TextField(blank=True, null=True)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"annotations_approved_by\",\n                    models.ForeignKey(\n                        blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"ImageClassificationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"Span\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"start_offset\", models.IntegerField()),\n                (\"end_offset\", models.IntegerField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"api.example\"\n                    ),\n                ),\n                (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.label\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"user\", \"label\", \"start_offset\", \"end_offset\")},\n            },\n        ),\n        migrations.CreateModel(\n            name=\"TextLabel\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.TextField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"api.example\"\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"user\", \"text\")},\n            },\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"documentannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"seq2seqannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"seq2seqannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"seq2seqannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"sequenceannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"speech2textannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"speech2textannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"speech2textannotation\",\n            name=\"user\",\n        ),\n        migrations.RenameField(\n            model_name=\"project\",\n            old_name=\"randomize_document_order\",\n            new_name=\"random_order\",\n        ),\n        migrations.RemoveField(\n            model_name=\"comment\",\n            name=\"document\",\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                ],\n                max_length=30,\n            ),\n        ),\n        migrations.DeleteModel(\n            name=\"Document\",\n        ),\n        migrations.DeleteModel(\n            name=\"DocumentAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"Seq2seqAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"SequenceAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"Speech2textAnnotation\",\n        ),\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"api.project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"example\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"api.example\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.label\"),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"user\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"comment\",\n            name=\"example\",\n            field=models.ForeignKey(\n                default=1, on_delete=django.db.models.deletion.CASCADE, related_name=\"comments\", to=\"api.example\"\n            ),\n            preserve_default=False,\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"category\",\n            unique_together={(\"example\", \"user\", \"label\")},\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2 on 2021-05-14 06:54\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0011_merge_0009_tag_0010_auto_20210413_0249\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Category\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Example\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"meta\", models.JSONField(default=dict)),\n                (\"filename\", models.FileField(default=\".\", upload_to=\"\")),\n                (\"text\", models.TextField(blank=True, null=True)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"annotations_approved_by\",\n                    models.ForeignKey(\n                        blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"ImageClassificationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"Span\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"start_offset\", models.IntegerField()),\n                (\"end_offset\", models.IntegerField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"api.example\"\n                    ),\n                ),\n                (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.label\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"user\", \"label\", \"start_offset\", \"end_offset\")},\n            },\n        ),\n        migrations.CreateModel(\n            name=\"TextLabel\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.TextField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"api.example\"\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"user\", \"text\")},\n            },\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"documentannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"seq2seqannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"seq2seqannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"seq2seqannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"sequenceannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"speech2textannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"speech2textannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"speech2textannotation\",\n            name=\"user\",\n        ),\n        migrations.RenameField(\n            model_name=\"project\",\n            old_name=\"randomize_document_order\",\n            new_name=\"random_order\",\n        ),\n        migrations.RemoveField(\n            model_name=\"comment\",\n            name=\"document\",\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                ],\n                max_length=30,\n            ),\n        ),\n        migrations.DeleteModel(\n            name=\"Document\",\n        ),\n        migrations.DeleteModel(\n            name=\"DocumentAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"Seq2seqAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"SequenceAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"Speech2textAnnotation\",\n        ),\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"api.project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"example\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"api.example\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.label\"),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"user\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"comment\",\n            name=\"example\",\n            field=models.ForeignKey(\n                default=1, on_delete=django.db.models.deletion.CASCADE, related_name=\"comments\", to=\"api.example\"\n            ),\n            preserve_default=False,\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"category\",\n            unique_together={(\"example\", \"user\", \"label\")},\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration file responsible for creating and modifying models and their relationships in the database schema.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A Django migration file that creates and modifies models and their relationships in the database schema."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0013_merge_20210528_1016.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0013_merge_20210528_1016.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0009_annotations_relations_20210421_1445\"),\n        (\"api\", \"0012_auto_20210514_0654\"),\n    ]\n\n    operations = []"
                                    ],
                                    "code": "# Generated by Django 3.2.3 on 2021-05-28 10:16\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0009_annotations_relations_20210421_1445\"),\n        (\"api\", \"0012_auto_20210514_0654\"),\n    ]\n\n    operations = []\n",
                                    "summary": "Class Migration: A class that manages database schema changes by defining dependencies and operations.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that defines dependencies and operations for database schema changes."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0014_auto_20210603_0438.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0014_auto_20210603_0438.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0013_merge_20210528_1016\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"timestamp\",\n            field=models.DateTimeField(),\n        ),\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"type\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"annotation_relations\", to=\"api.relationtypes\"\n            ),\n        ),\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"user\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"annotation_relations\",\n                to=settings.AUTH_USER_MODEL,\n            ),\n        ),\n        migrations.AlterField(\n            model_name=\"relationtypes\",\n            name=\"color\",\n            field=models.TextField(),\n        ),\n        migrations.AlterField(\n            model_name=\"relationtypes\",\n            name=\"name\",\n            field=models.TextField(),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"annotationrelations\",\n            unique_together={(\"annotation_id_1\", \"annotation_id_2\", \"type\", \"project\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"relationtypes\",\n            unique_together={(\"color\", \"name\")},\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.3 on 2021-06-03 04:38\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0013_merge_20210528_1016\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"timestamp\",\n            field=models.DateTimeField(),\n        ),\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"type\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"annotation_relations\", to=\"api.relationtypes\"\n            ),\n        ),\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"user\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"annotation_relations\",\n                to=settings.AUTH_USER_MODEL,\n            ),\n        ),\n        migrations.AlterField(\n            model_name=\"relationtypes\",\n            name=\"color\",\n            field=models.TextField(),\n        ),\n        migrations.AlterField(\n            model_name=\"relationtypes\",\n            name=\"name\",\n            field=models.TextField(),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"annotationrelations\",\n            unique_together={(\"annotation_id_1\", \"annotation_id_2\", \"type\", \"project\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"relationtypes\",\n            unique_together={(\"color\", \"name\")},\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class that handles database schema alterations for annotation relations and relation types.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that alters fields and unique constraints in the database schema for annotation relations and relation types."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0015_examplestate.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0015_examplestate.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0014_auto_20210603_0438\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExampleState\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"confirmed_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"confirmed_by\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"states\", to=\"api.example\"\n                    ),\n                ),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"confirmed_by\")},\n            },\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.3 on 2021-06-07 01:48\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0014_auto_20210603_0438\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExampleState\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"confirmed_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"confirmed_by\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"states\", to=\"api.example\"\n                    ),\n                ),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"confirmed_by\")},\n            },\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a new model called ExampleState with fields for confirmation details related to an example in the API.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a new model called `ExampleState` with fields for confirmation details related to an example in the API."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0016_auto_20211018_0556.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0016_auto_20211018_0556.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0015_examplestate\"),\n    ]\n\n    operations = [\n        migrations.AlterModelOptions(\n            name=\"comment\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AlterModelOptions(\n            name=\"example\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AlterModelOptions(\n            name=\"label\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"allow_overlapping\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"grapheme_mode\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AlterField(\n            model_name=\"autolabelingconfig\",\n            name=\"label_mapping\",\n            field=models.JSONField(blank=True, default=dict),\n        ),\n        migrations.AlterField(\n            model_name=\"comment\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"filename\",\n            field=models.FileField(default=\".\", max_length=1024, upload_to=\"\"),\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"text\",\n            field=models.CharField(db_index=True, max_length=100),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.4 on 2021-10-18 05:56\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0015_examplestate\"),\n    ]\n\n    operations = [\n        migrations.AlterModelOptions(\n            name=\"comment\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AlterModelOptions(\n            name=\"example\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AlterModelOptions(\n            name=\"label\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"allow_overlapping\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"grapheme_mode\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AlterField(\n            model_name=\"autolabelingconfig\",\n            name=\"label_mapping\",\n            field=models.JSONField(blank=True, default=dict),\n        ),\n        migrations.AlterField(\n            model_name=\"comment\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"filename\",\n            field=models.FileField(default=\".\", max_length=1024, upload_to=\"\"),\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"text\",\n            field=models.CharField(db_index=True, max_length=100),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class responsible for altering model options and fields for multiple models within the API app.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that alters model options and fields for various models in the API app."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0017_example_uuid.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0017_example_uuid.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `create_uuid`\nCode:\ndef create_uuid(apps, schema_editor):\n    Example = apps.get_model(\"api\", \"example\")\n    for example in Example.objects.all():\n        example.uuid = uuid.uuid4()\n        example.save(update_fields=[\"uuid\"])",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0016_auto_20211018_0556\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"uuid\",\n            field=models.UUIDField(editable=False, blank=True, null=True),\n        ),\n        migrations.RunPython(create_uuid, reverse_code=migrations.RunPython.noop),\n        migrations.AlterField(\n            model_name=\"example\", name=\"uuid\", field=models.UUIDField(default=uuid.uuid4, db_index=True, unique=True)\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-11-08 06:06\n\nimport uuid\n\nfrom django.db import migrations, models\n\n\ndef create_uuid(apps, schema_editor):\n    Example = apps.get_model(\"api\", \"example\")\n    for example in Example.objects.all():\n        example.uuid = uuid.uuid4()\n        example.save(update_fields=[\"uuid\"])\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0016_auto_20211018_0556\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"uuid\",\n            field=models.UUIDField(editable=False, blank=True, null=True),\n        ),\n        migrations.RunPython(create_uuid, reverse_code=migrations.RunPython.noop),\n        migrations.AlterField(\n            model_name=\"example\", name=\"uuid\", field=models.UUIDField(default=uuid.uuid4, db_index=True, unique=True)\n        ),\n    ]\n",
                                    "summary": "Content: Function `create_uuid` generates UUIDs for objects in the Example model and Class Migration adds a UUID field to the \"example\" model in the API app.",
                                    "code_element_summaries": [
                                        "Function `create_uuid`: A function that generates UUIDs for all objects in the Example model.",
                                        "Class Migration: A migration class that adds a UUID field to the \"example\" model in the API app with specific operations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0018_alter_label_background_color.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0018_alter_label_background_color.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0017_example_uuid\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"background_color\",\n            field=models.CharField(default=generate_random_hex_color, max_length=7),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-11-17 05:56\n\nfrom django.db import migrations, models\nfrom label_types.models import generate_random_hex_color\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0017_example_uuid\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"background_color\",\n            field=models.CharField(default=generate_random_hex_color, max_length=7),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that updates the Label model by setting a default value for the background_color field to generate a random hex color.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that alters the field background_color in the Label model by setting a default value to generate a random hex color."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0019_auto_20211124_0506.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0019_auto_20211124_0506.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0018_alter_label_background_color\"),\n    ]\n\n    operations = [\n        migrations.AlterUniqueTogether(\n            name=\"span\",\n            unique_together=set(),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(check=models.Q((\"start_offset__gte\", 0)), name=\"startOffset >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(check=models.Q((\"end_offset__gte\", 0)), name=\"endOffset >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(\n                check=models.Q((\"start_offset__lt\", django.db.models.expressions.F(\"end_offset\"))), name=\"start < end\"\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-11-24 05:06\n\nimport django.db.models.expressions\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0018_alter_label_background_color\"),\n    ]\n\n    operations = [\n        migrations.AlterUniqueTogether(\n            name=\"span\",\n            unique_together=set(),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(check=models.Q((\"start_offset__gte\", 0)), name=\"startOffset >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(check=models.Q((\"end_offset__gte\", 0)), name=\"endOffset >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(\n                check=models.Q((\"start_offset__lt\", django.db.models.expressions.F(\"end_offset\"))), name=\"start < end\"\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: Defines operations for altering unique constraints and adding check constraints to the Span model.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that defines operations for altering unique constraints and adding check constraints to the `Span` model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0020_auto_20211221_1415.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0020_auto_20211221_1415.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0019_auto_20211124_0506\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"CategoryType\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=generate_random_hex_color, max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.CreateModel(\n            name=\"SpanType\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=generate_random_hex_color, max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"label\",\n            unique_together=set(),\n        ),\n        migrations.AddConstraint(\n            model_name=\"label\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_label_is_unique\"),\n        ),\n        migrations.AddField(\n            model_name=\"spantype\",\n            name=\"project\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\"),\n        ),\n        migrations.AddField(\n            model_name=\"categorytype\",\n            name=\"project\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"spantype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_spantype_is_unique\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"categorytype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_categorytype_is_unique\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-12-21 14:15\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\nfrom label_types.models import generate_random_hex_color\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0019_auto_20211124_0506\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"CategoryType\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=generate_random_hex_color, max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.CreateModel(\n            name=\"SpanType\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=generate_random_hex_color, max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"label\",\n            unique_together=set(),\n        ),\n        migrations.AddConstraint(\n            model_name=\"label\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_label_is_unique\"),\n        ),\n        migrations.AddField(\n            model_name=\"spantype\",\n            name=\"project\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\"),\n        ),\n        migrations.AddField(\n            model_name=\"categorytype\",\n            name=\"project\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"spantype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_spantype_is_unique\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"categorytype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_categorytype_is_unique\"),\n        ),\n    ]\n",
                                    "summary": "Class `Migration`: A class that handles database schema changes such as creating models, modifying unique constraints, and establishing foreign key relationships.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that defines database schema changes including creating new models, altering unique constraints, and adding foreign key relationships."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0021_auto_20211221_1416.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0021_auto_20211221_1416.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `copy_label_to_subclass`\nCode:\ndef copy_label_to_subclass(apps, schema_editor):\n    Label = apps.get_model(\"api\", \"Label\")\n    for label in Label.objects.all():\n        project_type = label.project.project_type\n        if project_type.endswith(\"Classification\"):\n            model = apps.get_model(\"api\", \"CategoryType\")\n        else:\n            model = apps.get_model(\"api\", \"SpanType\")\n        model.objects.create(\n            id=label.id,\n            text=label.text,\n            prefix_key=label.prefix_key,\n            suffix_key=label.suffix_key,\n            project=label.project,\n            background_color=label.background_color,\n            text_color=label.text_color,\n            created_at=label.created_at,\n            updated_at=label.updated_at,\n        )",
                                        "Function `delete_subclass_object`\nCode:\ndef delete_subclass_object(apps, schema_editor):\n    CategoryType = apps.get_model(\"api\", \"CategoryType\")\n    SpanType = apps.get_model(\"api\", \"SpanType\")\n    Label = apps.get_model(\"api\", \"Label\")\n    for model in [CategoryType, SpanType]:\n        for label in model.objects.all():\n            old_label = Label(\n                id=label.id,\n                text=label.text,\n                prefix_key=label.prefix_key,\n                suffix_key=label.suffix_key,\n                project=label.project,\n                background_color=label.background_color,\n                text_color=label.text_color,\n                created_at=label.created_at,\n                updated_at=label.updated_at,\n            )\n            label.delete()\n            old_label.save()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0020_auto_20211221_1415\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_label_to_subclass, reverse_code=delete_subclass_object),\n    ]"
                                    ],
                                    "code": "from django.db import migrations\n\n\ndef copy_label_to_subclass(apps, schema_editor):\n    Label = apps.get_model(\"api\", \"Label\")\n    for label in Label.objects.all():\n        project_type = label.project.project_type\n        if project_type.endswith(\"Classification\"):\n            model = apps.get_model(\"api\", \"CategoryType\")\n        else:\n            model = apps.get_model(\"api\", \"SpanType\")\n        model.objects.create(\n            id=label.id,\n            text=label.text,\n            prefix_key=label.prefix_key,\n            suffix_key=label.suffix_key,\n            project=label.project,\n            background_color=label.background_color,\n            text_color=label.text_color,\n            created_at=label.created_at,\n            updated_at=label.updated_at,\n        )\n\n\ndef delete_subclass_object(apps, schema_editor):\n    CategoryType = apps.get_model(\"api\", \"CategoryType\")\n    SpanType = apps.get_model(\"api\", \"SpanType\")\n    Label = apps.get_model(\"api\", \"Label\")\n    for model in [CategoryType, SpanType]:\n        for label in model.objects.all():\n            old_label = Label(\n                id=label.id,\n                text=label.text,\n                prefix_key=label.prefix_key,\n                suffix_key=label.suffix_key,\n                project=label.project,\n                background_color=label.background_color,\n                text_color=label.text_color,\n                created_at=label.created_at,\n                updated_at=label.updated_at,\n            )\n            label.delete()\n            old_label.save()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0020_auto_20211221_1415\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_label_to_subclass, reverse_code=delete_subclass_object),\n    ]\n",
                                    "summary": "Content includes functions to copy label data to a subclass and delete subclass objects, as well as a migration class for database schema changes related to labels.",
                                    "code_element_summaries": [
                                        "Function `copy_label_to_subclass`: Copies label data to a subclass based on project type for classification or span annotations.",
                                        "Function `delete_subclass_object`: Deletes objects of CategoryType and SpanType models while preserving their data in a new Label object.",
                                        "Class Migration: A migration class that handles database schema changes by running Python code to copy labels to a subclass and delete subclass objects."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0022_auto_20211221_1430.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0022_auto_20211221_1430.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0021_auto_20211221_1416\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"new_label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.categorytype\"),\n        ),\n        migrations.AddField(\n            model_name=\"span\",\n            name=\"new_label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.spantype\"),\n        ),\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.label\"),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.label\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-12-21 14:30\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0021_auto_20211221_1416\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"new_label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.categorytype\"),\n        ),\n        migrations.AddField(\n            model_name=\"span\",\n            name=\"new_label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.spantype\"),\n        ),\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.label\"),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.label\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that modifies label fields in the Category and Span models by adding new fields and altering existing ones.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that adds new label fields and alters existing label fields in the Category and Span models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0023_auto_20211221_1430.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0023_auto_20211221_1430.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `copy_annotation`\nCode:\ndef copy_annotation(apps, schema_editor):\n    Category = apps.get_model(\"api\", \"Category\")\n    Span = apps.get_model(\"api\", \"Span\")\n    for model in [Category, Span]:\n        for annotation in model.objects.all():\n            if model == Category:\n                LabelModel = apps.get_model(\"api\", \"CategoryType\")\n            else:\n                LabelModel = apps.get_model(\"api\", \"SpanType\")\n            label = LabelModel.objects.get(pk=annotation.label.id)\n            annotation.new_label = label\n            annotation.save()",
                                        "Function `delete_annotation`\nCode:\ndef delete_annotation(apps, schema_editor):\n    Category = apps.get_model(\"api\", \"Category\")\n    Span = apps.get_model(\"api\", \"Span\")\n    for model in [Category, Span]:\n        for annotation in model.objects.all():\n            annotation.new_label = None\n            annotation.save()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0022_auto_20211221_1430\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_annotation, reverse_code=delete_annotation),\n    ]"
                                    ],
                                    "code": "from django.db import migrations\n\n\ndef copy_annotation(apps, schema_editor):\n    Category = apps.get_model(\"api\", \"Category\")\n    Span = apps.get_model(\"api\", \"Span\")\n    for model in [Category, Span]:\n        for annotation in model.objects.all():\n            if model == Category:\n                LabelModel = apps.get_model(\"api\", \"CategoryType\")\n            else:\n                LabelModel = apps.get_model(\"api\", \"SpanType\")\n            label = LabelModel.objects.get(pk=annotation.label.id)\n            annotation.new_label = label\n            annotation.save()\n\n\ndef delete_annotation(apps, schema_editor):\n    Category = apps.get_model(\"api\", \"Category\")\n    Span = apps.get_model(\"api\", \"Span\")\n    for model in [Category, Span]:\n        for annotation in model.objects.all():\n            annotation.new_label = None\n            annotation.save()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0022_auto_20211221_1430\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_annotation, reverse_code=delete_annotation),\n    ]\n",
                                    "summary": "Class Migration: Manages database migrations for the `api` app by providing functions to copy and delete annotations.",
                                    "code_element_summaries": [
                                        "Function `copy_annotation`: Copies annotations from Category and Span models to update their labels based on CategoryType or SpanType.",
                                        "Function `delete_annotation`: A function that deletes annotations by setting their new label to None.",
                                        "Class `Migration`: Handles database migrations for the `api` app, with operations to copy and delete annotations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0024_auto_20211221_1444.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0024_auto_20211221_1444.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0023_auto_20211221_1430\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"category\",\n            name=\"new_label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"span\",\n            name=\"new_label\",\n        ),\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.categorytype\"),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.spantype\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-12-21 14:44\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0023_auto_20211221_1430\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"category\",\n            name=\"new_label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"span\",\n            name=\"new_label\",\n        ),\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.categorytype\"),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.spantype\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class designed to handle database migrations by removing fields and altering field types in the Category and Span models.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that removes fields and alters field types in the `Category` and `Span` models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0025_auto_20220107_0158.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0025_auto_20220107_0158.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `recover_label`\nCode:\ndef recover_label(apps, schema_editor):\n    CategoryType = apps.get_model(\"api\", \"CategoryType\")\n    SpanType = apps.get_model(\"api\", \"SpanType\")\n    Label = apps.get_model(\"api\", \"Label\")\n    for model in [CategoryType, SpanType]:\n        for label in model.objects.all():\n            old_label = Label(\n                id=label.id,\n                text=label.text,\n                prefix_key=label.prefix_key,\n                suffix_key=label.suffix_key,\n                project=label.project,\n                background_color=label.background_color,\n                text_color=label.text_color,\n                created_at=label.created_at,\n                updated_at=label.updated_at,\n            )\n            old_label.save()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0024_auto_20211221_1444\"),\n    ]\n\n    operations = [migrations.RunPython(code=migrations.RunPython.noop, reverse_code=recover_label)]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-07 01:58\n\nfrom django.db import migrations\n\n\ndef recover_label(apps, schema_editor):\n    CategoryType = apps.get_model(\"api\", \"CategoryType\")\n    SpanType = apps.get_model(\"api\", \"SpanType\")\n    Label = apps.get_model(\"api\", \"Label\")\n    for model in [CategoryType, SpanType]:\n        for label in model.objects.all():\n            old_label = Label(\n                id=label.id,\n                text=label.text,\n                prefix_key=label.prefix_key,\n                suffix_key=label.suffix_key,\n                project=label.project,\n                background_color=label.background_color,\n                text_color=label.text_color,\n                created_at=label.created_at,\n                updated_at=label.updated_at,\n            )\n            old_label.save()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0024_auto_20211221_1444\"),\n    ]\n\n    operations = [migrations.RunPython(code=migrations.RunPython.noop, reverse_code=recover_label)]\n",
                                    "summary": "Function `recover_label` recovers label data from CategoryType and SpanType models and saves them as Label instances, while Class Migration handles database schema changes with dependencies and operations specified.",
                                    "code_element_summaries": [
                                        "Function `recover_label`: Recovers label data from CategoryType and SpanType models and saves them as Label instances.",
                                        "Class Migration: A migration class that handles database schema changes with dependencies and operations specified."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0026_auto_20220107_0200.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0026_auto_20220107_0200.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0025_auto_20220107_0158\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"Label\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-07 02:00\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0025_auto_20220107_0158\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"Label\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class responsible for deleting the Label model during the migration process.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that deletes the Label model as part of the migration process."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0027_auto_20211222_0454.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0027_auto_20211222_0454.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0026_auto_20220107_0200\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"IntentDetectionAndSlotFillingProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-12-22 04:54\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0026_auto_20220107_0200\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"IntentDetectionAndSlotFillingProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a new model for Intent Detection and Slot Filling projects and updates the project_type field in the Project model.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a new model for Intent Detection and Slot Filling projects and alters the project_type field in the Project model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0028_auto_20220111_0655.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0028_auto_20220111_0655.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0027_auto_20211222_0454\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterUniqueTogether(\n                    name=\"rolemapping\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"role\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"user\",\n                ),\n            ],\n            database_operations=[],\n        ),\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Role\",\n                ),\n                migrations.DeleteModel(\n                    name=\"RoleMapping\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Role\", table=\"roles_role\"),\n                migrations.AlterModelTable(name=\"RoleMapping\", table=\"roles_rolemapping\"),\n            ],\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-11 06:55\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0027_auto_20211222_0454\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterUniqueTogether(\n                    name=\"rolemapping\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"role\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"user\",\n                ),\n            ],\n            database_operations=[],\n        ),\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Role\",\n                ),\n                migrations.DeleteModel(\n                    name=\"RoleMapping\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Role\", table=\"roles_role\"),\n                migrations.AlterModelTable(name=\"RoleMapping\", table=\"roles_rolemapping\"),\n            ],\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class designed to handle database migration operations for altering and deleting models within the API app.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that separates database and state operations for altering and deleting models in the API app."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0029_auto_20220119_2333.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0029_auto_20220119_2333.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"project\",\n            name=\"users\",\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"created_by\",\n            field=models.ForeignKey(\n                null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-19 23:33\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"project\",\n            name=\"users\",\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"created_by\",\n            field=models.ForeignKey(\n                null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: Handles database schema changes by removing a field and adding a new foreign key field to the project model.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that handles changes to the database schema, removing a field and adding a new foreign key field in the project model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0030_delete_autolabelingconfig.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0030_delete_autolabelingconfig.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0029_auto_20220119_2333\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"AutoLabelingConfig\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"AutoLabelingConfig\", table=\"auto_labeling_autolabelingconfig\")\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-20 04:17\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0029_auto_20220119_2333\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"AutoLabelingConfig\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"AutoLabelingConfig\", table=\"auto_labeling_autolabelingconfig\")\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class that handles database operations for deleting and altering the model AutoLabelingConfig.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that separates database and state operations for deleting and altering the model `AutoLabelingConfig`."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0031_auto_20220127_0032.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0031_auto_20220127_0032.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0030_delete_autolabelingconfig\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterUniqueTogether(\n                    name=\"category\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"label\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"user\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"label\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"user\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"textlabel\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"textlabel\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"textlabel\",\n                    name=\"user\",\n                ),\n                migrations.DeleteModel(\n                    name=\"AnnotationRelations\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Category\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Span\",\n                ),\n                migrations.DeleteModel(\n                    name=\"TextLabel\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Span\", table=\"labels_span\"),\n                migrations.AlterModelTable(name=\"Category\", table=\"labels_category\"),\n                migrations.AlterModelTable(name=\"TextLabel\", table=\"labels_textlabel\"),\n                migrations.AlterModelTable(name=\"AnnotationRelations\", table=\"labels_annotationrelations\"),\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 00:32\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0030_delete_autolabelingconfig\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterUniqueTogether(\n                    name=\"category\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"label\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"user\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"label\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"user\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"textlabel\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"textlabel\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"textlabel\",\n                    name=\"user\",\n                ),\n                migrations.DeleteModel(\n                    name=\"AnnotationRelations\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Category\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Span\",\n                ),\n                migrations.DeleteModel(\n                    name=\"TextLabel\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Span\", table=\"labels_span\"),\n                migrations.AlterModelTable(name=\"Category\", table=\"labels_category\"),\n                migrations.AlterModelTable(name=\"TextLabel\", table=\"labels_textlabel\"),\n                migrations.AlterModelTable(name=\"AnnotationRelations\", table=\"labels_annotationrelations\"),\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class designed to handle database and state operations for the removal of specific fields and models.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that separates database and state operations for removing certain fields and models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0032_auto_20220127_0654.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0032_auto_20220127_0654.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0031_auto_20220127_0032\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"categorytype\",\n                    name=\"project\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"relationtypes\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"relationtypes\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"spantype\",\n                    name=\"project\",\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 06:54\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0031_auto_20220127_0032\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"categorytype\",\n                    name=\"project\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"relationtypes\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"relationtypes\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"spantype\",\n                    name=\"project\",\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A model that defines migration operations to separate database and state operations for specific model fields.",
                                    "code_element_summaries": [
                                        "Class Migration: Defines a migration operation to separate database and state operations for specific model fields."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0033_auto_20220127_0654.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0033_auto_20220127_0654.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0003_auto_20220127_0654\"),\n        (\"api\", \"0032_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"CategoryType\",\n                ),\n                migrations.DeleteModel(\n                    name=\"RelationTypes\",\n                ),\n                migrations.DeleteModel(\n                    name=\"SpanType\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"CategoryType\", table=\"label_types_categorytype\"),\n                migrations.AlterModelTable(name=\"RelationTypes\", table=\"label_types_relationtypes\"),\n                migrations.AlterModelTable(name=\"SpanType\", table=\"label_types_spantype\"),\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 06:54\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0003_auto_20220127_0654\"),\n        (\"api\", \"0032_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"CategoryType\",\n                ),\n                migrations.DeleteModel(\n                    name=\"RelationTypes\",\n                ),\n                migrations.DeleteModel(\n                    name=\"SpanType\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"CategoryType\", table=\"label_types_categorytype\"),\n                migrations.AlterModelTable(name=\"RelationTypes\", table=\"label_types_relationtypes\"),\n                migrations.AlterModelTable(name=\"SpanType\", table=\"label_types_spantype\"),\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class designed to manage database schema changes by separating database and state operations for specific models.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that handles database schema changes by separating database and state operations for specified models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0034_auto_20220128_0246.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0034_auto_20220128_0246.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0033_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"example\",\n                    name=\"annotations_approved_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"example\",\n                    name=\"project\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"examplestate\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"examplestate\",\n                    name=\"confirmed_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"examplestate\",\n                    name=\"example\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Comment\",\n                ),\n            ],\n            database_operations=[migrations.AlterModelTable(name=\"Comment\", table=\"examples_comment\")],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-28 02:46\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0033_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"example\",\n                    name=\"annotations_approved_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"example\",\n                    name=\"project\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"examplestate\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"examplestate\",\n                    name=\"confirmed_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"examplestate\",\n                    name=\"example\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Comment\",\n                ),\n            ],\n            database_operations=[migrations.AlterModelTable(name=\"Comment\", table=\"examples_comment\")],\n        )\n    ]\n",
                                    "summary": "Class Migration: Handles database schema changes for the API app by modifying fields, unique constraints, and model deletions.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that handles database schema changes for the API app by removing fields, altering unique constraints, and deleting models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0035_auto_20220128_0246.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0035_auto_20220128_0246.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0034_auto_20220128_0246\"),\n        (\"labels\", \"0004_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Example\",\n                ),\n                migrations.DeleteModel(\n                    name=\"ExampleState\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Example\", table=\"examples_example\"),\n                migrations.AlterModelTable(name=\"ExampleState\", table=\"examples_examplestate\"),\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-28 02:46\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0034_auto_20220128_0246\"),\n        (\"labels\", \"0004_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Example\",\n                ),\n                migrations.DeleteModel(\n                    name=\"ExampleState\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Example\", table=\"examples_example\"),\n                migrations.AlterModelTable(name=\"ExampleState\", table=\"examples_examplestate\"),\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class that handles database and state operations for models Example and ExampleState separately.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that separates database and state operations for models Example and ExampleState."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0036_auto_20220204_0201.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0036_auto_20220204_0201.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0035_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"imageclassificationproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"intentdetectionandslotfillingproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"project\",\n                    name=\"created_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"project\",\n                    name=\"polymorphic_ctype\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"seq2seqproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"sequencelabelingproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"speech2textproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"tag\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"textclassificationproject\",\n                    name=\"project_ptr\",\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0035_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"imageclassificationproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"intentdetectionandslotfillingproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"project\",\n                    name=\"created_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"project\",\n                    name=\"polymorphic_ctype\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"seq2seqproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"sequencelabelingproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"speech2textproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"tag\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"textclassificationproject\",\n                    name=\"project_ptr\",\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class designed to remove specified fields from multiple models within the database during migrations.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that removes specified fields from various models in the database."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0037_auto_20220204_0201.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0037_auto_20220204_0201.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0005_alter_relation_project\"),\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"auto_labeling\", \"0004_alter_autolabelingconfig_project\"),\n        (\"api\", \"0036_auto_20220204_0201\"),\n        (\"label_types\", \"0003_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"ImageClassificationProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"IntentDetectionAndSlotFillingProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Project\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Seq2seqProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"SequenceLabelingProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Speech2textProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Tag\",\n                ),\n                migrations.DeleteModel(\n                    name=\"TextClassificationProject\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(\n                    name=\"ImageClassificationProject\", table=\"projects_imageclassificationproject\"\n                ),\n                migrations.AlterModelTable(\n                    name=\"IntentDetectionAndSlotFillingProject\", table=\"projects_intentdetectionandslotfillingproject\"\n                ),\n                migrations.AlterModelTable(name=\"Project\", table=\"projects_project\"),\n                migrations.AlterModelTable(name=\"Seq2seqProject\", table=\"projects_seq2seqproject\"),\n                migrations.AlterModelTable(name=\"SequenceLabelingProject\", table=\"projects_sequencelabelingproject\"),\n                migrations.AlterModelTable(name=\"Speech2textProject\", table=\"projects_speech2textproject\"),\n                migrations.AlterModelTable(name=\"Tag\", table=\"projects_tag\"),\n                migrations.AlterModelTable(\n                    name=\"TextClassificationProject\", table=\"projects_textclassificationproject\"\n                ),\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0005_alter_relation_project\"),\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"auto_labeling\", \"0004_alter_autolabelingconfig_project\"),\n        (\"api\", \"0036_auto_20220204_0201\"),\n        (\"label_types\", \"0003_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"ImageClassificationProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"IntentDetectionAndSlotFillingProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Project\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Seq2seqProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"SequenceLabelingProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Speech2textProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Tag\",\n                ),\n                migrations.DeleteModel(\n                    name=\"TextClassificationProject\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(\n                    name=\"ImageClassificationProject\", table=\"projects_imageclassificationproject\"\n                ),\n                migrations.AlterModelTable(\n                    name=\"IntentDetectionAndSlotFillingProject\", table=\"projects_intentdetectionandslotfillingproject\"\n                ),\n                migrations.AlterModelTable(name=\"Project\", table=\"projects_project\"),\n                migrations.AlterModelTable(name=\"Seq2seqProject\", table=\"projects_seq2seqproject\"),\n                migrations.AlterModelTable(name=\"SequenceLabelingProject\", table=\"projects_sequencelabelingproject\"),\n                migrations.AlterModelTable(name=\"Speech2textProject\", table=\"projects_speech2textproject\"),\n                migrations.AlterModelTable(name=\"Tag\", table=\"projects_tag\"),\n                migrations.AlterModelTable(\n                    name=\"TextClassificationProject\", table=\"projects_textclassificationproject\"\n                ),\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class designed to handle database operations for deleting multiple models and altering model tables.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that separates database and state operations for deleting multiple models and altering model tables."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a proxy model ExportedBoundingBox with methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content includes test classes for validating admin user creation, testing database URL SSL settings, verifying user superuser status, and performing CRUD operations using HTTP methods.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_commands.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests\\test_commands.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestCreateAdminCommand`\nCode:\nclass TestCreateAdminCommand(TestCase):\n    def test_can_create_user(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_out.write.assert_called_once_with(\"Setting password for User user.\\n\")\n\n    def test_raise_error_if_username_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                password=\"whoami\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank username isn't allowed.\\n\")\n\n    def test_raise_error_if_password_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                username=\"user\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank password isn't allowed.\\n\")\n\n    def test_warn_default_password(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"password\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        self.assertEqual(mock_out.write.call_count, 2)\n        mock_out.write.assert_any_call(\"Warning: You should change the default password.\\n\")\n        mock_out.write.assert_any_call(\"Setting password for User user.\\n\")\n\n    def test_warn_duplicate_username(self):\n        get_user_model().objects.create(username=\"admin\", password=\"pass\")\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        command.handle(\n            username=\"admin\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_err.write.assert_called_once_with(\"User admin already exists.\\n\")",
                                        "Function `test_can_create_user`\nCode:\n    def test_can_create_user(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_out.write.assert_called_once_with(\"Setting password for User user.\\n\")",
                                        "Function `test_raise_error_if_username_is_not_given`\nCode:\n    def test_raise_error_if_username_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                password=\"whoami\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank username isn't allowed.\\n\")",
                                        "Function `test_raise_error_if_password_is_not_given`\nCode:\n    def test_raise_error_if_password_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                username=\"user\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank password isn't allowed.\\n\")",
                                        "Function `test_warn_default_password`\nCode:\n    def test_warn_default_password(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"password\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        self.assertEqual(mock_out.write.call_count, 2)\n        mock_out.write.assert_any_call(\"Warning: You should change the default password.\\n\")\n        mock_out.write.assert_any_call(\"Setting password for User user.\\n\")",
                                        "Function `test_warn_duplicate_username`\nCode:\n    def test_warn_duplicate_username(self):\n        get_user_model().objects.create(username=\"admin\", password=\"pass\")\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        command.handle(\n            username=\"admin\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_err.write.assert_called_once_with(\"User admin already exists.\\n\")"
                                    ],
                                    "code": "from unittest.mock import MagicMock\n\nfrom django.contrib.auth import get_user_model\nfrom django.core.management import CommandError\nfrom django.test import TestCase\n\nfrom api.management.commands.create_admin import Command\n\n\nclass TestCreateAdminCommand(TestCase):\n    def test_can_create_user(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_out.write.assert_called_once_with(\"Setting password for User user.\\n\")\n\n    def test_raise_error_if_username_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                password=\"whoami\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank username isn't allowed.\\n\")\n\n    def test_raise_error_if_password_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                username=\"user\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank password isn't allowed.\\n\")\n\n    def test_warn_default_password(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"password\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        self.assertEqual(mock_out.write.call_count, 2)\n        mock_out.write.assert_any_call(\"Warning: You should change the default password.\\n\")\n        mock_out.write.assert_any_call(\"Setting password for User user.\\n\")\n\n    def test_warn_duplicate_username(self):\n        get_user_model().objects.create(username=\"admin\", password=\"pass\")\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        command.handle(\n            username=\"admin\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_err.write.assert_called_once_with(\"User admin already exists.\\n\")\n",
                                    "summary": "Class `TestCreateAdminCommand`: A test class for validating the creation of admin users with specific conditions and warnings, including tests for username, password, default password warning, and duplicate username warning.",
                                    "code_element_summaries": [
                                        "Class `TestCreateAdminCommand`: A test class that validates the functionality of creating admin users with specific conditions and warnings.",
                                        "Function `test_can_create_user`: Verifies the successful creation of a user with specified credentials and settings.",
                                        "Function `test_raise_error_if_username_is_not_given`: Tests if an error is raised when a username is not provided in the command handling process.",
                                        "Function `test_raise_error_if_password_is_not_given`: Tests if an error is raised when a password is not provided in the command handle function.",
                                        "Function `test_warn_default_password`: A unit test for a command that warns about using default passwords and sets a new password for a user.",
                                        "Function `test_warn_duplicate_username`: A test function that checks if a warning is raised when trying to create a user with a duplicate username."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_config.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests\\test_config.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestDatabaseUrl`\nCode:\nclass TestDatabaseUrl(TestCase):\n    def test_sslmode_defaults_to_required(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d\"):\n            self._assert_sslmode_is(\"require\")\n\n    def test_sslmode_not_set_for_sqlite(self):\n        with setenv(\"DATABASE_URL\", \"sqlite:///some/path\"):\n            self._assert_sslmode_is(None)\n\n    def test_sslmode_can_be_disabled_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=disable\"):\n            self._assert_sslmode_is(\"disable\")\n\n    def test_sslmode_can_be_required_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=require\"):\n            self._assert_sslmode_is(\"require\")\n\n    def test_database_url_with_complex_user(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://user%40host:p@h/d\"):\n            self._assert_user_is(\"user@host\")\n\n    def _assert_sslmode_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"OPTIONS\", {}).get(\"sslmode\")\n        self.assertEqual(actual, expected)\n\n    def _assert_user_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"USER\", \"\")\n        self.assertEqual(actual, expected)",
                                        "Function `test_sslmode_defaults_to_required`\nCode:\n    def test_sslmode_defaults_to_required(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d\"):\n            self._assert_sslmode_is(\"require\")",
                                        "Function `test_sslmode_not_set_for_sqlite`\nCode:\n    def test_sslmode_not_set_for_sqlite(self):\n        with setenv(\"DATABASE_URL\", \"sqlite:///some/path\"):\n            self._assert_sslmode_is(None)",
                                        "Function `test_sslmode_can_be_disabled_via_database_url`\nCode:\n    def test_sslmode_can_be_disabled_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=disable\"):\n            self._assert_sslmode_is(\"disable\")",
                                        "Function `test_sslmode_can_be_required_via_database_url`\nCode:\n    def test_sslmode_can_be_required_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=require\"):\n            self._assert_sslmode_is(\"require\")",
                                        "Function `test_database_url_with_complex_user`\nCode:\n    def test_database_url_with_complex_user(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://user%40host:p@h/d\"):\n            self._assert_user_is(\"user@host\")",
                                        "Function `_assert_sslmode_is`\nCode:\n    def _assert_sslmode_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"OPTIONS\", {}).get(\"sslmode\")\n        self.assertEqual(actual, expected)",
                                        "Function `_assert_user_is`\nCode:\n    def _assert_user_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"USER\", \"\")\n        self.assertEqual(actual, expected)",
                                        "Function `setenv`\nCode:\ndef setenv(key, value):\n    environ[key] = value\n    reload(settings)\n    yield\n    del environ[key]"
                                    ],
                                    "code": "from contextlib import contextmanager\nfrom importlib import reload\nfrom os import environ\n\nfrom django.test import TestCase\n\nfrom config.settings import base as settings\n\n\nclass TestDatabaseUrl(TestCase):\n    def test_sslmode_defaults_to_required(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d\"):\n            self._assert_sslmode_is(\"require\")\n\n    def test_sslmode_not_set_for_sqlite(self):\n        with setenv(\"DATABASE_URL\", \"sqlite:///some/path\"):\n            self._assert_sslmode_is(None)\n\n    def test_sslmode_can_be_disabled_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=disable\"):\n            self._assert_sslmode_is(\"disable\")\n\n    def test_sslmode_can_be_required_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=require\"):\n            self._assert_sslmode_is(\"require\")\n\n    def test_database_url_with_complex_user(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://user%40host:p@h/d\"):\n            self._assert_user_is(\"user@host\")\n\n    def _assert_sslmode_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"OPTIONS\", {}).get(\"sslmode\")\n        self.assertEqual(actual, expected)\n\n    def _assert_user_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"USER\", \"\")\n        self.assertEqual(actual, expected)\n\n\n@contextmanager\ndef setenv(key, value):\n    environ[key] = value\n    reload(settings)\n    yield\n    del environ[key]\n",
                                    "summary": "Class `TestDatabaseUrl`: A TestCase class that tests SSL mode settings and user information in database URLs, with functions verifying default SSL mode, SSL mode behavior for different databases, user extraction, and environment variable manipulation.",
                                    "code_element_summaries": [
                                        "Class `TestDatabaseUrl`: A TestCase class that tests various scenarios related to SSL mode settings and user information in database URLs.",
                                        "Function `test_sslmode_defaults_to_required`: Verifies that the SSL mode defaults to \"require\" when connecting to a PostgreSQL database.",
                                        "Function `test_sslmode_not_set_for_sqlite`: Tests that the SSL mode is not set when using SQLite as the database.",
                                        "Function `test_sslmode_can_be_disabled_via_database_url`: Tests that the SSL mode can be disabled by setting the database URL parameter accordingly.",
                                        "Function `test_sslmode_can_be_required_via_database_url`: Tests whether SSL mode can be required via the database URL.",
                                        "Function test_database_url_with_complex_user: A test function that checks if the database URL with a complex user is parsed correctly to extract the user information.",
                                        "Function `_assert_sslmode_is`: A function that asserts the sslmode setting in the default database options matches the expected value.",
                                        "Function `_assert_user_is`: Compares the actual database user with an expected user and asserts equality.",
                                        "Function `setenv`: A function that sets an environment variable, reloads settings, and then deletes the environment variable."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_middleware.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests\\test_middleware.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `HeaderAuthMiddlewareTest`\nCode:\nclass HeaderAuthMiddlewareTest(TestCase):\n    def test_process_user_groups_is_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = False\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Admin;Reader\"})\n\n        self.assertTrue(user.is_superuser)\n\n    def test_process_user_groups_is_not_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = True\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Guest;Reader\"})\n\n        self.assertFalse(user.is_superuser)",
                                        "Function `test_process_user_groups_is_super`\nCode:\n    def test_process_user_groups_is_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = False\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Admin;Reader\"})\n\n        self.assertTrue(user.is_superuser)",
                                        "Function `test_process_user_groups_is_not_super`\nCode:\n    def test_process_user_groups_is_not_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = True\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Guest;Reader\"})\n\n        self.assertFalse(user.is_superuser)"
                                    ],
                                    "code": "from unittest import mock\n\nfrom django.contrib.auth.models import User\nfrom django.test import TestCase, override_settings\n\nfrom api.middleware import HeaderAuthMiddleware\n\n\n@override_settings(HEADER_AUTH_USER_GROUPS=\"X-AuthProxy-Groups\")\n@override_settings(HEADER_AUTH_ADMIN_GROUP_NAME=\"Admin\")\n@override_settings(HEADER_AUTH_GROUPS_SEPERATOR=\";\")\nclass HeaderAuthMiddlewareTest(TestCase):\n    def test_process_user_groups_is_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = False\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Admin;Reader\"})\n\n        self.assertTrue(user.is_superuser)\n\n    def test_process_user_groups_is_not_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = True\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Guest;Reader\"})\n\n        self.assertFalse(user.is_superuser)\n",
                                    "summary": "Class `HeaderAuthMiddlewareTest`: Tests for the `process_user_groups` method in HeaderAuthMiddleware to verify user superuser status based on assigned user groups.",
                                    "code_element_summaries": [
                                        "Class `HeaderAuthMiddlewareTest`: Tests for the `process_user_groups` method in the HeaderAuthMiddleware class to check if user is set as superuser based on provided user groups.",
                                        "Function `test_process_user_groups_is_super`: Tests whether a user is set as a superuser based on the groups assigned to them in the HeaderAuthMiddleware.",
                                        "Function `test_process_user_groups_is_not_super`: Tests that the user's `is_superuser` attribute is set to False after processing user groups in the HeaderAuthMiddleware."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `CRUDMixin`\nCode:\nclass CRUDMixin(APITestCase):\n    url = \"\"\n    data: Dict[str, Any] = {}\n\n    def assert_fetch(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_create(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.post(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_update(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.patch(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN, data=None):\n        if user:\n            self.client.force_login(user)\n\n        if data is None:\n            data = {}\n        response = self.client.delete(self.url, data=data)\n        self.assertEqual(response.status_code, expected)",
                                        "Function `assert_fetch`\nCode:\n    def assert_fetch(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, expected)\n        return response",
                                        "Function `assert_create`\nCode:\n    def assert_create(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.post(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response",
                                        "Function `assert_update`\nCode:\n    def assert_update(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.patch(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response",
                                        "Function `assert_delete`\nCode:\n    def assert_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN, data=None):\n        if user:\n            self.client.force_login(user)\n\n        if data is None:\n            data = {}\n        response = self.client.delete(self.url, data=data)\n        self.assertEqual(response.status_code, expected)"
                                    ],
                                    "code": "from typing import Any, Dict\n\nfrom rest_framework import status\nfrom rest_framework.test import APITestCase\n\n\nclass CRUDMixin(APITestCase):\n    url = \"\"\n    data: Dict[str, Any] = {}\n\n    def assert_fetch(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_create(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.post(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_update(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.patch(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN, data=None):\n        if user:\n            self.client.force_login(user)\n\n        if data is None:\n            data = {}\n        response = self.client.delete(self.url, data=data)\n        self.assertEqual(response.status_code, expected)\n",
                                    "summary": "Class `CRUDMixin`: A mixin class with assertion methods for performing CRUD operations (Create, Read, Update, Delete) using different HTTP methods.",
                                    "code_element_summaries": [
                                        "Class `CRUDMixin`: A mixin class for performing CRUD operations (Create, Read, Update, Delete) with assertion methods for different HTTP methods.",
                                        "Function `assert_fetch`: A method that asserts the expected HTTP status code for a GET request with optional user authentication.",
                                        "Function `assert_create`: A method for asserting the creation of an object with optional user authentication and expected response status code.",
                                        "Function `assert_update`: A method to assert the update operation with specified user authentication and expected response status code.",
                                        "Function `assert_delete`: A method that asserts the deletion of an object with optional user authentication and expected status code."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a proxy model ExportedBoundingBox that allows for bounding box annotations to be represented in dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import TaskStatus\n\nurlpatterns = [\n    path(route=\"tasks/status/<task_id>\", view=TaskStatus.as_view(), name=\"task_status\"),\n]\n",
                            "summary": "Defining a URL pattern for accessing task status information using TaskStatus view in Django.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `TaskStatus`\nCode:\nclass TaskStatus(APIView):\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, *args, **kwargs):\n        task = AsyncResult(kwargs[\"task_id\"])\n        ready = task.ready()\n        error = ready and not task.successful()\n\n        return Response(\n            {\n                \"ready\": ready,\n                \"result\": task.result if ready and not error else None,\n                \"error\": {\"text\": str(task.result)} if error else None,\n            }\n        )",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        task = AsyncResult(kwargs[\"task_id\"])\n        ready = task.ready()\n        error = ready and not task.successful()\n\n        return Response(\n            {\n                \"ready\": ready,\n                \"result\": task.result if ready and not error else None,\n                \"error\": {\"text\": str(task.result)} if error else None,\n            }\n        )"
                            ],
                            "code": "from celery.result import AsyncResult\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\n\nclass TaskStatus(APIView):\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, *args, **kwargs):\n        task = AsyncResult(kwargs[\"task_id\"])\n        ready = task.ready()\n        error = ready and not task.successful()\n\n        return Response(\n            {\n                \"ready\": ready,\n                \"result\": task.result if ready and not error else None,\n                \"error\": {\"text\": str(task.result)} if error else None,\n            }\n        )\n",
                            "summary": "Class TaskStatus: An API view for retrieving the status, result, and potential errors of a specific task, with a function to get the status and result based on the task_id.",
                            "code_element_summaries": [
                                "Class `TaskStatus`: An API view that retrieves the status of a specific task, including whether it is ready, its result, and any potential errors.",
                                "Function `get`: Retrieves the status and result of an asynchronous task based on the provided task_id."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that provides methods to convert bounding box annotations into dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "auto_labeling",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content includes various classes related to auto labeling configurations, permission denial, URL connection errors, AWS token validation, sample data exceptions, template mapping errors, JSON decoding errors, database migrations, label collections, serializers, API testing, template and config management, and automated labeling processes.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `AutoLabelingConfigAdmin`\nCode:\nclass AutoLabelingConfigAdmin(admin.ModelAdmin):\n    list_display = (\n        \"project\",\n        \"model_name\",\n        \"model_attrs\",\n    )\n    ordering = (\"project\",)\n\n    def get_readonly_fields(self, request, obj=None):\n        if obj:\n            return [\"model_name\"]\n        else:\n            return []",
                                "Function `get_readonly_fields`\nCode:\n    def get_readonly_fields(self, request, obj=None):\n        if obj:\n            return [\"model_name\"]\n        else:\n            return []"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import AutoLabelingConfig\n\n\nclass AutoLabelingConfigAdmin(admin.ModelAdmin):\n    list_display = (\n        \"project\",\n        \"model_name\",\n        \"model_attrs\",\n    )\n    ordering = (\"project\",)\n\n    def get_readonly_fields(self, request, obj=None):\n        if obj:\n            return [\"model_name\"]\n        else:\n            return []\n\n\nadmin.site.register(AutoLabelingConfig, AutoLabelingConfigAdmin)\n",
                            "summary": "Class AutoLabelingConfigAdmin: A model admin class for managing auto labeling configurations with specified list display fields and read-only fields, including a function to retrieve read-only fields based on object presence.",
                            "code_element_summaries": [
                                "Class AutoLabelingConfigAdmin: A model admin class for managing auto labeling configurations with specified list display fields and read-only fields.",
                                "Function `get_readonly_fields`: Returns a list of read-only fields based on the presence of an object."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `AutoLabelingConfig`\nCode:\nclass AutoLabelingConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"auto_labeling\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass AutoLabelingConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"auto_labeling\"\n",
                            "summary": "Class AutoLabelingConfig: An AppConfig class in Django tailored for auto labeling functionality with default auto field configurations.",
                            "code_element_summaries": [
                                "Class `AutoLabelingConfig`: An AppConfig class for the auto labeling functionality in Django with a default auto field setting."
                            ],
                            "children": []
                        },
                        {
                            "name": "exceptions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\exceptions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `AutoLabelingPermissionDenied`\nCode:\nclass AutoLabelingPermissionDenied(PermissionDenied):\n    default_detail = (\n        \"You do not have permission to perform auto labeling.\" \"Please ask the project administrators to add you.\"\n    )",
                                "Class `URLConnectionError`\nCode:\nclass URLConnectionError(ValidationError):\n    default_detail = \"Failed to establish a connection. Please check the URL or network.\"",
                                "Class `AWSTokenError`\nCode:\nclass AWSTokenError(ValidationError):\n    default_detail = \"The security token included in the request is invalid.\"",
                                "Class `SampleDataException`\nCode:\nclass SampleDataException(ValidationError):\n    default_detail = (\n        \"The response is empty. Maybe the sample data is not appropriate.\"\n        \"Please specify another sample data which returns at least one label.\"\n    )",
                                "Class `TemplateMappingError`\nCode:\nclass TemplateMappingError(ValidationError):\n    default_detail = \"The response cannot be mapped. You might need to change the template.\"",
                                "Class `ResponseJSONDecodeError`\nCode:\nclass ResponseJSONDecodeError(ValidationError):\n    default_detail = \"The response cannot be decoded.\" \"Please try to return the response in dictionary or list format.\""
                            ],
                            "code": "from rest_framework.exceptions import PermissionDenied, ValidationError\n\n\nclass AutoLabelingPermissionDenied(PermissionDenied):\n    default_detail = (\n        \"You do not have permission to perform auto labeling.\" \"Please ask the project administrators to add you.\"\n    )\n\n\nclass URLConnectionError(ValidationError):\n    default_detail = \"Failed to establish a connection. Please check the URL or network.\"\n\n\nclass AWSTokenError(ValidationError):\n    default_detail = \"The security token included in the request is invalid.\"\n\n\nclass SampleDataException(ValidationError):\n    default_detail = (\n        \"The response is empty. Maybe the sample data is not appropriate.\"\n        \"Please specify another sample data which returns at least one label.\"\n    )\n\n\nclass TemplateMappingError(ValidationError):\n    default_detail = \"The response cannot be mapped. You might need to change the template.\"\n\n\nclass ResponseJSONDecodeError(ValidationError):\n    default_detail = \"The response cannot be decoded.\" \"Please try to return the response in dictionary or list format.\"\n",
                            "summary": "Class AutoLabelingPermissionDenied: Represents permission denial for auto labeling actions in a project. \nClass URLConnectionError: Represents an error when establishing a connection to a URL with a default message. \nClass AWSTokenError: Represents a custom validation error for invalid AWS security tokens. \nClass SampleDataException: Handles validation errors related to empty sample data responses. \nClass TemplateMappingError: Represents validation errors related to mapping response data to a template. \nClass ResponseJSONDecodeError: Extends ValidationError with a default message for failed JSON decoding.",
                            "code_element_summaries": [
                                "Class AutoLabelingPermissionDenied: An exception class that represents permission denial for auto labeling actions in a project.",
                                "Class URLConnectionError: A subclass of ValidationError that represents an error when establishing a connection to a URL with a default error message.",
                                "Class AWSTokenError: Represents a custom validation error for invalid AWS security tokens.",
                                "Class SampleDataException: A custom exception class that handles validation errors related to empty sample data responses.",
                                "Class TemplateMappingError: A custom error class that represents validation errors related to mapping response data to a template.",
                                "Class ResponseJSONDecodeError: A custom error class that extends ValidationError and provides a default detail message for failed JSON decoding."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A migration class that manages database schema modifications and data transitions for the AutoLabelingConfig model, including adding a new field 'task_type' with specified choices and updating it according to project type.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"api\", \"0030_delete_autolabelingconfig\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"AutoLabelingConfig\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"model_name\", models.CharField(max_length=100)),\n                        (\"model_attrs\", models.JSONField(default=dict)),\n                        (\"template\", models.TextField(default=\"\")),\n                        (\"label_mapping\", models.JSONField(blank=True, default=dict)),\n                        (\"default\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"auto_labeling_config\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                    ],\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-20 04:17\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"api\", \"0030_delete_autolabelingconfig\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"AutoLabelingConfig\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"model_name\", models.CharField(max_length=100)),\n                        (\"model_attrs\", models.JSONField(default=dict)),\n                        (\"template\", models.TextField(default=\"\")),\n                        (\"label_mapping\", models.JSONField(blank=True, default=dict)),\n                        (\"default\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"auto_labeling_config\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                    ],\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a new model AutoLabelingConfig with specified fields and dependencies.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a new model `AutoLabelingConfig` with specified fields and dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_autolabelingconfig_task_type.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations\\0002_autolabelingconfig_task_type.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"auto_labeling\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"autolabelingconfig\",\n            name=\"task_type\",\n            field=models.CharField(\n                choices=[(\"Category\", \"category\"), (\"Span\", \"span\"), (\"Text\", \"text\"), (\"Relation\", \"relation\")],\n                default=\"Category\",\n                max_length=100,\n            ),\n            preserve_default=False,\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-25 00:23\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"auto_labeling\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"autolabelingconfig\",\n            name=\"task_type\",\n            field=models.CharField(\n                choices=[(\"Category\", \"category\"), (\"Span\", \"span\"), (\"Text\", \"text\"), (\"Relation\", \"relation\")],\n                default=\"Category\",\n                max_length=100,\n            ),\n            preserve_default=False,\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that adds a new field 'task_type' to the AutoLabelingConfig model with specified choices.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that adds a new field `task_type` to the `AutoLabelingConfig` model with specified choices."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_fill_task_type.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations\\0003_fill_task_type.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `fill_task_type`\nCode:\ndef fill_task_type(apps, schema_editor):\n    AutoLabelingConfig = apps.get_model(\"auto_labeling\", \"AutoLabelingConfig\")\n    for config in AutoLabelingConfig.objects.all():\n        project = config.project\n        if project.project_type in [ProjectType.DOCUMENT_CLASSIFICATION, ProjectType.IMAGE_CLASSIFICATION]:\n            config.task_type = \"Category\"\n        elif project.project_type in [ProjectType.SEQ2SEQ, ProjectType.SPEECH2TEXT]:\n            config.task_type = \"Text\"\n        elif project.project_type in [ProjectType.SEQUENCE_LABELING]:\n            config.task_type = \"Span\"\n        else:\n            config.task_type = \"Category\"\n        config.save()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"auto_labeling\", \"0002_autolabelingconfig_task_type\"),\n    ]\n\n    operations = [migrations.RunPython(code=fill_task_type, reverse_code=migrations.RunPython.noop)]"
                                    ],
                                    "code": "from django.db import migrations\n\nfrom projects.models import ProjectType\n\n\ndef fill_task_type(apps, schema_editor):\n    AutoLabelingConfig = apps.get_model(\"auto_labeling\", \"AutoLabelingConfig\")\n    for config in AutoLabelingConfig.objects.all():\n        project = config.project\n        if project.project_type in [ProjectType.DOCUMENT_CLASSIFICATION, ProjectType.IMAGE_CLASSIFICATION]:\n            config.task_type = \"Category\"\n        elif project.project_type in [ProjectType.SEQ2SEQ, ProjectType.SPEECH2TEXT]:\n            config.task_type = \"Text\"\n        elif project.project_type in [ProjectType.SEQUENCE_LABELING]:\n            config.task_type = \"Span\"\n        else:\n            config.task_type = \"Category\"\n        config.save()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"auto_labeling\", \"0002_autolabelingconfig_task_type\"),\n    ]\n\n    operations = [migrations.RunPython(code=fill_task_type, reverse_code=migrations.RunPython.noop)]\n",
                                    "summary": "Function `fill_task_type`: A function that updates the task type field in AutoLabelingConfig according to the project type.\nClass Migration: A migration class responsible for managing database schema modifications and data transitions within the auto_labeling application.",
                                    "code_element_summaries": [
                                        "Function `fill_task_type`: A function that fills the task type field in AutoLabelingConfig based on the project type.",
                                        "Class Migration: A migration class that handles database schema changes and data migrations for the auto_labeling app."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_alter_autolabelingconfig_project.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations\\0004_alter_autolabelingconfig_project.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"auto_labeling\", \"0003_fill_task_type\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"autolabelingconfig\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"auto_labeling_config\",\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"auto_labeling\", \"0003_fill_task_type\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"autolabelingconfig\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"auto_labeling_config\",\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class designed to handle database and state operations for modifying the project field in the autolabelingconfig model.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that separates database and state operations for altering the autolabelingconfig model's project field."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that provides methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `AutoLabelingConfig`\nCode:\nclass AutoLabelingConfig(models.Model):\n    TASK_CHOICES = ((\"Category\", \"category\"), (\"Span\", \"span\"), (\"Text\", \"text\"), (\"Relation\", \"relation\"))\n    model_name = models.CharField(max_length=100)\n    model_attrs = models.JSONField(default=dict)\n    template = models.TextField(default=\"\")\n    label_mapping = models.JSONField(default=dict, blank=True)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"auto_labeling_config\")\n    task_type = models.CharField(max_length=100, choices=TASK_CHOICES)\n    default = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.model_name\n\n    def clean_fields(self, exclude=None):\n        super().clean_fields(exclude=exclude)\n        try:\n            RequestModelFactory.find(self.model_name)\n        except NameError:\n            message = f\"The specified model name {self.model_name} does not exist.\"\n            raise ValidationError(message)\n        except Exception:\n            message = \"The attributes does not match the model.\"\n            raise ValidationError(message)",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        return self.model_name",
                                "Function `clean_fields`\nCode:\n    def clean_fields(self, exclude=None):\n        super().clean_fields(exclude=exclude)\n        try:\n            RequestModelFactory.find(self.model_name)\n        except NameError:\n            message = f\"The specified model name {self.model_name} does not exist.\"\n            raise ValidationError(message)\n        except Exception:\n            message = \"The attributes does not match the model.\"\n            raise ValidationError(message)"
                            ],
                            "code": "from auto_labeling_pipeline.models import RequestModelFactory\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\n\nfrom projects.models import Project\n\n\nclass AutoLabelingConfig(models.Model):\n    TASK_CHOICES = ((\"Category\", \"category\"), (\"Span\", \"span\"), (\"Text\", \"text\"), (\"Relation\", \"relation\"))\n    model_name = models.CharField(max_length=100)\n    model_attrs = models.JSONField(default=dict)\n    template = models.TextField(default=\"\")\n    label_mapping = models.JSONField(default=dict, blank=True)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"auto_labeling_config\")\n    task_type = models.CharField(max_length=100, choices=TASK_CHOICES)\n    default = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.model_name\n\n    def clean_fields(self, exclude=None):\n        super().clean_fields(exclude=exclude)\n        try:\n            RequestModelFactory.find(self.model_name)\n        except NameError:\n            message = f\"The specified model name {self.model_name} does not exist.\"\n            raise ValidationError(message)\n        except Exception:\n            message = \"The attributes does not match the model.\"\n            raise ValidationError(message)\n",
                            "summary": "Class `AutoLabelingConfig`: A model storing auto labeling configuration settings with functions for string conversion and field cleaning.",
                            "code_element_summaries": [
                                "Class `AutoLabelingConfig`: A model that stores configuration settings for auto labeling tasks, including model name, attributes, template, label mapping, project association, task type, default status, and timestamps.",
                                "Function `__str__`: Returns the model name when the object is converted to a string.",
                                "Function `clean_fields`: Cleans the fields of a model instance by checking if the specified model name exists and if the attributes match the model."
                            ],
                            "children": []
                        },
                        {
                            "name": "pipeline",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\pipeline",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class LabelCollection: An abstract base class for managing and transforming label annotations in a project, with functions to handle label collection and auto-labeling data operations based on specified configurations.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "execution.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\pipeline\\execution.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `get_label_collection`\nCode:\ndef get_label_collection(task_type: str) -> Type[Labels]:\n    return {\"Category\": ClassificationLabels, \"Span\": SequenceLabels, \"Text\": Seq2seqLabels}[task_type]",
                                        "Function `execute_pipeline`\nCode:\ndef execute_pipeline(data: str, config: AutoLabelingConfig):\n    label_collection = get_label_collection(config.task_type)\n    model = RequestModelFactory.create(model_name=config.model_name, attributes=config.model_attrs)\n    template = MappingTemplate(label_collection=label_collection, template=config.template)\n    post_processor = PostProcessor(config.label_mapping)\n    labels = pipeline(text=data, request_model=model, mapping_template=template, post_processing=post_processor)\n    labels = create_labels(config.task_type, labels)\n    return labels"
                                    ],
                                    "code": "from typing import Type\n\nfrom auto_labeling_pipeline.labels import (\n    ClassificationLabels,\n    Labels,\n    Seq2seqLabels,\n    SequenceLabels,\n)\nfrom auto_labeling_pipeline.mappings import MappingTemplate\nfrom auto_labeling_pipeline.models import RequestModelFactory\nfrom auto_labeling_pipeline.pipeline import pipeline\nfrom auto_labeling_pipeline.postprocessing import PostProcessor\n\nfrom .labels import create_labels\nfrom auto_labeling.models import AutoLabelingConfig\n\n\ndef get_label_collection(task_type: str) -> Type[Labels]:\n    return {\"Category\": ClassificationLabels, \"Span\": SequenceLabels, \"Text\": Seq2seqLabels}[task_type]\n\n\ndef execute_pipeline(data: str, config: AutoLabelingConfig):\n    label_collection = get_label_collection(config.task_type)\n    model = RequestModelFactory.create(model_name=config.model_name, attributes=config.model_attrs)\n    template = MappingTemplate(label_collection=label_collection, template=config.template)\n    post_processor = PostProcessor(config.label_mapping)\n    labels = pipeline(text=data, request_model=model, mapping_template=template, post_processing=post_processor)\n    labels = create_labels(config.task_type, labels)\n    return labels\n",
                                    "summary": "Functions `get_label_collection` and `execute_pipeline` handle label collection and auto-labeling data operations respectively based on specified configurations.",
                                    "code_element_summaries": [
                                        "Function `get_label_collection`: Returns the appropriate label collection class based on the specified task type.",
                                        "Function `execute_pipeline`: Executes a pipeline for auto-labeling data using specified configuration and returns the generated labels."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "labels.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\pipeline\\labels.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `LabelCollection`\nCode:\nclass LabelCollection(abc.ABC):\n    label_type: Type[LabelType]\n    model: Type[Label]\n\n    def __init__(self, labels):\n        self.labels = labels\n\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        mapping = {c.text: c for c in self.label_type.objects.filter(project=project)}\n        annotations = []\n        for label in self.labels:\n            if label[\"label\"] not in mapping:\n                continue\n            label[\"example\"] = example\n            label[\"label\"] = mapping[label[\"label\"]]\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations\n\n    def save(self, project: Project, example: Example, user: User):\n        labels = self.transform(project, example, user)\n        labels = self.model.objects.filter_annotatable_labels(labels, project)\n        self.model.objects.bulk_create(labels)",
                                        "Function `__init__`\nCode:\n    def __init__(self, labels):\n        self.labels = labels",
                                        "Function `transform`\nCode:\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        mapping = {c.text: c for c in self.label_type.objects.filter(project=project)}\n        annotations = []\n        for label in self.labels:\n            if label[\"label\"] not in mapping:\n                continue\n            label[\"example\"] = example\n            label[\"label\"] = mapping[label[\"label\"]]\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations",
                                        "Function `save`\nCode:\n    def save(self, project: Project, example: Example, user: User):\n        labels = self.transform(project, example, user)\n        labels = self.model.objects.filter_annotatable_labels(labels, project)\n        self.model.objects.bulk_create(labels)",
                                        "Class `Categories`\nCode:\nclass Categories(LabelCollection):\n    label_type = CategoryType\n    model = Category",
                                        "Class `Spans`\nCode:\nclass Spans(LabelCollection):\n    label_type = SpanType\n    model = Span",
                                        "Class `Texts`\nCode:\nclass Texts(LabelCollection):\n    model = TextLabel\n\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        annotations = []\n        for label in self.labels:\n            label[\"example\"] = example\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations",
                                        "Function `transform`\nCode:\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        annotations = []\n        for label in self.labels:\n            label[\"example\"] = example\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations",
                                        "Function `create_labels`\nCode:\ndef create_labels(task_type: str, labels: Labels) -> LabelCollection:\n    return {\"Category\": Categories, \"Span\": Spans, \"Text\": Texts}[task_type](labels.dict())"
                                    ],
                                    "code": "import abc\nfrom typing import List, Type\n\nfrom auto_labeling_pipeline.labels import Labels\nfrom django.contrib.auth.models import User\n\nfrom examples.models import Example\nfrom label_types.models import CategoryType, LabelType, SpanType\nfrom labels.models import Category, Label, Span, TextLabel\nfrom projects.models import Project\n\n\nclass LabelCollection(abc.ABC):\n    label_type: Type[LabelType]\n    model: Type[Label]\n\n    def __init__(self, labels):\n        self.labels = labels\n\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        mapping = {c.text: c for c in self.label_type.objects.filter(project=project)}\n        annotations = []\n        for label in self.labels:\n            if label[\"label\"] not in mapping:\n                continue\n            label[\"example\"] = example\n            label[\"label\"] = mapping[label[\"label\"]]\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations\n\n    def save(self, project: Project, example: Example, user: User):\n        labels = self.transform(project, example, user)\n        labels = self.model.objects.filter_annotatable_labels(labels, project)\n        self.model.objects.bulk_create(labels)\n\n\nclass Categories(LabelCollection):\n    label_type = CategoryType\n    model = Category\n\n\nclass Spans(LabelCollection):\n    label_type = SpanType\n    model = Span\n\n\nclass Texts(LabelCollection):\n    model = TextLabel\n\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        annotations = []\n        for label in self.labels:\n            label[\"example\"] = example\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations\n\n\ndef create_labels(task_type: str, labels: Labels) -> LabelCollection:\n    return {\"Category\": Categories, \"Span\": Spans, \"Text\": Texts}[task_type](labels.dict())\n",
                                    "summary": "Class `LabelCollection`: An abstract base class for managing and transforming label annotations within a project, with functions to transform labels, save annotations, and create label collections based on task type.",
                                    "code_element_summaries": [
                                        "Class `LabelCollection`: An abstract base class for managing and transforming label annotations within a project.",
                                        "Function `__init__`: Initializes the function with a parameter `labels`.",
                                        "Function `transform`: A method that transforms labels based on a mapping and creates annotations for a given project, example, and user.",
                                        "Function `save`: Saves transformed labels for a project's example in bulk.",
                                        "Class Categories: Represents a collection of category labels with a specific label type and model.",
                                        "Class Spans: A model representing a collection of spans with a specified label type and model.",
                                        "Class `Texts`: A model representing a collection of text labels with a method to transform them into label objects for a project example.",
                                        "Function `transform`: A method that transforms labels into annotations associated with a project, example, and user.",
                                        "Function `create_labels`: Returns a LabelCollection based on the task type and labels provided."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\pipeline\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a proxy model ExportedBoundingBox that represents bounding box annotations in dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `AutoLabelingConfigSerializer`\nCode:\nclass AutoLabelingConfigSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = AutoLabelingConfig\n        fields = (\"id\", \"model_name\", \"model_attrs\", \"template\", \"label_mapping\", \"default\", \"task_type\")\n        read_only_fields = (\"created_at\", \"updated_at\")\n\n    def validate_model_name(self, value):\n        try:\n            RequestModelFactory.find(value)\n        except NameError:\n            raise serializers.ValidationError(f\"The specified model name {value} does not exist.\")\n        return value\n\n    def valid_label_mapping(self, value):\n        if isinstance(value, dict):\n            return value\n        else:\n            raise serializers.ValidationError(f\"The {value} is not a dictionary. Please specify it as a dictionary.\")\n\n    def validate(self, data):\n        try:\n            RequestModelFactory.create(data[\"model_name\"], data[\"model_attrs\"])\n        except Exception:\n            model = RequestModelFactory.find(data[\"model_name\"])\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise serializers.ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )\n        return data",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = AutoLabelingConfig\n        fields = (\"id\", \"model_name\", \"model_attrs\", \"template\", \"label_mapping\", \"default\", \"task_type\")\n        read_only_fields = (\"created_at\", \"updated_at\")",
                                "Function `validate_model_name`\nCode:\n    def validate_model_name(self, value):\n        try:\n            RequestModelFactory.find(value)\n        except NameError:\n            raise serializers.ValidationError(f\"The specified model name {value} does not exist.\")\n        return value",
                                "Function `valid_label_mapping`\nCode:\n    def valid_label_mapping(self, value):\n        if isinstance(value, dict):\n            return value\n        else:\n            raise serializers.ValidationError(f\"The {value} is not a dictionary. Please specify it as a dictionary.\")",
                                "Function `validate`\nCode:\n    def validate(self, data):\n        try:\n            RequestModelFactory.create(data[\"model_name\"], data[\"model_attrs\"])\n        except Exception:\n            model = RequestModelFactory.find(data[\"model_name\"])\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise serializers.ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )\n        return data"
                            ],
                            "code": "from auto_labeling_pipeline.models import RequestModelFactory\nfrom rest_framework import serializers\n\nfrom .models import AutoLabelingConfig\n\n\nclass AutoLabelingConfigSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = AutoLabelingConfig\n        fields = (\"id\", \"model_name\", \"model_attrs\", \"template\", \"label_mapping\", \"default\", \"task_type\")\n        read_only_fields = (\"created_at\", \"updated_at\")\n\n    def validate_model_name(self, value):\n        try:\n            RequestModelFactory.find(value)\n        except NameError:\n            raise serializers.ValidationError(f\"The specified model name {value} does not exist.\")\n        return value\n\n    def valid_label_mapping(self, value):\n        if isinstance(value, dict):\n            return value\n        else:\n            raise serializers.ValidationError(f\"The {value} is not a dictionary. Please specify it as a dictionary.\")\n\n    def validate(self, data):\n        try:\n            RequestModelFactory.create(data[\"model_name\"], data[\"model_attrs\"])\n        except Exception:\n            model = RequestModelFactory.find(data[\"model_name\"])\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise serializers.ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )\n        return data\n",
                            "summary": "Class `AutoLabelingConfigSerializer`: A serializer class for AutoLabelingConfig model that validates model name, label mapping, and attributes, with additional functions for validation and exception handling.",
                            "code_element_summaries": [
                                "Class `AutoLabelingConfigSerializer`: A serializer class for AutoLabelingConfig model that validates model name, label mapping, and attributes.",
                                "Class Meta: Defines metadata options for the AutoLabelingConfig model including model, fields, read-only fields, and more.",
                                "Function `validate_model_name`: Validates the existence of a specified model name using RequestModelFactory.",
                                "Function `valid_label_mapping`: Validates if the input value is a dictionary and returns it, otherwise raises a validation error.",
                                "Function `validate`: Validates the data by creating a model instance based on provided attributes and handling exceptions by checking required fields."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content consists of various test classes for different functionalities such as template list fetching, auto labeling parameter testing, template mapping, label mapping, configuration creation, and automated labeling testing.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestTemplateList`\nCode:\nclass TestTemplateList(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"auto_labeling_templates\", args=[self.project.item.id])\n\n    def test_allow_admin_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertIn(\"Custom REST Request\", response.data)\n        self.assertGreaterEqual(len(response.data), 1)\n\n    def test_deny_project_staff_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        for user in self.project.staffs:\n            self.assert_fetch(user, status.HTTP_403_FORBIDDEN)\n\n    def test_return_only_default_template_with_empty_task_name(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)\n\n    def test_return_only_default_template_with_wrong_task_name(self):\n        self.url += \"?task_name=foobar\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"auto_labeling_templates\", args=[self.project.item.id])",
                                        "Function `test_allow_admin_to_fetch_template_list`\nCode:\n    def test_allow_admin_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertIn(\"Custom REST Request\", response.data)\n        self.assertGreaterEqual(len(response.data), 1)",
                                        "Function `test_deny_project_staff_to_fetch_template_list`\nCode:\n    def test_deny_project_staff_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        for user in self.project.staffs:\n            self.assert_fetch(user, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_return_only_default_template_with_empty_task_name`\nCode:\n    def test_return_only_default_template_with_empty_task_name(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)",
                                        "Function `test_return_only_default_template_with_wrong_task_name`\nCode:\n    def test_return_only_default_template_with_wrong_task_name(self):\n        self.url += \"?task_name=foobar\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)",
                                        "Class `TestConfigParameter`\nCode:\nclass TestConfigParameter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"GCP Entity Analysis\",\n            \"model_attrs\": {\"key\": \"hoge\", \"type\": \"PLAIN_TEXT\", \"language\": \"en\"},\n            \"text\": \"example\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_parameter_testing\", args=[self.project.item.id])\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_proper_model(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        expected = RequestModelFactory.create(self.data[\"model_name\"], self.data[\"model_attrs\"])\n        self.assertEqual(kwargs[\"model\"], expected)\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_text(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_image(self, mock):\n        self.data[\"text\"] = str(data_dir / \"images/1500x500.jpeg\")\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"GCP Entity Analysis\",\n            \"model_attrs\": {\"key\": \"hoge\", \"type\": \"PLAIN_TEXT\", \"language\": \"en\"},\n            \"text\": \"example\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_parameter_testing\", args=[self.project.item.id])",
                                        "Function `test_called_with_proper_model`\nCode:\n    def test_called_with_proper_model(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        expected = RequestModelFactory.create(self.data[\"model_name\"], self.data[\"model_attrs\"])\n        self.assertEqual(kwargs[\"model\"], expected)",
                                        "Function `test_called_with_text`\nCode:\n    def test_called_with_text(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])",
                                        "Function `test_called_with_image`\nCode:\n    def test_called_with_image(self, mock):\n        self.data[\"text\"] = str(data_dir / \"images/1500x500.jpeg\")\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])",
                                        "Class `TestTemplateMapping`\nCode:\nclass TestTemplateMapping(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": {\n                \"Sentiment\": \"NEUTRAL\",\n                \"SentimentScore\": {\n                    \"Positive\": 0.004438233096152544,\n                    \"Negative\": 0.0005306027014739811,\n                    \"Neutral\": 0.9950305223464966,\n                    \"Mixed\": 5.80838445785048e-7,\n                },\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_template_test\", args=[self.project.item.id])\n\n    def test_template_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"NEUTRAL\"}]\n        self.assertEqual(response.json(), expected)\n\n    def test_json_decode_error(self):\n        self.data[\"template\"] = \"\"\n        self.assert_create(self.project.admin, status.HTTP_400_BAD_REQUEST)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": {\n                \"Sentiment\": \"NEUTRAL\",\n                \"SentimentScore\": {\n                    \"Positive\": 0.004438233096152544,\n                    \"Negative\": 0.0005306027014739811,\n                    \"Neutral\": 0.9950305223464966,\n                    \"Mixed\": 5.80838445785048e-7,\n                },\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_template_test\", args=[self.project.item.id])",
                                        "Function `test_template_mapping`\nCode:\n    def test_template_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"NEUTRAL\"}]\n        self.assertEqual(response.json(), expected)",
                                        "Function `test_json_decode_error`\nCode:\n    def test_json_decode_error(self):\n        self.data[\"template\"] = \"\"\n        self.assert_create(self.project.admin, status.HTTP_400_BAD_REQUEST)",
                                        "Class `TestLabelMapping`\nCode:\nclass TestLabelMapping(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": [{\"label\": \"NEGATIVE\"}],\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_mapping_test\", args=[self.project.item.id])\n\n    def test_label_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"Negative\"}]\n        self.assertEqual(response.json(), expected)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": [{\"label\": \"NEGATIVE\"}],\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_mapping_test\", args=[self.project.item.id])",
                                        "Function `test_label_mapping`\nCode:\n    def test_label_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"Negative\"}]\n        self.assertEqual(response.json(), expected)",
                                        "Class `TestConfigCreation`\nCode:\nclass TestConfigCreation(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"Amazon Comprehend Sentiment Analysis\",\n            \"model_attrs\": {\n                \"aws_access_key\": \"str\",\n                \"aws_secret_access_key\": \"str\",\n                \"region_name\": \"us-east-1\",\n                \"language_code\": \"en\",\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_configs\", args=[self.project.item.id])\n\n    def test_create_config(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"model_name\"], self.data[\"model_name\"])\n\n    def test_list_config(self):\n        mommy.make(\"AutoLabelingConfig\", project=self.project.item)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"Amazon Comprehend Sentiment Analysis\",\n            \"model_attrs\": {\n                \"aws_access_key\": \"str\",\n                \"aws_secret_access_key\": \"str\",\n                \"region_name\": \"us-east-1\",\n                \"language_code\": \"en\",\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_configs\", args=[self.project.item.id])",
                                        "Function `test_create_config`\nCode:\n    def test_create_config(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"model_name\"], self.data[\"model_name\"])",
                                        "Function `test_list_config`\nCode:\n    def test_list_config(self):\n        mommy.make(\"AutoLabelingConfig\", project=self.project.item)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)",
                                        "Class `TestAutomatedLabeling`\nCode:\nclass TestAutomatedLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, single_class_classification=False)\n        self.example = make_doc(self.project.item)\n        self.category_pos = mommy.make(\"CategoryType\", project=self.project.item, text=\"POS\")\n        self.category_neg = mommy.make(\"CategoryType\", project=self.project.item, text=\"NEG\")\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"POS\"}]))\n    def test_category_labeling(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Category.objects.first().label, self.category_pos)\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"NEUTRAL\"}]))\n    def test_nonexistent_category(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[Categories([{\"label\": \"POS\"}]), Categories([{\"label\": \"NEG\"}])],\n    )\n    def test_multiple_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 2)\n        self.assertEqual(Category.objects.first().label, self.category_pos)\n        self.assertEqual(Category.objects.last().label, self.category_neg)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[Categories([{\"label\": \"POS\"}]), Categories([{\"label\": \"POS\"}])],\n    )\n    def test_cannot_label_same_category_type(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[\n            Categories([{\"label\": \"POS\"}]),\n            Spans([{\"label\": \"LOC\", \"start_offset\": 0, \"end_offset\": 5}]),\n        ],\n    )\n    def test_allow_multi_type_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Span.objects.count(), 1)\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"POS\"}]))\n    def test_cannot_use_other_project_config(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\")\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, single_class_classification=False)\n        self.example = make_doc(self.project.item)\n        self.category_pos = mommy.make(\"CategoryType\", project=self.project.item, text=\"POS\")\n        self.category_neg = mommy.make(\"CategoryType\", project=self.project.item, text=\"NEG\")\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"",
                                        "Function `test_category_labeling`\nCode:\n    def test_category_labeling(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Category.objects.first().label, self.category_pos)",
                                        "Function `test_nonexistent_category`\nCode:\n    def test_nonexistent_category(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)",
                                        "Function `test_multiple_configs`\nCode:\n    def test_multiple_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 2)\n        self.assertEqual(Category.objects.first().label, self.category_pos)\n        self.assertEqual(Category.objects.last().label, self.category_neg)",
                                        "Function `test_cannot_label_same_category_type`\nCode:\n    def test_cannot_label_same_category_type(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)",
                                        "Function `test_allow_multi_type_configs`\nCode:\n    def test_allow_multi_type_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Span.objects.count(), 1)",
                                        "Function `test_cannot_use_other_project_config`\nCode:\n    def test_cannot_use_other_project_config(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\")\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)",
                                        "Class `TestAutomatedSpanLabeling`\nCode:\nclass TestAutomatedSpanLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQUENCE_LABELING)\n        self.example = make_doc(self.project.item)\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[\n            Spans([{\"label\": \"LOC\", \"start_offset\": 0, \"end_offset\": 5}]),\n            Spans([{\"label\": \"LOC\", \"start_offset\": 4, \"end_offset\": 10}]),\n        ],\n    )\n    def test_cannot_label_overlapping_span(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Span.objects.count(), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQUENCE_LABELING)\n        self.example = make_doc(self.project.item)\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"",
                                        "Function `test_cannot_label_overlapping_span`\nCode:\n    def test_cannot_label_overlapping_span(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Span.objects.count(), 1)",
                                        "Class `TestAutomatedTextLabeling`\nCode:\nclass TestAutomatedTextLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQ2SEQ)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\"auto_labeling.views.execute_pipeline\", side_effect=[Texts([{\"text\": \"foo\"}]), Texts([{\"text\": \"foo\"}])])\n    def test_cannot_label_same_text(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(TextLabel.objects.count(), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQ2SEQ)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"",
                                        "Function `test_cannot_label_same_text`\nCode:\n    def test_cannot_label_same_text(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(TextLabel.objects.count(), 1)"
                                    ],
                                    "code": "import pathlib\nfrom unittest.mock import patch\n\nfrom auto_labeling_pipeline.mappings import AmazonComprehendSentimentTemplate\nfrom auto_labeling_pipeline.models import RequestModelFactory\nfrom model_mommy import mommy\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom auto_labeling.pipeline.labels import Categories, Spans, Texts\nfrom examples.tests.utils import make_doc\nfrom labels.models import Category, Span, TextLabel\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\ndata_dir = pathlib.Path(__file__).parent / \"data\"\n\n\nclass TestTemplateList(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"auto_labeling_templates\", args=[self.project.item.id])\n\n    def test_allow_admin_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertIn(\"Custom REST Request\", response.data)\n        self.assertGreaterEqual(len(response.data), 1)\n\n    def test_deny_project_staff_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        for user in self.project.staffs:\n            self.assert_fetch(user, status.HTTP_403_FORBIDDEN)\n\n    def test_return_only_default_template_with_empty_task_name(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)\n\n    def test_return_only_default_template_with_wrong_task_name(self):\n        self.url += \"?task_name=foobar\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)\n\n\nclass TestConfigParameter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"GCP Entity Analysis\",\n            \"model_attrs\": {\"key\": \"hoge\", \"type\": \"PLAIN_TEXT\", \"language\": \"en\"},\n            \"text\": \"example\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_parameter_testing\", args=[self.project.item.id])\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_proper_model(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        expected = RequestModelFactory.create(self.data[\"model_name\"], self.data[\"model_attrs\"])\n        self.assertEqual(kwargs[\"model\"], expected)\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_text(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_image(self, mock):\n        self.data[\"text\"] = str(data_dir / \"images/1500x500.jpeg\")\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])\n\n\nclass TestTemplateMapping(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": {\n                \"Sentiment\": \"NEUTRAL\",\n                \"SentimentScore\": {\n                    \"Positive\": 0.004438233096152544,\n                    \"Negative\": 0.0005306027014739811,\n                    \"Neutral\": 0.9950305223464966,\n                    \"Mixed\": 5.80838445785048e-7,\n                },\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_template_test\", args=[self.project.item.id])\n\n    def test_template_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"NEUTRAL\"}]\n        self.assertEqual(response.json(), expected)\n\n    def test_json_decode_error(self):\n        self.data[\"template\"] = \"\"\n        self.assert_create(self.project.admin, status.HTTP_400_BAD_REQUEST)\n\n\nclass TestLabelMapping(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": [{\"label\": \"NEGATIVE\"}],\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_mapping_test\", args=[self.project.item.id])\n\n    def test_label_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"Negative\"}]\n        self.assertEqual(response.json(), expected)\n\n\nclass TestConfigCreation(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"Amazon Comprehend Sentiment Analysis\",\n            \"model_attrs\": {\n                \"aws_access_key\": \"str\",\n                \"aws_secret_access_key\": \"str\",\n                \"region_name\": \"us-east-1\",\n                \"language_code\": \"en\",\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_configs\", args=[self.project.item.id])\n\n    def test_create_config(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"model_name\"], self.data[\"model_name\"])\n\n    def test_list_config(self):\n        mommy.make(\"AutoLabelingConfig\", project=self.project.item)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n\n\nclass TestAutomatedLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, single_class_classification=False)\n        self.example = make_doc(self.project.item)\n        self.category_pos = mommy.make(\"CategoryType\", project=self.project.item, text=\"POS\")\n        self.category_neg = mommy.make(\"CategoryType\", project=self.project.item, text=\"NEG\")\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"POS\"}]))\n    def test_category_labeling(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Category.objects.first().label, self.category_pos)\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"NEUTRAL\"}]))\n    def test_nonexistent_category(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[Categories([{\"label\": \"POS\"}]), Categories([{\"label\": \"NEG\"}])],\n    )\n    def test_multiple_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 2)\n        self.assertEqual(Category.objects.first().label, self.category_pos)\n        self.assertEqual(Category.objects.last().label, self.category_neg)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[Categories([{\"label\": \"POS\"}]), Categories([{\"label\": \"POS\"}])],\n    )\n    def test_cannot_label_same_category_type(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[\n            Categories([{\"label\": \"POS\"}]),\n            Spans([{\"label\": \"LOC\", \"start_offset\": 0, \"end_offset\": 5}]),\n        ],\n    )\n    def test_allow_multi_type_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Span.objects.count(), 1)\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"POS\"}]))\n    def test_cannot_use_other_project_config(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\")\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)\n\n\nclass TestAutomatedSpanLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQUENCE_LABELING)\n        self.example = make_doc(self.project.item)\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[\n            Spans([{\"label\": \"LOC\", \"start_offset\": 0, \"end_offset\": 5}]),\n            Spans([{\"label\": \"LOC\", \"start_offset\": 4, \"end_offset\": 10}]),\n        ],\n    )\n    def test_cannot_label_overlapping_span(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Span.objects.count(), 1)\n\n\nclass TestAutomatedTextLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQ2SEQ)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\"auto_labeling.views.execute_pipeline\", side_effect=[Texts([{\"text\": \"foo\"}]), Texts([{\"text\": \"foo\"}])])\n    def test_cannot_label_same_text(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(TextLabel.objects.count(), 1)\n",
                                    "summary": "Class `TestTemplateList`: Contains test methods for fetching template lists based on task names for project admins and staff members, with specific functions for setup, admin access, staff denial, default template handling, and incorrect task name scenarios.\nClass `TestConfigParameter`: A test class for model creation and data handling in auto labeling parameter testing, including setup, model verification, text data testing, and image data handling.\nClass `TestTemplateMapping`: A test case class for mapping template data with sentiment analysis results, covering template mapping with neutral labels and JSON decoding error scenarios.\nClass `TestLabelMapping`: A test class for label mapping functionality in a document classification project, focusing on setup, label mapping testing, and project creation with specified labels.\nClass `TestConfigCreation`: A test class for creating and listing auto labeling configurations in a document classification project, with functions for configuration creation and listing of AutoLabelingConfig objects.\nClass `TestAutomatedLabeling`: Contains test cases for automated labeling functionality with different",
                                    "code_element_summaries": [
                                        "Class `TestTemplateList`: Contains test methods to validate fetching of template lists based on task names for project admins and staff members.",
                                        "Function `setUp`: Sets up a project for document classification and generates a URL for auto labeling templates.",
                                        "Function `test_allow_admin_to_fetch_template_list`: Tests if admin users can fetch a list of templates for document classification tasks.",
                                        "Function `test_deny_project_staff_to_fetch_template_list`: Tests that project staff members are denied access to fetch template list for a specific task.",
                                        "Function test_return_only_default_template_with_empty_task_name: Tests that only the default template is returned when the task name is empty.",
                                        "Function `test_return_only_default_template_with_wrong_task_name`: Tests that only the default template is returned when an incorrect task name is provided.",
                                        "Class `TestConfigParameter`: A test class for verifying proper model creation and data handling in auto labeling parameter testing.",
                                        "Function `setUp`: Sets up the necessary data and parameters for testing auto labeling with a specific project type.",
                                        "Function `test_called_with_proper_model`: Asserts that the proper model is created and called with the expected attributes.",
                                        "Function `test_called_with_text`: Asserts that a certain function is called with specific text data.",
                                        "Function `test_called_with_image`: Tests if the function correctly handles image data and asserts that the expected result matches the provided image path.",
                                        "Class `TestTemplateMapping`: A test case class for mapping template data with sentiment analysis results.",
                                        "Function `setUp`: Initializes the project, data, and URL for testing auto labeling templates in a document classification task.",
                                        "Function test_template_mapping: Tests the mapping of a template with a neutral label.",
                                        "Function `test_json_decode_error`: A test function that checks for JSON decoding errors by setting the template data to an empty string and asserting a bad request status during creation.",
                                        "Class `TestLabelMapping`: A test class for label mapping functionality in a document classification project.",
                                        "Function `setUp`: Sets up the necessary data and project for testing auto labeling mappings in document classification tasks.",
                                        "Function `test_label_mapping`: Tests label mapping functionality by asserting the creation of a project with a specified label.",
                                        "Class `TestConfigCreation`: A test class for creating and listing auto labeling configurations for a document classification project.",
                                        "Function `setUp`: Sets up data and configuration for a document classification project using Amazon Comprehend Sentiment Analysis model.",
                                        "Function `test_create_config`: Tests the creation of a configuration by asserting the status code and comparing the model name in the response data with the input data model name.",
                                        "Function `test_list_config`: Tests the retrieval of AutoLabelingConfig objects for a project and asserts that only one object is returned.",
                                        "Class `TestAutomatedLabeling`: Contains test cases for automated labeling functionality with different configurations and assertions.",
                                        "Function `setUp`: Initializes project, example, categories, span type, and URL for auto labeling in a document classification task.",
                                        "Function `test_category_labeling`: Tests the category labeling functionality by creating an AutoLabelingConfig object with task type as \"Category\" and asserting the creation status and label correctness.",
                                        "Function `test_nonexistent_category`: A test function that checks if creating a category with a nonexistent project results in the category not being created.",
                                        "Function `test_multiple_configs`: Tests the creation of multiple AutoLabelingConfig instances with task type \"Category\" and asserts the correct number of Category objects created with corresponding labels.",
                                        "Function `test_cannot_label_same_category_type`: Tests that multiple AutoLabelingConfig instances with the same task_type \"Category\" cannot be created for a project, ensuring only one instance is created.",
                                        "Function `test_allow_multi_type_configs`: Tests the ability to create multiple AutoLabelingConfig instances with different task types within a project.",
                                        "Function `test_cannot_use_other_project_config`: Tests that a user cannot use the configuration of another project for category auto-labeling.",
                                        "Class `TestAutomatedSpanLabeling`: A test class for automated span labeling functionality that sets up necessary data and tests the behavior of not being able to label overlapping spans.",
                                        "Function `setUp`: Sets up necessary data for testing sequence labeling project with an example document, location span type, and auto labeling URL.",
                                        "Function `test_cannot_label_overlapping_span`: Tests that overlapping spans cannot be labeled within the same project.",
                                        "Class `TestAutomatedTextLabeling`: A test class for automated text labeling functionality in a project, ensuring that the same text cannot be labeled multiple times.",
                                        "Function `setUp`: Sets up the necessary data for testing auto labeling functionality in a Seq2Seq project.",
                                        "Function `test_cannot_label_same_text`: Tests that only one TextLabel object is created when attempting to label the same text multiple times."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a class ExportedBoundingBox that acts as a proxy model for BoundingBox, offering methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import (\n    AutomatedLabeling,\n    ConfigDetail,\n    ConfigList,\n    LabelExtractorTesting,\n    LabelMapperTesting,\n    RestAPIRequestTesting,\n    TemplateDetailAPI,\n    TemplateListAPI,\n)\n\nurlpatterns = [\n    path(route=\"auto-labeling/templates\", view=TemplateListAPI.as_view(), name=\"auto_labeling_templates\"),\n    path(\n        route=\"auto-labeling/templates/<str:option_name>\",\n        view=TemplateDetailAPI.as_view(),\n        name=\"auto_labeling_template\",\n    ),\n    path(route=\"auto-labeling/configs\", view=ConfigList.as_view(), name=\"auto_labeling_configs\"),\n    path(route=\"auto-labeling/configs/<int:config_id>\", view=ConfigDetail.as_view(), name=\"auto_labeling_config\"),\n    path(\n        route=\"auto-labeling/request-testing\",\n        view=RestAPIRequestTesting.as_view(),\n        name=\"auto_labeling_parameter_testing\",\n    ),\n    path(\n        route=\"auto-labeling/label-extractor-testing\",\n        view=LabelExtractorTesting.as_view(),\n        name=\"auto_labeling_template_test\",\n    ),\n    path(\n        route=\"auto-labeling/label-mapper-testing\", view=LabelMapperTesting.as_view(), name=\"auto_labeling_mapping_test\"\n    ),\n    path(route=\"auto-labeling\", view=AutomatedLabeling.as_view(), name=\"auto_labeling\"),\n]\n",
                            "summary": "URL patterns for various views related to auto-labeling including template list, template detail, config list, config detail, API request testing, label extractor testing, and label mapper testing.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `TemplateListAPI`\nCode:\nclass TemplateListAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request: Request, *args, **kwargs):\n        task_name = request.query_params.get(\"task_name\")\n        options = Options.filter_by_task(task_name=task_name)\n        option_names = [o.name for o in options]\n        return Response(option_names, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request: Request, *args, **kwargs):\n        task_name = request.query_params.get(\"task_name\")\n        options = Options.filter_by_task(task_name=task_name)\n        option_names = [o.name for o in options]\n        return Response(option_names, status=status.HTTP_200_OK)",
                                "Class `TemplateDetailAPI`\nCode:\nclass TemplateDetailAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        option = Options.find(option_name=self.kwargs[\"option_name\"])\n        return Response(option.to_dict(), status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        option = Options.find(option_name=self.kwargs[\"option_name\"])\n        return Response(option.to_dict(), status=status.HTTP_200_OK)",
                                "Class `ConfigList`\nCode:\nclass ConfigList(generics.ListCreateAPIView):\n    serializer_class = AutoLabelingConfigSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get_queryset(self):\n        return AutoLabelingConfig.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])",
                                "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        return AutoLabelingConfig.objects.filter(project=self.kwargs[\"project_id\"])",
                                "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])",
                                "Class `ConfigDetail`\nCode:\nclass ConfigDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = AutoLabelingConfig.objects.all()\n    serializer_class = AutoLabelingConfigSerializer\n    lookup_url_kwarg = \"config_id\"\n    permission_classes = [IsAuthenticated & IsProjectAdmin]",
                                "Class `RestAPIRequestTesting`\nCode:\nclass RestAPIRequestTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def create_model(self):\n        model_name = self.request.data[\"model_name\"]\n        model_attrs = self.request.data[\"model_attrs\"]\n        try:\n            model = RequestModelFactory.create(model_name, model_attrs)\n            return model\n        except Exception:\n            model = RequestModelFactory.find(model_name)\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )\n\n    def send_request(self, model, example):\n        try:\n            return model.send(example)\n        except requests.exceptions.ConnectionError:\n            raise URLConnectionError\n        except botocore.exceptions.ClientError:\n            raise AWSTokenError()\n        except json.decoder.JSONDecodeError:\n            raise ResponseJSONDecodeError()\n        except Exception as e:\n            raise e\n\n    def prepare_example(self):\n        text = self.request.data[\"text\"]\n        if self.project.is_text_project:\n            return text\n        else:\n            tu = TemporaryUpload.objects.get(upload_id=text)\n            return tu.get_file_path()\n\n    def post(self, *args, **kwargs):\n        model = self.create_model()\n        example = self.prepare_example()\n        response = self.send_request(model=model, example=example)\n        return Response(response, status=status.HTTP_200_OK)",
                                "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                "Function `create_model`\nCode:\n    def create_model(self):\n        model_name = self.request.data[\"model_name\"]\n        model_attrs = self.request.data[\"model_attrs\"]\n        try:\n            model = RequestModelFactory.create(model_name, model_attrs)\n            return model\n        except Exception:\n            model = RequestModelFactory.find(model_name)\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )",
                                "Function `send_request`\nCode:\n    def send_request(self, model, example):\n        try:\n            return model.send(example)\n        except requests.exceptions.ConnectionError:\n            raise URLConnectionError\n        except botocore.exceptions.ClientError:\n            raise AWSTokenError()\n        except json.decoder.JSONDecodeError:\n            raise ResponseJSONDecodeError()\n        except Exception as e:\n            raise e",
                                "Function `prepare_example`\nCode:\n    def prepare_example(self):\n        text = self.request.data[\"text\"]\n        if self.project.is_text_project:\n            return text\n        else:\n            tu = TemporaryUpload.objects.get(upload_id=text)\n            return tu.get_file_path()",
                                "Function `post`\nCode:\n    def post(self, *args, **kwargs):\n        model = self.create_model()\n        example = self.prepare_example()\n        response = self.send_request(model=model, example=example)\n        return Response(response, status=status.HTTP_200_OK)",
                                "Class `LabelExtractorTesting`\nCode:\nclass LabelExtractorTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        template = self.request.data[\"template\"]\n        task_type = self.request.data[\"task_type\"]\n        label_collection = get_label_collection(task_type)\n        template = MappingTemplate(label_collection=label_collection, template=template)\n        try:\n            labels = template.render(response)\n        except json.decoder.JSONDecodeError:\n            raise TemplateMappingError()\n        if not labels.dict():\n            raise SampleDataException()\n        return Response(labels.dict(), status=status.HTTP_200_OK)",
                                "Function `post`\nCode:\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        template = self.request.data[\"template\"]\n        task_type = self.request.data[\"task_type\"]\n        label_collection = get_label_collection(task_type)\n        template = MappingTemplate(label_collection=label_collection, template=template)\n        try:\n            labels = template.render(response)\n        except json.decoder.JSONDecodeError:\n            raise TemplateMappingError()\n        if not labels.dict():\n            raise SampleDataException()\n        return Response(labels.dict(), status=status.HTTP_200_OK)",
                                "Class `LabelMapperTesting`\nCode:\nclass LabelMapperTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        task_type = self.request.data[\"task_type\"]\n        label_mapping = self.request.data[\"label_mapping\"]\n        label_collection = get_label_collection(task_type)\n        labels = label_collection(response)\n        post_processor = PostProcessor(label_mapping)\n        labels = post_processor.transform(labels)\n        return Response(labels.dict(), status=status.HTTP_200_OK)",
                                "Function `post`\nCode:\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        task_type = self.request.data[\"task_type\"]\n        label_mapping = self.request.data[\"label_mapping\"]\n        label_collection = get_label_collection(task_type)\n        labels = label_collection(response)\n        post_processor = PostProcessor(label_mapping)\n        labels = post_processor.transform(labels)\n        return Response(labels.dict(), status=status.HTTP_200_OK)",
                                "Class `AutomatedLabeling`\nCode:\nclass AutomatedLabeling(generics.CreateAPIView):\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    swagger_schema = None\n\n    def create(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        example = project.examples.get(pk=self.request.query_params[\"example\"])\n        configs = AutoLabelingConfig.objects.filter(project=project)\n        # Todo: make async calls or celery tasks to reduce waiting time.\n        for config in configs:\n            labels = execute_pipeline(example.data, config=config)\n            labels.save(project, example, self.request.user)\n        return Response({\"ok\": True}, status=status.HTTP_201_CREATED)",
                                "Function `create`\nCode:\n    def create(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        example = project.examples.get(pk=self.request.query_params[\"example\"])\n        configs = AutoLabelingConfig.objects.filter(project=project)\n        # Todo: make async calls or celery tasks to reduce waiting time.\n        for config in configs:\n            labels = execute_pipeline(example.data, config=config)\n            labels.save(project, example, self.request.user)\n        return Response({\"ok\": True}, status=status.HTTP_201_CREATED)"
                            ],
                            "code": "import json\n\nimport botocore.exceptions\nimport requests\nfrom auto_labeling_pipeline.mappings import MappingTemplate\nfrom auto_labeling_pipeline.menu import Options\nfrom auto_labeling_pipeline.models import RequestModelFactory\nfrom auto_labeling_pipeline.postprocessing import PostProcessor\nfrom django.shortcuts import get_object_or_404\nfrom django_drf_filepond.models import TemporaryUpload\nfrom rest_framework import generics, status\nfrom rest_framework.exceptions import ValidationError\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom .exceptions import (\n    AWSTokenError,\n    ResponseJSONDecodeError,\n    SampleDataException,\n    TemplateMappingError,\n    URLConnectionError,\n)\nfrom .models import AutoLabelingConfig\nfrom .pipeline.execution import execute_pipeline, get_label_collection\nfrom .serializers import AutoLabelingConfigSerializer\nfrom projects.models import Project\nfrom projects.permissions import IsProjectAdmin, IsProjectMember\n\n\nclass TemplateListAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request: Request, *args, **kwargs):\n        task_name = request.query_params.get(\"task_name\")\n        options = Options.filter_by_task(task_name=task_name)\n        option_names = [o.name for o in options]\n        return Response(option_names, status=status.HTTP_200_OK)\n\n\nclass TemplateDetailAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        option = Options.find(option_name=self.kwargs[\"option_name\"])\n        return Response(option.to_dict(), status=status.HTTP_200_OK)\n\n\nclass ConfigList(generics.ListCreateAPIView):\n    serializer_class = AutoLabelingConfigSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get_queryset(self):\n        return AutoLabelingConfig.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])\n\n\nclass ConfigDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = AutoLabelingConfig.objects.all()\n    serializer_class = AutoLabelingConfigSerializer\n    lookup_url_kwarg = \"config_id\"\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n\nclass RestAPIRequestTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def create_model(self):\n        model_name = self.request.data[\"model_name\"]\n        model_attrs = self.request.data[\"model_attrs\"]\n        try:\n            model = RequestModelFactory.create(model_name, model_attrs)\n            return model\n        except Exception:\n            model = RequestModelFactory.find(model_name)\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )\n\n    def send_request(self, model, example):\n        try:\n            return model.send(example)\n        except requests.exceptions.ConnectionError:\n            raise URLConnectionError\n        except botocore.exceptions.ClientError:\n            raise AWSTokenError()\n        except json.decoder.JSONDecodeError:\n            raise ResponseJSONDecodeError()\n        except Exception as e:\n            raise e\n\n    def prepare_example(self):\n        text = self.request.data[\"text\"]\n        if self.project.is_text_project:\n            return text\n        else:\n            tu = TemporaryUpload.objects.get(upload_id=text)\n            return tu.get_file_path()\n\n    def post(self, *args, **kwargs):\n        model = self.create_model()\n        example = self.prepare_example()\n        response = self.send_request(model=model, example=example)\n        return Response(response, status=status.HTTP_200_OK)\n\n\nclass LabelExtractorTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        template = self.request.data[\"template\"]\n        task_type = self.request.data[\"task_type\"]\n        label_collection = get_label_collection(task_type)\n        template = MappingTemplate(label_collection=label_collection, template=template)\n        try:\n            labels = template.render(response)\n        except json.decoder.JSONDecodeError:\n            raise TemplateMappingError()\n        if not labels.dict():\n            raise SampleDataException()\n        return Response(labels.dict(), status=status.HTTP_200_OK)\n\n\nclass LabelMapperTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        task_type = self.request.data[\"task_type\"]\n        label_mapping = self.request.data[\"label_mapping\"]\n        label_collection = get_label_collection(task_type)\n        labels = label_collection(response)\n        post_processor = PostProcessor(label_mapping)\n        labels = post_processor.transform(labels)\n        return Response(labels.dict(), status=status.HTTP_200_OK)\n\n\nclass AutomatedLabeling(generics.CreateAPIView):\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    swagger_schema = None\n\n    def create(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        example = project.examples.get(pk=self.request.query_params[\"example\"])\n        configs = AutoLabelingConfig.objects.filter(project=project)\n        # Todo: make async calls or celery tasks to reduce waiting time.\n        for config in configs:\n            labels = execute_pipeline(example.data, config=config)\n            labels.save(project, example, self.request.user)\n        return Response({\"ok\": True}, status=status.HTTP_201_CREATED)\n",
                            "summary": "Class TemplateListAPI: Retrieves a list of option names based on a specified task name, Class TemplateDetailAPI: Retrieves details of a specific template option in dictionary form, Class ConfigList: Handles listing and creating AutoLabelingConfig objects for a specific project, Class ConfigDetail: Manages retrieving, updating, and deleting AutoLabelingConfig instances, Class RestAPIRequestTesting: Tests REST API requests including model creation, request sending, and response handling, Class LabelExtractorTesting: Extracts labels from a response using a template and task type, Class LabelMapperTesting: Handles label mapping and post-processing on response data, Class AutomatedLabeling: Automates labeling process for a project by executing pipelines with configurations and saving labels.",
                            "code_element_summaries": [
                                "Class TemplateListAPI: An API view that retrieves a list of option names based on a specified task name.",
                                "Function `get`: Retrieves options based on task name from the request query parameters and returns a list of option names in the response.",
                                "Class TemplateDetailAPI: An API view that retrieves and returns details of a specific template option in dictionary form.",
                                "Function `get`: Retrieves an option object by name and returns its dictionary representation in a Response object.",
                                "Class `ConfigList`: A view that handles listing and creating AutoLabelingConfig objects for a specific project with authentication and project admin permissions.",
                                "Function `get_queryset`: Retrieves AutoLabelingConfig objects filtered by project ID.",
                                "Function `perform_create`: Saves the serializer with the project_id taken from the URL kwargs.",
                                "Class ConfigDetail: A view for retrieving, updating, and deleting AutoLabelingConfig instances with authentication and permission checks.",
                                "Class `RestAPIRequestTesting`: An API view class for testing REST API requests, including methods for creating models, sending requests, and handling responses.",
                                "Function `project`: Retrieves a Project object based on the project_id parameter from the URL.",
                                "Function `create_model`: A method that creates a model based on provided model name and attributes, handling exceptions and validation errors.",
                                "Function `send_request`: Sends a request using a specified model and handles different types of exceptions that may occur.",
                                "Function `prepare_example`: Retrieves text data or file path based on project type.",
                                "Function `post`: Creates a model, prepares an example, sends a request, and returns the response.",
                                "Class `LabelExtractorTesting`: An APIView class that extracts labels from a response using a template and task type, handling exceptions and returning the labels in dictionary form.",
                                "Function `post`: Processes incoming data to generate labels based on a provided template and task type, returning the labels in dictionary format if successful.",
                                "Class LabelMapperTesting: An API view class that handles post requests for label mapping and post-processing on response data.",
                                "Function `post`: Processes a POST request data to retrieve labels, apply post-processing, and return the transformed labels in a dictionary format.",
                                "Class `AutomatedLabeling`: A view that automates labeling process for a project by executing pipelines with configurations and saving labels.",
                                "Function `create`: Creates annotations for a project's example using AutoLabelingConfig configurations and saves them."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that provides methods to convert bounding box annotations into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "cli.py",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\cli.py",
                    "is_dir": false,
                    "code_elements": [
                        "Function `number_of_workers`\nCode:\ndef number_of_workers():\n    return (multiprocessing.cpu_count() * 2) + 1",
                        "Function `is_windows`\nCode:\ndef is_windows():\n    return platform.system() == \"Windows\"",
                        "Function `run_on_nix`\nCode:\ndef run_on_nix(args):\n    import gunicorn.app.base\n    import gunicorn.util\n\n    class StandaloneApplication(gunicorn.app.base.BaseApplication):\n        def __init__(self, options=None):\n            self.options = options or {}\n            super().__init__()\n\n        def load_config(self):\n            config = {\n                key: value for key, value in self.options.items() if key in self.cfg.settings and value is not None\n            }\n            for key, value in config.items():\n                self.cfg.set(key.lower(), value)\n\n        def load(self):\n            return gunicorn.util.import_app(\"config.wsgi\")\n\n    options = {\n        \"bind\": \"%s:%s\" % (\"0.0.0.0\", args.port),\n        \"workers\": args.workers,\n        \"chdir\": base,\n        \"capture_output\": True,\n        \"loglevel\": \"info\",\n    }\n    StandaloneApplication(options).run()",
                        "Class `StandaloneApplication`\nCode:\n    class StandaloneApplication(gunicorn.app.base.BaseApplication):\n        def __init__(self, options=None):\n            self.options = options or {}\n            super().__init__()\n\n        def load_config(self):\n            config = {\n                key: value for key, value in self.options.items() if key in self.cfg.settings and value is not None\n            }\n            for key, value in config.items():\n                self.cfg.set(key.lower(), value)\n\n        def load(self):\n            return gunicorn.util.import_app(\"config.wsgi\")",
                        "Function `__init__`\nCode:\n        def __init__(self, options=None):\n            self.options = options or {}\n            super().__init__()",
                        "Function `load_config`\nCode:\n        def load_config(self):\n            config = {\n                key: value for key, value in self.options.items() if key in self.cfg.settings and value is not None\n            }\n            for key, value in config.items():\n                self.cfg.set(key.lower(), value)",
                        "Function `load`\nCode:\n        def load(self):\n            return gunicorn.util.import_app(\"config.wsgi\")",
                        "Function `run_on_windows`\nCode:\ndef run_on_windows(args):\n    from waitress import serve\n\n    from config.wsgi import application\n\n    serve(application, port=args.port, threads=args.workers)",
                        "Function `command_db_init`\nCode:\ndef command_db_init(args):\n    print(\"Setup Database.\")\n    management.call_command(\"wait_for_db\")\n    management.call_command(\"migrate\")\n    management.call_command(\"create_roles\")",
                        "Function `command_user_create`\nCode:\ndef command_user_create(args):\n    print(\"Create admin user.\")\n    management.call_command(\n        \"create_admin\", \"--noinput\", username=args.username, password=args.password, email=args.email\n    )",
                        "Function `command_migrate`\nCode:\ndef command_migrate(args):\n    print(\"Start migration.\")\n    management.call_command(\"migrate\")",
                        "Function `command_run_webserver`\nCode:\ndef command_run_webserver(args):\n    print(f\"Starting server with port {args.port}.\")\n    if is_windows():\n        run_on_windows(args)\n    else:\n        run_on_nix(args)",
                        "Function `command_run_task_queue`\nCode:\ndef command_run_task_queue(args):\n    print(\"Starting task queue.\")\n    argv = [\n        \"--app=config\",\n        \"--workdir={}\".format(base),\n        \"worker\",\n        \"--loglevel=info\",\n        \"--concurrency={}\".format(args.concurrency),\n    ]\n    if is_windows():\n        argv.append(\"--pool=solo\")\n    app.worker_main(argv=argv)",
                        "Function `command_run_flower`\nCode:\ndef command_run_flower(args):\n    print(\"Starting flower.\")\n    argv = [\n        \"--app=config\",\n        \"--workdir={}\".format(base),\n        \"flower\",\n    ]\n    if args.basic_auth:\n        argv.append(\"--basic_auth={}\".format(args.basic_auth))\n    app.worker_main(argv=argv)",
                        "Function `command_help`\nCode:\ndef command_help(args):\n    print(parser.parse_args([args.command, \"--help\"]))",
                        "Function `main`\nCode:\ndef main():\n    # Create a command line parser.\n    subparsers = parser.add_subparsers()\n\n    # Create a parser for db initialization.\n    parser_init = subparsers.add_parser(\"init\", help=\"see `init -h`\")\n    parser_init.set_defaults(handler=command_db_init)\n\n    # Create a parser for migration.\n    parser_migration = subparsers.add_parser(\"migrate\", help=\"Updates database schema.\")\n    parser_migration.set_defaults(handler=command_migrate)\n\n    # Create a parser for user creation.\n    parser_create_user = subparsers.add_parser(\"createuser\", help=\"see `createuser -h`\")\n    parser_create_user.add_argument(\"--username\", type=str, default=\"admin\", help=\"admin username\")\n    parser_create_user.add_argument(\"--password\", type=str, default=\"password\", help=\"admin password\")\n    parser_create_user.add_argument(\"--email\", type=str, default=\"example@example.com\", help=\"admin email\")\n    parser_create_user.set_defaults(handler=command_user_create)\n\n    # Create a parser for web server.\n    parser_server = subparsers.add_parser(\"webserver\", help=\"see `webserver -h`\")\n    parser_server.add_argument(\"--port\", type=int, default=8000, help=\"port number\")\n    parser_server.add_argument(\"--workers\", type=int, default=number_of_workers(), help=\"the number of workers\")\n    parser_server.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_server.set_defaults(handler=command_run_webserver)\n\n    # Create a parser for task queue.\n    parser_queue = subparsers.add_parser(\"task\", help=\"see `task -h`\")\n    parser_queue.add_argument(\"--concurrency\", type=int, default=2, help=\"concurrency\")\n    parser_queue.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_queue.set_defaults(handler=command_run_task_queue)\n\n    parser_flower = subparsers.add_parser(\"flower\", help=\"see `flower -h`\")\n    parser_flower.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_flower.add_argument(\"--basic_auth\", type=str, help=\"username and password for basic authentication\")\n    parser_flower.set_defaults(handler=command_run_flower)\n\n    # Create a parser for help.\n    parser_help = subparsers.add_parser(\"help\", help=\"see `help -h`\")\n    parser_help.add_argument(\"command\", help=\"command name which help is shown\")\n    parser_help.set_defaults(handler=command_help)\n\n    # Dispatch handler.\n    args = parser.parse_args()\n    if hasattr(args, \"env_file\") and args.env_file and Path(args.env_file).is_file():\n        env.read_env(args.env_file, recurse=False, override=True)\n    if hasattr(args, \"handler\"):\n        django.setup()\n        args.handler(args)\n    else:\n        # If specified unknown command, show help.\n        parser.print_help()"
                    ],
                    "code": "import argparse\nimport multiprocessing\nimport os\nimport platform\nimport sys\nfrom pathlib import Path\n\nimport django\nfrom django.core import management\nfrom environs import Env\n\nfrom .config.celery import app\n\nenv = Env()\nDOCCANO_HOME = os.path.expanduser(os.environ.get(\"DOCCANO_HOME\", \"~/doccano\"))\nPath(DOCCANO_HOME).mkdir(parents=True, exist_ok=True)\nenv.bool(\"DEBUG\", False)\nos.environ[\"STANDALONE\"] = \"True\"\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings.production\")\nos.environ.setdefault(\"DATABASE_URL\", os.path.join(f\"sqlite:///{DOCCANO_HOME}\", \"db.sqlite3\"))\nos.environ.setdefault(\"MEDIA_ROOT\", os.path.join(DOCCANO_HOME, \"media\"))\nbase = os.path.abspath(os.path.dirname(__file__))\nsys.path.append(base)\nparser = argparse.ArgumentParser(description=\"doccano, text annotation for machine learning practitioners.\")\n\n\ndef number_of_workers():\n    return (multiprocessing.cpu_count() * 2) + 1\n\n\ndef is_windows():\n    return platform.system() == \"Windows\"\n\n\ndef run_on_nix(args):\n    import gunicorn.app.base\n    import gunicorn.util\n\n    class StandaloneApplication(gunicorn.app.base.BaseApplication):\n        def __init__(self, options=None):\n            self.options = options or {}\n            super().__init__()\n\n        def load_config(self):\n            config = {\n                key: value for key, value in self.options.items() if key in self.cfg.settings and value is not None\n            }\n            for key, value in config.items():\n                self.cfg.set(key.lower(), value)\n\n        def load(self):\n            return gunicorn.util.import_app(\"config.wsgi\")\n\n    options = {\n        \"bind\": \"%s:%s\" % (\"0.0.0.0\", args.port),\n        \"workers\": args.workers,\n        \"chdir\": base,\n        \"capture_output\": True,\n        \"loglevel\": \"info\",\n    }\n    StandaloneApplication(options).run()\n\n\ndef run_on_windows(args):\n    from waitress import serve\n\n    from config.wsgi import application\n\n    serve(application, port=args.port, threads=args.workers)\n\n\ndef command_db_init(args):\n    print(\"Setup Database.\")\n    management.call_command(\"wait_for_db\")\n    management.call_command(\"migrate\")\n    management.call_command(\"create_roles\")\n\n\ndef command_user_create(args):\n    print(\"Create admin user.\")\n    management.call_command(\n        \"create_admin\", \"--noinput\", username=args.username, password=args.password, email=args.email\n    )\n\n\ndef command_migrate(args):\n    print(\"Start migration.\")\n    management.call_command(\"migrate\")\n\n\ndef command_run_webserver(args):\n    print(f\"Starting server with port {args.port}.\")\n    if is_windows():\n        run_on_windows(args)\n    else:\n        run_on_nix(args)\n\n\ndef command_run_task_queue(args):\n    print(\"Starting task queue.\")\n    argv = [\n        \"--app=config\",\n        \"--workdir={}\".format(base),\n        \"worker\",\n        \"--loglevel=info\",\n        \"--concurrency={}\".format(args.concurrency),\n    ]\n    if is_windows():\n        argv.append(\"--pool=solo\")\n    app.worker_main(argv=argv)\n\n\ndef command_run_flower(args):\n    print(\"Starting flower.\")\n    argv = [\n        \"--app=config\",\n        \"--workdir={}\".format(base),\n        \"flower\",\n    ]\n    if args.basic_auth:\n        argv.append(\"--basic_auth={}\".format(args.basic_auth))\n    app.worker_main(argv=argv)\n\n\ndef command_help(args):\n    print(parser.parse_args([args.command, \"--help\"]))\n\n\ndef main():\n    # Create a command line parser.\n    subparsers = parser.add_subparsers()\n\n    # Create a parser for db initialization.\n    parser_init = subparsers.add_parser(\"init\", help=\"see `init -h`\")\n    parser_init.set_defaults(handler=command_db_init)\n\n    # Create a parser for migration.\n    parser_migration = subparsers.add_parser(\"migrate\", help=\"Updates database schema.\")\n    parser_migration.set_defaults(handler=command_migrate)\n\n    # Create a parser for user creation.\n    parser_create_user = subparsers.add_parser(\"createuser\", help=\"see `createuser -h`\")\n    parser_create_user.add_argument(\"--username\", type=str, default=\"admin\", help=\"admin username\")\n    parser_create_user.add_argument(\"--password\", type=str, default=\"password\", help=\"admin password\")\n    parser_create_user.add_argument(\"--email\", type=str, default=\"example@example.com\", help=\"admin email\")\n    parser_create_user.set_defaults(handler=command_user_create)\n\n    # Create a parser for web server.\n    parser_server = subparsers.add_parser(\"webserver\", help=\"see `webserver -h`\")\n    parser_server.add_argument(\"--port\", type=int, default=8000, help=\"port number\")\n    parser_server.add_argument(\"--workers\", type=int, default=number_of_workers(), help=\"the number of workers\")\n    parser_server.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_server.set_defaults(handler=command_run_webserver)\n\n    # Create a parser for task queue.\n    parser_queue = subparsers.add_parser(\"task\", help=\"see `task -h`\")\n    parser_queue.add_argument(\"--concurrency\", type=int, default=2, help=\"concurrency\")\n    parser_queue.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_queue.set_defaults(handler=command_run_task_queue)\n\n    parser_flower = subparsers.add_parser(\"flower\", help=\"see `flower -h`\")\n    parser_flower.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_flower.add_argument(\"--basic_auth\", type=str, help=\"username and password for basic authentication\")\n    parser_flower.set_defaults(handler=command_run_flower)\n\n    # Create a parser for help.\n    parser_help = subparsers.add_parser(\"help\", help=\"see `help -h`\")\n    parser_help.add_argument(\"command\", help=\"command name which help is shown\")\n    parser_help.set_defaults(handler=command_help)\n\n    # Dispatch handler.\n    args = parser.parse_args()\n    if hasattr(args, \"env_file\") and args.env_file and Path(args.env_file).is_file():\n        env.read_env(args.env_file, recurse=False, override=True)\n    if hasattr(args, \"handler\"):\n        django.setup()\n        args.handler(args)\n    else:\n        # If specified unknown command, show help.\n        parser.print_help()\n\n\nif __name__ == \"__main__\":\n    main()\n",
                    "summary": "A collection of functions and a custom application class for managing server deployment, database initialization, user creation, migration processes, and task queue operations with support for Windows and Unix-based systems.",
                    "code_element_summaries": [
                        "Function `number_of_workers`: Returns the number of workers required for multiprocessing based on CPU count.",
                        "Function `is_windows`: Returns a boolean value indicating if the current operating system is Windows.",
                        "Function `run_on_nix`: A function that runs a Gunicorn application on a Unix-based system with specified options.",
                        "Class StandaloneApplication: A custom application class that extends gunicorn's BaseApplication for standalone deployment with configurable settings.",
                        "Function `__init__`: Initializes the object with optional options dictionary.",
                        "Function `load_config`: Loads configuration settings from options into the cfg object based on specified keys and values.",
                        "Function `load`: Returns the imported application from the \"config.wsgi\" module using gunicorn utility.",
                        "Function `run_on_windows`: A function that runs a Waitress server on Windows using the specified port and number of worker threads.",
                        "Function `command_db_init`: A function that sets up the database by waiting for it, migrating, and creating roles.",
                        "Function `command_user_create`: A function that creates an admin user by calling the \"create_admin\" management command with specified username, password, and email arguments.",
                        "Function `command_migrate`: Executes the migration process by calling the Django management command \"migrate\".",
                        "Function `command_run_webserver`: A function that starts a server with a specified port and runs different implementations based on the operating system.",
                        "Function `command_run_task_queue`: A function that starts a task queue with specific configurations based on the arguments provided.",
                        "Function `command_run_flower`: A function that starts the Flower monitoring tool with specified arguments.",
                        "Function `command_help`: A function that prints the help information for a specific command using the argparse parser.",
                        "Function `main`: A function that creates a command line parser with subparsers for various commands and their respective handlers."
                    ],
                    "children": []
                },
                {
                    "name": "config",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "Setting up Celery for asynchronous task handling in a Django project, configuring Django and Django Rest Framework settings for AWS S3 and Google Cloud Storage, defining URL routes and WSGI configurations, and importing the Celery application for use in the current module.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "celery.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\celery.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "import os\n\nfrom celery import Celery\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings.production\")\n\napp = Celery(\"config\")\n\napp.config_from_object(\"django.conf:settings\", namespace=\"CELERY\")\n\napp.autodiscover_tasks(related_name=\"celery_tasks\")\n",
                            "summary": "Initializing a Celery app for handling asynchronous tasks in a Django project with auto-discovery of tasks.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "settings",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Configuration settings for Django and Django Rest Framework Filepond using AWS S3 and Google Cloud Storage backends, middleware, authentication, database, email, and logging configurations, as well as settings for Heroku deployment.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "aws.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\aws.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "from .base import *  # noqa: F403\nfrom .base import env\n\nMIDDLEWARE.append(\"api.middleware.RangesMiddleware\")  # noqa: F405\n\nDJANGO_DRF_FILEPOND_STORAGES_BACKEND = \"storages.backends.s3boto3.S3Boto3Storage\"\nAWS_ACCESS_KEY_ID = env(\"AWS_ACCESS_KEY_ID\")\nAWS_SECRET_ACCESS_KEY = env(\"AWS_SECRET_ACCESS_KEY\")\nAWS_S3_REGION_NAME = env(\"REGION_NAME\", \"us-west-1\")\nAWS_STORAGE_BUCKET_NAME = env(\"BUCKET_NAME\", \"doccano\")\nAWS_S3_ENDPOINT_URL = env(\"AWS_S3_ENDPOINT_URL\", None)\nAWS_DEFAULT_ACL = \"private\"\nAWS_BUCKET_ACL = \"private\"\nAWS_AUTO_CREATE_BUCKET = True\n",
                                    "summary": "Configuration settings for Django and Django Rest Framework Filepond using AWS S3 storage backend with specified access keys and bucket settings.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "base.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\base.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "\"\"\"\nDjango settings for app project.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/2.0/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/2.0/ref/settings/\n\nAny setting that is configured via an environment variable may\nalso be set in a `.env` file in the project base directory.\n\"\"\"\nfrom os import path\n\nimport dj_database_url\nfrom environs import Env, EnvError\nfrom furl import furl\n\n# Build paths inside the project like this: path.join(BASE_DIR, ...)\nBASE_DIR = path.dirname(path.dirname(path.dirname(path.abspath(__file__))))\n\nenv = Env()\nenv.read_env(path.join(BASE_DIR, \".env\"), recurse=False)\n\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/2.0/howto/deployment/checklist/\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = env(\"SECRET_KEY\", \"v8sk33sy82!uw3ty=!jjv5vp7=s2phrzw(m(hrn^f7e_#1h2al\")\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = env.bool(\"DEBUG\", True)\n\n# Application definition\nINSTALLED_APPS = [\n    \"whitenoise.runserver_nostatic\",\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"api\",\n    \"roles\",\n    \"projects\",\n    \"metrics\",\n    \"users\",\n    \"data_import\",\n    \"data_export\",\n    \"auto_labeling\",\n    \"labels\",\n    \"label_types\",\n    \"examples\",\n    \"rest_framework\",\n    \"rest_framework.authtoken\",\n    \"django_filters\",\n    \"polymorphic\",\n    \"corsheaders\",\n    \"drf_yasg\",\n    \"allauth\",\n    \"allauth.account\",\n    \"allauth.socialaccount\",\n    \"allauth.socialaccount.providers.okta\",\n    \"dj_rest_auth\",\n    \"dj_rest_auth.registration\",\n    \"django.contrib.sites\",\n    \"django_celery_results\",\n    \"django_drf_filepond\",\n    \"health_check\",\n    \"health_check.cache\",\n    \"health_check.storage\",\n    \"health_check.contrib.migrations\",\n    \"health_check.contrib.celery\",\n    \"django_cleanup\",\n]\n\n\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"whitenoise.middleware.WhiteNoiseMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n    \"corsheaders.middleware.CorsMiddleware\",\n]\n\n\nROOT_URLCONF = \"config.urls\"\nWSGI_APPLICATION = \"config.wsgi.application\"\n\n# Django templates\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [path.join(BASE_DIR, \"client/dist\")],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n            ],\n        },\n    },\n]\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/2.0/howto/static-files/\nSTATIC_URL = \"/static/\"\nSTATIC_ROOT = path.join(BASE_DIR, \"staticfiles\")\nSTATICFILES_DIRS = [\n    path.join(BASE_DIR, \"client/dist/static\"),\n]\n# STATICFILES_STORAGE = \"whitenoise.storage.CompressedManifestStaticFilesStorage\"\nSTATICFILES_STORAGE = \"whitenoise.storage.CompressedStaticFilesStorage\"\n\n# Auth settings\nAUTHENTICATION_BACKENDS = [\n    \"django.contrib.auth.backends.ModelBackend\",\n]\nHEADER_AUTH_USER_NAME = env(\"HEADER_AUTH_USER_NAME\", \"\")\nHEADER_AUTH_USER_GROUPS = env(\"HEADER_AUTH_USER_GROUPS\", \"\")\nHEADER_AUTH_ADMIN_GROUP_NAME = env(\"HEADER_AUTH_ADMIN_GROUP_NAME\", \"\")\nHEADER_AUTH_GROUPS_SEPERATOR = env(\"HEADER_AUTH_GROUPS_SEPERATOR\", default=\",\")\nif HEADER_AUTH_USER_NAME and HEADER_AUTH_USER_GROUPS and HEADER_AUTH_ADMIN_GROUP_NAME:\n    MIDDLEWARE.append(\"api.middleware.HeaderAuthMiddleware\")\n    AUTHENTICATION_BACKENDS.append(\"django.contrib.auth.backends.RemoteUserBackend\")\n\n# Role settings\nROLE_PROJECT_ADMIN = env(\"ROLE_PROJECT_ADMIN\", \"project_admin\")\nROLE_ANNOTATOR = env(\"ROLE_ANNOTATOR\", \"annotator\")\nROLE_ANNOTATION_APPROVER = env(\"ROLE_ANNOTATION_APPROVER\", \"annotation_approver\")\n\n# Password validation\n# https://docs.djangoproject.com/en/2.0/ref/settings/#auth-password-validators\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n    },\n]\n\nREST_FRAMEWORK = {\n    # Use Django's standard `django.contrib.auth` permissions,\n    # or allow read-only access for unauthenticated users.\n    \"DEFAULT_PERMISSION_CLASSES\": [\n        \"rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly\",\n        \"rest_framework.permissions.IsAuthenticated\",\n    ],\n    \"DEFAULT_AUTHENTICATION_CLASSES\": (\n        \"rest_framework.authentication.SessionAuthentication\",\n        \"rest_framework.authentication.TokenAuthentication\",\n    ),\n    \"DEFAULT_PAGINATION_CLASS\": \"rest_framework.pagination.LimitOffsetPagination\",\n    \"PAGE_SIZE\": env.int(\"DOCCANO_PAGE_SIZE\", default=5),\n    \"DEFAULT_FILTER_BACKENDS\": (\"django_filters.rest_framework.DjangoFilterBackend\",),\n    \"SEARCH_PARAM\": \"q\",\n    \"DEFAULT_RENDERER_CLASSES\": (\n        \"rest_framework.renderers.JSONRenderer\",\n        \"rest_framework.renderers.BrowsableAPIRenderer\",\n        \"rest_framework_xml.renderers.XMLRenderer\",\n    ),\n}\n\n# Internationalization\n# https://docs.djangoproject.com/en/2.0/topics/i18n/\nLANGUAGE_CODE = \"en-us\"\nTIME_ZONE = \"UTC\"\nUSE_I18N = True\nUSE_L10N = True\nUSE_TZ = True\n\n# Testing\nTEST_RUNNER = \"xmlrunner.extra.djangotestrunner.XMLTestRunner\"\nTEST_OUTPUT_DIR = path.join(BASE_DIR, \"junitxml\")\n\nLOGIN_URL = \"/login/\"\nLOGIN_REDIRECT_URL = \"/projects/\"\nLOGOUT_REDIRECT_URL = \"/\"\n\n# Database\n# https://docs.djangoproject.com/en/2.0/ref/settings/#databases\nDATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": path.join(BASE_DIR, \"db.sqlite3\"),\n    }\n}\n# Change 'default' database configuration with $DATABASE_URL.\nDATABASES[\"default\"].update(\n    dj_database_url.config(\n        env=\"DATABASE_URL\",\n        conn_max_age=env.int(\"DATABASE_CONN_MAX_AGE\", 500),\n        ssl_require=\"sslmode\" not in furl(env(\"DATABASE_URL\", \"\")).args,\n    )\n)\n\n# work-around for dj-database-url: explicitly disable ssl for sqlite\nif DATABASES[\"default\"].get(\"ENGINE\") == \"django.db.backends.sqlite3\":\n    DATABASES[\"default\"].get(\"OPTIONS\", {}).pop(\"sslmode\", None)\n\n# work-around for dj-database-url: patch ssl for mysql\nif DATABASES[\"default\"].get(\"ENGINE\") == \"django.db.backends.mysql\":\n    DATABASES[\"default\"].get(\"OPTIONS\", {}).pop(\"sslmode\", None)\n    if env(\"MYSQL_SSL_CA\", None):\n        DATABASES[\"default\"].setdefault(\"OPTIONS\", {}).setdefault(\"ssl\", {}).setdefault(\"ca\", env(\"MYSQL_SSL_CA\", None))\n\n# default to a sensible modern driver for Azure SQL\nif DATABASES[\"default\"].get(\"ENGINE\") == \"sql_server.pyodbc\":\n    DATABASES[\"default\"].setdefault(\"OPTIONS\", {}).setdefault(\"driver\", \"ODBC Driver 17 for SQL Server\")\n\n\n# Sessions and CSRF\n# Honor the 'X-Forwarded-Proto' header for request.is_secure()\nSECURE_PROXY_SSL_HEADER = (\"HTTP_X_FORWARDED_PROTO\", \"https\")\nSESSION_COOKIE_SECURE = env.bool(\"SESSION_COOKIE_SECURE\", False)\nCSRF_COOKIE_SECURE = env.bool(\"CSRF_COOKIE_SECURE\", False)\nCSRF_TRUSTED_ORIGINS = env.list(\"CSRF_TRUSTED_ORIGINS\", [])\n\n# Allow all host headers\nALLOWED_HOSTS = [\"*\"]\n\nif DEBUG:\n    CORS_ORIGIN_ALLOW_ALL = True\n    CSRF_TRUSTED_ORIGINS = [\"http://127.0.0.1:3000\", \"http://0.0.0.0:3000\", \"http://localhost:3000\"]\n    CSRF_TRUSTED_ORIGINS += env.list(\"CSRF_TRUSTED_ORIGINS\", [])\n\n# Batch size for importing data\nIMPORT_BATCH_SIZE = env.int(\"IMPORT_BATCH_SIZE\", 1000)\n\n# Necessary for email verification of new accounts\nEMAIL_USE_TLS = env.bool(\"EMAIL_USE_TLS\", False)\nEMAIL_HOST = env(\"EMAIL_HOST\", None)\nEMAIL_HOST_USER = env(\"EMAIL_HOST_USER\", None)\nEMAIL_HOST_PASSWORD = env(\"EMAIL_HOST_PASSWORD\", None)\nEMAIL_PORT = env.int(\"EMAIL_PORT\", 587)\nDEFAULT_FROM_EMAIL = env(\"DEFAULT_FROM_EMAIL\", \"webmaster@localhost\")\nif not EMAIL_HOST:\n    EMAIL_BACKEND = \"django.core.mail.backends.console.EmailBackend\"\n\n\n# User media files\nMEDIA_ROOT = env(\"MEDIA_ROOT\", path.join(BASE_DIR, \"media\"))\nMEDIA_URL = \"/media/\"\n\n# Filepond settings\nDJANGO_DRF_FILEPOND_UPLOAD_TMP = path.join(BASE_DIR, \"filepond-temp-uploads\")\nDJANGO_DRF_FILEPOND_FILE_STORE_PATH = MEDIA_ROOT\n\n# File upload setting\nMAX_UPLOAD_SIZE = env.int(\"MAX_UPLOAD_SIZE\", pow(1024, 3))  # default: 1GB per a file\nENABLE_FILE_TYPE_CHECK = env.bool(\"ENABLE_FILE_TYPE_CHECK\", False)\n\n# Celery settings\nDJANGO_CELERY_RESULTS_TASK_ID_MAX_LENGTH = 191\nCELERY_RESULT_BACKEND = \"django-db\"\ntry:\n    CELERY_BROKER_URL = env(\"CELERY_BROKER_URL\")\nexcept EnvError:\n    try:\n        # quickfix for Heroku.\n        # See https://github.com/doccano/doccano/issues/1327.\n        uri = env(\"DATABASE_URL\")\n        if uri.startswith(\"postgres://\"):\n            uri = uri.replace(\"postgres://\", \"postgresql://\", 1)\n        CELERY_BROKER_URL = \"sqla+{}\".format(uri)\n    except EnvError:\n        CELERY_BROKER_URL = \"sqla+sqlite:///{}\".format(DATABASES[\"default\"][\"NAME\"])\nCELERY_ACCEPT_CONTENT = [\"application/json\"]\nCELERY_TASK_SERIALIZER = \"json\"\nCELERY_RESULT_SERIALIZER = \"json\"\n\nDEFAULT_AUTO_FIELD = \"django.db.models.AutoField\"\n\nSOCIALACCOUNT_PROVIDERS = {\n    \"okta\": {\n        \"OKTA_BASE_URL\": env(\"OAUTH_OKTA_OAUTH2_API_URL\", \"\"),\n        \"OAUTH_PKCE_ENABLED\": True,\n        \"APP\": {\"client_id\": env(\"OAUTH_OKTA_OAUTH2_KEY\", \"\"), \"secret\": env(\"OAUTH_OKTA_OAUTH2_SECRET\", \"\")},\n    }\n}\n\nSITE_ID = 1\n",
                                    "summary": "Django settings for app project including database configurations, middleware, authentication, role settings, REST framework settings, internationalization, testing, database URL handling, email settings, file upload settings, Celery settings, and social account providers.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "development.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\development.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "from .base import *  # noqa: F403\n\nMIDDLEWARE.append(\"api.middleware.RangesMiddleware\")  # noqa: F405\n# LOGGING = {\n#     'version': 1,\n#     'handlers': {\n#         'console': {\n#             'level': 'DEBUG',\n#             'class': 'logging.StreamHandler',\n#         }\n#     },\n#     'loggers': {\n#         'django.db.backends': {\n#             'level': 'DEBUG',\n#             'handlers': ['console'],\n#         },\n#     }\n# }\n",
                                    "summary": "Importing base module and adding a middleware for handling ranges, with commented-out logging configurations.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "gcp.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\gcp.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "from google.oauth2 import service_account\n\nfrom .base import *  # noqa: F403\nfrom .base import env\n\nMIDDLEWARE.append(\"api.middleware.RangesMiddleware\")  # noqa: F405\n\nDJANGO_DRF_FILEPOND_STORAGES_BACKEND = \"storages.backends.gcloud.GoogleCloudStorage\"\nGS_BUCKET_NAME = env(\"BUCKET_NAME\", \"doccano\")\nGS_PROJECT_ID = env(\"GS_PROJECT_ID\")\n\n# for more details refer to\n# https://django-storages.readthedocs.io/en/latest/backends/gcloud.html#authentication-settings\n_google_application_credentials = env(\"GOOGLE_APPLICATION_CREDENTIALS\", \"\")\nif _google_application_credentials:\n    GS_CREDENTIALS = service_account.Credentials.from_service_account_file(_google_application_credentials)\n",
                                    "summary": "Configuration settings for using Google Cloud Storage as the backend storage for Django DRF Filepond, with middleware and authentication settings included.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "heroku.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\heroku.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "import django_heroku\n\nfrom .base import *  # noqa: F401,F403\n\ndjango_heroku.settings(locals(), test_runner=False, staticfiles=False)\n",
                                    "summary": "Imports django_heroku and configures settings for Heroku deployment while ignoring base module errors.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "production.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\production.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "from .base import *  # noqa: F401,F403\n\nDEBUG = False\n\nLOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"standard\": {\n            \"format\": \"[%(asctime)s] [%(process)d] [%(levelname)s] [%(name)s::%(funcName)s::%(lineno)d] %(message)s\",\n            \"datefmt\": \"%Y-%m-%d %H:%M:%S %z\",\n        }\n    },\n    \"handlers\": {\n        \"console\": {\n            \"level\": \"INFO\",\n            \"class\": \"logging.StreamHandler\",\n            \"formatter\": \"standard\",\n        },\n    },\n    \"root\": {\n        \"handlers\": [\"console\"],\n        \"level\": \"INFO\",\n    },\n    \"loggers\": {\n        \"django\": {\n            \"handlers\": [\"console\"],\n            \"level\": \"INFO\",\n        },\n    },\n}\n",
                                    "summary": "Configuration settings for logging in the application with DEBUG set to False and log messages formatted with timestamp, process ID, log level, function name, and line number.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a proxy model ExportedBoundingBox with methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "\"\"\"app URL Configuration\n\nThe `urlpatterns` list routes URLs to views. For more information please see:\n    https://docs.djangoproject.com/en/2.0/topics/http/urls/\nExamples:\nFunction views\n    1. Add an import:  from my_app import views\n    2. Add a URL to urlpatterns:  path('', views.home, name='home')\nClass-based views\n    1. Add an import:  from other_app.views import Home\n    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\nIncluding another URLconf\n    1. Import the include() function: from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\"\"\"\nimport os\nimport re\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.contrib import admin\nfrom django.contrib.auth.views import TemplateView\nfrom django.urls import include, path, re_path\nfrom django.views.static import serve\nfrom drf_yasg import openapi\nfrom drf_yasg.views import get_schema_view\n\nschema_view = get_schema_view(\n    openapi.Info(\n        title=\"doccano API\",\n        default_version=\"v1\",\n        description=\"doccano API description\",\n        license=openapi.License(name=\"MIT License\"),\n    ),\n    public=True,\n)\n\nurlpatterns = []\nif settings.DEBUG or os.environ.get(\"STANDALONE\", False):\n    static_dir = Path(__file__).resolve().parent.parent / \"client\" / \"dist\"\n    # For showing images and audios in the case of pip and Docker.\n    urlpatterns.append(\n        re_path(\n            r\"^%s(?P<path>.*)$\" % re.escape(settings.MEDIA_URL.lstrip(\"/\")),\n            serve,\n            {\"document_root\": settings.MEDIA_ROOT},\n        )\n    )\n    # For showing favicon on the case of pip and Docker.\n    urlpatterns.append(path(\"favicon.ico\", serve, {\"document_root\": static_dir, \"path\": \"favicon.ico\"}))\n\nurlpatterns += [\n    path(\"admin/\", admin.site.urls),\n    path(\"api-auth/\", include(\"rest_framework.urls\")),\n    path(\"social/\", include(\"social.urls\")),\n    path(\"v1/social/\", include(\"social.v1_urls\")),\n    path(\"v1/health/\", include(\"health_check.urls\")),\n    path(\"v1/\", include(\"api.urls\")),\n    path(\"v1/\", include(\"roles.urls\")),\n    path(\"v1/\", include(\"users.urls\")),\n    path(\"v1/\", include(\"data_import.urls\")),\n    path(\"v1/\", include(\"data_export.urls\")),\n    path(\"v1/\", include(\"projects.urls\")),\n    path(\"v1/projects/<int:project_id>/metrics/\", include(\"metrics.urls\")),\n    path(\"v1/projects/<int:project_id>/\", include(\"auto_labeling.urls\")),\n    path(\"v1/projects/<int:project_id>/\", include(\"examples.urls\")),\n    path(\"v1/projects/<int:project_id>/\", include(\"labels.urls\")),\n    path(\"v1/projects/<int:project_id>/\", include(\"label_types.urls\")),\n    path(\"swagger/\", schema_view.with_ui(\"swagger\", cache_timeout=0), name=\"schema-swagger-ui\"),\n    re_path(\"\", TemplateView.as_view(template_name=\"index.html\")),\n]\n",
                            "summary": "URL Configuration: A Django URL configuration file that routes URLs to views and includes various app URLs for different functionalities.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "wsgi.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\wsgi.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "\"\"\"\nWSGI config for app project.\n\nIt exposes the WSGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/2.0/howto/deployment/wsgi/\n\"\"\"\n\nimport os\n\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings.production\")\n\napplication = get_wsgi_application()\n",
                            "summary": "WSGI configuration file for the Django app project with settings for deployment using the production environment.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from .celery import app as celery_app\n\n__all__ = (\"celery_app\",)\n",
                            "summary": "Importing the Celery application instance as celery_app and making it available for use in the current module.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "data_export",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content discusses a proxy model ExportedBoundingBox that facilitates the conversion of bounding box annotations into dictionary and tuple forms.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\admin.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content provides a proxy model ExportedBoundingBox with methods to convert bounding box annotations into dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `DataExportConfig`\nCode:\nclass DataExportConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"data_export\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass DataExportConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"data_export\"\n",
                            "summary": "Class DataExportConfig: Contains configuration settings for exporting data in a Django application.",
                            "code_element_summaries": [
                                "Class DataExportConfig: Configuration settings for exporting data within a Django application."
                            ],
                            "children": []
                        },
                        {
                            "name": "celery_tasks.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\celery_tasks.py",
                            "is_dir": false,
                            "code_elements": [
                                "Function `create_collaborative_dataset`\nCode:\ndef create_collaborative_dataset(project: Project, dirpath: str, confirmed_only: bool, formatters, writer):\n    is_text_project = project.is_text_project\n    if confirmed_only:\n        examples = ExportedExample.objects.confirmed(project)\n    else:\n        examples = ExportedExample.objects.filter(project=project)\n    labels = create_labels(project, examples)\n    comments = create_comment(examples)\n    dataset = Dataset(examples, labels, comments, is_text_project)\n\n    service = ExportApplicationService(dataset, formatters, writer)\n\n    filepath = os.path.join(dirpath, f\"all.{writer.extension}\")\n    service.export(filepath)",
                                "Function `create_individual_dataset`\nCode:\ndef create_individual_dataset(project: Project, dirpath: str, confirmed_only: bool, formatters, writer):\n    is_text_project = project.is_text_project\n    members = Member.objects.filter(project=project)\n    for member in members:\n        if confirmed_only:\n            examples = ExportedExample.objects.confirmed(project, user=member.user)\n        else:\n            examples = ExportedExample.objects.filter(project=project)\n        labels = create_labels(project, examples, member.user)\n        comments = create_comment(examples, member.user)\n        dataset = Dataset(examples, labels, comments, is_text_project)\n\n        service = ExportApplicationService(dataset, formatters, writer)\n\n        filepath = os.path.join(dirpath, f\"{member.username}.{writer.extension}\")\n        service.export(filepath)",
                                "Function `export_dataset`\nCode:\ndef export_dataset(project_id, file_format: str, confirmed_only=False):\n    project = get_object_or_404(Project, pk=project_id)\n    dirpath = os.path.join(settings.MEDIA_ROOT, str(uuid.uuid4()))\n    os.makedirs(dirpath, exist_ok=True)\n    formatters = create_formatter(project, file_format)\n    writer = create_writer(file_format)\n    if project.collaborative_annotation:\n        create_collaborative_dataset(project, dirpath, confirmed_only, formatters, writer)\n    else:\n        create_individual_dataset(project, dirpath, confirmed_only, formatters, writer)\n    zip_file = shutil.make_archive(dirpath, \"zip\", dirpath)\n    shutil.rmtree(dirpath)\n    return zip_file"
                            ],
                            "code": "import os\nimport shutil\nimport uuid\n\nfrom celery import shared_task\nfrom celery.utils.log import get_task_logger\nfrom django.conf import settings\nfrom django.shortcuts import get_object_or_404\n\nfrom .pipeline.dataset import Dataset\nfrom .pipeline.factories import (\n    create_comment,\n    create_formatter,\n    create_labels,\n    create_writer,\n)\nfrom .pipeline.services import ExportApplicationService\nfrom data_export.models import ExportedExample\nfrom projects.models import Member, Project\n\nlogger = get_task_logger(__name__)\n\n\ndef create_collaborative_dataset(project: Project, dirpath: str, confirmed_only: bool, formatters, writer):\n    is_text_project = project.is_text_project\n    if confirmed_only:\n        examples = ExportedExample.objects.confirmed(project)\n    else:\n        examples = ExportedExample.objects.filter(project=project)\n    labels = create_labels(project, examples)\n    comments = create_comment(examples)\n    dataset = Dataset(examples, labels, comments, is_text_project)\n\n    service = ExportApplicationService(dataset, formatters, writer)\n\n    filepath = os.path.join(dirpath, f\"all.{writer.extension}\")\n    service.export(filepath)\n\n\ndef create_individual_dataset(project: Project, dirpath: str, confirmed_only: bool, formatters, writer):\n    is_text_project = project.is_text_project\n    members = Member.objects.filter(project=project)\n    for member in members:\n        if confirmed_only:\n            examples = ExportedExample.objects.confirmed(project, user=member.user)\n        else:\n            examples = ExportedExample.objects.filter(project=project)\n        labels = create_labels(project, examples, member.user)\n        comments = create_comment(examples, member.user)\n        dataset = Dataset(examples, labels, comments, is_text_project)\n\n        service = ExportApplicationService(dataset, formatters, writer)\n\n        filepath = os.path.join(dirpath, f\"{member.username}.{writer.extension}\")\n        service.export(filepath)\n\n\n@shared_task(autoretry_for=(Exception,), retry_backoff=True, retry_jitter=True)\ndef export_dataset(project_id, file_format: str, confirmed_only=False):\n    project = get_object_or_404(Project, pk=project_id)\n    dirpath = os.path.join(settings.MEDIA_ROOT, str(uuid.uuid4()))\n    os.makedirs(dirpath, exist_ok=True)\n    formatters = create_formatter(project, file_format)\n    writer = create_writer(file_format)\n    if project.collaborative_annotation:\n        create_collaborative_dataset(project, dirpath, confirmed_only, formatters, writer)\n    else:\n        create_individual_dataset(project, dirpath, confirmed_only, formatters, writer)\n    zip_file = shutil.make_archive(dirpath, \"zip\", dirpath)\n    shutil.rmtree(dirpath)\n    return zip_file\n",
                            "summary": "Functions `create_collaborative_dataset`, `create_individual_dataset`, and `export_dataset` handle the creation and export of datasets based on project specifications and annotations.",
                            "code_element_summaries": [
                                "Function `create_collaborative_dataset`: A function that creates a collaborative dataset based on project specifications and exports it using specified formatters and writer.",
                                "Function `create_individual_dataset`: Creates individual datasets for each member in a project with confirmed examples, labels, comments, and exports them using specified formatters and writers.",
                                "Function `export_dataset`: Exports dataset annotations in the specified file format and returns a zip file containing the exported data."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class `Migration`: A migration class that creates proxy models for ExportedCategory, ExportedExample, ExportedRelation, ExportedSpan, and ExportedText based on existing models.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"labels\", \"0012_add_uuid_field\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedCategory\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.category\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedExample\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"examples.example\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedRelation\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.relation\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedSpan\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.span\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedText\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.textlabel\",),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-05-12 02:27\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"labels\", \"0012_add_uuid_field\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedCategory\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.category\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedExample\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"examples.example\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedRelation\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.relation\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedSpan\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.span\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedText\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.textlabel\",),\n        ),\n    ]\n",
                                    "summary": "Class `Migration`: A migration class that creates proxy models for ExportedCategory, ExportedExample, ExportedRelation, ExportedSpan, and ExportedText based on existing models.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates proxy models for ExportedCategory, ExportedExample, ExportedRelation, ExportedSpan, and ExportedText based on existing models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_exportedboundingbox.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations\\0002_exportedboundingbox.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0015_create_boundingbox_table\"),\n        (\"data_export\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedBoundingBox\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.boundingbox\",),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 02:44\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0015_create_boundingbox_table\"),\n        (\"data_export\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedBoundingBox\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.boundingbox\",),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a proxy model ExportedBoundingBox for data export based on the BoundingBox model from the labels app.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that creates a proxy model ExportedBoundingBox based on the BoundingBox model from the labels app for data export purposes."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_exportedsegmentation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations\\0003_exportedsegmentation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0016_segmentation\"),\n        (\"data_export\", \"0002_exportedboundingbox\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedSegmentation\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.segmentation\",),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 06:57\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0016_segmentation\"),\n        (\"data_export\", \"0002_exportedboundingbox\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedSegmentation\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.segmentation\",),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a proxy model ExportedSegmentation based on the labels.segmentation model.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a proxy model `ExportedSegmentation` based on the `labels.segmentation` model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_exportedcomment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations\\0004_exportedcomment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"data_export\", \"0003_exportedsegmentation\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedComment\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"examples.comment\",),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-07-25 05:07\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"data_export\", \"0003_exportedsegmentation\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedComment\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"examples.comment\",),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a proxy model ExportedComment based on the examples.comment model with specified dependencies.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a proxy model `ExportedComment` based on the `examples.comment` model with specified dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that provides methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ExportedExampleManager`\nCode:\nclass ExportedExampleManager(models.Manager):\n    def confirmed(self, project: Project, user=None):\n        if project.collaborative_annotation:\n            return self.filter(project=project).exclude(states=None)\n        else:\n            assert user is not None\n            return self.filter(project=project, states__confirmed_by=user)",
                                "Function `confirmed`\nCode:\n    def confirmed(self, project: Project, user=None):\n        if project.collaborative_annotation:\n            return self.filter(project=project).exclude(states=None)\n        else:\n            assert user is not None\n            return self.filter(project=project, states__confirmed_by=user)",
                                "Class `ExportedExample`\nCode:\nclass ExportedExample(Example):\n    objects = ExportedExampleManager()\n\n    def to_dict(self, is_text_project=True) -> Dict[str, Any]:\n        return {\"id\": self.id, DATA: self.text if is_text_project else self.upload_name, **self.meta}\n\n    class Meta:\n        proxy = True",
                                "Function `to_dict`\nCode:\n    def to_dict(self, is_text_project=True) -> Dict[str, Any]:\n        return {\"id\": self.id, DATA: self.text if is_text_project else self.upload_name, **self.meta}",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedLabel`\nCode:\nclass ExportedLabel(Protocol):\n    objects: models.Manager\n\n    def to_dict(self) -> Dict[str, Any]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    def to_string(self) -> str:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    def to_tuple(self) -> Tuple:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                "Function `to_dict`\nCode:\n    def to_dict(self) -> Dict[str, Any]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                "Function `to_string`\nCode:\n    def to_string(self) -> str:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                "Function `to_tuple`\nCode:\n    def to_tuple(self) -> Tuple:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                "Class `ExportedCategory`\nCode:\nclass ExportedCategory(Category):\n    def to_string(self) -> str:\n        return self.label.text\n\n    class Meta:\n        proxy = True",
                                "Function `to_string`\nCode:\n    def to_string(self) -> str:\n        return self.label.text",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedSpan`\nCode:\nclass ExportedSpan(Span):\n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"label\": self.label.text,\n            \"start_offset\": self.start_offset,\n            \"end_offset\": self.end_offset,\n        }\n\n    def to_tuple(self):\n        return self.start_offset, self.end_offset, self.label.text\n\n    class Meta:\n        proxy = True",
                                "Function `to_dict`\nCode:\n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"label\": self.label.text,\n            \"start_offset\": self.start_offset,\n            \"end_offset\": self.end_offset,\n        }",
                                "Function `to_tuple`\nCode:\n    def to_tuple(self):\n        return self.start_offset, self.end_offset, self.label.text",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedRelation`\nCode:\nclass ExportedRelation(Relation):\n    def to_dict(self):\n        return {\"id\": self.id, \"from_id\": self.from_id.id, \"to_id\": self.to_id.id, \"type\": self.type.text}\n\n    class Meta:\n        proxy = True",
                                "Function `to_dict`\nCode:\n    def to_dict(self):\n        return {\"id\": self.id, \"from_id\": self.from_id.id, \"to_id\": self.to_id.id, \"type\": self.type.text}",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedText`\nCode:\nclass ExportedText(TextLabel):\n    def to_string(self) -> str:\n        return self.text\n\n    class Meta:\n        proxy = True",
                                "Function `to_string`\nCode:\n    def to_string(self) -> str:\n        return self.text",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedComment`\nCode:\nclass ExportedComment(Comment):\n    def to_string(self) -> str:\n        return self.text\n\n    def to_dict(self):\n        return {\"id\": self.id, \"comment\": self.text}\n\n    class Meta:\n        proxy = True",
                                "Function `to_string`\nCode:\n    def to_string(self) -> str:\n        return self.text",
                                "Function `to_dict`\nCode:\n    def to_dict(self):\n        return {\"id\": self.id, \"comment\": self.text}",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedBoundingBox`\nCode:\nclass ExportedBoundingBox(BoundingBox):\n    def to_dict(self):\n        return {\n            \"uuid\": str(self.uuid),\n            \"x\": self.x,\n            \"y\": self.y,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"label\": self.label.text,\n        }\n\n    def to_tuple(self):\n        return self.x, self.y, self.width, self.height\n\n    class Meta:\n        proxy = True",
                                "Function `to_dict`\nCode:\n    def to_dict(self):\n        return {\n            \"uuid\": str(self.uuid),\n            \"x\": self.x,\n            \"y\": self.y,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"label\": self.label.text,\n        }",
                                "Function `to_tuple`\nCode:\n    def to_tuple(self):\n        return self.x, self.y, self.width, self.height",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedSegmentation`\nCode:\nclass ExportedSegmentation(Segmentation):\n    def to_dict(self):\n        return {\"uuid\": str(self.uuid), \"points\": self.points, \"label\": self.label.text}\n\n    class Meta:\n        proxy = True",
                                "Function `to_dict`\nCode:\n    def to_dict(self):\n        return {\"uuid\": str(self.uuid), \"points\": self.points, \"label\": self.label.text}",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True"
                            ],
                            "code": "from typing import Any, Dict, Protocol, Tuple\n\nfrom django.db import models\n\nfrom examples.models import Comment, Example\nfrom labels.models import BoundingBox, Category, Relation, Segmentation, Span, TextLabel\nfrom projects.models import Project\n\nDATA = \"data\"\n\n\nclass ExportedExampleManager(models.Manager):\n    def confirmed(self, project: Project, user=None):\n        if project.collaborative_annotation:\n            return self.filter(project=project).exclude(states=None)\n        else:\n            assert user is not None\n            return self.filter(project=project, states__confirmed_by=user)\n\n\nclass ExportedExample(Example):\n    objects = ExportedExampleManager()\n\n    def to_dict(self, is_text_project=True) -> Dict[str, Any]:\n        return {\"id\": self.id, DATA: self.text if is_text_project else self.upload_name, **self.meta}\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedLabel(Protocol):\n    objects: models.Manager\n\n    def to_dict(self) -> Dict[str, Any]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    def to_string(self) -> str:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    def to_tuple(self) -> Tuple:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n\nclass ExportedCategory(Category):\n    def to_string(self) -> str:\n        return self.label.text\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedSpan(Span):\n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"label\": self.label.text,\n            \"start_offset\": self.start_offset,\n            \"end_offset\": self.end_offset,\n        }\n\n    def to_tuple(self):\n        return self.start_offset, self.end_offset, self.label.text\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedRelation(Relation):\n    def to_dict(self):\n        return {\"id\": self.id, \"from_id\": self.from_id.id, \"to_id\": self.to_id.id, \"type\": self.type.text}\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedText(TextLabel):\n    def to_string(self) -> str:\n        return self.text\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedComment(Comment):\n    def to_string(self) -> str:\n        return self.text\n\n    def to_dict(self):\n        return {\"id\": self.id, \"comment\": self.text}\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedBoundingBox(BoundingBox):\n    def to_dict(self):\n        return {\n            \"uuid\": str(self.uuid),\n            \"x\": self.x,\n            \"y\": self.y,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"label\": self.label.text,\n        }\n\n    def to_tuple(self):\n        return self.x, self.y, self.width, self.height\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedSegmentation(Segmentation):\n    def to_dict(self):\n        return {\"uuid\": str(self.uuid), \"points\": self.points, \"label\": self.label.text}\n\n    class Meta:\n        proxy = True\n",
                            "summary": "Class ExportedSegmentation: A proxy model of Segmentation that provides methods to convert segmentation annotations into dictionary form, with metadata options set for proxy models.",
                            "code_element_summaries": [
                                "Class ExportedExampleManager: A manager class for handling confirmed examples in a project, considering collaborative annotation settings and user-specific filtering.",
                                "Function `confirmed`: Returns confirmed annotations based on project type and user.",
                                "Class ExportedExample: A proxy model of Example that represents example data in dictionary form, with the option to include text or upload name based on the project type.",
                                "Function `to_dict`: Returns a dictionary representation of the object with specified attributes.",
                                "Class Meta: A class with a proxy attribute set to True.",
                                "Class ExportedLabel: A protocol model defining methods for converting label annotations into dictionary, string, and tuple forms.",
                                "Function `to_dict`: A method that raises a NotImplementedError to remind the subclass to implement this method.",
                                "Function `to_string`: A placeholder method that raises an error to remind implementation in the subclass.",
                                "Function `to_tuple`: A placeholder method that raises an error to remind the subclass to implement it.",
                                "Class ExportedCategory: A proxy model of Category that represents category labels as strings.",
                                "Function `to_string`: Returns the text content of the label associated with the object in string format.",
                                "Class Meta: A class attribute that specifies the model is a proxy model.",
                                "Class ExportedSpan: A proxy model of Span that represents span annotations in dictionary and tuple forms.",
                                "Function `to_dict`: Returns a dictionary representation of an object with id, label, start offset, and end offset attributes.",
                                "Function `to_tuple`: Returns the start and end offsets along with the label text of an annotation in tuple form.",
                                "Class Meta: A class that specifies that the model is a proxy model.",
                                "Class ExportedRelation: A proxy model of Relation that represents relation annotations in dictionary form.",
                                "Function `to_dict`: Returns a dictionary representation of the object with id, from_id, to_id, and type attributes.",
                                "Class Meta: A meta option within a Django model to indicate that it is a proxy model.",
                                "Class ExportedText: A proxy model of TextLabel that represents text annotations in string form.",
                                "Function `to_string`: Returns the text attribute of an object as a string.",
                                "Class Meta: A class used to define metadata options for a model in Django.",
                                "Class ExportedComment: A proxy model of Comment that represents comments in string and dictionary forms.",
                                "Function `to_string`: Returns the text attribute of the object as a string.",
                                "Function `to_dict`: Returns a dictionary representation of an object with 'id' and 'comment' attributes.",
                                "Class `Meta`: A meta class with the attribute `proxy` set to True.",
                                "Class ExportedBoundingBox: A proxy model of BoundingBox that provides methods to convert bounding box annotations into dictionary and tuple formats.",
                                "Function `to_dict`: Returns the bounding box annotation attributes in a dictionary format.",
                                "Function `to_tuple`: Returns the x, y, width, and height attributes of an object as a tuple.",
                                "Class Meta: A metadata class with a proxy attribute set to True.",
                                "Class ExportedSegmentation: A proxy model of Segmentation that represents segmentation annotations in dictionary form.",
                                "Function `to_dict`: Returns a dictionary representation of the object with UUID, points, and label information.",
                                "Class Meta: A class that defines metadata options for a model, with the attribute `proxy` set to True."
                            ],
                            "children": []
                        },
                        {
                            "name": "pipeline",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Classes Format, Comments, Dataset, Formatter, Labels, ExportApplicationService, and Writer provide functionalities for managing and exporting data in various formats, including comments, labels, and examples.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "catalog.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\catalog.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Format`\nCode:\nclass Format:\n    name = \"\"\n\n    @classmethod\n    def dict(cls):\n        return {\n            \"name\": cls.name,\n        }",
                                        "Function `dict`\nCode:\n    def dict(cls):\n        return {\n            \"name\": cls.name,\n        }",
                                        "Class `CSV`\nCode:\nclass CSV(Format):\n    name = \"CSV\"",
                                        "Class `FastText`\nCode:\nclass FastText(Format):\n    name = \"fastText\"",
                                        "Class `JSON`\nCode:\nclass JSON(Format):\n    name = \"JSON\"",
                                        "Class `JSONL`\nCode:\nclass JSONL(Format):\n    name = \"JSONL\"",
                                        "Class `Options`\nCode:\nclass Options:\n    options: Dict[str, List] = defaultdict(list)\n\n    @classmethod\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        return [\n            {**file_format.dict(), \"example\": example}\n            for file_format, example, use_rel in options\n            if use_rel == use_relation\n        ]\n\n    @classmethod\n    def register(cls, task: str, file_format: Type[Format], file: Path, use_relation: bool = False):\n        example = cls.load_example(file)\n        cls.options[task].append((file_format, example, use_relation))\n\n    @staticmethod\n    def load_example(file):\n        with open(file, encoding=\"utf-8\") as f:\n            return f.read()",
                                        "Function `filter_by_task`\nCode:\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        return [\n            {**file_format.dict(), \"example\": example}\n            for file_format, example, use_rel in options\n            if use_rel == use_relation\n        ]",
                                        "Function `register`\nCode:\n    def register(cls, task: str, file_format: Type[Format], file: Path, use_relation: bool = False):\n        example = cls.load_example(file)\n        cls.options[task].append((file_format, example, use_relation))",
                                        "Function `load_example`\nCode:\n    def load_example(file):\n        with open(file, encoding=\"utf-8\") as f:\n            return f.read()"
                                    ],
                                    "code": "from collections import defaultdict\nfrom pathlib import Path\nfrom typing import Dict, List, Type\n\nfrom projects.models import ProjectType\n\nEXAMPLE_DIR = Path(__file__).parent.resolve() / \"examples\"\n\n\nclass Format:\n    name = \"\"\n\n    @classmethod\n    def dict(cls):\n        return {\n            \"name\": cls.name,\n        }\n\n\nclass CSV(Format):\n    name = \"CSV\"\n\n\nclass FastText(Format):\n    name = \"fastText\"\n\n\nclass JSON(Format):\n    name = \"JSON\"\n\n\nclass JSONL(Format):\n    name = \"JSONL\"\n\n\nclass Options:\n    options: Dict[str, List] = defaultdict(list)\n\n    @classmethod\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        return [\n            {**file_format.dict(), \"example\": example}\n            for file_format, example, use_rel in options\n            if use_rel == use_relation\n        ]\n\n    @classmethod\n    def register(cls, task: str, file_format: Type[Format], file: Path, use_relation: bool = False):\n        example = cls.load_example(file)\n        cls.options[task].append((file_format, example, use_relation))\n\n    @staticmethod\n    def load_example(file):\n        with open(file, encoding=\"utf-8\") as f:\n            return f.read()\n\n\n# Text Classification\nTEXT_CLASSIFICATION_DIR = EXAMPLE_DIR / \"text_classification\"\nOptions.register(ProjectType.DOCUMENT_CLASSIFICATION, CSV, TEXT_CLASSIFICATION_DIR / \"example.csv\")\nOptions.register(ProjectType.DOCUMENT_CLASSIFICATION, FastText, TEXT_CLASSIFICATION_DIR / \"example.txt\")\nOptions.register(ProjectType.DOCUMENT_CLASSIFICATION, JSON, TEXT_CLASSIFICATION_DIR / \"example.json\")\nOptions.register(ProjectType.DOCUMENT_CLASSIFICATION, JSONL, TEXT_CLASSIFICATION_DIR / \"example.jsonl\")\n\n# Sequence Labeling\nSEQUENCE_LABELING_DIR = EXAMPLE_DIR / \"sequence_labeling\"\nRELATION_EXTRACTION_DIR = EXAMPLE_DIR / \"relation_extraction\"\nOptions.register(ProjectType.SEQUENCE_LABELING, JSONL, SEQUENCE_LABELING_DIR / \"example.jsonl\")\nOptions.register(ProjectType.SEQUENCE_LABELING, JSONL, RELATION_EXTRACTION_DIR / \"example.jsonl\", True)\n\n# Sequence to sequence\nSEQ2SEQ_DIR = EXAMPLE_DIR / \"sequence_to_sequence\"\nOptions.register(ProjectType.SEQ2SEQ, CSV, SEQ2SEQ_DIR / \"example.csv\")\nOptions.register(ProjectType.SEQ2SEQ, JSON, SEQ2SEQ_DIR / \"example.json\")\nOptions.register(ProjectType.SEQ2SEQ, JSONL, SEQ2SEQ_DIR / \"example.jsonl\")\n\n# Intent detection and slot filling\nINTENT_DETECTION_DIR = EXAMPLE_DIR / \"intent_detection\"\nOptions.register(ProjectType.INTENT_DETECTION_AND_SLOT_FILLING, JSONL, INTENT_DETECTION_DIR / \"example.jsonl\")\n\n# Image Classification\nIMAGE_CLASSIFICATION_DIR = EXAMPLE_DIR / \"image_classification\"\nOptions.register(ProjectType.IMAGE_CLASSIFICATION, JSONL, IMAGE_CLASSIFICATION_DIR / \"example.jsonl\")\n\nBOUNDING_BOX_DIR = EXAMPLE_DIR / \"bounding_box\"\nOptions.register(ProjectType.BOUNDING_BOX, JSONL, BOUNDING_BOX_DIR / \"example.jsonl\")\n\nSEGMENTATION_DIR = EXAMPLE_DIR / \"segmentation\"\nOptions.register(ProjectType.SEGMENTATION, JSONL, SEGMENTATION_DIR / \"example.jsonl\")\n\nIMAGE_CAPTIONING_DIR = EXAMPLE_DIR / \"image_captioning\"\nOptions.register(ProjectType.IMAGE_CAPTIONING, JSONL, IMAGE_CAPTIONING_DIR / \"example.jsonl\")\n\n# Speech to Text\nSPEECH2TEXT_DIR = EXAMPLE_DIR / \"speech_to_text\"\nOptions.register(ProjectType.SPEECH2TEXT, JSONL, SPEECH2TEXT_DIR / \"example.jsonl\")\n",
                                    "summary": "Class Format: A class with a static variable `name` and a method to convert its attributes into a dictionary format, along with classes representing CSV, fastText, JSON, JSONL formats, and a utility class for managing options with functions to filter and load examples.",
                                    "code_element_summaries": [
                                        "Class Format: A class with a static variable `name` and a method to convert its attributes into a dictionary format.",
                                        "Function `dict`: Returns a dictionary containing the name attribute of the class.",
                                        "Class CSV: Represents a CSV format for data storage and retrieval.",
                                        "Class FastText: A format class representing the fastText format for text data.",
                                        "Class JSON: Represents the JSON format for data serialization and deserialization.",
                                        "Class JSONL: Represents a JSON Lines format for data serialization.",
                                        "Class Options: A utility class for managing and filtering options based on task name and relation usage.",
                                        "Function `filter_by_task`: Filters options based on task name and returns a list of dictionaries with file format and example, optionally filtered by relation usage.",
                                        "Function `register`: Adds a loaded example with specified task, file format, and optional relation to the options dictionary.",
                                        "Function `load_example`: A function that reads and returns the content of a file specified as an argument."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "comments.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\comments.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Comments`\nCode:\nclass Comments(abc.ABC):\n    comment_class = ExportedComment\n    column = \"Comments\"\n    fields: Tuple[str, ...] = (\"example\", \"user\")  # To boost performance\n\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.comment_groups = defaultdict(list)\n        comments = self.comment_class.objects.filter(example__in=examples)\n        if user:\n            comments = comments.filter(user=user)\n        for comment in comments.select_related(*self.fields):\n            self.comment_groups[comment.example.id].append(comment)\n\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedComment]]:\n        return {self.column: self.comment_groups[example_id]}",
                                        "Function `__init__`\nCode:\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.comment_groups = defaultdict(list)\n        comments = self.comment_class.objects.filter(example__in=examples)\n        if user:\n            comments = comments.filter(user=user)\n        for comment in comments.select_related(*self.fields):\n            self.comment_groups[comment.example.id].append(comment)",
                                        "Function `find_by`\nCode:\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedComment]]:\n        return {self.column: self.comment_groups[example_id]}"
                                    ],
                                    "code": "import abc\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\nfrom django.db.models import QuerySet\n\nfrom data_export.models import ExportedComment, ExportedExample\n\n\nclass Comments(abc.ABC):\n    comment_class = ExportedComment\n    column = \"Comments\"\n    fields: Tuple[str, ...] = (\"example\", \"user\")  # To boost performance\n\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.comment_groups = defaultdict(list)\n        comments = self.comment_class.objects.filter(example__in=examples)\n        if user:\n            comments = comments.filter(user=user)\n        for comment in comments.select_related(*self.fields):\n            self.comment_groups[comment.example.id].append(comment)\n\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedComment]]:\n        return {self.column: self.comment_groups[example_id]}\n",
                                    "summary": "Class Comments: Manages comments associated with examples, filtering by user and organizing them by example ID, with a function to initialize comment groups and find comments based on example ID.",
                                    "code_element_summaries": [
                                        "Class `Comments`: A model that manages comments associated with examples, filtering by user and organizing them by example ID.",
                                        "Function `__init__`: Initializes an object with comment groups organized by example ID for a specified user.",
                                        "Function `find_by`: Returns a dictionary mapping column names to lists of ExportedComment instances based on the provided example_id."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "dataset.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\dataset.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Dataset`\nCode:\nclass Dataset:\n    def __init__(\n        self, examples: QuerySet[ExportedExample], labels: List[Labels], comments: List[Comments], is_text_project=True\n    ):\n        self.examples = examples\n        self.labels = labels\n        self.is_text_project = is_text_project\n        self.comments = comments\n\n    def __iter__(self) -> Iterator[Dict[str, Any]]:\n        for example in self.examples:\n            data = example.to_dict(self.is_text_project)\n            for labels in self.labels:\n                data.update(**labels.find_by(example.id))\n            for comment in self.comments:\n                data.update(**comment.find_by(example.id))\n            yield data\n\n    def to_dataframe(self) -> pd.DataFrame:\n        return pd.DataFrame(self)",
                                        "Function `__init__`\nCode:\n    def __init__(\n        self, examples: QuerySet[ExportedExample], labels: List[Labels], comments: List[Comments], is_text_project=True\n    ):\n        self.examples = examples\n        self.labels = labels\n        self.is_text_project = is_text_project\n        self.comments = comments",
                                        "Function `__iter__`\nCode:\n    def __iter__(self) -> Iterator[Dict[str, Any]]:\n        for example in self.examples:\n            data = example.to_dict(self.is_text_project)\n            for labels in self.labels:\n                data.update(**labels.find_by(example.id))\n            for comment in self.comments:\n                data.update(**comment.find_by(example.id))\n            yield data",
                                        "Function `to_dataframe`\nCode:\n    def to_dataframe(self) -> pd.DataFrame:\n        return pd.DataFrame(self)"
                                    ],
                                    "code": "from typing import Any, Dict, Iterator, List\n\nimport pandas as pd\nfrom django.db.models.query import QuerySet\n\nfrom .comments import Comments\nfrom .labels import Labels\nfrom data_export.models import ExportedExample\n\n\nclass Dataset:\n    def __init__(\n        self, examples: QuerySet[ExportedExample], labels: List[Labels], comments: List[Comments], is_text_project=True\n    ):\n        self.examples = examples\n        self.labels = labels\n        self.is_text_project = is_text_project\n        self.comments = comments\n\n    def __iter__(self) -> Iterator[Dict[str, Any]]:\n        for example in self.examples:\n            data = example.to_dict(self.is_text_project)\n            for labels in self.labels:\n                data.update(**labels.find_by(example.id))\n            for comment in self.comments:\n                data.update(**comment.find_by(example.id))\n            yield data\n\n    def to_dataframe(self) -> pd.DataFrame:\n        return pd.DataFrame(self)\n",
                                    "summary": "Class Dataset: Represents a dataset with examples, labels, and comments, providing methods to iterate over the data and convert it to a pandas DataFrame.",
                                    "code_element_summaries": [
                                        "Class `Dataset`: Represents a dataset with examples, labels, and comments, and provides methods to iterate over the data and convert it to a pandas DataFrame.",
                                        "Function `__init__`: Initializes an object with examples, labels, comments, and a flag for text project.",
                                        "Function `__iter__`: Iterates over examples and combines their data with labels and comments to yield a dictionary of information.",
                                        "Function to_dataframe: Converts the current object into a pandas DataFrame."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "factories.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\factories.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `create_writer`\nCode:\ndef create_writer(file_format: str) -> writers.Writer:\n    mapping = {\n        CSV.name: writers.CsvWriter(),\n        JSON.name: writers.JsonWriter(),\n        JSONL.name: writers.JsonlWriter(),\n        FastText.name: writers.FastTextWriter(),\n    }\n    if file_format not in mapping:\n        ValueError(f\"Invalid format: {file_format}\")\n    return mapping[file_format]",
                                        "Function `create_formatter`\nCode:\ndef create_formatter(project: Project, file_format: str) -> List[Formatter]:\n    use_relation = getattr(project, \"use_relation\", False)\n    # text tasks\n    mapper_text_classification = {DATA: \"text\", Categories.column: \"label\"}\n    mapper_sequence_labeling = {DATA: \"text\", Spans.column: \"label\"}\n    mapper_seq2seq = {DATA: \"text\", Texts.column: \"label\"}\n    mapper_intent_detection = {DATA: \"text\", Categories.column: \"cats\"}\n    mapper_relation_extraction = {DATA: \"text\"}\n\n    # image tasks\n    mapper_image_classification = {DATA: \"filename\", Categories.column: \"label\"}\n    mapper_bounding_box = {DATA: \"filename\", BoundingBoxes.column: \"bbox\"}\n    mapper_segmentation = {DATA: \"filename\", BoundingBoxes.column: \"segmentation\"}\n    mapper_image_captioning = {DATA: \"filename\", Texts.column: \"label\"}\n\n    # audio tasks\n    mapper_speech2text = {DATA: \"filename\", Texts.column: \"label\"}\n\n    mapping: Dict[str, Dict[str, List[Formatter]]] = {\n        ProjectType.DOCUMENT_CLASSIFICATION: {\n            CSV.name: [\n                JoinedCategoryFormatter(Categories.column),\n                JoinedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            JSON.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            FastText.name: [FastTextCategoryFormatter(Categories.column)],\n        },\n        ProjectType.SEQUENCE_LABELING: {\n            JSONL.name: [\n                DictFormatter(Spans.column),\n                DictFormatter(Relations.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_relation_extraction),\n            ]\n            if use_relation\n            else [\n                TupledSpanFormatter(Spans.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_sequence_labeling),\n            ]\n        },\n        ProjectType.SEQ2SEQ: {\n            CSV.name: [\n                JoinedCategoryFormatter(Texts.column),\n                JoinedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n            JSON.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n        },\n        ProjectType.IMAGE_CLASSIFICATION: {\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_image_classification),\n            ],\n        },\n        ProjectType.SPEECH2TEXT: {\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_speech2text),\n            ],\n        },\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: {\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                TupledSpanFormatter(Spans.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_intent_detection),\n            ]\n        },\n        ProjectType.BOUNDING_BOX: {\n            JSONL.name: [\n                DictFormatter(BoundingBoxes.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_bounding_box),\n            ]\n        },\n        ProjectType.SEGMENTATION: {\n            JSONL.name: [\n                DictFormatter(Segments.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_segmentation),\n            ]\n        },\n        ProjectType.IMAGE_CAPTIONING: {\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_image_captioning),\n            ]\n        },\n    }\n    return mapping[project.project_type][file_format]",
                                        "Function `select_label_collection`\nCode:\ndef select_label_collection(project: Project) -> List[Type[Labels]]:\n    use_relation = getattr(project, \"use_relation\", False)\n    mapping: Dict[str, List[Type[Labels]]] = {\n        ProjectType.DOCUMENT_CLASSIFICATION: [Categories],\n        ProjectType.SEQUENCE_LABELING: [Spans, Relations] if use_relation else [Spans],\n        ProjectType.SEQ2SEQ: [Texts],\n        ProjectType.IMAGE_CLASSIFICATION: [Categories],\n        ProjectType.SPEECH2TEXT: [Texts],\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: [Categories, Spans],\n        ProjectType.BOUNDING_BOX: [BoundingBoxes],\n        ProjectType.SEGMENTATION: [Segments],\n        ProjectType.IMAGE_CAPTIONING: [Texts],\n    }\n    return mapping[project.project_type]",
                                        "Function `create_labels`\nCode:\ndef create_labels(project: Project, examples: QuerySet[ExportedExample], user=None) -> List[Labels]:\n    label_collections = select_label_collection(project)\n    labels = [label_collection(examples=examples, user=user) for label_collection in label_collections]\n    return labels",
                                        "Function `create_comment`\nCode:\ndef create_comment(examples: QuerySet[ExportedExample], user=None) -> List[Comments]:\n    return [Comments(examples=examples, user=user)]"
                                    ],
                                    "code": "from typing import Dict, List, Type\n\nfrom django.db.models import QuerySet\n\nfrom . import writers\nfrom .catalog import CSV, JSON, JSONL, FastText\nfrom .comments import Comments\nfrom .formatters import (\n    DictFormatter,\n    FastTextCategoryFormatter,\n    Formatter,\n    JoinedCategoryFormatter,\n    ListedCategoryFormatter,\n    RenameFormatter,\n    TupledSpanFormatter,\n)\nfrom .labels import BoundingBoxes, Categories, Labels, Relations, Segments, Spans, Texts\nfrom data_export.models import DATA, ExportedExample\nfrom projects.models import Project, ProjectType\n\n\ndef create_writer(file_format: str) -> writers.Writer:\n    mapping = {\n        CSV.name: writers.CsvWriter(),\n        JSON.name: writers.JsonWriter(),\n        JSONL.name: writers.JsonlWriter(),\n        FastText.name: writers.FastTextWriter(),\n    }\n    if file_format not in mapping:\n        ValueError(f\"Invalid format: {file_format}\")\n    return mapping[file_format]\n\n\ndef create_formatter(project: Project, file_format: str) -> List[Formatter]:\n    use_relation = getattr(project, \"use_relation\", False)\n    # text tasks\n    mapper_text_classification = {DATA: \"text\", Categories.column: \"label\"}\n    mapper_sequence_labeling = {DATA: \"text\", Spans.column: \"label\"}\n    mapper_seq2seq = {DATA: \"text\", Texts.column: \"label\"}\n    mapper_intent_detection = {DATA: \"text\", Categories.column: \"cats\"}\n    mapper_relation_extraction = {DATA: \"text\"}\n\n    # image tasks\n    mapper_image_classification = {DATA: \"filename\", Categories.column: \"label\"}\n    mapper_bounding_box = {DATA: \"filename\", BoundingBoxes.column: \"bbox\"}\n    mapper_segmentation = {DATA: \"filename\", BoundingBoxes.column: \"segmentation\"}\n    mapper_image_captioning = {DATA: \"filename\", Texts.column: \"label\"}\n\n    # audio tasks\n    mapper_speech2text = {DATA: \"filename\", Texts.column: \"label\"}\n\n    mapping: Dict[str, Dict[str, List[Formatter]]] = {\n        ProjectType.DOCUMENT_CLASSIFICATION: {\n            CSV.name: [\n                JoinedCategoryFormatter(Categories.column),\n                JoinedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            JSON.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            FastText.name: [FastTextCategoryFormatter(Categories.column)],\n        },\n        ProjectType.SEQUENCE_LABELING: {\n            JSONL.name: [\n                DictFormatter(Spans.column),\n                DictFormatter(Relations.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_relation_extraction),\n            ]\n            if use_relation\n            else [\n                TupledSpanFormatter(Spans.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_sequence_labeling),\n            ]\n        },\n        ProjectType.SEQ2SEQ: {\n            CSV.name: [\n                JoinedCategoryFormatter(Texts.column),\n                JoinedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n            JSON.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n        },\n        ProjectType.IMAGE_CLASSIFICATION: {\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_image_classification),\n            ],\n        },\n        ProjectType.SPEECH2TEXT: {\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_speech2text),\n            ],\n        },\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: {\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                TupledSpanFormatter(Spans.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_intent_detection),\n            ]\n        },\n        ProjectType.BOUNDING_BOX: {\n            JSONL.name: [\n                DictFormatter(BoundingBoxes.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_bounding_box),\n            ]\n        },\n        ProjectType.SEGMENTATION: {\n            JSONL.name: [\n                DictFormatter(Segments.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_segmentation),\n            ]\n        },\n        ProjectType.IMAGE_CAPTIONING: {\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_image_captioning),\n            ]\n        },\n    }\n    return mapping[project.project_type][file_format]\n\n\ndef select_label_collection(project: Project) -> List[Type[Labels]]:\n    use_relation = getattr(project, \"use_relation\", False)\n    mapping: Dict[str, List[Type[Labels]]] = {\n        ProjectType.DOCUMENT_CLASSIFICATION: [Categories],\n        ProjectType.SEQUENCE_LABELING: [Spans, Relations] if use_relation else [Spans],\n        ProjectType.SEQ2SEQ: [Texts],\n        ProjectType.IMAGE_CLASSIFICATION: [Categories],\n        ProjectType.SPEECH2TEXT: [Texts],\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: [Categories, Spans],\n        ProjectType.BOUNDING_BOX: [BoundingBoxes],\n        ProjectType.SEGMENTATION: [Segments],\n        ProjectType.IMAGE_CAPTIONING: [Texts],\n    }\n    return mapping[project.project_type]\n\n\ndef create_labels(project: Project, examples: QuerySet[ExportedExample], user=None) -> List[Labels]:\n    label_collections = select_label_collection(project)\n    labels = [label_collection(examples=examples, user=user) for label_collection in label_collections]\n    return labels\n\n\ndef create_comment(examples: QuerySet[ExportedExample], user=None) -> List[Comments]:\n    return [Comments(examples=examples, user=user)]\n",
                                    "summary": "Functions for creating writers, formatters, label collections, labels, and comments based on project type, file format mappings, relations, and user input.",
                                    "code_element_summaries": [
                                        "Function `create_writer`: Returns a writer object based on the specified file format from a predefined mapping.",
                                        "Function `create_formatter`: Generates a list of formatters based on project type and file format mappings.",
                                        "Function `select_label_collection`: Returns a list of label types based on the project type and use of relation in the project.",
                                        "Function `create_labels`: Generates a list of labels for a given project and exported examples based on label collections.",
                                        "Function `create_comment`: A function that creates a list of Comments objects based on a QuerySet of ExportedExample instances and a user."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "formatters.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\formatters.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Formatter`\nCode:\nclass Formatter(abc.ABC):\n    def __init__(self, target_column: str = \"labels\", **kwargs):\n        self.target_column = target_column\n        self.mapper = kwargs\n\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        if self.target_column not in dataset.columns:\n            return dataset\n        return self.apply(dataset)\n\n    @abc.abstractmethod\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `__init__`\nCode:\n    def __init__(self, target_column: str = \"labels\", **kwargs):\n        self.target_column = target_column\n        self.mapper = kwargs",
                                        "Function `format`\nCode:\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        if self.target_column not in dataset.columns:\n            return dataset\n        return self.apply(dataset)",
                                        "Function `apply`\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Class `JoinedCategoryFormatter`\nCode:\nclass JoinedCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `LabelA#LabelB` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \"#\".join(sorted(label.to_string() for label in labels))\n        )\n        return dataset",
                                        "Function `apply`: Format the label column to `LabelA#LabelB` format.\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `LabelA#LabelB` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \"#\".join(sorted(label.to_string() for label in labels))\n        )\n        return dataset",
                                        "Class `ListedCategoryFormatter`\nCode:\nclass ListedCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `['LabelA', 'LabelB']` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: sorted([label.to_string() for label in labels])\n        )\n        return dataset",
                                        "Function `apply`: Format the label column to `['LabelA', 'LabelB']` format.\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `['LabelA', 'LabelB']` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: sorted([label.to_string() for label in labels])\n        )\n        return dataset",
                                        "Class `FastTextCategoryFormatter`\nCode:\nclass FastTextCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `__label__LabelA __label__LabelB` format.\n        Also, drop the columns except for `data` and `self.target_column`.\n        \"\"\"\n        dataset = dataset[[DATA, self.target_column, \"Comments\"]]\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \" \".join(sorted(f\"__label__{label.to_string()}\" for label in labels))\n        )\n        dataset[self.target_column] = dataset[self.target_column].fillna(\"\")\n        dataset[\"Comments\"] = dataset[\"Comments\"].apply(\n            lambda comments: \" \".join(f\"__comment__{comment.to_string()}\" for comment in comments)\n        )\n        dataset = dataset[self.target_column] + \" \" + dataset[DATA] + \" \" + dataset[\"Comments\"]\n        return dataset",
                                        "Function `apply`: Format the label column to `__label__LabelA __label__LabelB` format.\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `__label__LabelA __label__LabelB` format.\n        Also, drop the columns except for `data` and `self.target_column`.\n        \"\"\"\n        dataset = dataset[[DATA, self.target_column, \"Comments\"]]\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \" \".join(sorted(f\"__label__{label.to_string()}\" for label in labels))\n        )\n        dataset[self.target_column] = dataset[self.target_column].fillna(\"\")\n        dataset[\"Comments\"] = dataset[\"Comments\"].apply(\n            lambda comments: \" \".join(f\"__comment__{comment.to_string()}\" for comment in comments)\n        )\n        dataset = dataset[self.target_column] + \" \" + dataset[DATA] + \" \" + dataset[\"Comments\"]\n        return dataset",
                                        "Class `TupledSpanFormatter`\nCode:\nclass TupledSpanFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the span column to `(start_offset, end_offset, label)` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda spans: sorted(span.to_tuple() for span in spans)\n        )\n        return dataset",
                                        "Function `apply`: Format the span column to `(start_offset, end_offset, label)` format\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the span column to `(start_offset, end_offset, label)` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda spans: sorted(span.to_tuple() for span in spans)\n        )\n        return dataset",
                                        "Class `DictFormatter`\nCode:\nclass DictFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the column to `{key: value}` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: [label.to_dict() for label in labels]\n        )\n        return dataset",
                                        "Function `apply`: Format the column to `{key: value}` format\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the column to `{key: value}` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: [label.to_dict() for label in labels]\n        )\n        return dataset",
                                        "Class `RenameFormatter`\nCode:\nclass RenameFormatter(Formatter):\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        return self.apply(dataset)\n\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Rename columns\"\"\"\n        dataset.rename(columns=self.mapper, inplace=True)\n        return dataset",
                                        "Function `format`\nCode:\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        return self.apply(dataset)",
                                        "Function `apply`: Rename columns\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Rename columns\"\"\"\n        dataset.rename(columns=self.mapper, inplace=True)\n        return dataset"
                                    ],
                                    "code": "\"\"\"\nConvert a dataset to the specified format.\n\"\"\"\nimport abc\n\nimport pandas as pd\n\nfrom data_export.models import DATA\n\n\nclass Formatter(abc.ABC):\n    def __init__(self, target_column: str = \"labels\", **kwargs):\n        self.target_column = target_column\n        self.mapper = kwargs\n\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        if self.target_column not in dataset.columns:\n            return dataset\n        return self.apply(dataset)\n\n    @abc.abstractmethod\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n\nclass JoinedCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `LabelA#LabelB` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \"#\".join(sorted(label.to_string() for label in labels))\n        )\n        return dataset\n\n\nclass ListedCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `['LabelA', 'LabelB']` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: sorted([label.to_string() for label in labels])\n        )\n        return dataset\n\n\nclass FastTextCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `__label__LabelA __label__LabelB` format.\n        Also, drop the columns except for `data` and `self.target_column`.\n        \"\"\"\n        dataset = dataset[[DATA, self.target_column, \"Comments\"]]\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \" \".join(sorted(f\"__label__{label.to_string()}\" for label in labels))\n        )\n        dataset[self.target_column] = dataset[self.target_column].fillna(\"\")\n        dataset[\"Comments\"] = dataset[\"Comments\"].apply(\n            lambda comments: \" \".join(f\"__comment__{comment.to_string()}\" for comment in comments)\n        )\n        dataset = dataset[self.target_column] + \" \" + dataset[DATA] + \" \" + dataset[\"Comments\"]\n        return dataset\n\n\nclass TupledSpanFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the span column to `(start_offset, end_offset, label)` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda spans: sorted(span.to_tuple() for span in spans)\n        )\n        return dataset\n\n\nclass DictFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the column to `{key: value}` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: [label.to_dict() for label in labels]\n        )\n        return dataset\n\n\nclass RenameFormatter(Formatter):\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        return self.apply(dataset)\n\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Rename columns\"\"\"\n        dataset.rename(columns=self.mapper, inplace=True)\n        return dataset\n",
                                    "summary": "Class Formatter: An abstract base class for formatting data in a specified target column using a mapping dictionary, with subclasses like JoinedCategoryFormatter, ListedCategoryFormatter, FastTextCategoryFormatter, TupledSpanFormatter, DictFormatter, and RenameFormatter implementing specific formatting functionalities.",
                                    "code_element_summaries": [
                                        "Class Formatter: An abstract base class for formatting data in a specified target column using a mapping dictionary.",
                                        "Function `__init__`: Initializes the target column and mapper for the class instance.",
                                        "Function `format`: A method that formats a pandas DataFrame by applying a specific function to a target column if it exists.",
                                        "Function `apply`: A method that raises a NotImplementedError and prompts the subclass to implement it.",
                                        "Class JoinedCategoryFormatter: A formatter class that formats the label column in a DataFrame to `LabelA#LabelB` format.",
                                        "Function `apply`: Formats the label column in a DataFrame to `LabelA#LabelB` format by sorting and joining the labels.",
                                        "Class ListedCategoryFormatter: A formatter that sorts and converts labels in a DataFrame's column to a list format.",
                                        "Function `apply`: Formats the label column in a DataFrame to a specific format ['LabelA', 'LabelB'].",
                                        "Class `FastTextCategoryFormatter`: A formatter class that formats the label column of a DataFrame to `__label__LabelA __label__LabelB` format and drops unnecessary columns.",
                                        "Function `apply`: Formats the label column to `__label__LabelA __label__LabelB` format and drops columns except for `data` and `self.target_column`.",
                                        "Class TupledSpanFormatter: A formatter that converts span annotations in a DataFrame to tuple format (start_offset, end_offset, label).",
                                        "Function `apply`: Transforms the span column in a DataFrame to a tuple format of (start_offset, end_offset, label).",
                                        "Class DictFormatter: A formatter class that converts a column in a pandas DataFrame to a dictionary format `{key: value}`.",
                                        "Function `apply`: A function that formats a column in a pandas DataFrame to a dictionary format.",
                                        "Class RenameFormatter: A formatter class that renames columns in a pandas DataFrame using a mapper.",
                                        "Function `format`: A method that formats a pandas DataFrame using the `apply` method.",
                                        "Function `apply`: A method that renames columns in a pandas DataFrame using a specified mapper."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "labels.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\labels.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Labels`\nCode:\nclass Labels(abc.ABC):\n    label_class = ExportedLabel\n    column = \"labels\"\n    fields: Tuple[str, ...] = (\"example\", \"label\")  # To boost performance\n\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.label_groups = defaultdict(list)\n        labels = self.label_class.objects.filter(example__in=examples)\n        if user:\n            labels = labels.filter(user=user)\n        for label in labels.select_related(*self.fields):\n            self.label_groups[label.example.id].append(label)\n\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedLabel]]:\n        return {self.column: self.label_groups[example_id]}",
                                        "Function `__init__`\nCode:\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.label_groups = defaultdict(list)\n        labels = self.label_class.objects.filter(example__in=examples)\n        if user:\n            labels = labels.filter(user=user)\n        for label in labels.select_related(*self.fields):\n            self.label_groups[label.example.id].append(label)",
                                        "Function `find_by`\nCode:\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedLabel]]:\n        return {self.column: self.label_groups[example_id]}",
                                        "Class `Categories`\nCode:\nclass Categories(Labels):\n    label_class = ExportedCategory\n    column = \"categories\"\n    fields = (\"example\", \"label\")",
                                        "Class `Spans`\nCode:\nclass Spans(Labels):\n    label_class = ExportedSpan\n    column = \"entities\"\n    fields = (\"example\", \"label\")",
                                        "Class `Relations`\nCode:\nclass Relations(Labels):\n    label_class = ExportedRelation\n    column = \"relations\"\n    fields = (\"example\", \"type\")",
                                        "Class `Texts`\nCode:\nclass Texts(Labels):\n    label_class = ExportedText\n    column = \"labels\"\n    fields = (\"example\",)",
                                        "Class `BoundingBoxes`\nCode:\nclass BoundingBoxes(Labels):\n    label_class = ExportedBoundingBox\n    column = \"labels\"\n    fields = (\"example\", \"label\")",
                                        "Class `Segments`\nCode:\nclass Segments(Labels):\n    label_class = ExportedSegmentation\n    column = \"labels\"\n    fields = (\"example\", \"label\")"
                                    ],
                                    "code": "\"\"\"\nRepresents label collection.\n\"\"\"\nimport abc\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\nfrom django.db.models import QuerySet\n\nfrom data_export.models import (\n    ExportedBoundingBox,\n    ExportedCategory,\n    ExportedExample,\n    ExportedLabel,\n    ExportedRelation,\n    ExportedSegmentation,\n    ExportedSpan,\n    ExportedText,\n)\n\n\nclass Labels(abc.ABC):\n    label_class = ExportedLabel\n    column = \"labels\"\n    fields: Tuple[str, ...] = (\"example\", \"label\")  # To boost performance\n\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.label_groups = defaultdict(list)\n        labels = self.label_class.objects.filter(example__in=examples)\n        if user:\n            labels = labels.filter(user=user)\n        for label in labels.select_related(*self.fields):\n            self.label_groups[label.example.id].append(label)\n\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedLabel]]:\n        return {self.column: self.label_groups[example_id]}\n\n\nclass Categories(Labels):\n    label_class = ExportedCategory\n    column = \"categories\"\n    fields = (\"example\", \"label\")\n\n\nclass Spans(Labels):\n    label_class = ExportedSpan\n    column = \"entities\"\n    fields = (\"example\", \"label\")\n\n\nclass Relations(Labels):\n    label_class = ExportedRelation\n    column = \"relations\"\n    fields = (\"example\", \"type\")\n\n\nclass Texts(Labels):\n    label_class = ExportedText\n    column = \"labels\"\n    fields = (\"example\",)\n\n\nclass BoundingBoxes(Labels):\n    label_class = ExportedBoundingBox\n    column = \"labels\"\n    fields = (\"example\", \"label\")\n\n\nclass Segments(Labels):\n    label_class = ExportedSegmentation\n    column = \"labels\"\n    fields = (\"example\", \"label\")\n",
                                    "summary": "Class `Labels`: Represents label annotations associated with examples, allowing for filtering by user and retrieval by example ID, with additional classes for categories, spans, relations, texts, bounding boxes, and segments.",
                                    "code_element_summaries": [
                                        "Class `Labels`: Represents label annotations associated with examples, allowing for filtering by user and retrieval by example ID.",
                                        "Function `__init__`: Initializes the object with label groups based on examples and optional user filtering.",
                                        "Function `find_by`: Retrieves a dictionary of ExportedLabel lists based on the example_id.",
                                        "Class Categories: Inherits from Labels and defines a label_class, column, and fields for ExportedCategory objects representing categories.",
                                        "Class Spans: A model that represents spans annotations with specified label class, column, and fields.",
                                        "Class Relations: A model that represents relations between labeled entities with specified fields and label class.",
                                        "Class `Texts`: A class that extends Labels and represents text annotations with specific fields.",
                                        "Class BoundingBoxes: Extends Labels class and defines ExportedBoundingBox as the label_class with specified fields and column.",
                                        "Class Segments: A class that represents segmentation labels with specified fields and label class."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "services.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\services.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ExportApplicationService`\nCode:\nclass ExportApplicationService:\n    def __init__(self, dataset: Dataset, formatters: List[Formatter], writer: Writer):\n        self.dataset = dataset\n        self.formatters = formatters\n        self.writer = writer\n\n    def export(self, file):\n        dataset = self.dataset.to_dataframe()\n        for formatter in self.formatters:\n            dataset = formatter.format(dataset)\n        self.writer.write(file, dataset)\n        return file",
                                        "Function `__init__`\nCode:\n    def __init__(self, dataset: Dataset, formatters: List[Formatter], writer: Writer):\n        self.dataset = dataset\n        self.formatters = formatters\n        self.writer = writer",
                                        "Function `export`\nCode:\n    def export(self, file):\n        dataset = self.dataset.to_dataframe()\n        for formatter in self.formatters:\n            dataset = formatter.format(dataset)\n        self.writer.write(file, dataset)\n        return file"
                                    ],
                                    "code": "from typing import List\n\nfrom .dataset import Dataset\nfrom .formatters import Formatter\nfrom .writers import Writer\n\n\nclass ExportApplicationService:\n    def __init__(self, dataset: Dataset, formatters: List[Formatter], writer: Writer):\n        self.dataset = dataset\n        self.formatters = formatters\n        self.writer = writer\n\n    def export(self, file):\n        dataset = self.dataset.to_dataframe()\n        for formatter in self.formatters:\n            dataset = formatter.format(dataset)\n        self.writer.write(file, dataset)\n        return file\n",
                                    "summary": "Class ExportApplicationService: A service class that exports datasets using formatters and a writer with initialization and export functions.",
                                    "code_element_summaries": [
                                        "Class ExportApplicationService: A service class that exports dataset using formatters and a writer.",
                                        "Function `__init__`: Initializes an object with a dataset, list of formatters, and a writer.",
                                        "Function `export`: Exports dataset to a file using specified formatters and writer."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "writers.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\writers.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Writer`\nCode:\nclass Writer(abc.ABC):\n    extension = \"\"\n\n    @staticmethod\n    @abc.abstractmethod\n    def write(file, dataset: pd.DataFrame):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `write`\nCode:\n    def write(file, dataset: pd.DataFrame):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Class `CsvWriter`\nCode:\nclass CsvWriter(Writer):\n    extension = \"csv\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\")",
                                        "Function `write`\nCode:\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\")",
                                        "Class `JsonWriter`\nCode:\nclass JsonWriter(Writer):\n    extension = \"json\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False)",
                                        "Function `write`\nCode:\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False)",
                                        "Class `JsonlWriter`\nCode:\nclass JsonlWriter(Writer):\n    extension = \"jsonl\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False, lines=True)",
                                        "Function `write`\nCode:\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False, lines=True)",
                                        "Class `FastTextWriter`\nCode:\nclass FastTextWriter(Writer):\n    extension = \"txt\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\", header=False)",
                                        "Function `write`\nCode:\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\", header=False)"
                                    ],
                                    "code": "import abc\n\nimport pandas as pd\n\n\nclass Writer(abc.ABC):\n    extension = \"\"\n\n    @staticmethod\n    @abc.abstractmethod\n    def write(file, dataset: pd.DataFrame):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n\nclass CsvWriter(Writer):\n    extension = \"csv\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\")\n\n\nclass JsonWriter(Writer):\n    extension = \"json\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False)\n\n\nclass JsonlWriter(Writer):\n    extension = \"jsonl\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False, lines=True)\n\n\nclass FastTextWriter(Writer):\n    extension = \"txt\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\", header=False)\n",
                                    "summary": "Class Writer: An abstract base class with a method to write data to a file that needs to be implemented in subclasses, including CsvWriter, JsonWriter, JsonlWriter, and FastTextWriter with specific functionalities for writing DataFrame data.",
                                    "code_element_summaries": [
                                        "Class Writer: An abstract base class representing a generic writer with a method to write data to a file that needs to be implemented in subclasses.",
                                        "Function `write`: Raises a NotImplementedError with a message prompting to implement this method in the subclass.",
                                        "Class CsvWriter: A writer class that handles writing DataFrame data to a CSV file.",
                                        "Function `write`: Writes the contents of a pandas DataFrame to a CSV file without including the index column and using UTF-8 encoding.",
                                        "Class JsonWriter: A Writer subclass that writes a pandas DataFrame to a JSON file with non-ASCII characters support.",
                                        "Function `write`: Writes the contents of a pandas DataFrame to a JSON file with specified formatting options.",
                                        "Class JsonlWriter: A writer class that converts a pandas DataFrame into a JSONL file format.",
                                        "Function `write`: A function that writes a pandas DataFrame to a JSON file in record-oriented format with non-ASCII characters support and line-separated entries.",
                                        "Class FastTextWriter: A writer class that can efficiently write DataFrame data to a text file without headers.",
                                        "Function `write`: Writes a DataFrame to a CSV file without including the index and header."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a class ExportedBoundingBox that serves as a proxy model for BoundingBox, allowing representation of bounding box annotations in dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content includes various unit test cases for verifying functionality related to project options, dataset conversion, data formatting, label retrieval, exported examples, catalog listing, and dataset writing using different file formats.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_catalog.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_catalog.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestOptions`\nCode:\nclass TestOptions(unittest.TestCase):\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)",
                                        "Function `test_return_at_least_one_option`\nCode:\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)"
                                    ],
                                    "code": "import unittest\n\nfrom ..pipeline.catalog import Options\nfrom projects.models import ProjectType\n\n\nclass TestOptions(unittest.TestCase):\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)\n",
                                    "summary": "Class TestOptions: A unit test case for verifying the presence of at least one option for each task in a project type.",
                                    "code_element_summaries": [
                                        "Class TestOptions: A unit test case for ensuring that there is at least one option available for each task in a project type.",
                                        "Function `test_return_at_least_one_option`: Tests that at least one option is returned for each task in ProjectType."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_dataset.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_dataset.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestDataset`\nCode:\nclass TestDataset(unittest.TestCase):\n    def setUp(self):\n        example = MagicMock()\n        example.to_dict.return_value = {\"data\": \"example\"}\n        self.examples = MagicMock()\n        self.examples.__iter__.return_value = [example]\n        label = MagicMock()\n        label.find_by.return_value = {\"labels\": [\"label\"]}\n        self.labels = MagicMock()\n        self.labels.__iter__.return_value = [label]\n        comment = MagicMock()\n        comment.find_by.return_value = {\"comments\": [\"comment\"]}\n        self.comments = MagicMock()\n        self.comments.__iter__.return_value = [comment]\n\n    def test_to_dataframe(self):\n        dataset = Dataset(self.examples, self.labels, self.comments)\n        df = dataset.to_dataframe()\n        expected = pd.DataFrame([{\"data\": \"example\", \"labels\": [\"label\"], \"comments\": [\"comment\"]}])\n        assert_frame_equal(df, expected)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        example = MagicMock()\n        example.to_dict.return_value = {\"data\": \"example\"}\n        self.examples = MagicMock()\n        self.examples.__iter__.return_value = [example]\n        label = MagicMock()\n        label.find_by.return_value = {\"labels\": [\"label\"]}\n        self.labels = MagicMock()\n        self.labels.__iter__.return_value = [label]\n        comment = MagicMock()\n        comment.find_by.return_value = {\"comments\": [\"comment\"]}\n        self.comments = MagicMock()\n        self.comments.__iter__.return_value = [comment]",
                                        "Function `test_to_dataframe`\nCode:\n    def test_to_dataframe(self):\n        dataset = Dataset(self.examples, self.labels, self.comments)\n        df = dataset.to_dataframe()\n        expected = pd.DataFrame([{\"data\": \"example\", \"labels\": [\"label\"], \"comments\": [\"comment\"]}])\n        assert_frame_equal(df, expected)"
                                    ],
                                    "code": "import unittest\nfrom unittest.mock import MagicMock\n\nimport pandas as pd\nfrom pandas.testing import assert_frame_equal\n\nfrom data_export.pipeline.dataset import Dataset\n\n\nclass TestDataset(unittest.TestCase):\n    def setUp(self):\n        example = MagicMock()\n        example.to_dict.return_value = {\"data\": \"example\"}\n        self.examples = MagicMock()\n        self.examples.__iter__.return_value = [example]\n        label = MagicMock()\n        label.find_by.return_value = {\"labels\": [\"label\"]}\n        self.labels = MagicMock()\n        self.labels.__iter__.return_value = [label]\n        comment = MagicMock()\n        comment.find_by.return_value = {\"comments\": [\"comment\"]}\n        self.comments = MagicMock()\n        self.comments.__iter__.return_value = [comment]\n\n    def test_to_dataframe(self):\n        dataset = Dataset(self.examples, self.labels, self.comments)\n        df = dataset.to_dataframe()\n        expected = pd.DataFrame([{\"data\": \"example\", \"labels\": [\"label\"], \"comments\": [\"comment\"]}])\n        assert_frame_equal(df, expected)\n",
                                    "summary": "Class `TestDataset`: A unit test case for the `Dataset` class that validates the conversion of examples, labels, and comments into a Pandas DataFrame using mock objects.",
                                    "code_element_summaries": [
                                        "Class `TestDataset`: A unit test case for the `Dataset` class that tests the conversion of examples, labels, and comments into a pandas DataFrame.",
                                        "Function `setUp`: Sets up mock objects for example data, labels, and comments to be used in testing.",
                                        "Function `test_to_dataframe`: A test function that checks if the dataset can be converted to a Pandas DataFrame correctly."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_formatters.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_formatters.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestDictFormatter`\nCode:\nclass TestDictFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = {\"label\": \"Label\"}\n        label = MagicMock()\n        label.to_dict.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = DictFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.return_value = {\"label\": \"Label\"}\n        label = MagicMock()\n        label.to_dict.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        formatter = DictFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Class `TestJoinedCategoryFormatter`\nCode:\nclass TestJoinedCategoryFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = JoinedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: self.return_value}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        formatter = JoinedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: self.return_value}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Class `TestListedCategoryFormatter`\nCode:\nclass TestListedCategoryFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = ListedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        formatter = ListedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Class `TestTupledSpanFormatter`\nCode:\nclass TestTupledSpanFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = (0, 1, \"Label\")\n        label = MagicMock()\n        label.to_tuple.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = TupledSpanFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.return_value = (0, 1, \"Label\")\n        label = MagicMock()\n        label.to_tuple.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        formatter = TupledSpanFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Class `TestFastTextFormatter`\nCode:\nclass TestFastTextFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value_label = \"Label\"\n        self.return_value_comment = \"Comment\"\n        label = MagicMock()\n        comment = MagicMock()\n        label.to_string.return_value = self.return_value_label\n        comment.to_string.return_value = self.return_value_comment\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label], DATA: \"example\", \"Comments\": [comment]}])\n\n    def test_format(self):\n        formatter = FastTextCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame(\n            [f\"__label__{self.return_value_label} example __comment__{self.return_value_comment}\"]\n        )\n        self.assertEqual(dataset.to_csv(index=False, header=None), expected_dataset.to_csv(index=False, header=None))",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.return_value_label = \"Label\"\n        self.return_value_comment = \"Comment\"\n        label = MagicMock()\n        comment = MagicMock()\n        label.to_string.return_value = self.return_value_label\n        comment.to_string.return_value = self.return_value_comment\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label], DATA: \"example\", \"Comments\": [comment]}])",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        formatter = FastTextCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame(\n            [f\"__label__{self.return_value_label} example __comment__{self.return_value_comment}\"]\n        )\n        self.assertEqual(dataset.to_csv(index=False, header=None), expected_dataset.to_csv(index=False, header=None))",
                                        "Class `TestRenameFormatter`\nCode:\nclass TestRenameFormatter(unittest.TestCase):\n    def test_format(self):\n        dataset = pd.DataFrame([{\"data\": \"example\"}])\n        formatter = RenameFormatter(**{\"data\": \"text\"})\n        dataset = formatter.format(dataset)\n        expected_dataset = pd.DataFrame([{\"text\": \"example\"}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        dataset = pd.DataFrame([{\"data\": \"example\"}])\n        formatter = RenameFormatter(**{\"data\": \"text\"})\n        dataset = formatter.format(dataset)\n        expected_dataset = pd.DataFrame([{\"text\": \"example\"}])\n        assert_frame_equal(dataset, expected_dataset)"
                                    ],
                                    "code": "import unittest\nfrom unittest.mock import MagicMock\n\nimport pandas as pd\nfrom pandas.testing import assert_frame_equal\n\nfrom data_export.models import DATA\nfrom data_export.pipeline.formatters import (\n    DictFormatter,\n    FastTextCategoryFormatter,\n    JoinedCategoryFormatter,\n    ListedCategoryFormatter,\n    RenameFormatter,\n    TupledSpanFormatter,\n)\n\nTARGET_COLUMN = \"labels\"\n\n\nclass TestDictFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = {\"label\": \"Label\"}\n        label = MagicMock()\n        label.to_dict.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = DictFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)\n\n\nclass TestJoinedCategoryFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = JoinedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: self.return_value}])\n        assert_frame_equal(dataset, expected_dataset)\n\n\nclass TestListedCategoryFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = ListedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)\n\n\nclass TestTupledSpanFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = (0, 1, \"Label\")\n        label = MagicMock()\n        label.to_tuple.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = TupledSpanFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)\n\n\nclass TestFastTextFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value_label = \"Label\"\n        self.return_value_comment = \"Comment\"\n        label = MagicMock()\n        comment = MagicMock()\n        label.to_string.return_value = self.return_value_label\n        comment.to_string.return_value = self.return_value_comment\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label], DATA: \"example\", \"Comments\": [comment]}])\n\n    def test_format(self):\n        formatter = FastTextCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame(\n            [f\"__label__{self.return_value_label} example __comment__{self.return_value_comment}\"]\n        )\n        self.assertEqual(dataset.to_csv(index=False, header=None), expected_dataset.to_csv(index=False, header=None))\n\n\nclass TestRenameFormatter(unittest.TestCase):\n    def test_format(self):\n        dataset = pd.DataFrame([{\"data\": \"example\"}])\n        formatter = RenameFormatter(**{\"data\": \"text\"})\n        dataset = formatter.format(dataset)\n        expected_dataset = pd.DataFrame([{\"text\": \"example\"}])\n        assert_frame_equal(dataset, expected_dataset)\n",
                                    "summary": "Classes `TestDictFormatter`, `TestJoinedCategoryFormatter`, `TestListedCategoryFormatter`, `TestTupledSpanFormatter`, `TestFastTextFormatter`, and `TestRenameFormatter` are unit test classes that test the formatting functionality of various data formatters on different types of datasets.",
                                    "code_element_summaries": [
                                        "Class `TestDictFormatter`: A unit test class for testing the formatting of dictionary representations of data using a custom formatter.",
                                        "Function `setUp`: Initializes a dataset with a mocked label object for testing purposes.",
                                        "Function `test_format`: Tests the functionality of formatting a dataset using a DictFormatter and compares the result with an expected dataset.",
                                        "Class TestJoinedCategoryFormatter: A unit test class for testing the formatting functionality of JoinedCategoryFormatter on a pandas DataFrame.",
                                        "Function `setUp`: Initializes test data for a unit test by creating a mock label object and a pandas DataFrame with the label data.",
                                        "Function `test_format`: Tests the formatting functionality of JoinedCategoryFormatter on a dataset.",
                                        "Class `TestListedCategoryFormatter`: A unit test case for the ListedCategoryFormatter class that tests the formatting of a dataset with labeled categories.",
                                        "Function `setUp`: Initializes test data for a unit test by creating a mock label object and a dataset with the label data.",
                                        "Function `test_format`: Tests the ListedCategoryFormatter class by comparing the formatted dataset with an expected dataset.",
                                        "Class `TestTupledSpanFormatter`: A unit test class for testing the functionality of formatting span annotations into tuples.",
                                        "Function `setUp`: Sets up test data by creating a mock label and a DataFrame with the target column containing the mock label.",
                                        "Function `test_format`: A test function that checks if the TupledSpanFormatter properly formats a dataset into a DataFrame with expected values.",
                                        "Class `TestFastTextFormatter`: A unit test case for the `FastTextCategoryFormatter` class that tests the formatting of a dataset for FastText training.",
                                        "Function `setUp`: Sets up mock objects for label and comment, creates a pandas DataFrame with sample data.",
                                        "Function `test_format`: Tests the formatting functionality of a FastTextCategoryFormatter by comparing the formatted dataset with an expected dataset.",
                                        "Class TestRenameFormatter: A unit test case for the RenameFormatter class that tests the formatting of a dataset based on specified column name changes.",
                                        "Function `test_format`: A test function that checks if the RenameFormatter correctly renames columns in a pandas DataFrame."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_labels.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_labels.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestLabels`\nCode:\nclass TestLabels(TestCase):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.examples = ExportedExample.objects.all()\n\n    def test_find_by(self):\n        categories = Categories(self.examples)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 1)\n        result = categories.find_by(self.example2.id)\n        self.assertEqual(len(result[Categories.column]), 0)\n\n    def test_find_by_with_user(self):\n        categories = Categories(self.examples, user=self.project.annotator)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 0)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.examples = ExportedExample.objects.all()",
                                        "Function `test_find_by`\nCode:\n    def test_find_by(self):\n        categories = Categories(self.examples)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 1)\n        result = categories.find_by(self.example2.id)\n        self.assertEqual(len(result[Categories.column]), 0)",
                                        "Function `test_find_by_with_user`\nCode:\n    def test_find_by_with_user(self):\n        categories = Categories(self.examples, user=self.project.annotator)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 0)"
                                    ],
                                    "code": "from django.test import TestCase\nfrom model_mommy import mommy\n\nfrom ..pipeline.labels import Categories\nfrom data_export.models import ExportedExample\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestLabels(TestCase):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.examples = ExportedExample.objects.all()\n\n    def test_find_by(self):\n        categories = Categories(self.examples)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 1)\n        result = categories.find_by(self.example2.id)\n        self.assertEqual(len(result[Categories.column]), 0)\n\n    def test_find_by_with_user(self):\n        categories = Categories(self.examples, user=self.project.annotator)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 0)\n",
                                    "summary": "Class `TestLabels`: A test case class for finding categories by example ID and user in a document classification project with setup and test functions.",
                                    "code_element_summaries": [
                                        "Class `TestLabels`: A test case class for finding categories by example ID and user in a document classification project.",
                                        "Function `setUp`: Sets up test data for a document classification project with ExportedExample and ExportedCategory instances.",
                                        "Function `test_find_by`: A test function to find categories by ID and assert the length of the result.",
                                        "Function `test_find_by_with_user`: A test function to find categories with a specific user and verify the result."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_models.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_models.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExportedExample`\nCode:\nclass TestExportedExample(TestCase):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n\n    def test_collaborative(self):\n        self.prepare_data(collaborative=True)\n        examples = ExportedExample.objects.confirmed(self.project.item)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)\n\n    def test_filter_by_confirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.admin)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)\n\n    def test_filter_by_unconfirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.annotator)\n        self.assertEqual(examples.count(), 0)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)",
                                        "Function `test_collaborative`\nCode:\n    def test_collaborative(self):\n        self.prepare_data(collaborative=True)\n        examples = ExportedExample.objects.confirmed(self.project.item)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)",
                                        "Function `test_filter_by_confirmed_user`\nCode:\n    def test_filter_by_confirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.admin)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)",
                                        "Function `test_filter_by_unconfirmed_user`\nCode:\n    def test_filter_by_unconfirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.annotator)\n        self.assertEqual(examples.count(), 0)"
                                    ],
                                    "code": "from django.test import TestCase\nfrom model_mommy import mommy\n\nfrom data_export.models import ExportedExample\nfrom projects.tests.utils import prepare_project\n\n\nclass TestExportedExample(TestCase):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n\n    def test_collaborative(self):\n        self.prepare_data(collaborative=True)\n        examples = ExportedExample.objects.confirmed(self.project.item)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)\n\n    def test_filter_by_confirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.admin)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)\n\n    def test_filter_by_unconfirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.annotator)\n        self.assertEqual(examples.count(), 0)\n",
                                    "summary": "Class `TestExportedExample`: A test case class for verifying filtering and retrieval of ExportedExample instances based on confirmation status and user roles, with functions for preparing data, testing collaborative functionality, and filtering by confirmed/unconfirmed users.",
                                    "code_element_summaries": [
                                        "Class `TestExportedExample`: A test case class for verifying filtering and retrieval of ExportedExample instances based on confirmation status and user roles.",
                                        "Function `prepare_data`: Prepares data for collaborative or non-collaborative annotation by creating examples and setting example states.",
                                        "Function `test_collaborative`: Tests the collaborative functionality by preparing data, retrieving confirmed examples related to a project item, and asserting the count and content of the examples.",
                                        "Function `test_filter_by_confirmed_user`: A test function that filters ExportedExample objects by confirmed user and asserts the expected count and first example.",
                                        "Function `test_filter_by_unconfirmed_user`: A test function that filters ExportedExample objects by unconfirmed users and asserts that the count is 0."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_task.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_task.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `read_zip_content`\nCode:\ndef read_zip_content(file):\n    datasets = {}\n    with zipfile.ZipFile(file) as z:\n        for file in z.filelist:\n            username = file.filename.split(\".\")[0]\n            with z.open(file) as f:\n                try:\n                    df = pd.read_json(f, lines=True)\n                except pd.errors.EmptyDataError:\n                    continue\n            datasets[username] = df.to_dict(orient=\"records\")\n    return datasets",
                                        "Class `TestExport`\nCode:\nclass TestExport(TestCase):\n    def export_dataset(self, confirmed_only=False):\n        file = export_dataset(self.project.id, \"JSONL\", confirmed_only)\n        if self.project.item.collaborative_annotation:\n            dataset = pd.read_json(file, lines=True).to_dict(orient=\"records\")\n        else:\n            dataset = read_zip_content(file)\n        os.remove(file)\n        return dataset\n\n    def data_to_text(self, example):\n        d = example.to_dict()\n        d[\"text\"] = d.pop(DATA)\n        return d\n\n    def data_to_filename(self, example):\n        d = example.to_dict(is_text_project=False)\n        d[\"filename\"] = d.pop(DATA)\n        return d",
                                        "Function `export_dataset`\nCode:\n    def export_dataset(self, confirmed_only=False):\n        file = export_dataset(self.project.id, \"JSONL\", confirmed_only)\n        if self.project.item.collaborative_annotation:\n            dataset = pd.read_json(file, lines=True).to_dict(orient=\"records\")\n        else:\n            dataset = read_zip_content(file)\n        os.remove(file)\n        return dataset",
                                        "Function `data_to_text`\nCode:\n    def data_to_text(self, example):\n        d = example.to_dict()\n        d[\"text\"] = d.pop(DATA)\n        return d",
                                        "Function `data_to_filename`\nCode:\n    def data_to_filename(self, example):\n        d = example.to_dict(is_text_project=False)\n        d[\"filename\"] = d.pop(DATA)\n        return d",
                                        "Class `TestExportCategory`\nCode:\nclass TestExportCategory(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example1\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example2\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example1\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example2\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportSeq2seq`\nCode:\nclass TestExportSeq2seq(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportIntentDetectionAndSlotFilling`\nCode:\nclass TestExportIntentDetectionAndSlotFilling(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.INTENT_DETECTION_AND_SLOT_FILLING, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.span = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [],\n                    \"cats\": [self.category2.to_string()],\n                    \"Comments\": [self.comment2.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"cats\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.INTENT_DETECTION_AND_SLOT_FILLING, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.span = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [],\n                    \"cats\": [self.category2.to_string()],\n                    \"Comments\": [self.comment2.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"cats\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportSequenceLabeling`\nCode:\nclass TestExportSequenceLabeling(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=1, end_offset=2\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [list(self.span2.to_tuple())], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=1, end_offset=2\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [list(self.span2.to_tuple())], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportSpeechToText`\nCode:\nclass TestExportSpeechToText(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SPEECH2TEXT, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SPEECH2TEXT, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportImageClassification`\nCode:\nclass TestExportImageClassification(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportBoundingBox`\nCode:\nclass TestExportBoundingBox(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.BOUNDING_BOX, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.bbox1 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.admin, x=0, y=0, width=10, height=10\n        )\n        self.bbox2 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.annotator, x=10, y=10, width=20, height=20\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"bbox\": [self.bbox1.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"bbox\": [], \"Comments\": []},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"bbox\": [self.bbox2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"bbox\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"bbox\": [self.bbox1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.BOUNDING_BOX, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.bbox1 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.admin, x=0, y=0, width=10, height=10\n        )\n        self.bbox2 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.annotator, x=10, y=10, width=20, height=20\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"bbox\": [self.bbox1.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"bbox\": [], \"Comments\": []},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"bbox\": [self.bbox2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"bbox\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"bbox\": [self.bbox1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportSegmentation`\nCode:\nclass TestExportSegmentation(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEGMENTATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.seg1 = mommy.make(\"ExportedSegmentation\", example=self.example1, user=self.project.admin, points=[0, 1])\n        self.seg2 = mommy.make(\n            \"ExportedSegmentation\", example=self.example1, user=self.project.annotator, points=[1, 2]\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"segmentation\"\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.seg2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEGMENTATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.seg1 = mommy.make(\"ExportedSegmentation\", example=self.example1, user=self.project.admin, points=[0, 1])\n        self.seg2 = mommy.make(\n            \"ExportedSegmentation\", example=self.example1, user=self.project.annotator, points=[1, 2]\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"segmentation\"",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.seg2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportImageCaptioning`\nCode:\nclass TestExportImageCaptioning(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CAPTIONING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"label\"\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CAPTIONING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"label\"",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportRelation`\nCode:\nclass TestExportRelation(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, use_relation=True, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=1, end_offset=2\n        )\n        self.span3 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=2, end_offset=3\n        )\n        self.relation = mommy.make(\n            \"ExportedRelation\", from_id=self.span1, to_id=self.span2, example=self.example1, user=self.project.admin\n        )\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span3.to_dict()],\n                    \"relations\": [],\n                    \"Comments\": [self.comment2.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"relations\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, use_relation=True, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=1, end_offset=2\n        )\n        self.span3 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=2, end_offset=3\n        )\n        self.relation = mommy.make(\n            \"ExportedRelation\", from_id=self.span1, to_id=self.span2, example=self.example1, user=self.project.admin\n        )\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span3.to_dict()],\n                    \"relations\": [],\n                    \"Comments\": [self.comment2.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"relations\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)"
                                    ],
                                    "code": "import os\nimport zipfile\n\nimport pandas as pd\nfrom django.test import TestCase, override_settings\nfrom model_mommy import mommy\n\nfrom ..celery_tasks import export_dataset\nfrom data_export.models import DATA\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\ndef read_zip_content(file):\n    datasets = {}\n    with zipfile.ZipFile(file) as z:\n        for file in z.filelist:\n            username = file.filename.split(\".\")[0]\n            with z.open(file) as f:\n                try:\n                    df = pd.read_json(f, lines=True)\n                except pd.errors.EmptyDataError:\n                    continue\n            datasets[username] = df.to_dict(orient=\"records\")\n    return datasets\n\n\n@override_settings(MEDIA_URL=os.path.dirname(__file__))\nclass TestExport(TestCase):\n    def export_dataset(self, confirmed_only=False):\n        file = export_dataset(self.project.id, \"JSONL\", confirmed_only)\n        if self.project.item.collaborative_annotation:\n            dataset = pd.read_json(file, lines=True).to_dict(orient=\"records\")\n        else:\n            dataset = read_zip_content(file)\n        os.remove(file)\n        return dataset\n\n    def data_to_text(self, example):\n        d = example.to_dict()\n        d[\"text\"] = d.pop(DATA)\n        return d\n\n    def data_to_filename(self, example):\n        d = example.to_dict(is_text_project=False)\n        d[\"filename\"] = d.pop(DATA)\n        return d\n\n\nclass TestExportCategory(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example1\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example2\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportSeq2seq(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportIntentDetectionAndSlotFilling(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.INTENT_DETECTION_AND_SLOT_FILLING, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.span = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [],\n                    \"cats\": [self.category2.to_string()],\n                    \"Comments\": [self.comment2.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"cats\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportSequenceLabeling(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=1, end_offset=2\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [list(self.span2.to_tuple())], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportSpeechToText(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SPEECH2TEXT, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportImageClassification(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportBoundingBox(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.BOUNDING_BOX, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.bbox1 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.admin, x=0, y=0, width=10, height=10\n        )\n        self.bbox2 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.annotator, x=10, y=10, width=20, height=20\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"bbox\": [self.bbox1.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"bbox\": [], \"Comments\": []},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"bbox\": [self.bbox2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"bbox\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"bbox\": [self.bbox1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportSegmentation(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEGMENTATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.seg1 = mommy.make(\"ExportedSegmentation\", example=self.example1, user=self.project.admin, points=[0, 1])\n        self.seg2 = mommy.make(\n            \"ExportedSegmentation\", example=self.example1, user=self.project.annotator, points=[1, 2]\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"segmentation\"\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.seg2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportImageCaptioning(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CAPTIONING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"label\"\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportRelation(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, use_relation=True, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=1, end_offset=2\n        )\n        self.span3 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=2, end_offset=3\n        )\n        self.relation = mommy.make(\n            \"ExportedRelation\", from_id=self.span1, to_id=self.span2, example=self.example1, user=self.project.admin\n        )\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span3.to_dict()],\n                    \"relations\": [],\n                    \"Comments\": [self.comment2.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"relations\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n",
                                    "summary": "The content includes various classes and functions related to exporting different types of annotated data, such as image classification, bounding boxes, segmentation, speech-to-text, intent detection, and more, with test cases covering scenarios like confirmed vs. unconfirmed annotations and collaborative vs. non-collaborative settings.",
                                    "code_element_summaries": [
                                        "Function `read_zip_content`: Reads a zip file containing JSON files, extracts data, and returns it as a dictionary with usernames as keys and data as values.",
                                        "Class TestExport: Contains methods to export datasets in JSONL format and convert data to text and filename formats.",
                                        "Function `export_dataset`: Exports dataset in JSONL format, reads and returns dataset content based on collaborative annotation settings.",
                                        "Function `data_to_text`: A function that converts data stored in an example object to text format by updating the dictionary key.",
                                        "Function `data_to_filename`: A function that converts data to a filename by extracting it from a dictionary and updating the key.",
                                        "Class `TestExportCategory`: A test class for exporting category data with different scenarios such as unconfirmed, confirmed, collaborative, and non-collaborative annotations.",
                                        "Function `prepare_data`: Initializes data for a document classification project with examples, categories, comments, and states.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A unit test function to verify the export of datasets with unconfirmed and non-collaborative annotations.",
                                        "Function `test_unconfirmed_and_collaborative`: Tests the export of dataset with unconfirmed and collaborative annotations.",
                                        "Function `test_confirmed_and_non_collaborative`: A test function to verify exporting datasets with confirmed annotations only for non-collaborative projects.",
                                        "Function `test_confirmed_and_collaborative`: A test function that prepares data with collaborative annotations and exports a dataset with confirmed annotations only, asserting the expected dataset.",
                                        "Class `TestExportSeq2seq`: A test class for exporting datasets with different scenarios such as confirmed/non-confirmed and collaborative/non-collaborative annotations.",
                                        "Function `prepare_data`: Prepares data for a Seq2Seq project with examples, text labels, comments, and example states.",
                                        "Function `test_unconfirmed_and_non_collaborative`: Tests the export of datasets with unconfirmed and non-collaborative annotations for different users in a project.",
                                        "Function `test_unconfirmed_and_collaborative`: A unit test function that tests exporting datasets with unconfirmed and collaborative annotations.",
                                        "Function `test_confirmed_and_non_collaborative`: A unit test function that checks the exported datasets for confirmed annotations and non-collaborative users against expected values.",
                                        "Function `test_confirmed_and_collaborative`: A test function that prepares data for a collaborative dataset and exports it with confirmed annotations only, comparing the expected dataset with the actual dataset.",
                                        "Class `TestExportIntentDetectionAndSlotFilling`: A test class for exporting data related to intent detection and slot filling, covering various scenarios such as confirmed vs. unconfirmed annotations and collaborative vs. non-collaborative settings.",
                                        "Function `prepare_data`: Prepares data for intent detection and slot filling project by creating examples, categories, comments, spans, and example states.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test function that prepares data and exports datasets for unconfirmed and non-collaborative users, asserting equality between expected and actual datasets.",
                                        "Function `test_unconfirmed_and_collaborative`: Tests the export of dataset with unconfirmed and collaborative annotations.",
                                        "Function `test_confirmed_and_non_collaborative`: A unit test function that checks the exported datasets for confirmed annotations only.",
                                        "Function `test_confirmed_and_collaborative`: A test function to verify the export of confirmed and collaborative data in a dataset.",
                                        "Class `TestExportSequenceLabeling`: A test class for exporting sequence labeling data with different scenarios such as confirmed, unconfirmed, collaborative, and non-collaborative annotations.",
                                        "Function `prepare_data`: Prepares data for sequence labeling project by creating examples, spans, comments, and converting data to text.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test function to verify the export of datasets for unconfirmed and non-collaborative users in a project.",
                                        "Function `test_unconfirmed_and_collaborative`: Tests the export of a dataset with unconfirmed and collaborative annotations.",
                                        "Function `test_confirmed_and_non_collaborative`: A unit test function that verifies the exported datasets for confirmed and non-collaborative annotations.",
                                        "Function `test_confirmed_and_collaborative`: A test function that verifies the exported dataset with confirmed annotations and collaborative settings.",
                                        "Class `TestExportSpeechToText`: A test class for exporting speech-to-text project data with different scenarios and conditions.",
                                        "Function `prepare_data`: Prepares data for speech-to-text project with examples, text labels, comments, and example states.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A unit test function that verifies the data exported for unconfirmed and non-collaborative users matches the expected datasets.",
                                        "Function `test_unconfirmed_and_collaborative`: A test function to validate exporting datasets with unconfirmed and collaborative annotations.",
                                        "Function `test_confirmed_and_non_collaborative`: A test function to verify exporting datasets with confirmed annotations only and no collaborative annotations.",
                                        "Function `test_confirmed_and_collaborative`: A test function that prepares data for collaborative annotation and exports a dataset with confirmed annotations only, comparing it to an expected dataset.",
                                        "Class `TestExportImageClassification`: Contains test methods for exporting image classification data in different scenarios such as confirmed/non-confirmed and collaborative/non-collaborative annotations.",
                                        "Function `prepare_data`: Prepares data for an image classification project with examples, categories, comments, and example states.",
                                        "Function `test_unconfirmed_and_non_collaborative`: Tests the export of datasets for unconfirmed and non-collaborative users in a project.",
                                        "Function `test_unconfirmed_and_collaborative`: Tests the export of dataset with unconfirmed and collaborative annotations.",
                                        "Function `test_confirmed_and_non_collaborative`: A test function to verify exporting datasets with confirmed annotations only and non-collaborative comments.",
                                        "Function `test_confirmed_and_collaborative`: Tests the export of a dataset with confirmed annotations that are collaborative.",
                                        "Class `TestExportBoundingBox`: A test class for exporting bounding box annotations in different scenarios such as unconfirmed and confirmed annotations, collaborative and non-collaborative settings.",
                                        "Function `prepare_data`: Prepares data for bounding box annotation by creating examples, comments, bounding boxes, and example states.",
                                        "Function `test_unconfirmed_and_non_collaborative`: Tests the export of datasets with unconfirmed and non-collaborative users, comparing the expected datasets with the exported datasets.",
                                        "Function `test_unconfirmed_and_collaborative`: A test function that checks the exported dataset with unconfirmed and collaborative annotations.",
                                        "Function `test_confirmed_and_non_collaborative`: A unit test function that verifies the export of confirmed annotations for a specific user in a dataset.",
                                        "Function `test_confirmed_and_collaborative`: A test function that verifies the export of a dataset with confirmed and collaborative annotations.",
                                        "Class `TestExportSegmentation`: A test class that prepares data and tests exporting segmentation annotations in different scenarios.",
                                        "Function `prepare_data`: A function that prepares data for segmentation projects by creating examples, comments, segmentations, and example states.",
                                        "Function `test_unconfirmed_and_non_collaborative`: Tests the exporting of datasets with unconfirmed and non-collaborative annotations.",
                                        "Function `test_unconfirmed_and_collaborative`: Tests exporting dataset with unconfirmed and collaborative annotations.",
                                        "Function `test_confirmed_and_non_collaborative`: A unit test to verify the export of datasets with confirmed annotations only, comparing the expected datasets with the exported datasets.",
                                        "Function `test_confirmed_and_collaborative`: A test function that prepares data for a collaborative dataset and exports it with confirmed annotations only, comparing the result with an expected dataset.",
                                        "Class `TestExportImageCaptioning`: A test class for exporting image captioning data with different scenarios such as unconfirmed and confirmed annotations in collaborative and non-collaborative settings.",
                                        "Function `prepare_data`: Initializes data for an image captioning project, including examples, comments, text labels, and example states.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test function that checks the exported datasets for unconfirmed and non-collaborative project members.",
                                        "Function `test_unconfirmed_and_collaborative`: Tests the export of dataset with unconfirmed and collaborative data.",
                                        "Function `test_confirmed_and_non_collaborative`: A test function to validate the export of datasets with confirmed annotations only and non-collaborative users.",
                                        "Function `test_confirmed_and_collaborative`: A unit test function that checks the export of confirmed and collaborative dataset annotations.",
                                        "Class `TestExportRelation`: A test class for exporting relation data in different scenarios such as unconfirmed, collaborative, confirmed, and non-collaborative.",
                                        "Function `prepare_data`: Sets up data for collaborative annotation with examples, spans, relations, comments, and example states.",
                                        "Function `test_unconfirmed_and_non_collaborative`: Tests the export of datasets for unconfirmed and non-collaborative users in a project.",
                                        "Function `test_unconfirmed_and_collaborative`: Tests the export of dataset with unconfirmed and collaborative annotations.",
                                        "Function `test_confirmed_and_non_collaborative`: Tests exporting datasets with confirmed annotations only and ensures the expected datasets match the actual datasets for different user roles.",
                                        "Function `test_confirmed_and_collaborative`: A test function that validates the export of a dataset with confirmed annotations and collaborative data."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestDownloadCatalog`\nCode:\nclass TestDownloadCatalog(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"download-format\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)\n\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"download-format\", args=[self.project.item.id])",
                                        "Function `test_allows_project_admin_to_list_catalog`\nCode:\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)",
                                        "Function `test_denies_project_staff_to_list_catalog`\nCode:\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestDownloadCatalog(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"download-format\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)\n\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Class `TestDownloadCatalog`: Contains test methods for listing catalog items, with tests for project admin access and denial of project staff access.",
                                    "code_element_summaries": [
                                        "Class `TestDownloadCatalog`: Contains test methods to check if project admins can list catalog items and if project staff are denied access to listing catalog items.",
                                        "Function `setUp`: Sets up the necessary data and variables for testing document classification projects.",
                                        "Function `test_allows_project_admin_to_list_catalog`: Tests that project admins can successfully list the catalog items by checking if each item has a \"name\" attribute.",
                                        "Function `test_denies_project_staff_to_list_catalog`: Tests that project staff members are denied access to list the catalog items."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_writer.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_writer.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestWriter`\nCode:\nclass TestWriter(unittest.TestCase):\n    def setUp(self):\n        self.dataset = pd.DataFrame(\n            [\n                {\"id\": 0, \"text\": \"A\"},\n                {\"id\": 1, \"text\": \"B\"},\n                {\"id\": 2, \"text\": \"C\"},\n            ]\n        )\n        self.file = \"tmp.csv\"\n\n    def tearDown(self):\n        os.remove(self.file)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.dataset = pd.DataFrame(\n            [\n                {\"id\": 0, \"text\": \"A\"},\n                {\"id\": 1, \"text\": \"B\"},\n                {\"id\": 2, \"text\": \"C\"},\n            ]\n        )\n        self.file = \"tmp.csv\"",
                                        "Function `tearDown`\nCode:\n    def tearDown(self):\n        os.remove(self.file)",
                                        "Class `TestCSVWriter`\nCode:\nclass TestCSVWriter(TestWriter):\n    def test_write(self):\n        writer = CsvWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_csv(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Function `test_write`\nCode:\n    def test_write(self):\n        writer = CsvWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_csv(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Class `TestJsonWriter`\nCode:\nclass TestJsonWriter(TestWriter):\n    def test_write(self):\n        writer = JsonWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Function `test_write`\nCode:\n    def test_write(self):\n        writer = JsonWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Class `TestJsonlWriter`\nCode:\nclass TestJsonlWriter(TestWriter):\n    def test_write(self):\n        writer = JsonlWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file, lines=True)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Function `test_write`\nCode:\n    def test_write(self):\n        writer = JsonlWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file, lines=True)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Class `TestFastText`\nCode:\nclass TestFastText(unittest.TestCase):\n    def setUp(self):\n        self.expected = \"__label__A exampleA\\n__label__B exampleB\"\n        self.dataset = pd.DataFrame([*zip(self.expected.split(\"\\n\"))])\n\n    def test_write(self):\n        file = \"tmp.txt\"\n        writer = FastTextWriter()\n        writer.write(file, self.dataset)\n        loaded_dataset = open(file, encoding=\"utf-8\").read().strip()\n        self.assertEqual(loaded_dataset, self.expected)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.expected = \"__label__A exampleA\\n__label__B exampleB\"\n        self.dataset = pd.DataFrame([*zip(self.expected.split(\"\\n\"))])",
                                        "Function `test_write`\nCode:\n    def test_write(self):\n        file = \"tmp.txt\"\n        writer = FastTextWriter()\n        writer.write(file, self.dataset)\n        loaded_dataset = open(file, encoding=\"utf-8\").read().strip()\n        self.assertEqual(loaded_dataset, self.expected)"
                                    ],
                                    "code": "import os\nimport unittest\n\nimport pandas as pd\nfrom pandas.testing import assert_frame_equal\n\nfrom ..pipeline.writers import CsvWriter, FastTextWriter, JsonlWriter, JsonWriter\n\n\nclass TestWriter(unittest.TestCase):\n    def setUp(self):\n        self.dataset = pd.DataFrame(\n            [\n                {\"id\": 0, \"text\": \"A\"},\n                {\"id\": 1, \"text\": \"B\"},\n                {\"id\": 2, \"text\": \"C\"},\n            ]\n        )\n        self.file = \"tmp.csv\"\n\n    def tearDown(self):\n        os.remove(self.file)\n\n\nclass TestCSVWriter(TestWriter):\n    def test_write(self):\n        writer = CsvWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_csv(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)\n\n\nclass TestJsonWriter(TestWriter):\n    def test_write(self):\n        writer = JsonWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)\n\n\nclass TestJsonlWriter(TestWriter):\n    def test_write(self):\n        writer = JsonlWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file, lines=True)\n        assert_frame_equal(self.dataset, loaded_dataset)\n\n\nclass TestFastText(unittest.TestCase):\n    def setUp(self):\n        self.expected = \"__label__A exampleA\\n__label__B exampleB\"\n        self.dataset = pd.DataFrame([*zip(self.expected.split(\"\\n\"))])\n\n    def test_write(self):\n        file = \"tmp.txt\"\n        writer = FastTextWriter()\n        writer.write(file, self.dataset)\n        loaded_dataset = open(file, encoding=\"utf-8\").read().strip()\n        self.assertEqual(loaded_dataset, self.expected)\n",
                                    "summary": "Class TestWriter: A unit test class for writing datasets to temporary CSV, JSON, and JSONL files using different writers and comparing the loaded datasets with the original datasets.",
                                    "code_element_summaries": [
                                        "Class TestWriter: A unit test case for writing a pandas DataFrame to a temporary CSV file.",
                                        "Function `setUp`: Initializes a dataset DataFrame with id and text columns and assigns a file path for temporary CSV storage.",
                                        "Function tearDown: A method that removes a specific file after a test case has been executed.",
                                        "Class `TestCSVWriter`: A test class for writing dataset to CSV format and comparing the loaded dataset with the original dataset.",
                                        "Function `test_write`: Tests the functionality of writing dataset to a CSV file and comparing the loaded dataset with the original dataset.",
                                        "Class TestJsonWriter: A test class for writing dataset to JSON format and asserting equality with loaded dataset.",
                                        "Function `test_write`: A unit test that writes a dataset to a JSON file using a JsonWriter and compares the loaded dataset with the original dataset.",
                                        "Class `TestJsonlWriter`: A test class for testing the functionality of writing datasets to JSONL format using JsonlWriter.",
                                        "Function `test_write`: A unit test function that writes a dataset to a JSONL file and asserts that the loaded dataset is equal to the original dataset.",
                                        "Class `TestFastText`: A unit test class for testing the functionality of writing a dataset to a file using FastTextWriter.",
                                        "Function `setUp`: Initializes variables for testing with a sample dataset in a pandas DataFrame format.",
                                        "Function `test_write`: Tests the functionality of writing dataset to a file using FastTextWriter and compares the loaded dataset with the expected dataset."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content defines a class ExportedBoundingBox that acts as a proxy model for BoundingBox, providing methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import DatasetCatalog, DatasetExportAPI\n\nurlpatterns = [\n    path(route=\"projects/<int:project_id>/download-format\", view=DatasetCatalog.as_view(), name=\"download-format\"),\n    path(route=\"projects/<int:project_id>/download\", view=DatasetExportAPI.as_view(), name=\"download-dataset\"),\n]\n",
                            "summary": "URL patterns for downloading dataset formats and datasets from specific projects using Django views DatasetCatalog and DatasetExportAPI.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `DatasetCatalog`\nCode:\nclass DatasetCatalog(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)",
                                "Class `DatasetExportAPI`\nCode:\nclass DatasetExportAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        task_id = request.GET[\"taskId\"]\n        task = AsyncResult(task_id)\n        ready = task.ready()\n        if ready:\n            filename = task.result\n            return FileResponse(open(filename, mode=\"rb\"), as_attachment=True)\n        return Response({\"status\": \"Not ready\"})\n\n    def post(self, request, *args, **kwargs):\n        project_id = self.kwargs[\"project_id\"]\n        file_format = request.data.pop(\"format\")\n        export_approved = request.data.pop(\"exportApproved\", False)\n        task = export_dataset.delay(\n            project_id=project_id, file_format=file_format, confirmed_only=export_approved, **request.data\n        )\n        return Response({\"task_id\": task.task_id})",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        task_id = request.GET[\"taskId\"]\n        task = AsyncResult(task_id)\n        ready = task.ready()\n        if ready:\n            filename = task.result\n            return FileResponse(open(filename, mode=\"rb\"), as_attachment=True)\n        return Response({\"status\": \"Not ready\"})",
                                "Function `post`\nCode:\n    def post(self, request, *args, **kwargs):\n        project_id = self.kwargs[\"project_id\"]\n        file_format = request.data.pop(\"format\")\n        export_approved = request.data.pop(\"exportApproved\", False)\n        task = export_dataset.delay(\n            project_id=project_id, file_format=file_format, confirmed_only=export_approved, **request.data\n        )\n        return Response({\"task_id\": task.task_id})"
                            ],
                            "code": "from celery.result import AsyncResult\nfrom django.http import FileResponse\nfrom django.shortcuts import get_object_or_404\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom .celery_tasks import export_dataset\nfrom .pipeline.catalog import Options\nfrom projects.models import Project\nfrom projects.permissions import IsProjectAdmin\n\n\nclass DatasetCatalog(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)\n\n\nclass DatasetExportAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        task_id = request.GET[\"taskId\"]\n        task = AsyncResult(task_id)\n        ready = task.ready()\n        if ready:\n            filename = task.result\n            return FileResponse(open(filename, mode=\"rb\"), as_attachment=True)\n        return Response({\"status\": \"Not ready\"})\n\n    def post(self, request, *args, **kwargs):\n        project_id = self.kwargs[\"project_id\"]\n        file_format = request.data.pop(\"format\")\n        export_approved = request.data.pop(\"exportApproved\", False)\n        task = export_dataset.delay(\n            project_id=project_id, file_format=file_format, confirmed_only=export_approved, **request.data\n        )\n        return Response({\"task_id\": task.task_id})\n",
                            "summary": "Class `DatasetCatalog`: An API view class for retrieving project-related options, while `DatasetExportAPI` handles exporting datasets and checking export task status.",
                            "code_element_summaries": [
                                "Class `DatasetCatalog`: An API view class for retrieving options related to a project by project ID.",
                                "Function `get`: Retrieves options based on project type and relation setting for a specific project.",
                                "Class `DatasetExportAPI`: An API view class that handles exporting datasets in different formats and checking the status of the export task.",
                                "Function `get`: Retrieves the result of a task identified by a task ID from the request and returns a file response if the task is ready, otherwise returns a response indicating the task is not ready.",
                                "Function `post`: Handles POST requests to initiate dataset export with specified project ID, file format, and export approval status, returning the task ID for monitoring progress."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content defines a class ExportedBoundingBox that acts as a proxy model for BoundingBox, providing methods to convert the bounding box data into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "data_import",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content introduces a class ExportedBoundingBox that serves as a proxy model for BoundingBox, offering functionalities to convert bounding box annotations into dictionary and tuple formats.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\admin.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content provides a proxy model ExportedBoundingBox that includes methods to convert bounding box annotations into dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `DataImportConfig`\nCode:\nclass DataImportConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"data_import\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass DataImportConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"data_import\"\n",
                            "summary": "Class DataImportConfig: A configuration class for the data_import app in Django with a default_auto_field set to \"django.db.models.BigAutoField\".",
                            "code_element_summaries": [
                                "Class DataImportConfig: A configuration class for the data_import app in Django with a default_auto_field set to \"django.db.models.BigAutoField\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "celery_tasks.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\celery_tasks.py",
                            "is_dir": false,
                            "code_elements": [
                                "Function `check_file_type`\nCode:\ndef check_file_type(filename, file_format: Format, filepath: str):\n    if not settings.ENABLE_FILE_TYPE_CHECK:\n        return\n    kind = filetype.guess(filepath)\n    if not file_format.validate_mime(kind.mime):\n        raise FileTypeException(filename, kind.mime, file_format.accept_types)",
                                "Function `check_uploaded_files`\nCode:\ndef check_uploaded_files(upload_ids: List[str], file_format: Format):\n    errors: List[FileImportException] = []\n    cleaned_ids = []\n    temporary_uploads = TemporaryUpload.objects.filter(upload_id__in=upload_ids)\n    for tu in temporary_uploads:\n        if tu.file.size > settings.MAX_UPLOAD_SIZE:\n            errors.append(MaximumFileSizeException(tu.upload_name, settings.MAX_UPLOAD_SIZE))\n            tu.delete()\n            continue\n        try:\n            check_file_type(tu.upload_name, file_format, tu.get_file_path())\n        except FileTypeException as e:\n            errors.append(e)\n            tu.delete()\n            continue\n        cleaned_ids.append(tu.upload_id)\n    return cleaned_ids, errors",
                                "Function `import_dataset`\nCode:\ndef import_dataset(user_id, project_id, file_format: str, upload_ids: List[str], task: str, **kwargs):\n    project = get_object_or_404(Project, pk=project_id)\n    user = get_object_or_404(get_user_model(), pk=user_id)\n    try:\n        fmt = create_file_format(file_format)\n        upload_ids, errors = check_uploaded_files(upload_ids, fmt)\n        temporary_uploads = TemporaryUpload.objects.filter(upload_id__in=upload_ids)\n        filenames = [\n            FileName(full_path=tu.get_file_path(), generated_name=tu.file.name, upload_name=tu.upload_name)\n            for tu in temporary_uploads\n        ]\n\n        dataset = load_dataset(task, fmt, filenames, project, **kwargs)\n        dataset.save(user, batch_size=settings.IMPORT_BATCH_SIZE)\n        upload_to_store(temporary_uploads)\n        errors.extend(dataset.errors)\n        return {\"error\": [e.dict() for e in errors]}\n    except FileImportException as e:\n        return {\"error\": [e.dict()]}",
                                "Function `upload_to_store`\nCode:\ndef upload_to_store(temporary_uploads):\n    for tu in temporary_uploads:\n        store_upload(tu.upload_id, destination_file_path=tu.file.name)"
                            ],
                            "code": "from typing import List\n\nimport filetype\nfrom celery import shared_task\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.shortcuts import get_object_or_404\nfrom django_drf_filepond.api import store_upload\nfrom django_drf_filepond.models import TemporaryUpload\n\nfrom .datasets import load_dataset\nfrom .pipeline.catalog import Format, create_file_format\nfrom .pipeline.exceptions import (\n    FileImportException,\n    FileTypeException,\n    MaximumFileSizeException,\n)\nfrom .pipeline.readers import FileName\nfrom projects.models import Project\n\n\ndef check_file_type(filename, file_format: Format, filepath: str):\n    if not settings.ENABLE_FILE_TYPE_CHECK:\n        return\n    kind = filetype.guess(filepath)\n    if not file_format.validate_mime(kind.mime):\n        raise FileTypeException(filename, kind.mime, file_format.accept_types)\n\n\ndef check_uploaded_files(upload_ids: List[str], file_format: Format):\n    errors: List[FileImportException] = []\n    cleaned_ids = []\n    temporary_uploads = TemporaryUpload.objects.filter(upload_id__in=upload_ids)\n    for tu in temporary_uploads:\n        if tu.file.size > settings.MAX_UPLOAD_SIZE:\n            errors.append(MaximumFileSizeException(tu.upload_name, settings.MAX_UPLOAD_SIZE))\n            tu.delete()\n            continue\n        try:\n            check_file_type(tu.upload_name, file_format, tu.get_file_path())\n        except FileTypeException as e:\n            errors.append(e)\n            tu.delete()\n            continue\n        cleaned_ids.append(tu.upload_id)\n    return cleaned_ids, errors\n\n\n@shared_task(autoretry_for=(Exception,), retry_backoff=True, retry_jitter=True)\ndef import_dataset(user_id, project_id, file_format: str, upload_ids: List[str], task: str, **kwargs):\n    project = get_object_or_404(Project, pk=project_id)\n    user = get_object_or_404(get_user_model(), pk=user_id)\n    try:\n        fmt = create_file_format(file_format)\n        upload_ids, errors = check_uploaded_files(upload_ids, fmt)\n        temporary_uploads = TemporaryUpload.objects.filter(upload_id__in=upload_ids)\n        filenames = [\n            FileName(full_path=tu.get_file_path(), generated_name=tu.file.name, upload_name=tu.upload_name)\n            for tu in temporary_uploads\n        ]\n\n        dataset = load_dataset(task, fmt, filenames, project, **kwargs)\n        dataset.save(user, batch_size=settings.IMPORT_BATCH_SIZE)\n        upload_to_store(temporary_uploads)\n        errors.extend(dataset.errors)\n        return {\"error\": [e.dict() for e in errors]}\n    except FileImportException as e:\n        return {\"error\": [e.dict()]}\n\n\ndef upload_to_store(temporary_uploads):\n    for tu in temporary_uploads:\n        store_upload(tu.upload_id, destination_file_path=tu.file.name)\n",
                            "summary": "Functions `check_file_type`, `check_uploaded_files`, `import_dataset`, and `upload_to_store`: Functions that handle file type checking, uploaded file validation, dataset importing, and temporary file uploading operations.",
                            "code_element_summaries": [
                                "Function `check_file_type`: A function that checks the file type based on the provided filename, file format, and file path.",
                                "Function `check_uploaded_files`: Checks uploaded files for size and format, returning cleaned IDs and errors.",
                                "Function `import_dataset`: Imports dataset files uploaded by a user for a specific project, handling file format conversion, dataset loading, and error handling.",
                                "Function `upload_to_store`: Uploads temporary files to a store by iterating through a list of temporary uploads and storing them with their corresponding file paths."
                            ],
                            "children": []
                        },
                        {
                            "name": "datasets.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\datasets.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Dataset`\nCode:\nclass Dataset(abc.ABC):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        self.reader = reader\n        self.project = project\n        self.kwargs = kwargs\n\n    def save(self, user: User, batch_size: int = 1000):\n        raise NotImplementedError()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        raise NotImplementedError()",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        self.reader = reader\n        self.project = project\n        self.kwargs = kwargs",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        raise NotImplementedError()",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        raise NotImplementedError()",
                                "Class `PlainDataset`\nCode:\nclass PlainDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = ExampleMaker(project=project, data_class=TextData)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = ExampleMaker(project=project, data_class=TextData)",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors",
                                "Class `DatasetWithSingleLabelType`\nCode:\nclass DatasetWithSingleLabelType(Dataset):\n    data_class: Type[BaseData]\n    label_class: Type[Label]\n    label_type = LabelType\n    labels_class = Labels\n\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.types = LabelTypes(self.label_type)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=self.data_class,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN],\n        )\n        self.label_maker = LabelMaker(\n            column=kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN, label_class=self.label_class\n        )\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            labels = self.labels_class(self.label_maker.make(records), self.types)\n            labels.clean(self.project)\n            labels.save_types(self.project)\n\n            # create Labels\n            labels.save(user, examples)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.label_maker.errors",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.types = LabelTypes(self.label_type)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=self.data_class,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN],\n        )\n        self.label_maker = LabelMaker(\n            column=kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN, label_class=self.label_class\n        )",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            labels = self.labels_class(self.label_maker.make(records), self.types)\n            labels.clean(self.project)\n            labels.save_types(self.project)\n\n            # create Labels\n            labels.save(user, examples)",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.label_maker.errors",
                                "Class `BinaryDataset`\nCode:\nclass BinaryDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = BinaryExampleMaker(project=project, data_class=BinaryData)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = BinaryExampleMaker(project=project, data_class=BinaryData)",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors",
                                "Class `TextClassificationDataset`\nCode:\nclass TextClassificationDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = CategoryLabel\n    label_type = CategoryType\n    labels_class = Categories",
                                "Class `SequenceLabelingDataset`\nCode:\nclass SequenceLabelingDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = SpanLabel\n    label_type = SpanType\n    labels_class = Spans",
                                "Class `Seq2seqDataset`\nCode:\nclass Seq2seqDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = TextLabel\n    label_type = DummyLabelType\n    labels_class = Texts",
                                "Class `RelationExtractionDataset`\nCode:\nclass RelationExtractionDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.span_types = LabelTypes(SpanType)\n        self.relation_types = LabelTypes(RelationType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"entities\", \"relations\"],\n        )\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)\n        self.relation_maker = LabelMaker(column=\"relations\", label_class=RelationLabel)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            relations = Relations(self.relation_maker.make(records), self.relation_types)\n            relations.clean(self.project)\n            relations.save_types(self.project)\n\n            # create Labels\n            spans.save(user, examples)\n            relations.save(user, examples, spans=spans)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.span_maker.errors + self.relation_maker.errors",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.span_types = LabelTypes(SpanType)\n        self.relation_types = LabelTypes(RelationType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"entities\", \"relations\"],\n        )\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)\n        self.relation_maker = LabelMaker(column=\"relations\", label_class=RelationLabel)",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            relations = Relations(self.relation_maker.make(records), self.relation_types)\n            relations.clean(self.project)\n            relations.save_types(self.project)\n\n            # create Labels\n            spans.save(user, examples)\n            relations.save(user, examples, spans=spans)",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.span_maker.errors + self.relation_maker.errors",
                                "Class `CategoryAndSpanDataset`\nCode:\nclass CategoryAndSpanDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.category_types = LabelTypes(CategoryType)\n        self.span_types = LabelTypes(SpanType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"cats\", \"entities\"],\n        )\n        self.category_maker = LabelMaker(column=\"cats\", label_class=CategoryLabel)\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            categories = Categories(self.category_maker.make(records), self.category_types)\n            categories.clean(self.project)\n            categories.save_types(self.project)\n\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            # create Labels\n            categories.save(user, examples)\n            spans.save(user, examples)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.category_maker.errors + self.span_maker.errors",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.category_types = LabelTypes(CategoryType)\n        self.span_types = LabelTypes(SpanType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"cats\", \"entities\"],\n        )\n        self.category_maker = LabelMaker(column=\"cats\", label_class=CategoryLabel)\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            categories = Categories(self.category_maker.make(records), self.category_types)\n            categories.clean(self.project)\n            categories.save_types(self.project)\n\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            # create Labels\n            categories.save(user, examples)\n            spans.save(user, examples)",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.category_maker.errors + self.span_maker.errors",
                                "Function `select_dataset`\nCode:\ndef select_dataset(project: Project, task: str, file_format: Format) -> Type[Dataset]:\n    mapping = {\n        ProjectType.DOCUMENT_CLASSIFICATION: TextClassificationDataset,\n        ProjectType.SEQUENCE_LABELING: SequenceLabelingDataset,\n        RELATION_EXTRACTION: RelationExtractionDataset,\n        ProjectType.SEQ2SEQ: Seq2seqDataset,\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: CategoryAndSpanDataset,\n        ProjectType.IMAGE_CLASSIFICATION: BinaryDataset,\n        ProjectType.IMAGE_CAPTIONING: BinaryDataset,\n        ProjectType.BOUNDING_BOX: BinaryDataset,\n        ProjectType.SEGMENTATION: BinaryDataset,\n        ProjectType.SPEECH2TEXT: BinaryDataset,\n    }\n    if task not in mapping:\n        task = project.project_type\n    if project.is_text_project and file_format.is_plain_text():\n        return PlainDataset\n    return mapping[task]",
                                "Function `load_dataset`\nCode:\ndef load_dataset(task: str, file_format: Format, data_files: List[FileName], project: Project, **kwargs) -> Dataset:\n    parser = create_parser(file_format, **kwargs)\n    reader = Reader(data_files, parser)\n    dataset_class = select_dataset(project, task, file_format)\n    return dataset_class(reader, project, **kwargs)"
                            ],
                            "code": "import abc\nfrom typing import List, Type\n\nfrom django.contrib.auth.models import User\n\nfrom .models import DummyLabelType\nfrom .pipeline.catalog import RELATION_EXTRACTION, Format\nfrom .pipeline.data import BaseData, BinaryData, TextData\nfrom .pipeline.examples import Examples\nfrom .pipeline.exceptions import FileParseException\nfrom .pipeline.factories import create_parser\nfrom .pipeline.label import CategoryLabel, Label, RelationLabel, SpanLabel, TextLabel\nfrom .pipeline.label_types import LabelTypes\nfrom .pipeline.labels import Categories, Labels, Relations, Spans, Texts\nfrom .pipeline.makers import BinaryExampleMaker, ExampleMaker, LabelMaker\nfrom .pipeline.readers import (\n    DEFAULT_LABEL_COLUMN,\n    DEFAULT_TEXT_COLUMN,\n    FileName,\n    Reader,\n)\nfrom label_types.models import CategoryType, LabelType, RelationType, SpanType\nfrom projects.models import Project, ProjectType\n\n\nclass Dataset(abc.ABC):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        self.reader = reader\n        self.project = project\n        self.kwargs = kwargs\n\n    def save(self, user: User, batch_size: int = 1000):\n        raise NotImplementedError()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        raise NotImplementedError()\n\n\nclass PlainDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = ExampleMaker(project=project, data_class=TextData)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors\n\n\nclass DatasetWithSingleLabelType(Dataset):\n    data_class: Type[BaseData]\n    label_class: Type[Label]\n    label_type = LabelType\n    labels_class = Labels\n\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.types = LabelTypes(self.label_type)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=self.data_class,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN],\n        )\n        self.label_maker = LabelMaker(\n            column=kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN, label_class=self.label_class\n        )\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            labels = self.labels_class(self.label_maker.make(records), self.types)\n            labels.clean(self.project)\n            labels.save_types(self.project)\n\n            # create Labels\n            labels.save(user, examples)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.label_maker.errors\n\n\nclass BinaryDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = BinaryExampleMaker(project=project, data_class=BinaryData)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors\n\n\nclass TextClassificationDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = CategoryLabel\n    label_type = CategoryType\n    labels_class = Categories\n\n\nclass SequenceLabelingDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = SpanLabel\n    label_type = SpanType\n    labels_class = Spans\n\n\nclass Seq2seqDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = TextLabel\n    label_type = DummyLabelType\n    labels_class = Texts\n\n\nclass RelationExtractionDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.span_types = LabelTypes(SpanType)\n        self.relation_types = LabelTypes(RelationType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"entities\", \"relations\"],\n        )\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)\n        self.relation_maker = LabelMaker(column=\"relations\", label_class=RelationLabel)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            relations = Relations(self.relation_maker.make(records), self.relation_types)\n            relations.clean(self.project)\n            relations.save_types(self.project)\n\n            # create Labels\n            spans.save(user, examples)\n            relations.save(user, examples, spans=spans)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.span_maker.errors + self.relation_maker.errors\n\n\nclass CategoryAndSpanDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.category_types = LabelTypes(CategoryType)\n        self.span_types = LabelTypes(SpanType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"cats\", \"entities\"],\n        )\n        self.category_maker = LabelMaker(column=\"cats\", label_class=CategoryLabel)\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            categories = Categories(self.category_maker.make(records), self.category_types)\n            categories.clean(self.project)\n            categories.save_types(self.project)\n\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            # create Labels\n            categories.save(user, examples)\n            spans.save(user, examples)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.category_maker.errors + self.span_maker.errors\n\n\ndef select_dataset(project: Project, task: str, file_format: Format) -> Type[Dataset]:\n    mapping = {\n        ProjectType.DOCUMENT_CLASSIFICATION: TextClassificationDataset,\n        ProjectType.SEQUENCE_LABELING: SequenceLabelingDataset,\n        RELATION_EXTRACTION: RelationExtractionDataset,\n        ProjectType.SEQ2SEQ: Seq2seqDataset,\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: CategoryAndSpanDataset,\n        ProjectType.IMAGE_CLASSIFICATION: BinaryDataset,\n        ProjectType.IMAGE_CAPTIONING: BinaryDataset,\n        ProjectType.BOUNDING_BOX: BinaryDataset,\n        ProjectType.SEGMENTATION: BinaryDataset,\n        ProjectType.SPEECH2TEXT: BinaryDataset,\n    }\n    if task not in mapping:\n        task = project.project_type\n    if project.is_text_project and file_format.is_plain_text():\n        return PlainDataset\n    return mapping[task]\n\n\ndef load_dataset(task: str, file_format: Format, data_files: List[FileName], project: Project, **kwargs) -> Dataset:\n    parser = create_parser(file_format, **kwargs)\n    reader = Reader(data_files, parser)\n    dataset_class = select_dataset(project, task, file_format)\n    return dataset_class(reader, project, **kwargs)\n",
                            "summary": "Class Dataset: An abstract base class representing datasets with methods for saving data and accessing errors, along with subclasses like PlainDataset, DatasetWithSingleLabelType, BinaryDataset, TextClassificationDataset, SequenceLabelingDataset, Seq2seqDataset, RelationExtractionDataset, and CategoryAndSpanDataset that handle specific data tasks and functionalities.",
                            "code_element_summaries": [
                                "Class Dataset: An abstract base class representing datasets with methods for saving data and accessing errors.",
                                "Function `__init__`: Initializes an object with a reader, project, and additional keyword arguments.",
                                "Function `save`: A method that raises a NotImplementedError when called, indicating it needs to be implemented in a subclass.",
                                "Function `errors`: A placeholder function that raises a NotImplementedError when called.",
                                "Class `PlainDataset`: A dataset class that handles reading data, creating examples, and saving them in batches with error handling capabilities.",
                                "Function `__init__`: Initializes an instance of a class with a Reader, Project, and an ExampleMaker object.",
                                "Function `save`: Saves records in batches using Examples class.",
                                "Function `errors`: Returns a list of FileParseException errors by combining errors from reader and example_maker objects.",
                                "Class `DatasetWithSingleLabelType`: A dataset class that manages data with a single label type, creating examples and labels for a project.",
                                "Function `__init__`: Initializes the ExportedBoundingBox object with specified parameters and creates instances of LabelTypes, ExampleMaker, and LabelMaker.",
                                "Function `save`: Saves records in batches, creates examples, label types, and labels associated with a user in a project.",
                                "Function `errors`: Returns a list of FileParseException objects by combining errors from reader, example_maker, and label_maker.",
                                "Class BinaryDataset: A dataset class that handles binary data with methods for saving and accessing errors.",
                                "Function `__init__`: Initializes an instance of the class with a reader, project, and an example maker for binary data.",
                                "Function `save`: Saves records in batches using Examples and ExampleMaker.",
                                "Function `errors`: Returns a list of FileParseException objects by combining errors from reader and example_maker.",
                                "Class TextClassificationDataset: A dataset class for text classification tasks with specific data and label classes defined.",
                                "Class SequenceLabelingDataset: A dataset class for sequence labeling tasks with text data and span labels.",
                                "Class Seq2seqDataset: A dataset class for sequence-to-sequence models with specific data and label classes.",
                                "Class `RelationExtractionDataset`: A dataset class for relation extraction tasks that handles creating examples, label types, and labels for spans and relations.",
                                "Function `__init__`: Initializes a new instance with specified reader, project, span types, relation types, example maker, span maker, and relation maker attributes.",
                                "Function `save`: Saves batches of records by creating examples, label types, and labels, including spans and relations, for a specific project and user.",
                                "Function `errors`: Returns a list of errors from various components within the class.",
                                "Class `CategoryAndSpanDataset`: A dataset class that handles the creation and saving of examples, label types, and labels for categories and spans in a project.",
                                "Function `__init__`: Initializes the reader, project, category types, span types, example maker, category maker, and span maker for a given project.",
                                "Function `save`: Saves examples, label types, and labels for a given user in batches.",
                                "Function `errors`: Returns a list of errors from various components within the function.",
                                "Function `select_dataset`: Returns the appropriate dataset type based on the project type, task, and file format provided.",
                                "Function `load_dataset`: A function that loads a dataset based on the specified task, file format, data files, project, and additional parameters."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A migration file creating a proxy model DummyLabelType based on the category type model.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"DummyLabelType\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"label_types.categorytype\",),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-05-17 23:01\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"DummyLabelType\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"label_types.categorytype\",),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration file creating a proxy model DummyLabelType based on the category type model.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration file that creates a proxy model DummyLabelType based on the category type model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a class ExportedBoundingBox that serves as a proxy model of BoundingBox, offering methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `DummyLabelType`\nCode:\nclass DummyLabelType(CategoryType):\n    objects = MagicMock()\n\n    class Meta:\n        proxy = True",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True"
                            ],
                            "code": "from unittest.mock import MagicMock\n\nfrom label_types.models import CategoryType\n\n\nclass DummyLabelType(CategoryType):\n    objects = MagicMock()\n\n    class Meta:\n        proxy = True\n",
                            "summary": "Class DummyLabelType: A proxy model of CategoryType with a mock objects attribute and Meta class configuration.",
                            "code_element_summaries": [
                                "Class DummyLabelType: A proxy model of CategoryType with a mock objects attribute.",
                                "Class Meta: A configuration class indicating that the model is a proxy model."
                            ],
                            "children": []
                        },
                        {
                            "name": "pipeline",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content includes various classes and functions related to file formats, data handling, exceptions, label management, example generation, and parsing operations with a focus on error handling and efficient data processing.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "catalog.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\catalog.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Format`\nCode:\nclass Format:\n    name = \"\"\n    accept_types = \"\"\n\n    @classmethod\n    def dict(cls):\n        return {\"name\": cls.name, \"accept_types\": cls.accept_types}\n\n    def validate_mime(self, mime: str):\n        return True\n\n    @staticmethod\n    def is_plain_text():\n        return False",
                                        "Function `dict`\nCode:\n    def dict(cls):\n        return {\"name\": cls.name, \"accept_types\": cls.accept_types}",
                                        "Function `validate_mime`\nCode:\n    def validate_mime(self, mime: str):\n        return True",
                                        "Function `is_plain_text`\nCode:\n    def is_plain_text():\n        return False",
                                        "Class `CSV`\nCode:\nclass CSV(Format):\n    name = \"CSV\"\n    accept_types = \"text/csv\"",
                                        "Class `FastText`\nCode:\nclass FastText(Format):\n    name = \"fastText\"\n    accept_types = \"text/plain\"",
                                        "Class `JSON`\nCode:\nclass JSON(Format):\n    name = \"JSON\"\n    accept_types = \"application/json\"",
                                        "Class `JSONL`\nCode:\nclass JSONL(Format):\n    name = \"JSONL\"\n    accept_types = \"*\"",
                                        "Class `Excel`\nCode:\nclass Excel(Format):\n    name = \"Excel\"\n    accept_types = \"application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"",
                                        "Class `TextFile`\nCode:\nclass TextFile(Format):\n    name = \"TextFile\"\n    accept_types = \"text/*\"\n\n    @staticmethod\n    def is_plain_text():\n        return True",
                                        "Function `is_plain_text`\nCode:\n    def is_plain_text():\n        return True",
                                        "Class `TextLine`\nCode:\nclass TextLine(Format):\n    name = \"TextLine\"\n    accept_types = \"text/*\"\n\n    @staticmethod\n    def is_plain_text():\n        return True",
                                        "Function `is_plain_text`\nCode:\n    def is_plain_text():\n        return True",
                                        "Class `CoNLL`\nCode:\nclass CoNLL(Format):\n    name = \"CoNLL\"\n    accept_types = \"text/*\"",
                                        "Class `ImageFile`\nCode:\nclass ImageFile(Format):\n    name = \"ImageFile\"\n    accept_types = \"image/png, image/jpeg, image/bmp, image/gif\"\n\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types",
                                        "Function `validate_mime`\nCode:\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types",
                                        "Class `AudioFile`\nCode:\nclass AudioFile(Format):\n    name = \"AudioFile\"\n    accept_types = \"audio/ogg, audio/aac, audio/mpeg, audio/wav\"\n\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types",
                                        "Function `validate_mime`\nCode:\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types",
                                        "Class `ArgColumn`\nCode:\nclass ArgColumn(BaseModel):\n    encoding: encodings = \"utf_8\"\n    column_data: str = \"text\"\n    column_label: str = \"label\"",
                                        "Class `ArgDelimiter`\nCode:\nclass ArgDelimiter(ArgColumn):\n    encoding: encodings = \"utf_8\"\n    delimiter: Literal[\",\", \"\\t\", \";\", \"|\", \" \"] = \",\"",
                                        "Class `ArgEncoding`\nCode:\nclass ArgEncoding(BaseModel):\n    encoding: encodings = \"utf_8\"",
                                        "Class `ArgCoNLL`\nCode:\nclass ArgCoNLL(BaseModel):\n    encoding: encodings = \"utf_8\"\n    scheme: Literal[\"IOB2\", \"IOE2\", \"IOBES\", \"BILOU\"] = \"IOB2\"\n    delimiter: Literal[\" \", \"\"] = \" \"",
                                        "Class `ArgNone`\nCode:\nclass ArgNone(BaseModel):\n    pass",
                                        "Class `Option`\nCode:\nclass Option:\n    display_name: str\n    task_id: str\n    file_format: Type[Format]\n    arg: Type[BaseModel]\n    file: Path\n\n    @property\n    def example(self) -> str:\n        with open(self.file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n\n    def dict(self) -> Dict:\n        return {\n            **self.file_format.dict(),\n            **self.arg.schema(),\n            \"example\": self.example,\n            \"task_id\": self.task_id,\n            \"display_name\": self.display_name,\n        }",
                                        "Function `example`\nCode:\n    def example(self) -> str:\n        with open(self.file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()",
                                        "Function `dict`\nCode:\n    def dict(self) -> Dict:\n        return {\n            **self.file_format.dict(),\n            **self.arg.schema(),\n            \"example\": self.example,\n            \"task_id\": self.task_id,\n            \"display_name\": self.display_name,\n        }",
                                        "Function `create_file_format`\nCode:\ndef create_file_format(file_format: str) -> Format:\n    for format_class in Format.__subclasses__():\n        if format_class.name == file_format:\n            return format_class()\n    raise FileFormatException(file_format)",
                                        "Class `Options`\nCode:\nclass Options:\n    options: Dict[str, List] = defaultdict(list)\n\n    @classmethod\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        if use_relation:\n            options = cls.options[task_name] + cls.options[RELATION_EXTRACTION]\n        return [option.dict() for option in options]\n\n    @classmethod\n    def register(cls, option: Option):\n        cls.options[option.task_id].append(option)",
                                        "Function `filter_by_task`\nCode:\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        if use_relation:\n            options = cls.options[task_name] + cls.options[RELATION_EXTRACTION]\n        return [option.dict() for option in options]",
                                        "Function `register`\nCode:\n    def register(cls, option: Option):\n        cls.options[option.task_id].append(option)"
                                    ],
                                    "code": "from collections import defaultdict\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Type\n\nfrom pydantic import BaseModel\nfrom typing_extensions import Literal\n\nfrom .exceptions import FileFormatException\nfrom projects.models import ProjectType\n\n# Define the example directories\nEXAMPLE_DIR = Path(__file__).parent.resolve() / \"examples\"\nTASK_AGNOSTIC_DIR = EXAMPLE_DIR / \"task_agnostic\"\nTEXT_CLASSIFICATION_DIR = EXAMPLE_DIR / \"text_classification\"\nSEQUENCE_LABELING_DIR = EXAMPLE_DIR / \"sequence_labeling\"\nRELATION_EXTRACTION_DIR = EXAMPLE_DIR / \"relation_extraction\"\nSEQ2SEQ_DIR = EXAMPLE_DIR / \"sequence_to_sequence\"\nINTENT_DETECTION_DIR = EXAMPLE_DIR / \"intent_detection\"\nIMAGE_CLASSIFICATION_DIR = EXAMPLE_DIR / \"image_classification\"\nSPEECH_TO_TEXT_DIR = EXAMPLE_DIR / \"speech_to_text\"\n\n# Define the task identifiers\nRELATION_EXTRACTION = \"RelationExtraction\"\n\nencodings = Literal[\n    \"Auto\",\n    \"ascii\",\n    \"big5\",\n    \"big5hkscs\",\n    \"cp037\",\n    \"cp273\",\n    \"cp424\",\n    \"cp437\",\n    \"cp500\",\n    \"cp720\",\n    \"cp737\",\n    \"cp775\",\n    \"cp850\",\n    \"cp852\",\n    \"cp855\",\n    \"cp856\",\n    \"cp857\",\n    \"cp858\",\n    \"cp860\",\n    \"cp861\",\n    \"cp862\",\n    \"cp863\",\n    \"cp864\",\n    \"cp865\",\n    \"cp866\",\n    \"cp869\",\n    \"cp874\",\n    \"cp875\",\n    \"cp932\",\n    \"cp949\",\n    \"cp950\",\n    \"cp1006\",\n    \"cp1026\",\n    \"cp1125\",\n    \"cp1140\",\n    \"cp1250\",\n    \"cp1251\",\n    \"cp1252\",\n    \"cp1253\",\n    \"cp1254\",\n    \"cp1255\",\n    \"cp1256\",\n    \"cp1257\",\n    \"cp1258\",\n    \"cp65001\",\n    \"euc_jp\",\n    \"euc_jis_2004\",\n    \"euc_jisx0213\",\n    \"euc_kr\",\n    \"gb2312\",\n    \"gbk\",\n    \"gb18030\",\n    \"hz\",\n    \"iso2022_jp\",\n    \"iso2022_jp_1\",\n    \"iso2022_jp_2\",\n    \"iso2022_jp_2004\",\n    \"iso2022_jp_3\",\n    \"iso2022_jp_ext\",\n    \"iso2022_kr\",\n    \"latin_1\",\n    \"iso8859_2\",\n    \"iso8859_3\",\n    \"iso8859_4\",\n    \"iso8859_5\",\n    \"iso8859_6\",\n    \"iso8859_7\",\n    \"iso8859_8\",\n    \"iso8859_9\",\n    \"iso8859_10\",\n    \"iso8859_11\",\n    \"iso8859_13\",\n    \"iso8859_14\",\n    \"iso8859_15\",\n    \"iso8859_16\",\n    \"johab\",\n    \"koi8_r\",\n    \"koi8_t\",\n    \"koi8_u\",\n    \"kz1048\",\n    \"mac_cyrillic\",\n    \"mac_greek\",\n    \"mac_iceland\",\n    \"mac_latin2\",\n    \"mac_roman\",\n    \"mac_turkish\",\n    \"ptcp154\",\n    \"shift_jis\",\n    \"shift_jis_2004\",\n    \"shift_jisx0213\",\n    \"utf_32\",\n    \"utf_32_be\",\n    \"utf_32_le\",\n    \"utf_16\",\n    \"utf_16_be\",\n    \"utf_16_le\",\n    \"utf_7\",\n    \"utf_8\",\n    \"utf_8_sig\",\n]\n\n\nclass Format:\n    name = \"\"\n    accept_types = \"\"\n\n    @classmethod\n    def dict(cls):\n        return {\"name\": cls.name, \"accept_types\": cls.accept_types}\n\n    def validate_mime(self, mime: str):\n        return True\n\n    @staticmethod\n    def is_plain_text():\n        return False\n\n\nclass CSV(Format):\n    name = \"CSV\"\n    accept_types = \"text/csv\"\n\n\nclass FastText(Format):\n    name = \"fastText\"\n    accept_types = \"text/plain\"\n\n\nclass JSON(Format):\n    name = \"JSON\"\n    accept_types = \"application/json\"\n\n\nclass JSONL(Format):\n    name = \"JSONL\"\n    accept_types = \"*\"\n\n\nclass Excel(Format):\n    name = \"Excel\"\n    accept_types = \"application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n\n\nclass TextFile(Format):\n    name = \"TextFile\"\n    accept_types = \"text/*\"\n\n    @staticmethod\n    def is_plain_text():\n        return True\n\n\nclass TextLine(Format):\n    name = \"TextLine\"\n    accept_types = \"text/*\"\n\n    @staticmethod\n    def is_plain_text():\n        return True\n\n\nclass CoNLL(Format):\n    name = \"CoNLL\"\n    accept_types = \"text/*\"\n\n\nclass ImageFile(Format):\n    name = \"ImageFile\"\n    accept_types = \"image/png, image/jpeg, image/bmp, image/gif\"\n\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types\n\n\nclass AudioFile(Format):\n    name = \"AudioFile\"\n    accept_types = \"audio/ogg, audio/aac, audio/mpeg, audio/wav\"\n\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types\n\n\nclass ArgColumn(BaseModel):\n    encoding: encodings = \"utf_8\"\n    column_data: str = \"text\"\n    column_label: str = \"label\"\n\n\nclass ArgDelimiter(ArgColumn):\n    encoding: encodings = \"utf_8\"\n    delimiter: Literal[\",\", \"\\t\", \";\", \"|\", \" \"] = \",\"\n\n\nclass ArgEncoding(BaseModel):\n    encoding: encodings = \"utf_8\"\n\n\nclass ArgCoNLL(BaseModel):\n    encoding: encodings = \"utf_8\"\n    scheme: Literal[\"IOB2\", \"IOE2\", \"IOBES\", \"BILOU\"] = \"IOB2\"\n    delimiter: Literal[\" \", \"\"] = \" \"\n\n\nclass ArgNone(BaseModel):\n    pass\n\n\n@dataclass\nclass Option:\n    display_name: str\n    task_id: str\n    file_format: Type[Format]\n    arg: Type[BaseModel]\n    file: Path\n\n    @property\n    def example(self) -> str:\n        with open(self.file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n\n    def dict(self) -> Dict:\n        return {\n            **self.file_format.dict(),\n            **self.arg.schema(),\n            \"example\": self.example,\n            \"task_id\": self.task_id,\n            \"display_name\": self.display_name,\n        }\n\n\ndef create_file_format(file_format: str) -> Format:\n    for format_class in Format.__subclasses__():\n        if format_class.name == file_format:\n            return format_class()\n    raise FileFormatException(file_format)\n\n\nclass Options:\n    options: Dict[str, List] = defaultdict(list)\n\n    @classmethod\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        if use_relation:\n            options = cls.options[task_name] + cls.options[RELATION_EXTRACTION]\n        return [option.dict() for option in options]\n\n    @classmethod\n    def register(cls, option: Option):\n        cls.options[option.task_id].append(option)\n\n\n# Text tasks\ntext_tasks = [\n    ProjectType.DOCUMENT_CLASSIFICATION,\n    ProjectType.SEQUENCE_LABELING,\n    ProjectType.SEQ2SEQ,\n    ProjectType.INTENT_DETECTION_AND_SLOT_FILLING,\n]\nfor task_id in text_tasks:\n    Options.register(\n        Option(\n            display_name=TextFile.name,\n            task_id=task_id,\n            file_format=TextFile,\n            arg=ArgEncoding,\n            file=TASK_AGNOSTIC_DIR / \"text_files.txt\",\n        )\n    )\n    Options.register(\n        Option(\n            display_name=TextLine.name,\n            task_id=task_id,\n            file_format=TextLine,\n            arg=ArgEncoding,\n            file=TASK_AGNOSTIC_DIR / \"text_lines.txt\",\n        )\n    )\n\n# Text Classification\nOptions.register(\n    Option(\n        display_name=CSV.name,\n        task_id=ProjectType.DOCUMENT_CLASSIFICATION,\n        file_format=CSV,\n        arg=ArgDelimiter,\n        file=TEXT_CLASSIFICATION_DIR / \"example.csv\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=FastText.name,\n        task_id=ProjectType.DOCUMENT_CLASSIFICATION,\n        file_format=FastText,\n        arg=ArgEncoding,\n        file=TEXT_CLASSIFICATION_DIR / \"example.txt\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=JSON.name,\n        task_id=ProjectType.DOCUMENT_CLASSIFICATION,\n        file_format=JSON,\n        arg=ArgColumn,\n        file=TEXT_CLASSIFICATION_DIR / \"example.json\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=JSONL.name,\n        task_id=ProjectType.DOCUMENT_CLASSIFICATION,\n        file_format=JSONL,\n        arg=ArgColumn,\n        file=TEXT_CLASSIFICATION_DIR / \"example.jsonl\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=Excel.name,\n        task_id=ProjectType.DOCUMENT_CLASSIFICATION,\n        file_format=Excel,\n        arg=ArgColumn,\n        file=TEXT_CLASSIFICATION_DIR / \"example.csv\",\n    )\n)\n\n# Sequence Labelling\nOptions.register(\n    Option(\n        display_name=JSONL.name,\n        task_id=ProjectType.SEQUENCE_LABELING,\n        file_format=JSONL,\n        arg=ArgColumn,\n        file=SEQUENCE_LABELING_DIR / \"example.jsonl\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=CoNLL.name,\n        task_id=ProjectType.SEQUENCE_LABELING,\n        file_format=CoNLL,\n        arg=ArgCoNLL,\n        file=SEQUENCE_LABELING_DIR / \"example.txt\",\n    )\n)\n\n# Relation Extraction\nOptions.register(\n    Option(\n        display_name=\"JSONL(Relation)\",\n        task_id=RELATION_EXTRACTION,\n        file_format=JSONL,\n        arg=ArgNone,\n        file=RELATION_EXTRACTION_DIR / \"example.jsonl\",\n    )\n)\n\n# Seq2seq\nOptions.register(\n    Option(\n        display_name=CSV.name,\n        task_id=ProjectType.SEQ2SEQ,\n        file_format=CSV,\n        arg=ArgDelimiter,\n        file=SEQ2SEQ_DIR / \"example.csv\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=JSON.name,\n        task_id=ProjectType.SEQ2SEQ,\n        file_format=JSON,\n        arg=ArgColumn,\n        file=SEQ2SEQ_DIR / \"example.json\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=JSONL.name,\n        task_id=ProjectType.SEQ2SEQ,\n        file_format=JSONL,\n        arg=ArgColumn,\n        file=SEQ2SEQ_DIR / \"example.jsonl\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=Excel.name,\n        task_id=ProjectType.SEQ2SEQ,\n        file_format=Excel,\n        arg=ArgColumn,\n        file=SEQ2SEQ_DIR / \"example.csv\",\n    )\n)\n\n# Intent detection\nOptions.register(\n    Option(\n        display_name=JSONL.name,\n        task_id=ProjectType.INTENT_DETECTION_AND_SLOT_FILLING,\n        file_format=JSONL,\n        arg=ArgNone,\n        file=INTENT_DETECTION_DIR / \"example.jsonl\",\n    )\n)\n\n# Image tasks\nimage_tasks = [\n    ProjectType.IMAGE_CLASSIFICATION,\n    ProjectType.IMAGE_CAPTIONING,\n    ProjectType.BOUNDING_BOX,\n    ProjectType.SEGMENTATION,\n]\nfor task_name in image_tasks:\n    Options.register(\n        Option(\n            display_name=ImageFile.name,\n            task_id=task_name,\n            file_format=ImageFile,\n            arg=ArgNone,\n            file=IMAGE_CLASSIFICATION_DIR / \"image_files.txt\",\n        )\n    )\n\n# Speech to Text\nOptions.register(\n    Option(\n        display_name=AudioFile.name,\n        task_id=ProjectType.SPEECH2TEXT,\n        file_format=AudioFile,\n        arg=ArgNone,\n        file=SPEECH_TO_TEXT_DIR / \"audio_files.txt\",\n    )\n)\n",
                                    "summary": "Class Format: Represents various file formats with methods for conversion, validation, and checking properties such as MIME type and plain text.",
                                    "code_element_summaries": [
                                        "Class Format: Represents a format with name and accepted types, providing methods to convert to dictionary, validate MIME types, and check if it is plain text.",
                                        "Function `dict`: Returns a dictionary containing the name and accepted types of the class.",
                                        "Function `validate_mime`: A function that validates a MIME type string and returns True.",
                                        "Function `is_plain_text`: Returns False indicating that the text is not plain.",
                                        "Class CSV: A format class representing CSV files with a specific name and accepted file type.",
                                        "Class FastText: A format class representing fastText annotations with specified name and accepted types.",
                                        "Class JSON: A subclass of Format representing the JSON format with specified name and accepted types.",
                                        "Class JSONL: Represents a format for handling data in JSON Lines format.",
                                        "Class Excel: Represents the Excel format with specific name and accepted types for file extensions.",
                                        "Class `TextFile`: A format class representing text files that can accept text/* types and determine if it is plain text.",
                                        "Function `is_plain_text`: A function that always returns True, indicating that the input is plain text.",
                                        "Class TextLine: A format class for handling text lines with a specific name and acceptance of text types.",
                                        "Function `is_plain_text`: Returns True.",
                                        "Class CoNLL: Inherits from Format and represents the CoNLL format with the name \"CoNLL\" and accepts text types.",
                                        "Class ImageFile: Represents an image file format with specified accepted types and a method to validate MIME types.",
                                        "Function `validate_mime`: Validates if a given MIME type is accepted based on a list of accepted types.",
                                        "Class `AudioFile`: Represents an audio file format with specified accepted MIME types and a method to validate MIME type.",
                                        "Function `validate_mime`: Checks if a given MIME type is accepted based on a list of accepted types.",
                                        "Class ArgColumn: A model representing a column with default encoding, data type, and label.",
                                        "Class ArgDelimiter: Represents a delimiter for separating arguments in a specified encoding format.",
                                        "Class ArgEncoding: A model representing encoding configurations with a default value of \"utf_8\".",
                                        "Class ArgCoNLL: A BaseModel representing ArgCoNLL annotations with specified encoding, scheme, and delimiter.",
                                        "Class ArgNone: A BaseModel subclass that does not have any attributes or methods defined.",
                                        "Class `Option`: Represents an option with display name, task ID, file format, argument type, file path, and methods to return example content and dictionary representation.",
                                        "Function `example`: Reads and returns the content of a file specified by the `file` attribute as a string.",
                                        "Function `dict`: Returns a dictionary representation of the object with file format details, schema arguments, example, task ID, and display name.",
                                        "Function `create_file_format`: A function that creates a file format object based on the input file format string.",
                                        "Class Options: A model that manages options for different tasks and allows filtering and registration of options.",
                                        "Function `filter_by_task`: Filters options based on a task name and includes relation extraction options if specified.",
                                        "Function `register`: A method that adds an option to a list of options based on the task ID."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "data.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\data.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `BaseData`\nCode:\nclass BaseData(BaseModel, abc.ABC):\n    filename: str\n    upload_name: str\n    uuid: UUID4\n    meta: Dict[Any, Any] = {}\n\n    def __init__(self, **data):\n        super().__init__(**data)\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, filename: str, upload_name: str, text: str = \"\", **kwargs):\n        return cls(uuid=example_uuid, filename=filename, upload_name=upload_name, text=text, meta=kwargs)\n\n    def __hash__(self):\n        return hash(tuple(self.dict()))\n\n    @abc.abstractmethod\n    def create(self, project: Project) -> Example:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `__init__`\nCode:\n    def __init__(self, **data):\n        super().__init__(**data)",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, filename: str, upload_name: str, text: str = \"\", **kwargs):\n        return cls(uuid=example_uuid, filename=filename, upload_name=upload_name, text=text, meta=kwargs)",
                                        "Function `__hash__`\nCode:\n    def __hash__(self):\n        return hash(tuple(self.dict()))",
                                        "Function `create`\nCode:\n    def create(self, project: Project) -> Example:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Class `TextData`\nCode:\nclass TextData(BaseData):\n    text: str\n\n    @validator(\"text\")\n    def text_is_not_empty(cls, value: str):\n        if value:\n            return value\n        else:\n            raise ValueError(\"The empty text is not allowed.\")\n\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=self.text,\n            meta=self.meta,\n        )",
                                        "Function `text_is_not_empty`\nCode:\n    def text_is_not_empty(cls, value: str):\n        if value:\n            return value\n        else:\n            raise ValueError(\"The empty text is not allowed.\")",
                                        "Function `create`\nCode:\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=self.text,\n            meta=self.meta,\n        )",
                                        "Class `BinaryData`\nCode:\nclass BinaryData(BaseData):\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=None,\n            meta=self.meta,\n        )",
                                        "Function `create`\nCode:\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=None,\n            meta=self.meta,\n        )"
                                    ],
                                    "code": "import abc\nfrom typing import Any, Dict\n\nfrom pydantic import UUID4, BaseModel, validator\n\nfrom examples.models import Example\nfrom projects.models import Project\n\n\nclass BaseData(BaseModel, abc.ABC):\n    filename: str\n    upload_name: str\n    uuid: UUID4\n    meta: Dict[Any, Any] = {}\n\n    def __init__(self, **data):\n        super().__init__(**data)\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, filename: str, upload_name: str, text: str = \"\", **kwargs):\n        return cls(uuid=example_uuid, filename=filename, upload_name=upload_name, text=text, meta=kwargs)\n\n    def __hash__(self):\n        return hash(tuple(self.dict()))\n\n    @abc.abstractmethod\n    def create(self, project: Project) -> Example:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n\nclass TextData(BaseData):\n    text: str\n\n    @validator(\"text\")\n    def text_is_not_empty(cls, value: str):\n        if value:\n            return value\n        else:\n            raise ValueError(\"The empty text is not allowed.\")\n\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=self.text,\n            meta=self.meta,\n        )\n\n\nclass BinaryData(BaseData):\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=None,\n            meta=self.meta,\n        )\n",
                                    "summary": "Class BaseData: A BaseModel subclass with essential data attributes and abstract methods for project examples creation, alongside related classes TextData and BinaryData with validation and creation methods.",
                                    "code_element_summaries": [
                                        "Class `BaseData`: A BaseModel subclass representing base data with filename, upload name, UUID, metadata, and abstract methods for creating examples in a project.",
                                        "Function `__init__`: Initializes the ExportedBoundingBox class with the provided data.",
                                        "Function `parse`: A method that creates and returns an instance of the class with specified parameters.",
                                        "Function `__hash__`: Overrides the default hash function to hash the dictionary representation of an object.",
                                        "Function `create`: A placeholder method that raises a NotImplementedError to remind the subclass to implement it.",
                                        "Class TextData: Represents text data with validation for non-empty text and a method to create an Example object with the text data.",
                                        "Function `text_is_not_empty`: A function that checks if a given text value is not empty and raises a ValueError if it is.",
                                        "Function `create`: A method that creates an Example object with specified attributes and assigns it to a project.",
                                        "Class BinaryData: A class representing binary data with a method to create Example instances based on project information.",
                                        "Function `create`: Creates an Example instance with specified attributes and returns it."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "examples.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\examples.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Examples`\nCode:\nclass Examples:\n    def __init__(self, examples: List[Example]):\n        self.examples = examples\n        self.uuid_to_example: Dict[UUID4, Example] = {}\n\n    def __getitem__(self, uuid: UUID4) -> Example:\n        return self.uuid_to_example[uuid]\n\n    def __contains__(self, uuid: UUID4) -> bool:\n        return uuid in self.uuid_to_example\n\n    def save(self):\n        examples = Example.objects.bulk_create(self.examples)\n        self.uuid_to_example = {example.uuid: example for example in examples}",
                                        "Function `__init__`\nCode:\n    def __init__(self, examples: List[Example]):\n        self.examples = examples\n        self.uuid_to_example: Dict[UUID4, Example] = {}",
                                        "Function `__getitem__`\nCode:\n    def __getitem__(self, uuid: UUID4) -> Example:\n        return self.uuid_to_example[uuid]",
                                        "Function `__contains__`\nCode:\n    def __contains__(self, uuid: UUID4) -> bool:\n        return uuid in self.uuid_to_example",
                                        "Function `save`\nCode:\n    def save(self):\n        examples = Example.objects.bulk_create(self.examples)\n        self.uuid_to_example = {example.uuid: example for example in examples}"
                                    ],
                                    "code": "from typing import Dict, List\n\nfrom pydantic import UUID4\n\nfrom examples.models import Example\n\n\nclass Examples:\n    def __init__(self, examples: List[Example]):\n        self.examples = examples\n        self.uuid_to_example: Dict[UUID4, Example] = {}\n\n    def __getitem__(self, uuid: UUID4) -> Example:\n        return self.uuid_to_example[uuid]\n\n    def __contains__(self, uuid: UUID4) -> bool:\n        return uuid in self.uuid_to_example\n\n    def save(self):\n        examples = Example.objects.bulk_create(self.examples)\n        self.uuid_to_example = {example.uuid: example for example in examples}\n",
                                    "summary": "Class Examples: A model managing Example instances with methods for efficient access, saving, and UUID mapping.",
                                    "code_element_summaries": [
                                        "Class Examples: A model that manages a list of Example instances and provides methods to access and save them efficiently.",
                                        "Function `__init__`: Initializes an object with a list of examples and creates a dictionary mapping UUIDs to examples.",
                                        "Function `__getitem__`: Retrieves an Example object based on its UUID key from a dictionary mapping UUID to Example.",
                                        "Function `__contains__`: Checks if a UUID exists in the uuid_to_example dictionary and returns a boolean value.",
                                        "Function `save`: Saves a list of examples in bulk and creates a dictionary mapping UUID to example objects."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "exceptions.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\exceptions.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `FileImportException`\nCode:\nclass FileImportException(Exception):\n    def dict(self) -> Dict[str, Any]:\n        raise NotImplementedError()",
                                        "Function `dict`\nCode:\n    def dict(self) -> Dict[str, Any]:\n        raise NotImplementedError()",
                                        "Class `FileParseException`\nCode:\nclass FileParseException(FileImportException):\n    def __init__(self, filename: str, line_num: int, message: str):\n        self.filename = filename\n        self.line_num = line_num\n        self.message = message\n\n    def __str__(self):\n        return f\"ParseError: You cannot parse line {self.line_num} in {self.filename}: {self.message}\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": self.line_num, \"message\": self.message}",
                                        "Function `__init__`\nCode:\n    def __init__(self, filename: str, line_num: int, message: str):\n        self.filename = filename\n        self.line_num = line_num\n        self.message = message",
                                        "Function `__str__`\nCode:\n    def __str__(self):\n        return f\"ParseError: You cannot parse line {self.line_num} in {self.filename}: {self.message}\"",
                                        "Function `dict`\nCode:\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": self.line_num, \"message\": self.message}",
                                        "Class `MaximumFileSizeException`\nCode:\nclass MaximumFileSizeException(FileImportException):\n    def __init__(self, filename: str, max_size: int):\n        self.filename = filename\n        self.max_size = max_size\n\n    def __str__(self):\n        return f\"The maximum file size that can be uploaded is {self.max_size/1024/1024} MB\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}",
                                        "Function `__init__`\nCode:\n    def __init__(self, filename: str, max_size: int):\n        self.filename = filename\n        self.max_size = max_size",
                                        "Function `__str__`\nCode:\n    def __str__(self):\n        return f\"The maximum file size that can be uploaded is {self.max_size/1024/1024} MB\"",
                                        "Function `dict`\nCode:\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}",
                                        "Class `FileTypeException`\nCode:\nclass FileTypeException(FileImportException):\n    def __init__(self, filename: str, filetype: str, allowed_types=None):\n        self.filename = filename\n        self.filetype = filetype\n        self.allowed_types = allowed_types\n\n    def __str__(self):\n        return f\"The file type {self.filetype} is unexpected. Expected: {self.allowed_types}\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}",
                                        "Function `__init__`\nCode:\n    def __init__(self, filename: str, filetype: str, allowed_types=None):\n        self.filename = filename\n        self.filetype = filetype\n        self.allowed_types = allowed_types",
                                        "Function `__str__`\nCode:\n    def __str__(self):\n        return f\"The file type {self.filetype} is unexpected. Expected: {self.allowed_types}\"",
                                        "Function `dict`\nCode:\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}",
                                        "Class `FileFormatException`\nCode:\nclass FileFormatException(FileImportException):\n    def __init__(self, file_format: str):\n        self.file_format = file_format\n\n    def dict(self):\n        message = f\"Unknown file format: {self.file_format}\"\n        return {\"message\": message}",
                                        "Function `__init__`\nCode:\n    def __init__(self, file_format: str):\n        self.file_format = file_format",
                                        "Function `dict`\nCode:\n    def dict(self):\n        message = f\"Unknown file format: {self.file_format}\"\n        return {\"message\": message}"
                                    ],
                                    "code": "from typing import Any, Dict\n\n\nclass FileImportException(Exception):\n    def dict(self) -> Dict[str, Any]:\n        raise NotImplementedError()\n\n\nclass FileParseException(FileImportException):\n    def __init__(self, filename: str, line_num: int, message: str):\n        self.filename = filename\n        self.line_num = line_num\n        self.message = message\n\n    def __str__(self):\n        return f\"ParseError: You cannot parse line {self.line_num} in {self.filename}: {self.message}\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": self.line_num, \"message\": self.message}\n\n\nclass MaximumFileSizeException(FileImportException):\n    def __init__(self, filename: str, max_size: int):\n        self.filename = filename\n        self.max_size = max_size\n\n    def __str__(self):\n        return f\"The maximum file size that can be uploaded is {self.max_size/1024/1024} MB\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}\n\n\nclass FileTypeException(FileImportException):\n    def __init__(self, filename: str, filetype: str, allowed_types=None):\n        self.filename = filename\n        self.filetype = filetype\n        self.allowed_types = allowed_types\n\n    def __str__(self):\n        return f\"The file type {self.filetype} is unexpected. Expected: {self.allowed_types}\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}\n\n\nclass FileFormatException(FileImportException):\n    def __init__(self, file_format: str):\n        self.file_format = file_format\n\n    def dict(self):\n        message = f\"Unknown file format: {self.file_format}\"\n        return {\"message\": message}\n",
                                    "summary": "Class FileImportException: An exception class for file import operations with an unimplemented method to return information in dictionary form, along with other related exception classes and their respective methods for handling errors.",
                                    "code_element_summaries": [
                                        "Class FileImportException: Represents an exception for file import operations with a method to return a dictionary of information (not implemented).",
                                        "Function `dict`: A method that is not implemented and raises a NotImplementedError.",
                                        "Class FileParseException: An exception class representing errors that occur during file parsing, providing details such as filename, line number, and error message.",
                                        "Function `__init__`: Initializes an object with filename, line number, and message attributes.",
                                        "Function `__str__`: Returns a string representation of a ParseError object with information about the error.",
                                        "Function `dict`: Returns a dictionary containing filename, line number, and message attributes.",
                                        "Class MaximumFileSizeException: Represents an exception for when a file exceeds the maximum allowed size for upload.",
                                        "Function `__init__`: Initializes an object with a filename and maximum size attribute.",
                                        "Function `__str__`: Returns a string representation of the maximum file size that can be uploaded in MB.",
                                        "Function `dict`: Returns a dictionary containing the filename, line number (-1), and message of the object.",
                                        "Class `FileTypeException`: A custom exception class that handles unexpected file types during file import operations.",
                                        "Function `__init__`: Initializes an object with filename, filetype, and allowed types parameters.",
                                        "Function `__str__`: Returns a string representation of unexpected file types and their expected types.",
                                        "Function `dict`: Returns a dictionary containing the filename, line number, and message of the object.",
                                        "Class FileFormatException: An exception class that represents errors related to unknown file formats with a method to return the error message in a dictionary format.",
                                        "Function `__init__`: Initializes the file format attribute for the class.",
                                        "Function `dict`: Returns a dictionary with a message indicating an unknown file format."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "factories.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\factories.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `create_parser`\nCode:\ndef create_parser(file_format: Format, **kwargs):\n    mapping = {\n        TextFile.name: TextFileParser,\n        TextLine.name: LineParser,\n        CSV.name: CSVParser,\n        JSONL.name: JSONLParser,\n        JSON.name: JSONParser,\n        FastText.name: FastTextParser,\n        Excel.name: ExcelParser,\n        CoNLL.name: CoNLLParser,\n        ImageFile.name: PlainParser,\n        AudioFile.name: PlainParser,\n    }\n    return mapping[file_format.name](**kwargs)"
                                    ],
                                    "code": "from .catalog import (\n    CSV,\n    JSON,\n    JSONL,\n    AudioFile,\n    CoNLL,\n    Excel,\n    FastText,\n    Format,\n    ImageFile,\n    TextFile,\n    TextLine,\n)\nfrom .parsers import (\n    CoNLLParser,\n    CSVParser,\n    ExcelParser,\n    FastTextParser,\n    JSONLParser,\n    JSONParser,\n    LineParser,\n    PlainParser,\n    TextFileParser,\n)\n\n\ndef create_parser(file_format: Format, **kwargs):\n    mapping = {\n        TextFile.name: TextFileParser,\n        TextLine.name: LineParser,\n        CSV.name: CSVParser,\n        JSONL.name: JSONLParser,\n        JSON.name: JSONParser,\n        FastText.name: FastTextParser,\n        Excel.name: ExcelParser,\n        CoNLL.name: CoNLLParser,\n        ImageFile.name: PlainParser,\n        AudioFile.name: PlainParser,\n    }\n    return mapping[file_format.name](**kwargs)\n",
                                    "summary": "Function `create_parser`: A dynamic function that generates and returns a parser based on the specified file format.",
                                    "code_element_summaries": [
                                        "Function `create_parser`: A function that dynamically creates and returns a parser based on the specified file format."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "label.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\label.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Label`\nCode:\nclass Label(BaseModel, abc.ABC):\n    id: int = -1\n    uuid: UUID4\n    example_uuid: UUID4\n\n    def __init__(self, **data):\n        data[\"uuid\"] = uuid.uuid4()\n        super().__init__(**data)\n\n    @abc.abstractmethod\n    def __lt__(self, other):\n        return NotImplemented\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def create(self, user, example: Example, types: LabelTypes, **kwargs) -> LabelModel:\n        raise NotImplementedError\n\n    def __hash__(self):\n        return hash(tuple(self.dict()))",
                                        "Function `__init__`\nCode:\n    def __init__(self, **data):\n        data[\"uuid\"] = uuid.uuid4()\n        super().__init__(**data)",
                                        "Function `__lt__`\nCode:\n    def __lt__(self, other):\n        return NotImplemented",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        raise NotImplementedError()",
                                        "Function `create_type`\nCode:\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        raise NotImplementedError()",
                                        "Function `create`\nCode:\n    def create(self, user, example: Example, types: LabelTypes, **kwargs) -> LabelModel:\n        raise NotImplementedError",
                                        "Function `__hash__`\nCode:\n    def __hash__(self):\n        return hash(tuple(self.dict()))",
                                        "Class `CategoryLabel`\nCode:\nclass CategoryLabel(Label):\n    label: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.label < other.label\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, label=obj)  # type: ignore\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return CategoryType(text=self.label, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return CategoryModel(uuid=self.uuid, user=user, example=example, label=types[self.label])",
                                        "Function `__lt__`\nCode:\n    def __lt__(self, other):\n        return self.label < other.label",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, label=obj)  # type: ignore",
                                        "Function `create_type`\nCode:\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return CategoryType(text=self.label, project=project)",
                                        "Function `create`\nCode:\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return CategoryModel(uuid=self.uuid, user=user, example=example, label=types[self.label])",
                                        "Class `SpanLabel`\nCode:\nclass SpanLabel(Label):\n    label: constr(min_length=1)  # type: ignore\n    start_offset: NonNegativeInt\n    end_offset: NonNegativeInt\n\n    def __lt__(self, other):\n        return self.start_offset < other.start_offset\n\n    @root_validator(skip_on_failure=True)\n    def check_start_offset_is_less_than_end_offset(cls, values):\n        start_offset, end_offset = values.get(\"start_offset\"), values.get(\"end_offset\")\n        if start_offset >= end_offset:\n            raise ValueError(\"start_offset must be less than end_offset.\")\n        return values\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        if isinstance(obj, list) or isinstance(obj, tuple):\n            columns = [\"start_offset\", \"end_offset\", \"label\"]\n            obj = zip(columns, obj)\n            return cls(example_uuid=example_uuid, **dict(obj))\n        elif isinstance(obj, dict):\n            return cls(example_uuid=example_uuid, **obj)\n        raise ValueError(\"SpanLabel.parse()\")\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return SpanType(text=self.label, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return SpanModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            start_offset=self.start_offset,\n            end_offset=self.end_offset,\n            label=types[self.label],\n        )",
                                        "Function `__lt__`\nCode:\n    def __lt__(self, other):\n        return self.start_offset < other.start_offset",
                                        "Function `check_start_offset_is_less_than_end_offset`\nCode:\n    def check_start_offset_is_less_than_end_offset(cls, values):\n        start_offset, end_offset = values.get(\"start_offset\"), values.get(\"end_offset\")\n        if start_offset >= end_offset:\n            raise ValueError(\"start_offset must be less than end_offset.\")\n        return values",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        if isinstance(obj, list) or isinstance(obj, tuple):\n            columns = [\"start_offset\", \"end_offset\", \"label\"]\n            obj = zip(columns, obj)\n            return cls(example_uuid=example_uuid, **dict(obj))\n        elif isinstance(obj, dict):\n            return cls(example_uuid=example_uuid, **obj)\n        raise ValueError(\"SpanLabel.parse()\")",
                                        "Function `create_type`\nCode:\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return SpanType(text=self.label, project=project)",
                                        "Function `create`\nCode:\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return SpanModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            start_offset=self.start_offset,\n            end_offset=self.end_offset,\n            label=types[self.label],\n        )",
                                        "Class `TextLabel`\nCode:\nclass TextLabel(Label):\n    text: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.text < other.text\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, text=obj)  # type: ignore\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return None\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return TextLabelModel(uuid=self.uuid, user=user, example=example, text=self.text)",
                                        "Function `__lt__`\nCode:\n    def __lt__(self, other):\n        return self.text < other.text",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, text=obj)  # type: ignore",
                                        "Function `create_type`\nCode:\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return None",
                                        "Function `create`\nCode:\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return TextLabelModel(uuid=self.uuid, user=user, example=example, text=self.text)",
                                        "Class `RelationLabel`\nCode:\nclass RelationLabel(Label):\n    from_id: int\n    to_id: int\n    type: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.from_id < other.from_id\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, **obj)\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return RelationType(text=self.type, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return RelationModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            type=types[self.type],\n            from_id=kwargs[\"id_to_span\"][(self.from_id, str(self.example_uuid))],\n            to_id=kwargs[\"id_to_span\"][(self.to_id, str(self.example_uuid))],\n        )",
                                        "Function `__lt__`\nCode:\n    def __lt__(self, other):\n        return self.from_id < other.from_id",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, **obj)",
                                        "Function `create_type`\nCode:\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return RelationType(text=self.type, project=project)",
                                        "Function `create`\nCode:\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return RelationModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            type=types[self.type],\n            from_id=kwargs[\"id_to_span\"][(self.from_id, str(self.example_uuid))],\n            to_id=kwargs[\"id_to_span\"][(self.to_id, str(self.example_uuid))],\n        )"
                                    ],
                                    "code": "import abc\nimport uuid\nfrom typing import Any, Optional\n\nfrom pydantic import UUID4, BaseModel, NonNegativeInt, constr, root_validator\n\nfrom .label_types import LabelTypes\nfrom examples.models import Example\nfrom label_types.models import CategoryType, LabelType, RelationType, SpanType\nfrom labels.models import Category as CategoryModel\nfrom labels.models import Label as LabelModel\nfrom labels.models import Relation as RelationModel\nfrom labels.models import Span as SpanModel\nfrom labels.models import TextLabel as TextLabelModel\nfrom projects.models import Project\n\n\nclass Label(BaseModel, abc.ABC):\n    id: int = -1\n    uuid: UUID4\n    example_uuid: UUID4\n\n    def __init__(self, **data):\n        data[\"uuid\"] = uuid.uuid4()\n        super().__init__(**data)\n\n    @abc.abstractmethod\n    def __lt__(self, other):\n        return NotImplemented\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def create(self, user, example: Example, types: LabelTypes, **kwargs) -> LabelModel:\n        raise NotImplementedError\n\n    def __hash__(self):\n        return hash(tuple(self.dict()))\n\n\nclass CategoryLabel(Label):\n    label: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.label < other.label\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, label=obj)  # type: ignore\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return CategoryType(text=self.label, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return CategoryModel(uuid=self.uuid, user=user, example=example, label=types[self.label])\n\n\nclass SpanLabel(Label):\n    label: constr(min_length=1)  # type: ignore\n    start_offset: NonNegativeInt\n    end_offset: NonNegativeInt\n\n    def __lt__(self, other):\n        return self.start_offset < other.start_offset\n\n    @root_validator(skip_on_failure=True)\n    def check_start_offset_is_less_than_end_offset(cls, values):\n        start_offset, end_offset = values.get(\"start_offset\"), values.get(\"end_offset\")\n        if start_offset >= end_offset:\n            raise ValueError(\"start_offset must be less than end_offset.\")\n        return values\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        if isinstance(obj, list) or isinstance(obj, tuple):\n            columns = [\"start_offset\", \"end_offset\", \"label\"]\n            obj = zip(columns, obj)\n            return cls(example_uuid=example_uuid, **dict(obj))\n        elif isinstance(obj, dict):\n            return cls(example_uuid=example_uuid, **obj)\n        raise ValueError(\"SpanLabel.parse()\")\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return SpanType(text=self.label, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return SpanModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            start_offset=self.start_offset,\n            end_offset=self.end_offset,\n            label=types[self.label],\n        )\n\n\nclass TextLabel(Label):\n    text: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.text < other.text\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, text=obj)  # type: ignore\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return None\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return TextLabelModel(uuid=self.uuid, user=user, example=example, text=self.text)\n\n\nclass RelationLabel(Label):\n    from_id: int\n    to_id: int\n    type: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.from_id < other.from_id\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, **obj)\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return RelationType(text=self.type, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return RelationModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            type=types[self.type],\n            from_id=kwargs[\"id_to_span\"][(self.from_id, str(self.example_uuid))],\n            to_id=kwargs[\"id_to_span\"][(self.to_id, str(self.example_uuid))],\n        )\n",
                                    "summary": "Class `Label`: An abstract model for labels with methods for parsing, creating types, creating labels, and hashing, along with subclasses `CategoryLabel`, `SpanLabel`, `TextLabel`, and `RelationLabel` each with specific functionalities.",
                                    "code_element_summaries": [
                                        "Class `Label`: A base abstract model representing labels with methods for parsing, creating types, creating labels, and hashing.",
                                        "Function `__init__`: Initializes the object by generating a UUID and calling the superclass's constructor with provided data.",
                                        "Function `__lt__`: A comparison method that returns NotImplemented.",
                                        "Function `parse`: A method that raises NotImplementedError and is intended to be implemented by subclasses for parsing data.",
                                        "Function `create_type`: A method that creates a new label type for a specified project, returning the created LabelType object or None if not implemented.",
                                        "Function `create`: A method that creates a label model based on user, example, label types, and additional arguments, but raises a NotImplementedError.",
                                        "Function `__hash__`: Returns the hash value of the object by converting it to a tuple and hashing the tuple.",
                                        "Class `CategoryLabel`: Represents category labels with methods for parsing, comparison, and creating label types.",
                                        "Function `__lt__`: Defines the less than comparison method based on the label attribute of the class instances.",
                                        "Function `parse`: A method that creates an instance of the class with the given example UUID and object.",
                                        "Function `create_type`: A function that creates a LabelType object with a specified text and project, returning it as an optional value.",
                                        "Function `create`: Creates a new CategoryModel instance with specified user, example, label type, and additional keyword arguments.",
                                        "Class `SpanLabel`: Represents a span annotation with start and end offsets, and includes methods for parsing and creating annotations.",
                                        "Function `__lt__`: Compares the start offset of two objects and returns True if the start offset of the current object is less than the start offset of the other object.",
                                        "Function `check_start_offset_is_less_than_end_offset`: A function that checks if the start offset is less than the end offset in a given dictionary of values.",
                                        "Function `parse`: A method for parsing different types of input data into a SpanLabel object with specified attributes.",
                                        "Function `create_type`: Creates a LabelType object with a specified project and text value.",
                                        "Function `create`: A method that creates a SpanModel instance with specified parameters such as user, example, label types, and offsets.",
                                        "Class `TextLabel`: Represents a text label with minimum length constraint, comparison method, parsing method, and creation methods.",
                                        "Function `__lt__`: A method that compares instances based on the text attribute.",
                                        "Function `parse`: A method that creates an instance of the class with provided example UUID and text object.",
                                        "Function `create_type`: A method that creates a LabelType object for a given Project, returning None if unsuccessful.",
                                        "Function `create`: Creates a TextLabelModel instance with specified user, example, text, and label types.",
                                        "Class `RelationLabel`: Represents a label with relation information between two entities, including methods for parsing and creating relation models.",
                                        "Function `__lt__`: Defines the less than comparison method for objects based on their `from_id` attribute.",
                                        "Function `parse`: A method that creates an instance of a class with the given example UUID and object attributes.",
                                        "Function `create_type`: Creates a LabelType object with a specified text and project association.",
                                        "Function `create`: Creates a RelationModel instance with specified parameters and returns it."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "labels.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\labels.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Labels`\nCode:\nclass Labels(abc.ABC):\n    label_model = LabelModel\n\n    def __init__(self, labels: List[Label], types: LabelTypes):\n        self.labels = labels\n        self.types = types\n\n    def __len__(self) -> int:\n        return len(self.labels)\n\n    def clean(self, project: Project):\n        pass\n\n    def save_types(self, project: Project):\n        types = [label.create_type(project) for label in self.labels]\n        filtered_types = list(filter(None, types))\n        self.types.save(filtered_types)\n        self.types.update(project)\n\n    def save(self, user, examples: Examples, **kwargs):\n        labels = [\n            label.create(user, examples[label.example_uuid], self.types, **kwargs)\n            for label in self.labels\n            if label.example_uuid in examples\n        ]\n        self.label_model.objects.bulk_create(labels)",
                                        "Function `__init__`\nCode:\n    def __init__(self, labels: List[Label], types: LabelTypes):\n        self.labels = labels\n        self.types = types",
                                        "Function `__len__`\nCode:\n    def __len__(self) -> int:\n        return len(self.labels)",
                                        "Function `clean`\nCode:\n    def clean(self, project: Project):\n        pass",
                                        "Function `save_types`\nCode:\n    def save_types(self, project: Project):\n        types = [label.create_type(project) for label in self.labels]\n        filtered_types = list(filter(None, types))\n        self.types.save(filtered_types)\n        self.types.update(project)",
                                        "Function `save`\nCode:\n    def save(self, user, examples: Examples, **kwargs):\n        labels = [\n            label.create(user, examples[label.example_uuid], self.types, **kwargs)\n            for label in self.labels\n            if label.example_uuid in examples\n        ]\n        self.label_model.objects.bulk_create(labels)",
                                        "Class `Categories`\nCode:\nclass Categories(Labels):\n    label_model = CategoryModel\n\n    def clean(self, project: Project):\n        exclusive = getattr(project, \"single_class_classification\", False)\n        if exclusive:\n            groups = groupby(self.labels, lambda label: label.example_uuid)\n            self.labels = [next(group) for _, group in groups]",
                                        "Function `clean`\nCode:\n    def clean(self, project: Project):\n        exclusive = getattr(project, \"single_class_classification\", False)\n        if exclusive:\n            groups = groupby(self.labels, lambda label: label.example_uuid)\n            self.labels = [next(group) for _, group in groups]",
                                        "Class `Spans`\nCode:\nclass Spans(Labels):\n    label_model = SpanModel\n\n    def clean(self, project: Project):\n        allow_overlapping = getattr(project, \"allow_overlapping\", False)\n        if allow_overlapping:\n            return\n        spans = []\n        groups = groupby(self.labels, lambda label: label.example_uuid)\n        for _, group in groups:\n            labels = sorted(group)\n            last_offset = -1\n            for label in labels:\n                if getattr(label, \"start_offset\") >= last_offset:\n                    last_offset = getattr(label, \"end_offset\")\n                    spans.append(label)\n        self.labels = spans\n\n    @property\n    def id_to_span(self) -> Dict[Tuple[int, str], SpanModel]:\n        uuids = [str(span.uuid) for span in self.labels]\n        spans = SpanModel.objects.filter(uuid__in=uuids)\n        uuid_to_span = {span.uuid: span for span in spans}\n        return {(span.id, str(span.example_uuid)): uuid_to_span[span.uuid] for span in self.labels}",
                                        "Function `clean`\nCode:\n    def clean(self, project: Project):\n        allow_overlapping = getattr(project, \"allow_overlapping\", False)\n        if allow_overlapping:\n            return\n        spans = []\n        groups = groupby(self.labels, lambda label: label.example_uuid)\n        for _, group in groups:\n            labels = sorted(group)\n            last_offset = -1\n            for label in labels:\n                if getattr(label, \"start_offset\") >= last_offset:\n                    last_offset = getattr(label, \"end_offset\")\n                    spans.append(label)\n        self.labels = spans",
                                        "Function `id_to_span`\nCode:\n    def id_to_span(self) -> Dict[Tuple[int, str], SpanModel]:\n        uuids = [str(span.uuid) for span in self.labels]\n        spans = SpanModel.objects.filter(uuid__in=uuids)\n        uuid_to_span = {span.uuid: span for span in spans}\n        return {(span.id, str(span.example_uuid)): uuid_to_span[span.uuid] for span in self.labels}",
                                        "Class `Texts`\nCode:\nclass Texts(Labels):\n    label_model = TextLabelModel",
                                        "Class `Relations`\nCode:\nclass Relations(Labels):\n    label_model = RelationModel\n\n    def save(self, user, examples: Examples, **kwargs):\n        id_to_span = kwargs[\"spans\"].id_to_span\n        super().save(user, examples, id_to_span=id_to_span)",
                                        "Function `save`\nCode:\n    def save(self, user, examples: Examples, **kwargs):\n        id_to_span = kwargs[\"spans\"].id_to_span\n        super().save(user, examples, id_to_span=id_to_span)"
                                    ],
                                    "code": "import abc\nfrom itertools import groupby\nfrom typing import Dict, List, Tuple\n\nfrom .examples import Examples\nfrom .label import Label\nfrom .label_types import LabelTypes\nfrom labels.models import Category as CategoryModel\nfrom labels.models import Label as LabelModel\nfrom labels.models import Relation as RelationModel\nfrom labels.models import Span as SpanModel\nfrom labels.models import TextLabel as TextLabelModel\nfrom projects.models import Project\n\n\nclass Labels(abc.ABC):\n    label_model = LabelModel\n\n    def __init__(self, labels: List[Label], types: LabelTypes):\n        self.labels = labels\n        self.types = types\n\n    def __len__(self) -> int:\n        return len(self.labels)\n\n    def clean(self, project: Project):\n        pass\n\n    def save_types(self, project: Project):\n        types = [label.create_type(project) for label in self.labels]\n        filtered_types = list(filter(None, types))\n        self.types.save(filtered_types)\n        self.types.update(project)\n\n    def save(self, user, examples: Examples, **kwargs):\n        labels = [\n            label.create(user, examples[label.example_uuid], self.types, **kwargs)\n            for label in self.labels\n            if label.example_uuid in examples\n        ]\n        self.label_model.objects.bulk_create(labels)\n\n\nclass Categories(Labels):\n    label_model = CategoryModel\n\n    def clean(self, project: Project):\n        exclusive = getattr(project, \"single_class_classification\", False)\n        if exclusive:\n            groups = groupby(self.labels, lambda label: label.example_uuid)\n            self.labels = [next(group) for _, group in groups]\n\n\nclass Spans(Labels):\n    label_model = SpanModel\n\n    def clean(self, project: Project):\n        allow_overlapping = getattr(project, \"allow_overlapping\", False)\n        if allow_overlapping:\n            return\n        spans = []\n        groups = groupby(self.labels, lambda label: label.example_uuid)\n        for _, group in groups:\n            labels = sorted(group)\n            last_offset = -1\n            for label in labels:\n                if getattr(label, \"start_offset\") >= last_offset:\n                    last_offset = getattr(label, \"end_offset\")\n                    spans.append(label)\n        self.labels = spans\n\n    @property\n    def id_to_span(self) -> Dict[Tuple[int, str], SpanModel]:\n        uuids = [str(span.uuid) for span in self.labels]\n        spans = SpanModel.objects.filter(uuid__in=uuids)\n        uuid_to_span = {span.uuid: span for span in spans}\n        return {(span.id, str(span.example_uuid)): uuid_to_span[span.uuid] for span in self.labels}\n\n\nclass Texts(Labels):\n    label_model = TextLabelModel\n\n\nclass Relations(Labels):\n    label_model = RelationModel\n\n    def save(self, user, examples: Examples, **kwargs):\n        id_to_span = kwargs[\"spans\"].id_to_span\n        super().save(user, examples, id_to_span=id_to_span)\n",
                                    "summary": "Class `Labels`: Represents a collection of labels with methods for cleaning, saving types, and saving labels in bulk, while Class `Categories` focuses on single class classification and Class `Spans` handles overlapping spans and provides a mapping of span IDs to SpanModel objects.",
                                    "code_element_summaries": [
                                        "Class `Labels`: Represents a collection of labels with methods for cleaning, saving types, and saving labels in bulk.",
                                        "Function `__init__`: Initializes an object with a list of labels and a set of label types.",
                                        "Function `__len__`: Returns the length of the labels attribute within the class.",
                                        "Function `clean`: A method that takes a Project object as a parameter for cleaning purposes.",
                                        "Function `save_types`: Saves types created from labels associated with the project, filters out None types, and updates the types in the project.",
                                        "Function `save`: Saves labels created by a user for a specific example in bulk.",
                                        "Class Categories: Represents a collection of labels with a specific label model and cleans the labels based on project settings for single class classification.",
                                        "Function `clean`: A method that cleans the labels of a project by removing duplicate labels based on a specific condition.",
                                        "Class Spans: A model that represents spans of labels, cleans overlapping spans and provides a mapping of span IDs to SpanModel objects.",
                                        "Function `clean`: A method that sorts and filters labels based on their start and end offsets, with the option to allow overlapping labels based on project settings.",
                                        "Function `id_to_span`: Maps IDs and example UUIDs to corresponding SpanModel objects based on UUIDs extracted from labels.",
                                        "Class Texts: A model that represents text annotations with a specific label model.",
                                        "Class Relations: A class that extends Labels and uses RelationModel to save relation annotations with user, examples, and spans information.",
                                        "Function `save`: Saves user annotations for examples using the provided spans dictionary."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "label_types.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\label_types.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `LabelTypes`\nCode:\nclass LabelTypes:\n    def __init__(self, label_type_class: Type[LabelType]):\n        self.types: Dict[str, LabelType] = {}\n        self.label_type_class = label_type_class\n\n    def __contains__(self, text: str) -> bool:\n        return text in self.types\n\n    def __getitem__(self, text: str) -> LabelType:\n        return self.types[text]\n\n    def save(self, label_types: List[LabelType]):\n        self.label_type_class.objects.bulk_create(label_types, ignore_conflicts=True)\n\n    def update(self, project: Project):\n        types = self.label_type_class.objects.filter(project=project)\n        self.types = {label_type.text: label_type for label_type in types}",
                                        "Function `__init__`\nCode:\n    def __init__(self, label_type_class: Type[LabelType]):\n        self.types: Dict[str, LabelType] = {}\n        self.label_type_class = label_type_class",
                                        "Function `__contains__`\nCode:\n    def __contains__(self, text: str) -> bool:\n        return text in self.types",
                                        "Function `__getitem__`\nCode:\n    def __getitem__(self, text: str) -> LabelType:\n        return self.types[text]",
                                        "Function `save`\nCode:\n    def save(self, label_types: List[LabelType]):\n        self.label_type_class.objects.bulk_create(label_types, ignore_conflicts=True)",
                                        "Function `update`\nCode:\n    def update(self, project: Project):\n        types = self.label_type_class.objects.filter(project=project)\n        self.types = {label_type.text: label_type for label_type in types}"
                                    ],
                                    "code": "from typing import Dict, List, Type\n\nfrom label_types.models import LabelType\nfrom projects.models import Project\n\n\nclass LabelTypes:\n    def __init__(self, label_type_class: Type[LabelType]):\n        self.types: Dict[str, LabelType] = {}\n        self.label_type_class = label_type_class\n\n    def __contains__(self, text: str) -> bool:\n        return text in self.types\n\n    def __getitem__(self, text: str) -> LabelType:\n        return self.types[text]\n\n    def save(self, label_types: List[LabelType]):\n        self.label_type_class.objects.bulk_create(label_types, ignore_conflicts=True)\n\n    def update(self, project: Project):\n        types = self.label_type_class.objects.filter(project=project)\n        self.types = {label_type.text: label_type for label_type in types}\n",
                                    "summary": "Class `LabelTypes`: Manages and stores label types with methods for retrieval, saving, and updating label types in a project.",
                                    "code_element_summaries": [
                                        "Class `LabelTypes`: Manages and stores label types with methods for retrieval, saving, and updating label types in a project.",
                                        "Function `__init__`: Initializes a dictionary of LabelType objects with a specified label type class.",
                                        "Function `__contains__`: Checks if a given text is contained in the types attribute of the class.",
                                        "Function `__getitem__`: Returns the LabelType associated with the given text key.",
                                        "Function `save`: Saves a list of label types in bulk to the database while ignoring conflicts.",
                                        "Function `update`: Updates the types of labels associated with a project by querying the label_type_class."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "makers.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\makers.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ExampleMaker`\nCode:\nclass ExampleMaker:\n    def __init__(\n        self,\n        project: Project,\n        data_class: Type[BaseData],\n        column_data: str = DEFAULT_TEXT_COLUMN,\n        exclude_columns: Optional[List[str]] = None,\n    ):\n        self.project = project\n        self.data_class = data_class\n        self.column_data = column_data\n        self.exclude_columns = exclude_columns or []\n        self._errors: List[FileParseException] = []\n\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        if not self.check_column_existence(df):\n            return []\n        self.check_value_existence(df)\n        # make dataframe without exclude columns and missing data\n        df_with_data_column = df.loc[:, ~df.columns.isin(self.exclude_columns)]\n        df_with_data_column = df_with_data_column.dropna(subset=[self.column_data])\n\n        examples = []\n        for row in df_with_data_column.to_dict(orient=\"records\"):\n            line_num = row.pop(LINE_NUMBER_COLUMN, 0)\n            row[DEFAULT_TEXT_COLUMN] = row.pop(self.column_data)  # Rename column for parsing\n            try:\n                data = self.data_class.parse(**row)\n                example = data.create(self.project)\n                examples.append(example)\n            except ValueError:\n                message = f\"Invalid data in line {line_num}\"\n                error = FileParseException(row[UPLOAD_NAME_COLUMN], line_num, message)\n                self._errors.append(error)\n        return examples\n\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column_data} not found in the file\"\n        if self.column_data not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True\n\n    def check_value_existence(self, df: pd.DataFrame):\n        df_without_data_column = df[df[self.column_data].isnull()]\n        for row in df_without_data_column.to_dict(orient=\"records\"):\n            message = f\"Column {self.column_data} not found in record\"\n            error = FileParseException(row[UPLOAD_NAME_COLUMN], row.get(LINE_NUMBER_COLUMN, 0), message)\n            self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors",
                                        "Function `__init__`\nCode:\n    def __init__(\n        self,\n        project: Project,\n        data_class: Type[BaseData],\n        column_data: str = DEFAULT_TEXT_COLUMN,\n        exclude_columns: Optional[List[str]] = None,\n    ):\n        self.project = project\n        self.data_class = data_class\n        self.column_data = column_data\n        self.exclude_columns = exclude_columns or []\n        self._errors: List[FileParseException] = []",
                                        "Function `make`\nCode:\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        if not self.check_column_existence(df):\n            return []\n        self.check_value_existence(df)\n        # make dataframe without exclude columns and missing data\n        df_with_data_column = df.loc[:, ~df.columns.isin(self.exclude_columns)]\n        df_with_data_column = df_with_data_column.dropna(subset=[self.column_data])\n\n        examples = []\n        for row in df_with_data_column.to_dict(orient=\"records\"):\n            line_num = row.pop(LINE_NUMBER_COLUMN, 0)\n            row[DEFAULT_TEXT_COLUMN] = row.pop(self.column_data)  # Rename column for parsing\n            try:\n                data = self.data_class.parse(**row)\n                example = data.create(self.project)\n                examples.append(example)\n            except ValueError:\n                message = f\"Invalid data in line {line_num}\"\n                error = FileParseException(row[UPLOAD_NAME_COLUMN], line_num, message)\n                self._errors.append(error)\n        return examples",
                                        "Function `check_column_existence`\nCode:\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column_data} not found in the file\"\n        if self.column_data not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True",
                                        "Function `check_value_existence`\nCode:\n    def check_value_existence(self, df: pd.DataFrame):\n        df_without_data_column = df[df[self.column_data].isnull()]\n        for row in df_without_data_column.to_dict(orient=\"records\"):\n            message = f\"Column {self.column_data} not found in record\"\n            error = FileParseException(row[UPLOAD_NAME_COLUMN], row.get(LINE_NUMBER_COLUMN, 0), message)\n            self._errors.append(error)",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors",
                                        "Class `BinaryExampleMaker`\nCode:\nclass BinaryExampleMaker(ExampleMaker):\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        examples = []\n        for row in df.to_dict(orient=\"records\"):\n            data = self.data_class.parse(**row)\n            example = data.create(self.project)\n            examples.append(example)\n        return examples",
                                        "Function `make`\nCode:\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        examples = []\n        for row in df.to_dict(orient=\"records\"):\n            data = self.data_class.parse(**row)\n            example = data.create(self.project)\n            examples.append(example)\n        return examples",
                                        "Class `LabelMaker`\nCode:\nclass LabelMaker:\n    def __init__(self, column: str, label_class: Type[Label]):\n        self.column = column\n        self.label_class = label_class\n        self._errors: List[FileParseException] = []\n\n    def make(self, df: pd.DataFrame) -> List[Label]:\n        if not self.check_column_existence(df):\n            return []\n\n        df_label = df.explode(self.column)\n        df_label = df_label[[UUID_COLUMN, self.column]]\n        df_label.dropna(subset=[self.column], inplace=True)\n        labels = []\n        for row in df_label.to_dict(orient=\"records\"):\n            try:\n                label = self.label_class.parse(row[UUID_COLUMN], row[self.column])\n                labels.append(label)\n            except ValueError:\n                pass\n        return labels\n\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column} not found in the file\"\n        if self.column not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors",
                                        "Function `__init__`\nCode:\n    def __init__(self, column: str, label_class: Type[Label]):\n        self.column = column\n        self.label_class = label_class\n        self._errors: List[FileParseException] = []",
                                        "Function `make`\nCode:\n    def make(self, df: pd.DataFrame) -> List[Label]:\n        if not self.check_column_existence(df):\n            return []\n\n        df_label = df.explode(self.column)\n        df_label = df_label[[UUID_COLUMN, self.column]]\n        df_label.dropna(subset=[self.column], inplace=True)\n        labels = []\n        for row in df_label.to_dict(orient=\"records\"):\n            try:\n                label = self.label_class.parse(row[UUID_COLUMN], row[self.column])\n                labels.append(label)\n            except ValueError:\n                pass\n        return labels",
                                        "Function `check_column_existence`\nCode:\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column} not found in the file\"\n        if self.column not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors"
                                    ],
                                    "code": "from typing import List, Optional, Type\n\nimport pandas as pd\n\nfrom .data import BaseData\nfrom .exceptions import FileParseException\nfrom .label import Label\nfrom .readers import (\n    DEFAULT_TEXT_COLUMN,\n    LINE_NUMBER_COLUMN,\n    UPLOAD_NAME_COLUMN,\n    UUID_COLUMN,\n)\nfrom examples.models import Example\nfrom projects.models import Project\n\n\nclass ExampleMaker:\n    def __init__(\n        self,\n        project: Project,\n        data_class: Type[BaseData],\n        column_data: str = DEFAULT_TEXT_COLUMN,\n        exclude_columns: Optional[List[str]] = None,\n    ):\n        self.project = project\n        self.data_class = data_class\n        self.column_data = column_data\n        self.exclude_columns = exclude_columns or []\n        self._errors: List[FileParseException] = []\n\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        if not self.check_column_existence(df):\n            return []\n        self.check_value_existence(df)\n        # make dataframe without exclude columns and missing data\n        df_with_data_column = df.loc[:, ~df.columns.isin(self.exclude_columns)]\n        df_with_data_column = df_with_data_column.dropna(subset=[self.column_data])\n\n        examples = []\n        for row in df_with_data_column.to_dict(orient=\"records\"):\n            line_num = row.pop(LINE_NUMBER_COLUMN, 0)\n            row[DEFAULT_TEXT_COLUMN] = row.pop(self.column_data)  # Rename column for parsing\n            try:\n                data = self.data_class.parse(**row)\n                example = data.create(self.project)\n                examples.append(example)\n            except ValueError:\n                message = f\"Invalid data in line {line_num}\"\n                error = FileParseException(row[UPLOAD_NAME_COLUMN], line_num, message)\n                self._errors.append(error)\n        return examples\n\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column_data} not found in the file\"\n        if self.column_data not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True\n\n    def check_value_existence(self, df: pd.DataFrame):\n        df_without_data_column = df[df[self.column_data].isnull()]\n        for row in df_without_data_column.to_dict(orient=\"records\"):\n            message = f\"Column {self.column_data} not found in record\"\n            error = FileParseException(row[UPLOAD_NAME_COLUMN], row.get(LINE_NUMBER_COLUMN, 0), message)\n            self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors\n\n\nclass BinaryExampleMaker(ExampleMaker):\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        examples = []\n        for row in df.to_dict(orient=\"records\"):\n            data = self.data_class.parse(**row)\n            example = data.create(self.project)\n            examples.append(example)\n        return examples\n\n\nclass LabelMaker:\n    def __init__(self, column: str, label_class: Type[Label]):\n        self.column = column\n        self.label_class = label_class\n        self._errors: List[FileParseException] = []\n\n    def make(self, df: pd.DataFrame) -> List[Label]:\n        if not self.check_column_existence(df):\n            return []\n\n        df_label = df.explode(self.column)\n        df_label = df_label[[UUID_COLUMN, self.column]]\n        df_label.dropna(subset=[self.column], inplace=True)\n        labels = []\n        for row in df_label.to_dict(orient=\"records\"):\n            try:\n                label = self.label_class.parse(row[UUID_COLUMN], row[self.column])\n                labels.append(label)\n            except ValueError:\n                pass\n        return labels\n\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column} not found in the file\"\n        if self.column not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors\n",
                                    "summary": "Class `ExampleMaker`: Generates examples from a DataFrame with error handling and missing value management, while `BinaryExampleMaker` specializes in creating binary examples, and `LabelMaker` generates labels from DataFrame columns with error handling.",
                                    "code_element_summaries": [
                                        "Class `ExampleMaker`: A class that generates examples from a DataFrame based on specified project, data class, and column data, handling errors and missing values.",
                                        "Function `__init__`: Initializes an instance with project, data class, column data, and optional excluded columns.",
                                        "Function `make`: A method that generates a list of Example objects from a DataFrame after performing data validation and parsing.",
                                        "Function `check_column_existence`: Checks if a specified column exists in a pandas DataFrame and returns a boolean value indicating its presence.",
                                        "Function `check_value_existence`: A function that checks for the existence of a specific column in a pandas DataFrame and appends errors if the column is not found in the record.",
                                        "Function `errors`: Returns a sorted list of FileParseException objects representing errors encountered during file parsing.",
                                        "Class BinaryExampleMaker: A subclass of ExampleMaker that generates binary examples from a pandas DataFrame.",
                                        "Function `make`: Creates a list of Example objects by parsing DataFrame rows and creating instances based on project data.",
                                        "Class `LabelMaker`: A class that generates labels based on a specified column in a pandas DataFrame, handling errors and returning a list of labels.",
                                        "Function `__init__`: Initializes the column and label class for file parsing with a list of errors.",
                                        "Function `make`: A method that creates Label objects from a DataFrame by parsing UUID and label values.",
                                        "Function `check_column_existence`: Checks if a specific column exists in a pandas DataFrame and returns a boolean value based on the result.",
                                        "Function `errors`: Returns a sorted list of FileParseException objects representing errors encountered during file parsing."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "parsers.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\parsers.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `detect_encoding`: Detects character encoding automatically.\nCode:\ndef detect_encoding(filename: str, buffer_size: int = io.DEFAULT_BUFFER_SIZE) -> str:\n    \"\"\"Detects character encoding automatically.\n\n    If you want to know the supported encodings, please see the following document:\n    https://chardet.readthedocs.io/en/latest/supported-encodings.html\n\n    Args:\n        filename: the filename for detecting the encoding.\n        buffer_size: the buffer size to read file contents incrementally.\n\n    Returns:\n        The character encoding.\n    \"\"\"\n    # For a small file.\n    if os.path.getsize(filename) < buffer_size:\n        detected = chardet.detect(open(filename, \"rb\").read())\n        return detected.get(\"encoding\", \"utf-8\")\n\n    # For a large file, call the Universal Encoding Detector incrementally.\n    # It will stop as soon as it is confident enough to report its results.\n    # See: https://chardet.readthedocs.io/en/latest/usage.html\n    with open(filename, \"rb\") as f:\n        detector = UniversalDetector()\n        while True:\n            binary = f.read(buffer_size)\n            detector.feed(binary)\n            if binary == b\"\":\n                break\n            if detector.done:\n                break\n        if detector.done:\n            return detector.result[\"encoding\"] or \"utf-8\"\n        else:\n            return \"utf-8\"",
                                        "Function `decide_encoding`: Decide character encoding automatically.\nCode:\ndef decide_encoding(filename: str, encoding: str) -> str:\n    \"\"\"Decide character encoding automatically.\n\n    If the encoding is DEFAULT_ENCODING, detects it automatically.\n    Otherwise, return it as is.\n\n    Args:\n         filename: The filename for decide the encoding.\n         encoding: The specified encoding.\n\n    Returns:\n        The character encoding.\n    \"\"\"\n    if encoding == DEFAULT_ENCODING:\n        return detect_encoding(filename)\n    else:\n        return encoding",
                                        "Class `LineReader`: LineReader is a helper class to read a file line by line.\nCode:\nclass LineReader:\n    \"\"\"LineReader is a helper class to read a file line by line.\n\n    Attributes:\n        filename: The filename to read.\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, filename: str, encoding: str = DEFAULT_ENCODING):\n        self.filename = filename\n        self.encoding = encoding\n\n    def __iter__(self) -> Iterator[str]:\n        encoding = decide_encoding(self.filename, self.encoding)\n        with open(self.filename, encoding=encoding) as f:\n            for line in f:\n                yield line.rstrip()",
                                        "Function `__init__`\nCode:\n    def __init__(self, filename: str, encoding: str = DEFAULT_ENCODING):\n        self.filename = filename\n        self.encoding = encoding",
                                        "Function `__iter__`\nCode:\n    def __iter__(self) -> Iterator[str]:\n        encoding = decide_encoding(self.filename, self.encoding)\n        with open(self.filename, encoding=encoding) as f:\n            for line in f:\n                yield line.rstrip()",
                                        "Class `PlainParser`: PlainParser is a parser simply returns a dictionary.\nCode:\nclass PlainParser(Parser):\n    \"\"\"PlainParser is a parser simply returns a dictionary.\n\n    This is for a task without any text.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.kwargs = kwargs\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        yield {}",
                                        "Function `__init__`\nCode:\n    def __init__(self, **kwargs):\n        self.kwargs = kwargs",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        yield {}",
                                        "Class `LineParser`: LineParser is a parser to read a file line by line.\nCode:\nclass LineParser(Parser):\n    \"\"\"LineParser is a parser to read a file line by line.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            yield {DEFAULT_TEXT_COLUMN: line, LINE_NUMBER_COLUMN: line_num}",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            yield {DEFAULT_TEXT_COLUMN: line, LINE_NUMBER_COLUMN: line_num}",
                                        "Class `TextFileParser`: TextFileParser is a parser to read an entire file content.\nCode:\nclass TextFileParser(Parser):\n    \"\"\"TextFileParser is a parser to read an entire file content.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            yield {DEFAULT_TEXT_COLUMN: f.read()}",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            yield {DEFAULT_TEXT_COLUMN: f.read()}",
                                        "Class `CSVParser`: CSVParser is a parser to read a csv file and return its rows.\nCode:\nclass CSVParser(Parser):\n    \"\"\"CSVParser is a parser to read a csv file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n        delimiter: A one-character string used to separate fields. It defaults to ','.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \",\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            reader = csv.DictReader(f, delimiter=self.delimiter)\n            for line_num, row in enumerate(reader, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \",\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            reader = csv.DictReader(f, delimiter=self.delimiter)\n            for line_num, row in enumerate(reader, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}",
                                        "Class `JSONParser`: JSONParser is a parser to read a json file and return its rows.\nCode:\nclass JSONParser(Parser):\n    \"\"\"JSONParser is a parser to read a json file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            try:\n                rows = json.load(f)\n                for row in rows:\n                    yield row\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num=1, message=str(e))\n                self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            try:\n                rows = json.load(f)\n                for row in rows:\n                    yield row\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num=1, message=str(e))\n                self._errors.append(error)",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Class `JSONLParser`: JSONLParser is a parser to read a JSONL file and return its rows.\nCode:\nclass JSONLParser(Parser):\n    \"\"\"JSONLParser is a parser to read a JSONL file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            try:\n                row = json.loads(line)\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num, str(e))\n                self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            try:\n                row = json.loads(line)\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num, str(e))\n                self._errors.append(error)",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Class `ExcelParser`: ExcelParser is a parser to read a excel file.\nCode:\nclass ExcelParser(Parser):\n    \"\"\"ExcelParser is a parser to read a excel file.\"\"\"\n\n    def __init__(self, **kwargs):\n        self._errors = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        rows = pyexcel.iget_records(file_name=filename)\n        try:\n            for line_num, row in enumerate(rows, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n        except pyexcel.exceptions.FileTypeNotSupported as e:\n            error = FileParseException(filename, line_num=1, message=str(e))\n            self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Function `__init__`\nCode:\n    def __init__(self, **kwargs):\n        self._errors = []",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        rows = pyexcel.iget_records(file_name=filename)\n        try:\n            for line_num, row in enumerate(rows, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n        except pyexcel.exceptions.FileTypeNotSupported as e:\n            error = FileParseException(filename, line_num=1, message=str(e))\n            self._errors.append(error)",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Class `FastTextParser`: FastTextParser is a parser to read a fastText format and returns a text and labels.\nCode:\nclass FastTextParser(Parser):\n    \"\"\"FastTextParser is a parser to read a fastText format and returns a text and labels.\n\n    The example format is as follows:\n        __label__positive I really enjoyed this restaurant.\n    This format expects the category first, with the prefix ‘__label__’ before each category,\n    and then the input text, like so,\n\n    Attributes:\n        encoding: The character encoding.\n        label: The label prefix. It defaults to `__label__`.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, label: str = \"__label__\", **kwargs):\n        self.encoding = encoding\n        self.label = label\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            labels = []\n            tokens = []\n            for token in line.rstrip().split(\" \"):\n                if token.startswith(self.label):\n                    label_name = token[len(self.label) :]\n                    labels.append(label_name)\n                else:\n                    tokens.append(token)\n            text = \" \".join(tokens)\n            yield {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels, LINE_NUMBER_COLUMN: line_num}",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, label: str = \"__label__\", **kwargs):\n        self.encoding = encoding\n        self.label = label",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            labels = []\n            tokens = []\n            for token in line.rstrip().split(\" \"):\n                if token.startswith(self.label):\n                    label_name = token[len(self.label) :]\n                    labels.append(label_name)\n                else:\n                    tokens.append(token)\n            text = \" \".join(tokens)\n            yield {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels, LINE_NUMBER_COLUMN: line_num}",
                                        "Class `CoNLLParser`: CoNLLParser is a parser to read conll like format and returns a text and labels.\nCode:\nclass CoNLLParser(Parser):\n    \"\"\"CoNLLParser is a parser to read conll like format and returns a text and labels.\n\n    The example format is as follows:\n        EU  B-ORG\n        rejects O\n        German  B-MISC\n        call  O\n        to  O\n        boycott O\n        British B-MISC\n        lamb  O\n        . O\n\n        Peter B-PER\n        Blackburn I-PER\n    This format expects a token in the first column, and a tag in the second column.\n    The each data is separated by a new line.\n\n    Attributes:\n        encoding: The character encoding.\n        delimiter: A one-character string used to separate fields. It defaults to ' '.\n        scheme: The tagging scheme. It supports `IOB2`, `IOE2`, `IOBES`, and `BILOU`.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \" \", scheme: str = \"IOB2\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter\n        mapping = {\"IOB2\": IOB2, \"IOE2\": IOE2, \"IOBES\": IOBES, \"BILOU\": BILOU}\n        self._errors: List[FileParseException] = []\n        if scheme in mapping:\n            self.scheme = mapping[scheme]\n        else:\n            self.scheme = None\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        if not self.scheme:\n            message = \"The specified scheme is not supported.\"\n            error = FileParseException(filename, line_num=1, message=message)\n            self._errors.append(error)\n            return\n\n        reader = LineReader(filename, self.encoding)\n        words, tags = [], []\n        for line_num, line in enumerate(reader, start=1):\n            line = line.rstrip()\n            if line:\n                tokens = line.split(\"\\t\")\n                if len(tokens) != 2:\n                    message = \"A line must be separated by tab and has two columns.\"\n                    self._errors.append(FileParseException(filename, line_num, message))\n                    return\n                word, tag = tokens\n                words.append(word)\n                tags.append(tag)\n            else:\n                yield self.create_record(tags, words)\n                words, tags = [], []\n        if words:\n            yield self.create_record(tags, words)\n\n    def create_record(self, tags, words):\n        text = self.delimiter.join(words)\n        labels = self.align_span(words, tags)\n        return {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels}\n\n    def align_span(self, words: List[str], tags: List[str]) -> List[Tuple[int, int, str]]:\n        tokens = Tokens(tags, self.scheme)\n        labels = []\n        for entity in tokens.entities:\n            text = self.delimiter.join(words[: entity.start])\n            start = len(text) + len(self.delimiter) if text else len(text)\n            chunk = words[entity.start : entity.end]\n            text = self.delimiter.join(chunk)\n            end = start + len(text)\n            labels.append((start, end, entity.tag))\n        return labels",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \" \", scheme: str = \"IOB2\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter\n        mapping = {\"IOB2\": IOB2, \"IOE2\": IOE2, \"IOBES\": IOBES, \"BILOU\": BILOU}\n        self._errors: List[FileParseException] = []\n        if scheme in mapping:\n            self.scheme = mapping[scheme]\n        else:\n            self.scheme = None",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        if not self.scheme:\n            message = \"The specified scheme is not supported.\"\n            error = FileParseException(filename, line_num=1, message=message)\n            self._errors.append(error)\n            return\n\n        reader = LineReader(filename, self.encoding)\n        words, tags = [], []\n        for line_num, line in enumerate(reader, start=1):\n            line = line.rstrip()\n            if line:\n                tokens = line.split(\"\\t\")\n                if len(tokens) != 2:\n                    message = \"A line must be separated by tab and has two columns.\"\n                    self._errors.append(FileParseException(filename, line_num, message))\n                    return\n                word, tag = tokens\n                words.append(word)\n                tags.append(tag)\n            else:\n                yield self.create_record(tags, words)\n                words, tags = [], []\n        if words:\n            yield self.create_record(tags, words)",
                                        "Function `create_record`\nCode:\n    def create_record(self, tags, words):\n        text = self.delimiter.join(words)\n        labels = self.align_span(words, tags)\n        return {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels}",
                                        "Function `align_span`\nCode:\n    def align_span(self, words: List[str], tags: List[str]) -> List[Tuple[int, int, str]]:\n        tokens = Tokens(tags, self.scheme)\n        labels = []\n        for entity in tokens.entities:\n            text = self.delimiter.join(words[: entity.start])\n            start = len(text) + len(self.delimiter) if text else len(text)\n            chunk = words[entity.start : entity.end]\n            text = self.delimiter.join(chunk)\n            end = start + len(text)\n            labels.append((start, end, entity.tag))\n        return labels"
                                    ],
                                    "code": "import csv\nimport io\nimport json\nimport os\nfrom typing import Any, Dict, Iterator, List, Tuple\n\nimport chardet\nimport pyexcel\nimport pyexcel.exceptions\nfrom chardet import UniversalDetector\nfrom seqeval.scheme import BILOU, IOB2, IOBES, IOE2, Tokens\n\nfrom .exceptions import FileParseException\nfrom .readers import (\n    DEFAULT_LABEL_COLUMN,\n    DEFAULT_TEXT_COLUMN,\n    LINE_NUMBER_COLUMN,\n    Parser,\n)\n\nDEFAULT_ENCODING = \"Auto\"\n\n\ndef detect_encoding(filename: str, buffer_size: int = io.DEFAULT_BUFFER_SIZE) -> str:\n    \"\"\"Detects character encoding automatically.\n\n    If you want to know the supported encodings, please see the following document:\n    https://chardet.readthedocs.io/en/latest/supported-encodings.html\n\n    Args:\n        filename: the filename for detecting the encoding.\n        buffer_size: the buffer size to read file contents incrementally.\n\n    Returns:\n        The character encoding.\n    \"\"\"\n    # For a small file.\n    if os.path.getsize(filename) < buffer_size:\n        detected = chardet.detect(open(filename, \"rb\").read())\n        return detected.get(\"encoding\", \"utf-8\")\n\n    # For a large file, call the Universal Encoding Detector incrementally.\n    # It will stop as soon as it is confident enough to report its results.\n    # See: https://chardet.readthedocs.io/en/latest/usage.html\n    with open(filename, \"rb\") as f:\n        detector = UniversalDetector()\n        while True:\n            binary = f.read(buffer_size)\n            detector.feed(binary)\n            if binary == b\"\":\n                break\n            if detector.done:\n                break\n        if detector.done:\n            return detector.result[\"encoding\"] or \"utf-8\"\n        else:\n            return \"utf-8\"\n\n\ndef decide_encoding(filename: str, encoding: str) -> str:\n    \"\"\"Decide character encoding automatically.\n\n    If the encoding is DEFAULT_ENCODING, detects it automatically.\n    Otherwise, return it as is.\n\n    Args:\n         filename: The filename for decide the encoding.\n         encoding: The specified encoding.\n\n    Returns:\n        The character encoding.\n    \"\"\"\n    if encoding == DEFAULT_ENCODING:\n        return detect_encoding(filename)\n    else:\n        return encoding\n\n\nclass LineReader:\n    \"\"\"LineReader is a helper class to read a file line by line.\n\n    Attributes:\n        filename: The filename to read.\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, filename: str, encoding: str = DEFAULT_ENCODING):\n        self.filename = filename\n        self.encoding = encoding\n\n    def __iter__(self) -> Iterator[str]:\n        encoding = decide_encoding(self.filename, self.encoding)\n        with open(self.filename, encoding=encoding) as f:\n            for line in f:\n                yield line.rstrip()\n\n\nclass PlainParser(Parser):\n    \"\"\"PlainParser is a parser simply returns a dictionary.\n\n    This is for a task without any text.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.kwargs = kwargs\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        yield {}\n\n\nclass LineParser(Parser):\n    \"\"\"LineParser is a parser to read a file line by line.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            yield {DEFAULT_TEXT_COLUMN: line, LINE_NUMBER_COLUMN: line_num}\n\n\nclass TextFileParser(Parser):\n    \"\"\"TextFileParser is a parser to read an entire file content.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            yield {DEFAULT_TEXT_COLUMN: f.read()}\n\n\nclass CSVParser(Parser):\n    \"\"\"CSVParser is a parser to read a csv file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n        delimiter: A one-character string used to separate fields. It defaults to ','.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \",\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            reader = csv.DictReader(f, delimiter=self.delimiter)\n            for line_num, row in enumerate(reader, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n\n\nclass JSONParser(Parser):\n    \"\"\"JSONParser is a parser to read a json file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            try:\n                rows = json.load(f)\n                for row in rows:\n                    yield row\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num=1, message=str(e))\n                self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors\n\n\nclass JSONLParser(Parser):\n    \"\"\"JSONLParser is a parser to read a JSONL file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            try:\n                row = json.loads(line)\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num, str(e))\n                self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors\n\n\nclass ExcelParser(Parser):\n    \"\"\"ExcelParser is a parser to read a excel file.\"\"\"\n\n    def __init__(self, **kwargs):\n        self._errors = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        rows = pyexcel.iget_records(file_name=filename)\n        try:\n            for line_num, row in enumerate(rows, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n        except pyexcel.exceptions.FileTypeNotSupported as e:\n            error = FileParseException(filename, line_num=1, message=str(e))\n            self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors\n\n\nclass FastTextParser(Parser):\n    \"\"\"FastTextParser is a parser to read a fastText format and returns a text and labels.\n\n    The example format is as follows:\n        __label__positive I really enjoyed this restaurant.\n    This format expects the category first, with the prefix ‘__label__’ before each category,\n    and then the input text, like so,\n\n    Attributes:\n        encoding: The character encoding.\n        label: The label prefix. It defaults to `__label__`.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, label: str = \"__label__\", **kwargs):\n        self.encoding = encoding\n        self.label = label\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            labels = []\n            tokens = []\n            for token in line.rstrip().split(\" \"):\n                if token.startswith(self.label):\n                    label_name = token[len(self.label) :]\n                    labels.append(label_name)\n                else:\n                    tokens.append(token)\n            text = \" \".join(tokens)\n            yield {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels, LINE_NUMBER_COLUMN: line_num}\n\n\nclass CoNLLParser(Parser):\n    \"\"\"CoNLLParser is a parser to read conll like format and returns a text and labels.\n\n    The example format is as follows:\n        EU  B-ORG\n        rejects O\n        German  B-MISC\n        call  O\n        to  O\n        boycott O\n        British B-MISC\n        lamb  O\n        . O\n\n        Peter B-PER\n        Blackburn I-PER\n    This format expects a token in the first column, and a tag in the second column.\n    The each data is separated by a new line.\n\n    Attributes:\n        encoding: The character encoding.\n        delimiter: A one-character string used to separate fields. It defaults to ' '.\n        scheme: The tagging scheme. It supports `IOB2`, `IOE2`, `IOBES`, and `BILOU`.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \" \", scheme: str = \"IOB2\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter\n        mapping = {\"IOB2\": IOB2, \"IOE2\": IOE2, \"IOBES\": IOBES, \"BILOU\": BILOU}\n        self._errors: List[FileParseException] = []\n        if scheme in mapping:\n            self.scheme = mapping[scheme]\n        else:\n            self.scheme = None\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        if not self.scheme:\n            message = \"The specified scheme is not supported.\"\n            error = FileParseException(filename, line_num=1, message=message)\n            self._errors.append(error)\n            return\n\n        reader = LineReader(filename, self.encoding)\n        words, tags = [], []\n        for line_num, line in enumerate(reader, start=1):\n            line = line.rstrip()\n            if line:\n                tokens = line.split(\"\\t\")\n                if len(tokens) != 2:\n                    message = \"A line must be separated by tab and has two columns.\"\n                    self._errors.append(FileParseException(filename, line_num, message))\n                    return\n                word, tag = tokens\n                words.append(word)\n                tags.append(tag)\n            else:\n                yield self.create_record(tags, words)\n                words, tags = [], []\n        if words:\n            yield self.create_record(tags, words)\n\n    def create_record(self, tags, words):\n        text = self.delimiter.join(words)\n        labels = self.align_span(words, tags)\n        return {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels}\n\n    def align_span(self, words: List[str], tags: List[str]) -> List[Tuple[int, int, str]]:\n        tokens = Tokens(tags, self.scheme)\n        labels = []\n        for entity in tokens.entities:\n            text = self.delimiter.join(words[: entity.start])\n            start = len(text) + len(self.delimiter) if text else len(text)\n            chunk = words[entity.start : entity.end]\n            text = self.delimiter.join(chunk)\n            end = start + len(text)\n            labels.append((start, end, entity.tag))\n        return labels\n",
                                    "summary": "A collection of parser classes and functions designed to read and parse various file formats, including CSV, JSON, Excel, CoNLL, and fastText, with error handling and support for different encoding schemes and tagging formats.",
                                    "code_element_summaries": [
                                        "Function `detect_encoding`: Automatically detects character encoding for a given file, utilizing chardet library for small files and Universal Encoding Detector for large files.",
                                        "Function `decide_encoding`: Automatically determines character encoding based on the specified encoding or detects it automatically if DEFAULT_ENCODING is used.",
                                        "Class `LineReader`: A helper class that reads a file line by line with specified filename and encoding.",
                                        "Function `__init__`: Initializes an object with a filename and optional encoding parameter.",
                                        "Function `__iter__`: A generator function that yields lines from a file with specified encoding and removes trailing whitespaces.",
                                        "Class PlainParser: A parser that simply returns a dictionary for tasks without any text.",
                                        "Function `__init__`: Initializes the object with the provided keyword arguments stored in the `kwargs` attribute.",
                                        "Function `parse`: A function that yields an empty dictionary when parsing a specified file.",
                                        "Class `LineParser`: A parser that reads a file line by line and yields each line with line numbers as a dictionary.",
                                        "Function `__init__`: Initializes an object with an optional encoding parameter.",
                                        "Function `parse`: Reads a file line by line and yields a dictionary containing the line content and line number.",
                                        "Class `TextFileParser`: A parser class designed to read the entire content of a file.",
                                        "Function `__init__`: Initializes an object with an optional encoding parameter.",
                                        "Function `parse`: A function that reads a file with a specified encoding and yields the content as a dictionary with a default text column.",
                                        "Class `CSVParser`: CSVParser is a parser that reads a csv file and returns its rows as dictionaries.",
                                        "Function `__init__`: Initializes the encoding and delimiter attributes with default values if not provided.",
                                        "Function `parse`: A method that reads a CSV file, determines the encoding, and yields each row as a dictionary with line numbers included.",
                                        "Class `JSONParser`: A parser that reads a JSON file and returns its rows while handling potential decoding errors.",
                                        "Function `__init__`: Initializes an object with an optional encoding parameter and a list of errors.",
                                        "Function `parse`: A method that reads and parses JSON data from a file, yielding each row as a dictionary while handling JSON decoding errors.",
                                        "Function `errors`: Returns a list of FileParseException objects representing errors encountered during file parsing.",
                                        "Class `JSONLParser`: A parser that reads a JSONL file and returns its rows while handling JSON decoding errors.",
                                        "Function `__init__`: Initializes the encoding and error list for file parsing with optional encoding parameter.",
                                        "Function `parse`: A method that reads a file, parses each line as JSON, and yields a dictionary with line number and parsed data, handling JSON decoding errors.",
                                        "Function `errors`: Returns a list of FileParseException objects.",
                                        "Class ExcelParser: A parser designed to read and parse Excel files, with the ability to handle errors during the parsing process.",
                                        "Function `__init__`: Initializes the object with an empty list of errors.",
                                        "Function `parse`: A method that reads records from a file using pyexcel and yields them as dictionaries with line numbers, handling FileTypeNotSupported exceptions.",
                                        "Function `errors`: Returns a list of FileParseException objects.",
                                        "Class `FastTextParser`: FastTextParser is a parser that reads a fastText format and extracts text and labels from it.",
                                        "Function `__init__`: Initializes an object with specified encoding and label attributes.",
                                        "Function `parse`: Reads a file, extracts labels and tokens from each line, and yields a dictionary with text, labels, and line number.",
                                        "Class `CoNLLParser`: A parser that reads CoNLL-like format and returns text and labels, supporting various tagging schemes like `IOB2`, `IOE2`, `IOBES`, and `BILOU`.",
                                        "Function `__init__`: Initializes the encoding, delimiter, and scheme for a class instance with optional default values.",
                                        "Function `errors`: Returns a list of FileParseException objects.",
                                        "Function `parse`: Parses a file line by line, creating records from word-tag pairs and handling errors.",
                                        "Function `create_record`: A function that creates a record with text and corresponding labels based on input tags and words.",
                                        "Function `align_span`: Aligns words and tags to create a list of tuples representing the start and end indices of entities with their corresponding tags."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "readers.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\readers.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `BaseReader`: Reader has a role to parse files and return a Record iterator.\nCode:\nclass BaseReader(collections.abc.Iterable):\n    \"\"\"Reader has a role to parse files and return a Record iterator.\"\"\"\n\n    @abc.abstractmethod\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Creates an iterator for elements of this dataset.\n\n        Returns:\n            A `dict` for the elements of this dataset.\n        \"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @property\n    @abc.abstractmethod\n    def errors(self):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @abc.abstractmethod\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `__iter__`: Creates an iterator for elements of this dataset.\nCode:\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Creates an iterator for elements of this dataset.\n\n        Returns:\n            A `dict` for the elements of this dataset.\n        \"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `errors`\nCode:\n    def errors(self):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `batch`\nCode:\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Class `Parser`: The abstract file parser.\nCode:\nclass Parser(abc.ABC):\n    \"\"\"The abstract file parser.\"\"\"\n\n    @abc.abstractmethod\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Parses the file and returns the dictionary.\"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        \"\"\"Returns parsing errors.\"\"\"\n        return []",
                                        "Function `parse`: Parses the file and returns the dictionary.\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Parses the file and returns the dictionary.\"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `errors`: Returns parsing errors.\nCode:\n    def errors(self) -> List[FileParseException]:\n        \"\"\"Returns parsing errors.\"\"\"\n        return []",
                                        "Class `FileName`\nCode:\nclass FileName:\n    full_path: str\n    generated_name: str\n    upload_name: str",
                                        "Class `Reader`\nCode:\nclass Reader(BaseReader):\n    def __init__(self, filenames: List[FileName], parser: Parser):\n        self.filenames = filenames\n        self.parser = parser\n\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        for filename in self.filenames:\n            rows = self.parser.parse(filename.full_path)\n            for row in rows:\n                yield {\n                    UUID_COLUMN: uuid.uuid4(),\n                    FILE_NAME_COLUMN: filename.generated_name,\n                    UPLOAD_NAME_COLUMN: filename.upload_name,\n                    **row,\n                }\n\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        batch = []\n        for record in self:\n            batch.append(record)\n            if len(batch) == batch_size:\n                yield pd.DataFrame(batch)\n                batch = []\n        if batch:\n            yield pd.DataFrame(batch)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.parser.errors",
                                        "Function `__init__`\nCode:\n    def __init__(self, filenames: List[FileName], parser: Parser):\n        self.filenames = filenames\n        self.parser = parser",
                                        "Function `__iter__`\nCode:\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        for filename in self.filenames:\n            rows = self.parser.parse(filename.full_path)\n            for row in rows:\n                yield {\n                    UUID_COLUMN: uuid.uuid4(),\n                    FILE_NAME_COLUMN: filename.generated_name,\n                    UPLOAD_NAME_COLUMN: filename.upload_name,\n                    **row,\n                }",
                                        "Function `batch`\nCode:\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        batch = []\n        for record in self:\n            batch.append(record)\n            if len(batch) == batch_size:\n                yield pd.DataFrame(batch)\n                batch = []\n        if batch:\n            yield pd.DataFrame(batch)",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.parser.errors"
                                    ],
                                    "code": "import abc\nimport collections.abc\nimport dataclasses\nimport uuid\nfrom typing import Any, Dict, Iterator, List\n\nimport pandas as pd\n\nfrom .exceptions import FileParseException\n\nDEFAULT_TEXT_COLUMN = \"text\"\nDEFAULT_LABEL_COLUMN = \"label\"\nFILE_NAME_COLUMN = \"filename\"\nUPLOAD_NAME_COLUMN = \"upload_name\"\nUUID_COLUMN = \"example_uuid\"\nLINE_NUMBER_COLUMN = \"#line_number\"\n\n\nclass BaseReader(collections.abc.Iterable):\n    \"\"\"Reader has a role to parse files and return a Record iterator.\"\"\"\n\n    @abc.abstractmethod\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Creates an iterator for elements of this dataset.\n\n        Returns:\n            A `dict` for the elements of this dataset.\n        \"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @property\n    @abc.abstractmethod\n    def errors(self):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @abc.abstractmethod\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n\nclass Parser(abc.ABC):\n    \"\"\"The abstract file parser.\"\"\"\n\n    @abc.abstractmethod\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Parses the file and returns the dictionary.\"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        \"\"\"Returns parsing errors.\"\"\"\n        return []\n\n\n@dataclasses.dataclass\nclass FileName:\n    full_path: str\n    generated_name: str\n    upload_name: str\n\n\nclass Reader(BaseReader):\n    def __init__(self, filenames: List[FileName], parser: Parser):\n        self.filenames = filenames\n        self.parser = parser\n\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        for filename in self.filenames:\n            rows = self.parser.parse(filename.full_path)\n            for row in rows:\n                yield {\n                    UUID_COLUMN: uuid.uuid4(),\n                    FILE_NAME_COLUMN: filename.generated_name,\n                    UPLOAD_NAME_COLUMN: filename.upload_name,\n                    **row,\n                }\n\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        batch = []\n        for record in self:\n            batch.append(record)\n            if len(batch) == batch_size:\n                yield pd.DataFrame(batch)\n                batch = []\n        if batch:\n            yield pd.DataFrame(batch)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.parser.errors\n",
                                    "summary": "Class `BaseReader`: A base class for reading and parsing files, providing methods for iteration, error handling, and batching data into DataFrames.",
                                    "code_element_summaries": [
                                        "Class `BaseReader`: A base class that defines a reader responsible for parsing files and returning a Record iterator.",
                                        "Function `__iter__`: Implements an iterator for elements of a dataset, requiring implementation in subclasses.",
                                        "Function `errors`: A placeholder method that raises a NotImplementedError when called, prompting subclass implementation.",
                                        "Function `batch`: A method that batches data into pandas DataFrames with a specified batch size.",
                                        "Class `Parser`: An abstract file parser with a method to parse files and return dictionaries, along with a property for parsing errors.",
                                        "Function `parse`: A method that parses a file and returns the dictionary data.",
                                        "Function `errors`: Returns a list of parsing errors.",
                                        "Class FileName: Represents file information including full path, generated name, and upload name.",
                                        "Class Reader: A reader class that iterates through filenames, parses them using a specified parser, and yields dictionaries of parsed rows with additional columns.",
                                        "Function `__init__`: Initializes an object with a list of filenames and a parser.",
                                        "Function `__iter__`: Generates dictionaries containing parsed data from files with additional UUID and file name information.",
                                        "Function `batch`: A method that batches records into DataFrames based on a specified batch size.",
                                        "Function `errors`: Returns a list of FileParseException objects from the parser."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a class ExportedBoundingBox that serves as a proxy model of BoundingBox, allowing for representation of bounding box annotations in dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "A collection of test classes and functions that validate various data processing functionalities, including parsing, creating, and testing specific attributes, as well as importing and validating datasets in different formats, ensuring correctness and handling errors appropriately.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_catalog.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_catalog.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestOptions`\nCode:\nclass TestOptions(unittest.TestCase):\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)",
                                        "Function `test_return_at_least_one_option`\nCode:\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)"
                                    ],
                                    "code": "import unittest\n\nfrom data_import.pipeline.catalog import Options\nfrom projects.models import ProjectType\n\n\nclass TestOptions(unittest.TestCase):\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)\n",
                                    "summary": "Class TestOptions: Contains unit tests to ensure that there is at least one option available for each task in a project type, with a specific test function to validate this requirement.",
                                    "code_element_summaries": [
                                        "Class `TestOptions`: Contains unit tests to ensure that there is at least one option available for each task in a project type.",
                                        "Function `test_return_at_least_one_option`: A test function that ensures that there is at least one option available for each task in ProjectType."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_data.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_data.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestTextData`\nCode:\nclass TestTextData(TestCase):\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n            \"text\": \"test\",\n        }\n        self.project = prepare_project()\n\n    def test_parse(self):\n        data = TextData.parse(**self.dic)\n        self.assertIsInstance(data, TextData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(data.filename, self.dic[\"filename\"])\n        self.assertEqual(data.upload_name, self.dic[\"upload_name\"])\n        self.assertEqual(data.text, self.dic[\"text\"])\n\n    def test_parse_empty_text(self):\n        self.dic[\"text\"] = \"\"\n        with self.assertRaises(ValueError):\n            TextData.parse(**self.dic)\n\n    def test_create(self):\n        data = TextData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n            \"text\": \"test\",\n        }\n        self.project = prepare_project()",
                                        "Function `test_parse`\nCode:\n    def test_parse(self):\n        data = TextData.parse(**self.dic)\n        self.assertIsInstance(data, TextData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(data.filename, self.dic[\"filename\"])\n        self.assertEqual(data.upload_name, self.dic[\"upload_name\"])\n        self.assertEqual(data.text, self.dic[\"text\"])",
                                        "Function `test_parse_empty_text`\nCode:\n    def test_parse_empty_text(self):\n        self.dic[\"text\"] = \"\"\n        with self.assertRaises(ValueError):\n            TextData.parse(**self.dic)",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        data = TextData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])",
                                        "Class `TestBinaryData`\nCode:\nclass TestBinaryData(TestCase):\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n        }\n        self.project = prepare_project()\n\n    def test_parse(self):\n        data = BinaryData.parse(**self.dic)\n        self.assertIsInstance(data, BinaryData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])\n\n    def test_create(self):\n        data = BinaryData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(example.text, None)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n        }\n        self.project = prepare_project()",
                                        "Function `test_parse`\nCode:\n    def test_parse(self):\n        data = BinaryData.parse(**self.dic)\n        self.assertIsInstance(data, BinaryData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        data = BinaryData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(example.text, None)"
                                    ],
                                    "code": "import uuid\n\nfrom django.test import TestCase\n\nfrom data_import.pipeline.data import BinaryData, TextData\nfrom examples.models import Example\nfrom projects.tests.utils import prepare_project\n\n\nclass TestTextData(TestCase):\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n            \"text\": \"test\",\n        }\n        self.project = prepare_project()\n\n    def test_parse(self):\n        data = TextData.parse(**self.dic)\n        self.assertIsInstance(data, TextData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(data.filename, self.dic[\"filename\"])\n        self.assertEqual(data.upload_name, self.dic[\"upload_name\"])\n        self.assertEqual(data.text, self.dic[\"text\"])\n\n    def test_parse_empty_text(self):\n        self.dic[\"text\"] = \"\"\n        with self.assertRaises(ValueError):\n            TextData.parse(**self.dic)\n\n    def test_create(self):\n        data = TextData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])\n\n\nclass TestBinaryData(TestCase):\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n        }\n        self.project = prepare_project()\n\n    def test_parse(self):\n        data = BinaryData.parse(**self.dic)\n        self.assertIsInstance(data, BinaryData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])\n\n    def test_create(self):\n        data = BinaryData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(example.text, None)\n",
                                    "summary": "Class `TestTextData` and `TestBinaryData`: Test case classes for parsing and creating TextData and BinaryData objects with various scenarios, including parsing, creating, and testing specific attributes.",
                                    "code_element_summaries": [
                                        "Class `TestTextData`: A test case class for parsing and creating TextData objects with various test scenarios.",
                                        "Function `setUp`: Initializes test data including a dictionary and project for testing purposes.",
                                        "Function `test_parse`: A unit test function that checks the parsing of TextData object attributes from a dictionary.",
                                        "Function `test_parse_empty_text`: Tests the parsing of empty text data and expects a ValueError to be raised.",
                                        "Function `test_create`: Tests the creation of an Example instance from TextData with specific attributes.",
                                        "Class `TestBinaryData`: A test case class for parsing and creating BinaryData objects within a project.",
                                        "Function `setUp`: Initializes variables for testing purposes in a unit test.",
                                        "Function `test_parse`: A unit test that validates the parsing functionality of the BinaryData class.",
                                        "Function `test_create`: Tests the creation of an Example object from BinaryData with specific attributes."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_examples.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_examples.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExamples`\nCode:\nclass TestExamples(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example_uuid = uuid.uuid4()\n        example = Example(uuid=self.example_uuid, text=\"A\", project=self.project.item)\n        self.examples = Examples([example])\n\n    def test_save(self):\n        self.examples.save()\n        self.assertEqual(Example.objects.count(), 1)\n\n    def test_getitem(self):\n        self.examples.save()\n        example = self.examples[self.example_uuid]\n        self.assertEqual(example.uuid, self.example_uuid)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example_uuid = uuid.uuid4()\n        example = Example(uuid=self.example_uuid, text=\"A\", project=self.project.item)\n        self.examples = Examples([example])",
                                        "Function `test_save`\nCode:\n    def test_save(self):\n        self.examples.save()\n        self.assertEqual(Example.objects.count(), 1)",
                                        "Function `test_getitem`\nCode:\n    def test_getitem(self):\n        self.examples.save()\n        example = self.examples[self.example_uuid]\n        self.assertEqual(example.uuid, self.example_uuid)"
                                    ],
                                    "code": "import uuid\n\nfrom django.test import TestCase\n\nfrom data_import.pipeline.examples import Examples\nfrom examples.models import Example\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestExamples(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example_uuid = uuid.uuid4()\n        example = Example(uuid=self.example_uuid, text=\"A\", project=self.project.item)\n        self.examples = Examples([example])\n\n    def test_save(self):\n        self.examples.save()\n        self.assertEqual(Example.objects.count(), 1)\n\n    def test_getitem(self):\n        self.examples.save()\n        example = self.examples[self.example_uuid]\n        self.assertEqual(example.uuid, self.example_uuid)\n",
                                    "summary": "Class TestExamples: A test case for saving and retrieving examples in a project for document classification with specific test functions for saving and retrieving examples.",
                                    "code_element_summaries": [
                                        "Class TestExamples: A test case for saving and retrieving examples in a project for document classification.",
                                        "Function `setUp`: Initializes a project and example data for document classification testing.",
                                        "Function `test_save`: Tests the saving functionality of the Example model.",
                                        "Function `test_getitem`: Tests the `__getitem__` method of a class by saving an example, retrieving it by UUID, and asserting its UUID matches the expected UUID."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_label.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_label.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestLabel`\nCode:\nclass TestLabel(TestCase):\n    task = \"Any\"\n\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item, text=\"hello world\")",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item, text=\"hello world\")",
                                        "Class `TestCategoryLabel`\nCode:\nclass TestCategoryLabel(TestLabel):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_comparison(self):\n        category1 = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category2 = CategoryLabel(label=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(category1, category2)\n\n    def test_empty_label_raises_value_error(self):\n        with self.assertRaises(ValueError):\n            CategoryLabel(label=\"\", example_uuid=uuid.uuid4())\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        category = CategoryLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(category.label, \"A\")\n        self.assertEqual(category.example_uuid, example_uuid)\n\n    def test_create_type(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category_type = category.create_type(self.project.item)\n        self.assertIsInstance(category_type, CategoryType)\n        self.assertEqual(category_type.text, \"A\")\n\n    def test_create(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(CategoryType, project=self.project.item)\n        category_model = category.create(self.user, self.example, types)\n        self.assertIsInstance(category_model, CategoryModel)",
                                        "Function `test_comparison`\nCode:\n    def test_comparison(self):\n        category1 = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category2 = CategoryLabel(label=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(category1, category2)",
                                        "Function `test_empty_label_raises_value_error`\nCode:\n    def test_empty_label_raises_value_error(self):\n        with self.assertRaises(ValueError):\n            CategoryLabel(label=\"\", example_uuid=uuid.uuid4())",
                                        "Function `test_parse`\nCode:\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        category = CategoryLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(category.label, \"A\")\n        self.assertEqual(category.example_uuid, example_uuid)",
                                        "Function `test_create_type`\nCode:\n    def test_create_type(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category_type = category.create_type(self.project.item)\n        self.assertIsInstance(category_type, CategoryType)\n        self.assertEqual(category_type.text, \"A\")",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(CategoryType, project=self.project.item)\n        category_model = category.create(self.user, self.example, types)\n        self.assertIsInstance(category_model, CategoryModel)",
                                        "Class `TestSpanLabel`\nCode:\nclass TestSpanLabel(TestLabel):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def test_comparison(self):\n        span1 = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span2 = SpanLabel(label=\"A\", start_offset=1, end_offset=2, example_uuid=uuid.uuid4())\n        self.assertLess(span1, span2)\n\n    def test_parse_tuple(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj=(0, 1, \"A\"))\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)\n\n    def test_parse_dict(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0, \"end_offset\": 1})\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)\n\n    def test_invalid_negative_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=-1, end_offset=1, example_uuid=uuid.uuid4())\n\n    def test_invalid_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=1, end_offset=0, example_uuid=uuid.uuid4())\n\n    def test_parse_invalid_dict(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0})\n\n    def test_create_type(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span_type = span.create_type(self.project.item)\n        self.assertIsInstance(span_type, SpanType)\n        self.assertEqual(span_type.text, \"A\")\n\n    def test_create(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(SpanType, project=self.project.item)\n        span_model = span.create(self.user, self.example, types)\n        self.assertIsInstance(span_model, SpanModel)",
                                        "Function `test_comparison`\nCode:\n    def test_comparison(self):\n        span1 = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span2 = SpanLabel(label=\"A\", start_offset=1, end_offset=2, example_uuid=uuid.uuid4())\n        self.assertLess(span1, span2)",
                                        "Function `test_parse_tuple`\nCode:\n    def test_parse_tuple(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj=(0, 1, \"A\"))\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)",
                                        "Function `test_parse_dict`\nCode:\n    def test_parse_dict(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0, \"end_offset\": 1})\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)",
                                        "Function `test_invalid_negative_offset`\nCode:\n    def test_invalid_negative_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=-1, end_offset=1, example_uuid=uuid.uuid4())",
                                        "Function `test_invalid_offset`\nCode:\n    def test_invalid_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=1, end_offset=0, example_uuid=uuid.uuid4())",
                                        "Function `test_parse_invalid_dict`\nCode:\n    def test_parse_invalid_dict(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0})",
                                        "Function `test_create_type`\nCode:\n    def test_create_type(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span_type = span.create_type(self.project.item)\n        self.assertIsInstance(span_type, SpanType)\n        self.assertEqual(span_type.text, \"A\")",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(SpanType, project=self.project.item)\n        span_model = span.create(self.user, self.example, types)\n        self.assertIsInstance(span_model, SpanModel)",
                                        "Class `TestTextLabel`\nCode:\nclass TestTextLabel(TestLabel):\n    task = ProjectType.SEQ2SEQ\n\n    def test_comparison(self):\n        text1 = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text2 = TextLabel(text=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(text1, text2)\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        text = TextLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(text.text, \"A\")\n\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            TextLabel.parse(example_uuid, obj=[])\n\n    def test_create_type(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text_type = text.create_type(self.project.item)\n        self.assertEqual(text_type, None)\n\n    def test_create(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        text_model = text.create(self.user, self.example, types)\n        self.assertIsInstance(text_model, TextModel)",
                                        "Function `test_comparison`\nCode:\n    def test_comparison(self):\n        text1 = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text2 = TextLabel(text=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(text1, text2)",
                                        "Function `test_parse`\nCode:\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        text = TextLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(text.text, \"A\")",
                                        "Function `test_parse_invalid_data`\nCode:\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            TextLabel.parse(example_uuid, obj=[])",
                                        "Function `test_create_type`\nCode:\n    def test_create_type(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text_type = text.create_type(self.project.item)\n        self.assertEqual(text_type, None)",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        text_model = text.create(self.user, self.example, types)\n        self.assertIsInstance(text_model, TextModel)",
                                        "Class `TestRelationLabel`\nCode:\nclass TestRelationLabel(TestLabel):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def test_comparison(self):\n        relation1 = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation2 = RelationLabel(type=\"A\", from_id=1, to_id=1, example_uuid=uuid.uuid4())\n        self.assertLess(relation1, relation2)\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        relation = RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0, \"to_id\": 1})\n        self.assertEqual(relation.type, \"A\")\n        self.assertEqual(relation.from_id, 0)\n        self.assertEqual(relation.to_id, 1)\n\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0})\n\n    def test_create_type(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation_type = relation.create_type(self.project.item)\n        self.assertIsInstance(relation_type, RelationType)\n        self.assertEqual(relation_type.text, \"A\")\n\n    def test_create(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=self.example.uuid)\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(RelationType, project=self.project.item)\n        id_to_span = {\n            (0, str(self.example.uuid)): mommy.make(SpanModel, start_offset=0, end_offset=1, example=self.example),\n            (1, str(self.example.uuid)): mommy.make(SpanModel, start_offset=2, end_offset=3, example=self.example),\n        }\n        relation_model = relation.create(self.user, self.example, types, id_to_span=id_to_span)\n        self.assertIsInstance(relation_model, RelationModel)",
                                        "Function `test_comparison`\nCode:\n    def test_comparison(self):\n        relation1 = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation2 = RelationLabel(type=\"A\", from_id=1, to_id=1, example_uuid=uuid.uuid4())\n        self.assertLess(relation1, relation2)",
                                        "Function `test_parse`\nCode:\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        relation = RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0, \"to_id\": 1})\n        self.assertEqual(relation.type, \"A\")\n        self.assertEqual(relation.from_id, 0)\n        self.assertEqual(relation.to_id, 1)",
                                        "Function `test_parse_invalid_data`\nCode:\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0})",
                                        "Function `test_create_type`\nCode:\n    def test_create_type(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation_type = relation.create_type(self.project.item)\n        self.assertIsInstance(relation_type, RelationType)\n        self.assertEqual(relation_type.text, \"A\")",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=self.example.uuid)\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(RelationType, project=self.project.item)\n        id_to_span = {\n            (0, str(self.example.uuid)): mommy.make(SpanModel, start_offset=0, end_offset=1, example=self.example),\n            (1, str(self.example.uuid)): mommy.make(SpanModel, start_offset=2, end_offset=3, example=self.example),\n        }\n        relation_model = relation.create(self.user, self.example, types, id_to_span=id_to_span)\n        self.assertIsInstance(relation_model, RelationModel)"
                                    ],
                                    "code": "import uuid\nfrom unittest.mock import MagicMock\n\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom data_import.pipeline.label import (\n    CategoryLabel,\n    RelationLabel,\n    SpanLabel,\n    TextLabel,\n)\nfrom label_types.models import CategoryType, RelationType, SpanType\nfrom labels.models import Category as CategoryModel\nfrom labels.models import Relation as RelationModel\nfrom labels.models import Span as SpanModel\nfrom labels.models import TextLabel as TextModel\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestLabel(TestCase):\n    task = \"Any\"\n\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item, text=\"hello world\")\n\n\nclass TestCategoryLabel(TestLabel):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_comparison(self):\n        category1 = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category2 = CategoryLabel(label=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(category1, category2)\n\n    def test_empty_label_raises_value_error(self):\n        with self.assertRaises(ValueError):\n            CategoryLabel(label=\"\", example_uuid=uuid.uuid4())\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        category = CategoryLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(category.label, \"A\")\n        self.assertEqual(category.example_uuid, example_uuid)\n\n    def test_create_type(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category_type = category.create_type(self.project.item)\n        self.assertIsInstance(category_type, CategoryType)\n        self.assertEqual(category_type.text, \"A\")\n\n    def test_create(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(CategoryType, project=self.project.item)\n        category_model = category.create(self.user, self.example, types)\n        self.assertIsInstance(category_model, CategoryModel)\n\n\nclass TestSpanLabel(TestLabel):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def test_comparison(self):\n        span1 = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span2 = SpanLabel(label=\"A\", start_offset=1, end_offset=2, example_uuid=uuid.uuid4())\n        self.assertLess(span1, span2)\n\n    def test_parse_tuple(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj=(0, 1, \"A\"))\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)\n\n    def test_parse_dict(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0, \"end_offset\": 1})\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)\n\n    def test_invalid_negative_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=-1, end_offset=1, example_uuid=uuid.uuid4())\n\n    def test_invalid_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=1, end_offset=0, example_uuid=uuid.uuid4())\n\n    def test_parse_invalid_dict(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0})\n\n    def test_create_type(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span_type = span.create_type(self.project.item)\n        self.assertIsInstance(span_type, SpanType)\n        self.assertEqual(span_type.text, \"A\")\n\n    def test_create(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(SpanType, project=self.project.item)\n        span_model = span.create(self.user, self.example, types)\n        self.assertIsInstance(span_model, SpanModel)\n\n\nclass TestTextLabel(TestLabel):\n    task = ProjectType.SEQ2SEQ\n\n    def test_comparison(self):\n        text1 = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text2 = TextLabel(text=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(text1, text2)\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        text = TextLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(text.text, \"A\")\n\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            TextLabel.parse(example_uuid, obj=[])\n\n    def test_create_type(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text_type = text.create_type(self.project.item)\n        self.assertEqual(text_type, None)\n\n    def test_create(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        text_model = text.create(self.user, self.example, types)\n        self.assertIsInstance(text_model, TextModel)\n\n\nclass TestRelationLabel(TestLabel):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def test_comparison(self):\n        relation1 = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation2 = RelationLabel(type=\"A\", from_id=1, to_id=1, example_uuid=uuid.uuid4())\n        self.assertLess(relation1, relation2)\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        relation = RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0, \"to_id\": 1})\n        self.assertEqual(relation.type, \"A\")\n        self.assertEqual(relation.from_id, 0)\n        self.assertEqual(relation.to_id, 1)\n\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0})\n\n    def test_create_type(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation_type = relation.create_type(self.project.item)\n        self.assertIsInstance(relation_type, RelationType)\n        self.assertEqual(relation_type.text, \"A\")\n\n    def test_create(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=self.example.uuid)\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(RelationType, project=self.project.item)\n        id_to_span = {\n            (0, str(self.example.uuid)): mommy.make(SpanModel, start_offset=0, end_offset=1, example=self.example),\n            (1, str(self.example.uuid)): mommy.make(SpanModel, start_offset=2, end_offset=3, example=self.example),\n        }\n        relation_model = relation.create(self.user, self.example, types, id_to_span=id_to_span)\n        self.assertIsInstance(relation_model, RelationModel)\n",
                                    "summary": "Class TestLabel: A test case class for testing label functionality with setup method, and classes TestCategoryLabel, TestSpanLabel, TestTextLabel, and TestRelationLabel contain test methods for CategoryLabel, SpanLabel, TextLabel, and RelationLabel classes respectively.",
                                    "code_element_summaries": [
                                        "Class TestLabel: A test case class for testing label functionality with a setup method to prepare project and create example data.",
                                        "Function `setUp`: Initializes necessary objects for testing, including a project, user, and example data.",
                                        "Class `TestCategoryLabel`: Contains test methods for CategoryLabel class including comparison, error handling, parsing, type creation, and model creation.",
                                        "Function `test_comparison`: A unit test function that checks if one CategoryLabel object is less than another based on their labels.",
                                        "Function `test_empty_label_raises_value_error`: A test function that checks if creating a CategoryLabel instance with an empty label raises a ValueError.",
                                        "Function `test_parse`: A unit test function that tests the parsing of a category label with a specific UUID and object.",
                                        "Function `test_create_type`: Tests the creation of a CategoryType object based on a CategoryLabel object with specified attributes.",
                                        "Function `test_create`: Tests the creation of a CategoryModel instance based on a CategoryLabel object.",
                                        "Class `TestSpanLabel`: A test class for SpanLabel that includes methods for comparison, parsing from tuple and dictionary, handling invalid offsets, and creating SpanType and SpanModel instances.",
                                        "Function `test_comparison`: Compares two SpanLabel objects based on their start_offset values and asserts that the first object is less than the second.",
                                        "Function `test_parse_tuple`: A unit test that validates the parsing of tuple data into a SpanLabel object.",
                                        "Function `test_parse_dict`: A unit test function that validates the parsing of dictionary input into a SpanLabel object with specific attributes.",
                                        "Function `test_invalid_negative_offset`: Tests that a ValueError is raised when trying to create a SpanLabel with a negative start offset.",
                                        "Function `test_invalid_offset`: Tests that a ValueError is raised when creating a SpanLabel instance with invalid offset values.",
                                        "Function test_parse_invalid_dict: Tests the parsing of an invalid dictionary input for SpanLabel.",
                                        "Function `test_create_type`: Tests the creation of a SpanType object based on a SpanLabel object with specific attributes.",
                                        "Function `test_create`: A unit test for creating a SpanModel object with specified attributes.",
                                        "Class `TestTextLabel`: A test class for testing text labels with methods for comparison, parsing, creation, and type validation.",
                                        "Function `test_comparison`: A unit test function that asserts the comparison between two TextLabel objects based on their text values.",
                                        "Function `test_parse`: A test function that checks if the TextLabel class can correctly parse text with a specified UUID.",
                                        "Function `test_parse_invalid_data`: Tests the parsing of invalid data using a specific example UUID and raises a ValueError if the parsing fails.",
                                        "Function `test_create_type`: Verifies the creation of a text label type associated with a project item and asserts that it is None.",
                                        "Function `test_create`: A unit test for creating a TextModel instance using a TextLabel object.",
                                        "Class `TestRelationLabel`: A test class for testing the functionality of RelationLabel including comparison, parsing, creation of types, and creating relation models.",
                                        "Function `test_comparison`: Compares two instances of RelationLabel based on their attributes and asserts that one is less than the other.",
                                        "Function `test_parse`: Tests the parsing functionality of the RelationLabel class by creating an instance with specified attributes and asserting their values.",
                                        "Function `test_parse_invalid_data`: Tests the parsing of invalid data for RelationLabel objects.",
                                        "Function `test_create_type`: Tests the creation of a relation type with specified attributes and checks if it is an instance of RelationType with the correct text value.",
                                        "Function `test_create`: Tests the creation of a relation model with specified attributes and asserts its instance type."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_labels.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_labels.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestCategories`\nCode:\nclass TestCategories(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(CategoryType)\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            CategoryLabel(example_uuid=example_uuid, label=\"A\"),\n            CategoryLabel(example_uuid=example_uuid, label=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.categories = Categories(labels, self.types)\n\n    def test_clean(self):\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 2)\n\n    def test_clean_with_exclusive_labels(self):\n        self.project.item.single_class_classification = True\n        self.project.item.save()\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 1)\n\n    def test_save(self):\n        self.categories.save_types(self.project.item)\n        self.categories.save(self.user, self.examples)\n        self.assertEqual(Category.objects.count(), 2)\n\n    def test_save_types(self):\n        self.categories.save_types(self.project.item)\n        self.assertEqual(CategoryType.objects.count(), 2)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.types = LabelTypes(CategoryType)\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            CategoryLabel(example_uuid=example_uuid, label=\"A\"),\n            CategoryLabel(example_uuid=example_uuid, label=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.categories = Categories(labels, self.types)",
                                        "Function `test_clean`\nCode:\n    def test_clean(self):\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 2)",
                                        "Function `test_clean_with_exclusive_labels`\nCode:\n    def test_clean_with_exclusive_labels(self):\n        self.project.item.single_class_classification = True\n        self.project.item.save()\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 1)",
                                        "Function `test_save`\nCode:\n    def test_save(self):\n        self.categories.save_types(self.project.item)\n        self.categories.save(self.user, self.examples)\n        self.assertEqual(Category.objects.count(), 2)",
                                        "Function `test_save_types`\nCode:\n    def test_save_types(self):\n        self.categories.save_types(self.project.item)\n        self.assertEqual(CategoryType.objects.count(), 2)",
                                        "Class `TestSpans`\nCode:\nclass TestSpans(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(SpanType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=0, end_offset=3),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=3, end_offset=4),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.spans = Spans(labels, self.types)\n\n    def disable_overlapping(self):\n        self.project.item.allow_overlapping = False\n        self.project.item.save()\n\n    def test_clean(self):\n        self.disable_overlapping()\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 2)\n\n    def test_clean_with_overlapping(self):\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 3)\n\n    def test_clean_with_multiple_examples(self):\n        self.disable_overlapping()\n        example_uuid1 = uuid.uuid4()\n        example_uuid2 = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid1, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid2, label=\"B\", start_offset=0, end_offset=3),\n        ]\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid1)\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid2)\n        spans = Spans(labels, self.types)\n        spans.clean(self.project.item)\n        self.assertEqual(len(spans), 2)\n\n    def test_save(self):\n        self.spans.save_types(self.project.item)\n        self.spans.save(self.user, self.examples)\n        self.assertEqual(Span.objects.count(), 3)\n\n    def test_save_types(self):\n        self.spans.save_types(self.project.item)\n        self.assertEqual(SpanType.objects.count(), 2)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.types = LabelTypes(SpanType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=0, end_offset=3),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=3, end_offset=4),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.spans = Spans(labels, self.types)",
                                        "Function `disable_overlapping`\nCode:\n    def disable_overlapping(self):\n        self.project.item.allow_overlapping = False\n        self.project.item.save()",
                                        "Function `test_clean`\nCode:\n    def test_clean(self):\n        self.disable_overlapping()\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 2)",
                                        "Function `test_clean_with_overlapping`\nCode:\n    def test_clean_with_overlapping(self):\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 3)",
                                        "Function `test_clean_with_multiple_examples`\nCode:\n    def test_clean_with_multiple_examples(self):\n        self.disable_overlapping()\n        example_uuid1 = uuid.uuid4()\n        example_uuid2 = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid1, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid2, label=\"B\", start_offset=0, end_offset=3),\n        ]\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid1)\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid2)\n        spans = Spans(labels, self.types)\n        spans.clean(self.project.item)\n        self.assertEqual(len(spans), 2)",
                                        "Function `test_save`\nCode:\n    def test_save(self):\n        self.spans.save_types(self.project.item)\n        self.spans.save(self.user, self.examples)\n        self.assertEqual(Span.objects.count(), 3)",
                                        "Function `test_save_types`\nCode:\n    def test_save_types(self):\n        self.spans.save_types(self.project.item)\n        self.assertEqual(SpanType.objects.count(), 2)",
                                        "Class `TestTexts`\nCode:\nclass TestTexts(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(DummyLabelType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            TextLabel(example_uuid=example_uuid, text=\"A\"),\n            TextLabel(example_uuid=example_uuid, text=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.texts = Texts(labels, self.types)\n\n    def test_clean(self):\n        self.texts.clean(self.project.item)\n        self.assertEqual(len(self.texts), 2)\n\n    def test_save(self):\n        self.texts.save_types(self.project.item)\n        self.texts.save(self.user, self.examples)\n        self.assertEqual(TextLabelModel.objects.count(), 2)\n\n    def test_save_types(self):\n        # nothing happen\n        self.texts.save_types(self.project.item)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.types = LabelTypes(DummyLabelType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            TextLabel(example_uuid=example_uuid, text=\"A\"),\n            TextLabel(example_uuid=example_uuid, text=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.texts = Texts(labels, self.types)",
                                        "Function `test_clean`\nCode:\n    def test_clean(self):\n        self.texts.clean(self.project.item)\n        self.assertEqual(len(self.texts), 2)",
                                        "Function `test_save`\nCode:\n    def test_save(self):\n        self.texts.save_types(self.project.item)\n        self.texts.save(self.user, self.examples)\n        self.assertEqual(TextLabelModel.objects.count(), 2)",
                                        "Function `test_save_types`\nCode:\n    def test_save_types(self):\n        # nothing happen\n        self.texts.save_types(self.project.item)",
                                        "Class `TestRelations`\nCode:\nclass TestRelations(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(RelationType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, use_relation=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid, text=\"hello world\")\n        from_span = mommy.make(\"Span\", example=example, start_offset=0, end_offset=1)\n        to_span = mommy.make(\"Span\", example=example, start_offset=2, end_offset=3)\n        labels = [\n            RelationLabel(example_uuid=example_uuid, type=\"A\", from_id=from_span.id, to_id=to_span.id),\n        ]\n        self.relations = Relations(labels, self.types)\n        self.spans = MagicMock()\n        self.spans.id_to_span = {(from_span.id, str(example_uuid)): from_span, (to_span.id, str(example_uuid)): to_span}\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n\n    def test_clean(self):\n        self.relations.clean(self.project.item)\n        self.assertEqual(len(self.relations), 1)\n\n    def test_save(self):\n        self.relations.save_types(self.project.item)\n        self.relations.save(self.user, self.examples, spans=self.spans)\n        self.assertEqual(Relation.objects.count(), 1)\n\n    def test_save_types(self):\n        self.relations.save_types(self.project.item)\n        self.assertEqual(RelationType.objects.count(), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.types = LabelTypes(RelationType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, use_relation=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid, text=\"hello world\")\n        from_span = mommy.make(\"Span\", example=example, start_offset=0, end_offset=1)\n        to_span = mommy.make(\"Span\", example=example, start_offset=2, end_offset=3)\n        labels = [\n            RelationLabel(example_uuid=example_uuid, type=\"A\", from_id=from_span.id, to_id=to_span.id),\n        ]\n        self.relations = Relations(labels, self.types)\n        self.spans = MagicMock()\n        self.spans.id_to_span = {(from_span.id, str(example_uuid)): from_span, (to_span.id, str(example_uuid)): to_span}\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True",
                                        "Function `test_clean`\nCode:\n    def test_clean(self):\n        self.relations.clean(self.project.item)\n        self.assertEqual(len(self.relations), 1)",
                                        "Function `test_save`\nCode:\n    def test_save(self):\n        self.relations.save_types(self.project.item)\n        self.relations.save(self.user, self.examples, spans=self.spans)\n        self.assertEqual(Relation.objects.count(), 1)",
                                        "Function `test_save_types`\nCode:\n    def test_save_types(self):\n        self.relations.save_types(self.project.item)\n        self.assertEqual(RelationType.objects.count(), 1)"
                                    ],
                                    "code": "import uuid\nfrom unittest.mock import MagicMock\n\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom data_import.models import DummyLabelType\nfrom data_import.pipeline.label import (\n    CategoryLabel,\n    RelationLabel,\n    SpanLabel,\n    TextLabel,\n)\nfrom data_import.pipeline.label_types import LabelTypes\nfrom data_import.pipeline.labels import Categories, Relations, Spans, Texts\nfrom label_types.models import CategoryType, RelationType, SpanType\nfrom labels.models import Category, Relation, Span\nfrom labels.models import TextLabel as TextLabelModel\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestCategories(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(CategoryType)\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            CategoryLabel(example_uuid=example_uuid, label=\"A\"),\n            CategoryLabel(example_uuid=example_uuid, label=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.categories = Categories(labels, self.types)\n\n    def test_clean(self):\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 2)\n\n    def test_clean_with_exclusive_labels(self):\n        self.project.item.single_class_classification = True\n        self.project.item.save()\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 1)\n\n    def test_save(self):\n        self.categories.save_types(self.project.item)\n        self.categories.save(self.user, self.examples)\n        self.assertEqual(Category.objects.count(), 2)\n\n    def test_save_types(self):\n        self.categories.save_types(self.project.item)\n        self.assertEqual(CategoryType.objects.count(), 2)\n\n\nclass TestSpans(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(SpanType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=0, end_offset=3),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=3, end_offset=4),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.spans = Spans(labels, self.types)\n\n    def disable_overlapping(self):\n        self.project.item.allow_overlapping = False\n        self.project.item.save()\n\n    def test_clean(self):\n        self.disable_overlapping()\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 2)\n\n    def test_clean_with_overlapping(self):\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 3)\n\n    def test_clean_with_multiple_examples(self):\n        self.disable_overlapping()\n        example_uuid1 = uuid.uuid4()\n        example_uuid2 = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid1, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid2, label=\"B\", start_offset=0, end_offset=3),\n        ]\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid1)\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid2)\n        spans = Spans(labels, self.types)\n        spans.clean(self.project.item)\n        self.assertEqual(len(spans), 2)\n\n    def test_save(self):\n        self.spans.save_types(self.project.item)\n        self.spans.save(self.user, self.examples)\n        self.assertEqual(Span.objects.count(), 3)\n\n    def test_save_types(self):\n        self.spans.save_types(self.project.item)\n        self.assertEqual(SpanType.objects.count(), 2)\n\n\nclass TestTexts(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(DummyLabelType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            TextLabel(example_uuid=example_uuid, text=\"A\"),\n            TextLabel(example_uuid=example_uuid, text=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.texts = Texts(labels, self.types)\n\n    def test_clean(self):\n        self.texts.clean(self.project.item)\n        self.assertEqual(len(self.texts), 2)\n\n    def test_save(self):\n        self.texts.save_types(self.project.item)\n        self.texts.save(self.user, self.examples)\n        self.assertEqual(TextLabelModel.objects.count(), 2)\n\n    def test_save_types(self):\n        # nothing happen\n        self.texts.save_types(self.project.item)\n\n\nclass TestRelations(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(RelationType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, use_relation=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid, text=\"hello world\")\n        from_span = mommy.make(\"Span\", example=example, start_offset=0, end_offset=1)\n        to_span = mommy.make(\"Span\", example=example, start_offset=2, end_offset=3)\n        labels = [\n            RelationLabel(example_uuid=example_uuid, type=\"A\", from_id=from_span.id, to_id=to_span.id),\n        ]\n        self.relations = Relations(labels, self.types)\n        self.spans = MagicMock()\n        self.spans.id_to_span = {(from_span.id, str(example_uuid)): from_span, (to_span.id, str(example_uuid)): to_span}\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n\n    def test_clean(self):\n        self.relations.clean(self.project.item)\n        self.assertEqual(len(self.relations), 1)\n\n    def test_save(self):\n        self.relations.save_types(self.project.item)\n        self.relations.save(self.user, self.examples, spans=self.spans)\n        self.assertEqual(Relation.objects.count(), 1)\n\n    def test_save_types(self):\n        self.relations.save_types(self.project.item)\n        self.assertEqual(RelationType.objects.count(), 1)\n",
                                    "summary": "Class `TestCategories`: Tests for cleaning, saving, and managing category labels in a document classification project, while Class `TestSpans` and Class `TestTexts` focus on testing span labels and text labels functionality within a project respectively, and Class `TestRelations` is dedicated to testing relation labels creation, cleaning, and saving in a project.",
                                    "code_element_summaries": [
                                        "Class `TestCategories`: Tests for cleaning, saving, and managing category labels in a document classification project.",
                                        "Function `setUp`: Initializes variables and objects needed for testing document classification projects.",
                                        "Function `test_clean`: Tests the clean method of categories for a project item and asserts that the length of categories is 2.",
                                        "Function `test_clean_with_exclusive_labels`: Tests the cleaning functionality of exclusive labels in a single class classification project item.",
                                        "Function `test_save`: Tests saving categories for a project item and user, asserting that the Category objects count is 2.",
                                        "Function `test_save_types`: A test function that checks if the save_types method saves 2 CategoryType objects.",
                                        "Class `TestSpans`: A test case class for testing the functionality of span labels in a project.",
                                        "Function `setUp`: Initializes test data for a sequence labeling project with overlapping spans.",
                                        "Function `disable_overlapping`: A method that disables overlapping for items in a project.",
                                        "Function `test_clean`: Tests the clean functionality of the spans with disabled overlapping for a project item, asserting that the number of spans is 2.",
                                        "Function `test_clean_with_overlapping`: Tests the cleaning functionality of spans with overlapping items and asserts the expected length of spans after cleaning.",
                                        "Function `test_clean_with_multiple_examples`: Tests the cleaning process of multiple examples with non-overlapping spans and labels.",
                                        "Function `test_save`: Tests the saving functionality of spans related to a project item, user, and examples, ensuring that the total count of Span objects is 3.",
                                        "Function `test_save_types`: Tests the saving of span types associated with a project item and asserts that the count of SpanType objects is 2.",
                                        "Class `TestTexts`: A test case class for testing the functionality of Texts class in handling text labels within a project.",
                                        "Function `setUp`: Initializes variables and objects needed for testing, including label types, project, user, example UUID, example labels, and text annotations.",
                                        "Function 'test_clean': A test function that validates the clean method of texts in a project item.",
                                        "Function `test_save`: Tests the saving functionality of text labels for a project item and user, ensuring that the TextLabelModel count is correct.",
                                        "Function `test_save_types`: A test function that saves types for texts within a project item.",
                                        "Class `TestRelations`: A test case class for testing the creation, cleaning, and saving of relation labels in a project.",
                                        "Function `setUp`: Initializes necessary objects and data for testing relation labels in a project with sequence labeling.",
                                        "Function `test_clean`: A test function that validates the cleaning process of relations in a project item.",
                                        "Function `test_save`: Tests the saving functionality of relations for a specific project item, user, examples, and spans, asserting that the count of Relation objects is 1.",
                                        "Function `test_save_types`: Tests saving types for relations associated with a project item and asserts that only one RelationType object is created."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_label_types.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_label_types.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestCategoryLabel`\nCode:\nclass TestCategoryLabel(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_create(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        self.assertEqual(CategoryType.objects.count(), 1)\n        self.assertEqual(CategoryType.objects.first().text, \"A\")\n\n    def test_update(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        label_types.update(self.project.item)\n        category_type = label_types[\"A\"]\n        self.assertEqual(category_type.text, \"A\")",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item)",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        self.assertEqual(CategoryType.objects.count(), 1)\n        self.assertEqual(CategoryType.objects.first().text, \"A\")",
                                        "Function `test_update`\nCode:\n    def test_update(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        label_types.update(self.project.item)\n        category_type = label_types[\"A\"]\n        self.assertEqual(category_type.text, \"A\")"
                                    ],
                                    "code": "from django.test import TestCase\nfrom model_mommy import mommy\n\nfrom data_import.pipeline.label_types import LabelTypes\nfrom label_types.models import CategoryType\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestCategoryLabel(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_create(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        self.assertEqual(CategoryType.objects.count(), 1)\n        self.assertEqual(CategoryType.objects.first().text, \"A\")\n\n    def test_update(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        label_types.update(self.project.item)\n        category_type = label_types[\"A\"]\n        self.assertEqual(category_type.text, \"A\")\n",
                                    "summary": "Class TestCategoryLabel: Contains test cases for creating, updating, and testing category types within a project using prepared data.",
                                    "code_element_summaries": [
                                        "Class `TestCategoryLabel`: Contains test cases for creating and updating category types within a project.",
                                        "Function `setUp`: Initializes the project, user, and example for document classification using the prepare_project function and mommy.make method.",
                                        "Function test_create: Tests the creation of a CategoryType object and asserts its properties.",
                                        "Function `test_update`: Tests the update functionality of label types in a project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_makers.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_makers.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExamplesMaker`\nCode:\nclass TestExamplesMaker(TestCase):\n    def setUp(self):\n        self.project = prepare_project()\n        self.label_column = \"label\"\n        self.text_column = \"text\"\n        self.record = {\n            LINE_NUMBER_COLUMN: 1,\n            UUID_COLUMN: uuid.uuid4(),\n            FILE_NAME_COLUMN: \"file1\",\n            UPLOAD_NAME_COLUMN: \"upload1\",\n            self.text_column: \"text1\",\n            self.label_column: [\"A\"],\n        }\n        self.maker = ExampleMaker(self.project.item, TextData, self.text_column, [self.label_column])\n\n    def test_make_examples(self):\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 1)\n\n    def test_check_column_existence(self):\n        self.record.pop(self.text_column)\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)\n\n    def test_empty_text_raises_error(self):\n        self.record[self.text_column] = \"\"\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.label_column = \"label\"\n        self.text_column = \"text\"\n        self.record = {\n            LINE_NUMBER_COLUMN: 1,\n            UUID_COLUMN: uuid.uuid4(),\n            FILE_NAME_COLUMN: \"file1\",\n            UPLOAD_NAME_COLUMN: \"upload1\",\n            self.text_column: \"text1\",\n            self.label_column: [\"A\"],\n        }\n        self.maker = ExampleMaker(self.project.item, TextData, self.text_column, [self.label_column])",
                                        "Function `test_make_examples`\nCode:\n    def test_make_examples(self):\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 1)",
                                        "Function `test_check_column_existence`\nCode:\n    def test_check_column_existence(self):\n        self.record.pop(self.text_column)\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)",
                                        "Function `test_empty_text_raises_error`\nCode:\n    def test_empty_text_raises_error(self):\n        self.record[self.text_column] = \"\"\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)",
                                        "Class `TestLabelFormatter`\nCode:\nclass TestLabelFormatter(TestCase):\n    def setUp(self):\n        self.label_column = \"label\"\n        self.label_class = CategoryLabel\n        self.df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"B\", \"C\"]},\n            ]\n        )\n\n    def test_make(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        labels = label_maker.make(self.df)\n        self.assertEqual(len(labels), 3)\n        with self.subTest():\n            for label, expected in zip(labels, [\"A\", \"B\", \"C\"]):\n                self.assertEqual(getattr(label, \"label\"), expected)\n\n    def test_format_without_specified_column(self):\n        label_maker = LabelMaker(column=\"invalid_column\", label_class=self.label_class)\n        with self.assertRaises(KeyError):\n            label_maker.make(self.df)\n\n    def test_format_with_partially_correct_column(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), \"invalid_column\": [\"B\"]},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4()},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4(), self.label_column: [{}]},\n            ]\n        )\n        labels = label_maker.make(df)\n        self.assertEqual(len(labels), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.label_column = \"label\"\n        self.label_class = CategoryLabel\n        self.df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"B\", \"C\"]},\n            ]\n        )",
                                        "Function `test_make`\nCode:\n    def test_make(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        labels = label_maker.make(self.df)\n        self.assertEqual(len(labels), 3)\n        with self.subTest():\n            for label, expected in zip(labels, [\"A\", \"B\", \"C\"]):\n                self.assertEqual(getattr(label, \"label\"), expected)",
                                        "Function `test_format_without_specified_column`\nCode:\n    def test_format_without_specified_column(self):\n        label_maker = LabelMaker(column=\"invalid_column\", label_class=self.label_class)\n        with self.assertRaises(KeyError):\n            label_maker.make(self.df)",
                                        "Function `test_format_with_partially_correct_column`\nCode:\n    def test_format_with_partially_correct_column(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), \"invalid_column\": [\"B\"]},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4()},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4(), self.label_column: [{}]},\n            ]\n        )\n        labels = label_maker.make(df)\n        self.assertEqual(len(labels), 1)"
                                    ],
                                    "code": "import uuid\n\nimport pandas as pd\nfrom django.test import TestCase\n\nfrom data_import.pipeline.data import TextData\nfrom data_import.pipeline.label import CategoryLabel\nfrom data_import.pipeline.makers import ExampleMaker, LabelMaker\nfrom data_import.pipeline.readers import (\n    FILE_NAME_COLUMN,\n    LINE_NUMBER_COLUMN,\n    UPLOAD_NAME_COLUMN,\n    UUID_COLUMN,\n)\nfrom projects.tests.utils import prepare_project\n\n\nclass TestExamplesMaker(TestCase):\n    def setUp(self):\n        self.project = prepare_project()\n        self.label_column = \"label\"\n        self.text_column = \"text\"\n        self.record = {\n            LINE_NUMBER_COLUMN: 1,\n            UUID_COLUMN: uuid.uuid4(),\n            FILE_NAME_COLUMN: \"file1\",\n            UPLOAD_NAME_COLUMN: \"upload1\",\n            self.text_column: \"text1\",\n            self.label_column: [\"A\"],\n        }\n        self.maker = ExampleMaker(self.project.item, TextData, self.text_column, [self.label_column])\n\n    def test_make_examples(self):\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 1)\n\n    def test_check_column_existence(self):\n        self.record.pop(self.text_column)\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)\n\n    def test_empty_text_raises_error(self):\n        self.record[self.text_column] = \"\"\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)\n\n\nclass TestLabelFormatter(TestCase):\n    def setUp(self):\n        self.label_column = \"label\"\n        self.label_class = CategoryLabel\n        self.df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"B\", \"C\"]},\n            ]\n        )\n\n    def test_make(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        labels = label_maker.make(self.df)\n        self.assertEqual(len(labels), 3)\n        with self.subTest():\n            for label, expected in zip(labels, [\"A\", \"B\", \"C\"]):\n                self.assertEqual(getattr(label, \"label\"), expected)\n\n    def test_format_without_specified_column(self):\n        label_maker = LabelMaker(column=\"invalid_column\", label_class=self.label_class)\n        with self.assertRaises(KeyError):\n            label_maker.make(self.df)\n\n    def test_format_with_partially_correct_column(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), \"invalid_column\": [\"B\"]},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4()},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4(), self.label_column: [{}]},\n            ]\n        )\n        labels = label_maker.make(df)\n        self.assertEqual(len(labels), 1)\n",
                                    "summary": "Class `TestExamplesMaker`: A test class for `ExampleMaker` that tests example creation from DataFrame, column existence, and empty text errors, along with a test case class `TestLabelFormatter` for testing LabelMaker's label formatting functionality.",
                                    "code_element_summaries": [
                                        "Class `TestExamplesMaker`: A test class for the `ExampleMaker` class that tests the creation of examples from a DataFrame and checks for column existence and empty text errors.",
                                        "Function `setUp`: Initializes variables and objects needed for testing with specific project and data setup.",
                                        "Function `test_make_examples`: A unit test for the `make` function that creates examples from a DataFrame and asserts the length of the output.",
                                        "Function `test_check_column_existence`: A test function that checks for the existence of a specific column in a DataFrame and verifies the creation of examples and errors accordingly.",
                                        "Function `test_empty_text_raises_error`: Tests that an empty text column in a DataFrame will raise an error when creating examples using a maker object.",
                                        "Class `TestLabelFormatter`: A test case class for testing the functionality of LabelMaker in formatting labels from a DataFrame.",
                                        "Function `setUp`: Initializes variables for label column name, label class, and a DataFrame with sample data for testing purposes.",
                                        "Function `test_make`: Tests the `make` method of a `LabelMaker` object by asserting the generated labels against expected values.",
                                        "Function `test_format_without_specified_column`: Tests the behavior of the LabelMaker class when an invalid column is specified for labeling.",
                                        "Function `test_format_with_partially_correct_column`: Tests the formatting of labels with partially correct columns in a DataFrame."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_parser.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_parser.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestParser`\nCode:\nclass TestParser(unittest.TestCase):\n    def setUp(self):\n        self.test_dir = tempfile.mkdtemp()\n        self.test_file = os.path.join(self.test_dir, \"test_file.csv\")\n\n    def tearDown(self):\n        shutil.rmtree(self.test_dir)\n\n    def create_file(self, content):\n        with open(self.test_file, \"w\") as f:\n            f.write(content)\n\n    def assert_record(self, content, parser, expected):\n        self.create_file(content)\n        it = parser.parse(self.test_file)\n        for expect in expected:\n            row = next(it)\n            row.pop(LINE_NUMBER_COLUMN, None)\n            self.assertEqual(row, expect)\n        with self.assertRaises(StopIteration):\n            next(it)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.test_dir = tempfile.mkdtemp()\n        self.test_file = os.path.join(self.test_dir, \"test_file.csv\")",
                                        "Function `tearDown`\nCode:\n    def tearDown(self):\n        shutil.rmtree(self.test_dir)",
                                        "Function `create_file`\nCode:\n    def create_file(self, content):\n        with open(self.test_file, \"w\") as f:\n            f.write(content)",
                                        "Function `assert_record`\nCode:\n    def assert_record(self, content, parser, expected):\n        self.create_file(content)\n        it = parser.parse(self.test_file)\n        for expect in expected:\n            row = next(it)\n            row.pop(LINE_NUMBER_COLUMN, None)\n            self.assertEqual(row, expect)\n        with self.assertRaises(StopIteration):\n            next(it)",
                                        "Class `TestPlainParser`\nCode:\nclass TestPlainParser(TestParser):\n    def test_read(self):\n        content = \"example\"\n        parser = parsers.PlainParser()\n        expected = [{}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = \"example\"\n        parser = parsers.PlainParser()\n        expected = [{}]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestLineParser`\nCode:\nclass TestLineParser(TestParser):\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.LineParser()\n        expected = [{\"text\": \"Hello, World!\"}, {\"text\": \"こんにちは\"}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.LineParser()\n        expected = [{\"text\": \"Hello, World!\"}, {\"text\": \"こんにちは\"}]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestTextFileParser`\nCode:\nclass TestTextFileParser(TestParser):\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.TextFileParser()\n        expected = [{\"text\": content}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.TextFileParser()\n        expected = [{\"text\": content}]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestCsvParser`\nCode:\nclass TestCsvParser(TestParser):\n    def test_read(self):\n        content = \"label,text\\nLabel,Text\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)\n\n    def test_can_change_delimiter(self):\n        content = \"label\\ttext\\nLabel\\tText\"\n        parser = parsers.CSVParser(delimiter=\"\\t\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)\n\n    def test_can_read_null_value(self):\n        content = \"text,label\\nText\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"text\": \"Text\", \"label\": None}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = \"label,text\\nLabel,Text\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_can_change_delimiter`\nCode:\n    def test_can_change_delimiter(self):\n        content = \"label\\ttext\\nLabel\\tText\"\n        parser = parsers.CSVParser(delimiter=\"\\t\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_can_read_null_value`\nCode:\n    def test_can_read_null_value(self):\n        content = \"text,label\\nText\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"text\": \"Text\", \"label\": None}]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestJSONParser`\nCode:\nclass TestJSONParser(TestParser):\n    def test_read(self):\n        content = json.dumps([{\"text\": \"line1\", \"labels\": \"Label1\"}, {\"text\": \"line2\", \"labels\": \"Label2\"}])\n        parser = parsers.JSONParser()\n        expected = json.loads(content)\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = json.dumps([{\"text\": \"line1\", \"labels\": \"Label1\"}, {\"text\": \"line2\", \"labels\": \"Label2\"}])\n        parser = parsers.JSONParser()\n        expected = json.loads(content)\n        self.assert_record(content, parser, expected)",
                                        "Class `TestJSONLParser`\nCode:\nclass TestJSONLParser(TestParser):\n    def test_read(self):\n        line1 = json.dumps({\"text\": \"line1\", \"labels\": \"Label1\"})\n        line2 = json.dumps({\"text\": \"line2\", \"labels\": \"Label2\"})\n        content = f\"{line1}\\n{line2}\"\n        parser = parsers.JSONLParser()\n        expected = [json.loads(line1), json.loads(line2)]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        line1 = json.dumps({\"text\": \"line1\", \"labels\": \"Label1\"})\n        line2 = json.dumps({\"text\": \"line2\", \"labels\": \"Label2\"})\n        content = f\"{line1}\\n{line2}\"\n        parser = parsers.JSONLParser()\n        expected = [json.loads(line1), json.loads(line2)]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestFastTextParser`\nCode:\nclass TestFastTextParser(TestParser):\n    def test_read(self):\n        content = \"__label__sauce __label__cheese Text\"\n        parser = parsers.FastTextParser()\n        expected = [{\"text\": \"Text\", \"label\": [\"sauce\", \"cheese\"]}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = \"__label__sauce __label__cheese Text\"\n        parser = parsers.FastTextParser()\n        expected = [{\"text\": \"Text\", \"label\": [\"sauce\", \"cheese\"]}]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestCoNLLParser`\nCode:\nclass TestCoNLLParser(TestParser):\n    def test_can_read(self):\n        content = \"\"\"EU\\tB-ORG\nrejects\\tO\nGerman\\tB-MISC\ncall\\tO\nto\\tO\nboycott\\tO\nBritish\\tB-MISC\nlamb\\tO\n.\\tO\n\nPeter\\tB-PER\nBlackburn\\tI-PER\n\n\"\"\"\n        parser = parsers.CoNLLParser()\n        expected = [\n            {\n                \"text\": \"EU rejects German call to boycott British lamb .\",\n                \"label\": [(0, 2, \"ORG\"), (11, 17, \"MISC\"), (34, 41, \"MISC\")],\n            },\n            {\"text\": \"Peter Blackburn\", \"label\": [(0, 15, \"PER\")]},\n        ]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_can_read`\nCode:\n    def test_can_read(self):\n        content = \"\"\"EU\\tB-ORG\nrejects\\tO\nGerman\\tB-MISC\ncall\\tO\nto\\tO\nboycott\\tO\nBritish\\tB-MISC\nlamb\\tO\n.\\tO\n\nPeter\\tB-PER\nBlackburn\\tI-PER\n\n\"\"\"\n        parser = parsers.CoNLLParser()\n        expected = [\n            {\n                \"text\": \"EU rejects German call to boycott British lamb .\",\n                \"label\": [(0, 2, \"ORG\"), (11, 17, \"MISC\"), (34, 41, \"MISC\")],\n            },\n            {\"text\": \"Peter Blackburn\", \"label\": [(0, 15, \"PER\")]},\n        ]\n        self.assert_record(content, parser, expected)"
                                    ],
                                    "code": "import json\nimport os\nimport shutil\nimport tempfile\nimport unittest\n\nfrom data_import.pipeline import parsers\nfrom data_import.pipeline.readers import LINE_NUMBER_COLUMN\n\n\nclass TestParser(unittest.TestCase):\n    def setUp(self):\n        self.test_dir = tempfile.mkdtemp()\n        self.test_file = os.path.join(self.test_dir, \"test_file.csv\")\n\n    def tearDown(self):\n        shutil.rmtree(self.test_dir)\n\n    def create_file(self, content):\n        with open(self.test_file, \"w\") as f:\n            f.write(content)\n\n    def assert_record(self, content, parser, expected):\n        self.create_file(content)\n        it = parser.parse(self.test_file)\n        for expect in expected:\n            row = next(it)\n            row.pop(LINE_NUMBER_COLUMN, None)\n            self.assertEqual(row, expect)\n        with self.assertRaises(StopIteration):\n            next(it)\n\n\nclass TestPlainParser(TestParser):\n    def test_read(self):\n        content = \"example\"\n        parser = parsers.PlainParser()\n        expected = [{}]\n        self.assert_record(content, parser, expected)\n\n\nclass TestLineParser(TestParser):\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.LineParser()\n        expected = [{\"text\": \"Hello, World!\"}, {\"text\": \"こんにちは\"}]\n        self.assert_record(content, parser, expected)\n\n\nclass TestTextFileParser(TestParser):\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.TextFileParser()\n        expected = [{\"text\": content}]\n        self.assert_record(content, parser, expected)\n\n\nclass TestCsvParser(TestParser):\n    def test_read(self):\n        content = \"label,text\\nLabel,Text\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)\n\n    def test_can_change_delimiter(self):\n        content = \"label\\ttext\\nLabel\\tText\"\n        parser = parsers.CSVParser(delimiter=\"\\t\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)\n\n    def test_can_read_null_value(self):\n        content = \"text,label\\nText\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"text\": \"Text\", \"label\": None}]\n        self.assert_record(content, parser, expected)\n\n\nclass TestJSONParser(TestParser):\n    def test_read(self):\n        content = json.dumps([{\"text\": \"line1\", \"labels\": \"Label1\"}, {\"text\": \"line2\", \"labels\": \"Label2\"}])\n        parser = parsers.JSONParser()\n        expected = json.loads(content)\n        self.assert_record(content, parser, expected)\n\n\nclass TestJSONLParser(TestParser):\n    def test_read(self):\n        line1 = json.dumps({\"text\": \"line1\", \"labels\": \"Label1\"})\n        line2 = json.dumps({\"text\": \"line2\", \"labels\": \"Label2\"})\n        content = f\"{line1}\\n{line2}\"\n        parser = parsers.JSONLParser()\n        expected = [json.loads(line1), json.loads(line2)]\n        self.assert_record(content, parser, expected)\n\n\nclass TestFastTextParser(TestParser):\n    def test_read(self):\n        content = \"__label__sauce __label__cheese Text\"\n        parser = parsers.FastTextParser()\n        expected = [{\"text\": \"Text\", \"label\": [\"sauce\", \"cheese\"]}]\n        self.assert_record(content, parser, expected)\n\n\nclass TestCoNLLParser(TestParser):\n    def test_can_read(self):\n        content = \"\"\"EU\\tB-ORG\nrejects\\tO\nGerman\\tB-MISC\ncall\\tO\nto\\tO\nboycott\\tO\nBritish\\tB-MISC\nlamb\\tO\n.\\tO\n\nPeter\\tB-PER\nBlackburn\\tI-PER\n\n\"\"\"\n        parser = parsers.CoNLLParser()\n        expected = [\n            {\n                \"text\": \"EU rejects German call to boycott British lamb .\",\n                \"label\": [(0, 2, \"ORG\"), (11, 17, \"MISC\"), (34, 41, \"MISC\")],\n            },\n            {\"text\": \"Peter Blackburn\", \"label\": [(0, 15, \"PER\")]},\n        ]\n        self.assert_record(content, parser, expected)\n",
                                    "summary": "Class `TestParser`: A unit test case for testing file parsing functionality with setup, teardown, and assertion methods, including subclasses for testing different types of parsers.",
                                    "code_element_summaries": [
                                        "Class `TestParser`: A unit test case for testing file parsing functionality with setup, teardown, and assertion methods.",
                                        "Function `setUp`: Sets up a temporary directory and file for testing purposes.",
                                        "Function tearDown: Cleans up the test directory by removing it using shutil.rmtree.",
                                        "Function create_file: A method that creates a file and writes content to it.",
                                        "Function `assert_record`: A function that asserts the parsed content from a file against expected values using a parser.",
                                        "Class TestPlainParser: A test class that tests the read method of PlainParser by asserting the content, parser, and expected output.",
                                        "Function `test_read`: A test function that checks the parsing of \"example\" content using PlainParser and expects an empty list as the result.",
                                        "Class TestLineParser: A subclass of TestParser that tests the functionality of LineParser by parsing a string into separate records.",
                                        "Function `test_read`: Tests the LineParser class by asserting that the content is correctly parsed into separate text elements.",
                                        "Class TestTextFileParser: A test class for reading text content using TextFileParser and asserting the expected output.",
                                        "Function `test_read`: A test function that checks if the TextFileParser correctly reads and parses content from a text file.",
                                        "Class `TestCsvParser`: A test class for testing CSV parsing functionality with different delimiters and handling of null values.",
                                        "Function `test_read`: A test function that checks the functionality of reading CSV content into a dictionary using a specified delimiter.",
                                        "Function `test_can_change_delimiter`: Tests the ability to change the delimiter in a CSVParser object and asserts the expected output.",
                                        "Function `test_can_read_null_value`: Tests the ability to read null values from a CSV file using a specified delimiter and parser.",
                                        "Class TestJSONParser: A test class for JSONParser that tests the read functionality by comparing expected and actual JSON content.",
                                        "Function `test_read`: A test function that validates reading JSON content using a JSONParser object and comparing it with expected results.",
                                        "Class `TestJSONLParser`: A test class for parsing JSONL formatted data into records for testing purposes.",
                                        "Function `test_read`: A unit test function that validates the reading of JSONL formatted content using a JSONLParser.",
                                        "Class TestFastTextParser: A test class for the FastTextParser that verifies the correct parsing of text with labels.",
                                        "Function `test_read`: Tests the reading functionality of a FastTextParser by parsing a given content with labels and asserting the expected output.",
                                        "Class `TestCoNLLParser`: A test class for the CoNLLParser that checks if the parser can read and extract specific information from a given content.",
                                        "Function `test_can_read`: A unit test to check if the CoNLLParser correctly parses and extracts text and labels from a given content."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_reader.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_reader.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestReader`\nCode:\nclass TestReader(unittest.TestCase):\n    def setUp(self):\n        self.parser = MagicMock()\n        self.parser.parse.return_value = [{\"a\": 1}, {\"a\": 2}]\n        filename = MagicMock()\n        filename.generated_name = \"filename\"\n        filename.upload_name = \"upload_name\"\n        self.filenames = MagicMock()\n        self.filenames.__iter__.return_value = [filename]\n        self.rows = [\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 1,\n            },\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 2,\n            },\n        ]\n\n    @patch(\"data_import.pipeline.readers.uuid.uuid4\")\n    def test_iter_method(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        self.assertEqual(list(reader), self.rows)\n\n    @patch(\"data_import.pipeline.readers.uuid.uuid4\")\n    def test_batch(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        batch = next(reader.batch(2))\n        expected_df = pd.DataFrame(self.rows)\n        assert_frame_equal(batch, expected_df)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.parser = MagicMock()\n        self.parser.parse.return_value = [{\"a\": 1}, {\"a\": 2}]\n        filename = MagicMock()\n        filename.generated_name = \"filename\"\n        filename.upload_name = \"upload_name\"\n        self.filenames = MagicMock()\n        self.filenames.__iter__.return_value = [filename]\n        self.rows = [\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 1,\n            },\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 2,\n            },\n        ]",
                                        "Function `test_iter_method`\nCode:\n    def test_iter_method(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        self.assertEqual(list(reader), self.rows)",
                                        "Function `test_batch`\nCode:\n    def test_batch(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        batch = next(reader.batch(2))\n        expected_df = pd.DataFrame(self.rows)\n        assert_frame_equal(batch, expected_df)"
                                    ],
                                    "code": "import unittest\nfrom unittest.mock import MagicMock, patch\n\nimport pandas as pd\nfrom pandas.testing import assert_frame_equal\n\nfrom data_import.pipeline.readers import (\n    FILE_NAME_COLUMN,\n    UPLOAD_NAME_COLUMN,\n    UUID_COLUMN,\n    Reader,\n)\n\n\nclass TestReader(unittest.TestCase):\n    def setUp(self):\n        self.parser = MagicMock()\n        self.parser.parse.return_value = [{\"a\": 1}, {\"a\": 2}]\n        filename = MagicMock()\n        filename.generated_name = \"filename\"\n        filename.upload_name = \"upload_name\"\n        self.filenames = MagicMock()\n        self.filenames.__iter__.return_value = [filename]\n        self.rows = [\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 1,\n            },\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 2,\n            },\n        ]\n\n    @patch(\"data_import.pipeline.readers.uuid.uuid4\")\n    def test_iter_method(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        self.assertEqual(list(reader), self.rows)\n\n    @patch(\"data_import.pipeline.readers.uuid.uuid4\")\n    def test_batch(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        batch = next(reader.batch(2))\n        expected_df = pd.DataFrame(self.rows)\n        assert_frame_equal(batch, expected_df)\n",
                                    "summary": "Class `TestReader`: A unit test case for the `Reader` class that tests the `iter_method` and `batch` methods using mock data and objects.",
                                    "code_element_summaries": [
                                        "Class `TestReader`: A unit test case for the `Reader` class that sets up mock data and tests the `iter_method` and `batch` methods.",
                                        "Function `setUp`: Sets up mock objects and data for testing purposes.",
                                        "Function `test_iter_method`: Tests the iteration method of a Reader object by mocking a UUID and comparing the result with a list of rows.",
                                        "Function `test_batch`: A test function that checks if the batch generated by the Reader class matches the expected DataFrame."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_tasks.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_tasks.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestImportData`\nCode:\nclass TestImportData(TestCase):\n    task = \"Any\"\n    annotation_class = Category\n\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()\n\n    def tearDown(self):\n        try:\n            su = StoredUpload.objects.get(upload_id=self.upload_id)\n            directory = pathlib.Path(su.get_absolute_file_path()).parent\n            shutil.rmtree(directory)\n        except StoredUpload.DoesNotExist:\n            pass\n\n    def import_dataset(self, filename, file_format, task, kwargs=None):\n        file_path = str(self.data_path / filename)\n        TemporaryUpload.objects.create(\n            upload_id=self.upload_id,\n            file_id=\"1\",\n            file=File(open(file_path, mode=\"rb\"), filename.split(\"/\")[-1]),\n            upload_name=filename,\n            upload_type=\"F\",\n        )\n        upload_ids = [self.upload_id]\n        kwargs = kwargs or {}\n        return import_dataset(self.user.id, self.project.item.id, file_format, upload_ids, task, **kwargs)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()",
                                        "Function `tearDown`\nCode:\n    def tearDown(self):\n        try:\n            su = StoredUpload.objects.get(upload_id=self.upload_id)\n            directory = pathlib.Path(su.get_absolute_file_path()).parent\n            shutil.rmtree(directory)\n        except StoredUpload.DoesNotExist:\n            pass",
                                        "Function `import_dataset`\nCode:\n    def import_dataset(self, filename, file_format, task, kwargs=None):\n        file_path = str(self.data_path / filename)\n        TemporaryUpload.objects.create(\n            upload_id=self.upload_id,\n            file_id=\"1\",\n            file=File(open(file_path, mode=\"rb\"), filename.split(\"/\")[-1]),\n            upload_name=filename,\n            upload_type=\"F\",\n        )\n        upload_ids = [self.upload_id]\n        kwargs = kwargs or {}\n        return import_dataset(self.user.id, self.project.item.id, file_format, upload_ids, task, **kwargs)",
                                        "Class `TestMaxFileSize`\nCode:\nclass TestMaxFileSize(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        response = self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"maximum file size\", response[\"error\"][0][\"message\"])",
                                        "Function `test_jsonl`\nCode:\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        response = self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"maximum file size\", response[\"error\"][0][\"message\"])",
                                        "Class `TestInvalidFileFormat`\nCode:\nclass TestInvalidFileFormat(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_invalid_file_format(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"INVALID_FORMAT\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)",
                                        "Function `test_invalid_file_format`\nCode:\n    def test_invalid_file_format(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"INVALID_FORMAT\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)",
                                        "Class `TestImportClassificationData`\nCode:\nclass TestImportClassificationData(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def assert_examples(self, dataset):\n        with self.subTest():\n            self.assertEqual(Example.objects.count(), len(dataset))\n            for text, expected_labels in dataset:\n                example = Example.objects.get(text=text)\n                labels = set(cat.label.text for cat in example.categories.all())\n                self.assertEqual(labels, set(expected_labels))\n\n    def assert_parse_error(self, response):\n        with self.subTest():\n            self.assertGreaterEqual(len(response[\"error\"]), 1)\n            self.assertEqual(Example.objects.count(), 0)\n            self.assertEqual(Category.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assert_examples(dataset)\n\n    def test_csv(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_csv_out_of_order_columns(self):\n        filename = \"text_classification/example_out_of_order_columns.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_fasttext(self):\n        filename = \"text_classification/example_fasttext.txt\"\n        file_format = \"fastText\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_excel(self):\n        filename = \"text_classification/example.xlsx\"\n        file_format = \"Excel\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_json(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_textfile(self):\n        filename = \"example.txt\"\n        file_format = \"TextFile\"\n        dataset = [(\"exampleA\\nexampleB\\n\\nexampleC\\n\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 0)\n\n    def test_textline(self):\n        filename = \"example.txt\"\n        file_format = \"TextLine\"\n        dataset = [(\"exampleA\", []), (\"exampleB\", []), (\"exampleC\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 1)\n\n    def test_wrong_jsonl(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_json(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSON\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_excel(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"Excel\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_csv(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"CSV\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Function `assert_examples`\nCode:\n    def assert_examples(self, dataset):\n        with self.subTest():\n            self.assertEqual(Example.objects.count(), len(dataset))\n            for text, expected_labels in dataset:\n                example = Example.objects.get(text=text)\n                labels = set(cat.label.text for cat in example.categories.all())\n                self.assertEqual(labels, set(expected_labels))",
                                        "Function `assert_parse_error`\nCode:\n    def assert_parse_error(self, response):\n        with self.subTest():\n            self.assertGreaterEqual(len(response[\"error\"]), 1)\n            self.assertEqual(Example.objects.count(), 0)\n            self.assertEqual(Category.objects.count(), 0)",
                                        "Function `test_jsonl`\nCode:\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assert_examples(dataset)",
                                        "Function `test_csv`\nCode:\n    def test_csv(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_csv_out_of_order_columns`\nCode:\n    def test_csv_out_of_order_columns(self):\n        filename = \"text_classification/example_out_of_order_columns.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_fasttext`\nCode:\n    def test_fasttext(self):\n        filename = \"text_classification/example_fasttext.txt\"\n        file_format = \"fastText\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_excel`\nCode:\n    def test_excel(self):\n        filename = \"text_classification/example.xlsx\"\n        file_format = \"Excel\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_json`\nCode:\n    def test_json(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_textfile`\nCode:\n    def test_textfile(self):\n        filename = \"example.txt\"\n        file_format = \"TextFile\"\n        dataset = [(\"exampleA\\nexampleB\\n\\nexampleC\\n\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 0)",
                                        "Function `test_textline`\nCode:\n    def test_textline(self):\n        filename = \"example.txt\"\n        file_format = \"TextLine\"\n        dataset = [(\"exampleA\", []), (\"exampleB\", []), (\"exampleC\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 1)",
                                        "Function `test_wrong_jsonl`\nCode:\n    def test_wrong_jsonl(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Function `test_wrong_json`\nCode:\n    def test_wrong_json(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSON\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Function `test_wrong_excel`\nCode:\n    def test_wrong_excel(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"Excel\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Function `test_wrong_csv`\nCode:\n    def test_wrong_csv(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"CSV\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Class `TestImportSequenceLabelingData`\nCode:\nclass TestImportSequenceLabelingData(TestImportData):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(labels, expected_labels)\n\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [[0, 1, \"LOC\"]]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_conll(self):\n        filename = \"sequence_labeling/example.conll\"\n        file_format = \"CoNLL\"\n        dataset = [(\"JAPAN GET\", [[0, 5, \"LOC\"]]), (\"Nadim Ladki\", [[0, 11, \"PER\"]])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_wrong_conll(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"CoNLL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_jsonl_with_overlapping(self):\n        filename = \"sequence_labeling/example_overlapping.jsonl\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 0)",
                                        "Function `assert_examples`\nCode:\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(labels, expected_labels)",
                                        "Function `assert_parse_error`\nCode:\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)",
                                        "Function `test_jsonl`\nCode:\n    def test_jsonl(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [[0, 1, \"LOC\"]]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_conll`\nCode:\n    def test_conll(self):\n        filename = \"sequence_labeling/example.conll\"\n        file_format = \"CoNLL\"\n        dataset = [(\"JAPAN GET\", [[0, 5, \"LOC\"]]), (\"Nadim Ladki\", [[0, 11, \"PER\"]])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_wrong_conll`\nCode:\n    def test_wrong_conll(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"CoNLL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Function `test_jsonl_with_overlapping`\nCode:\n    def test_jsonl_with_overlapping(self):\n        filename = \"sequence_labeling/example_overlapping.jsonl\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 0)",
                                        "Class `TestImportRelationExtractionData`\nCode:\nclass TestImportRelationExtractionData(TestImportData):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def setUp(self):\n        self.project = prepare_project(self.task, use_relation=True)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_spans in dataset:\n            example = Example.objects.get(text=text)\n            spans = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(spans, expected_spans)\n            self.assertEqual(example.relations.count(), 3)\n\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"relation_extraction/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\n                \"Google was founded on September 4, 1998, by Larry Page and Sergey Brin.\",\n                [[0, 6, \"ORG\"], [22, 39, \"DATE\"], [44, 54, \"PERSON\"], [59, 70, \"PERSON\"]],\n            ),\n        ]\n        self.import_dataset(filename, file_format, RELATION_EXTRACTION)\n        self.assert_examples(dataset)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(self.task, use_relation=True)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()",
                                        "Function `assert_examples`\nCode:\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_spans in dataset:\n            example = Example.objects.get(text=text)\n            spans = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(spans, expected_spans)\n            self.assertEqual(example.relations.count(), 3)",
                                        "Function `assert_parse_error`\nCode:\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)",
                                        "Function `test_jsonl`\nCode:\n    def test_jsonl(self):\n        filename = \"relation_extraction/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\n                \"Google was founded on September 4, 1998, by Larry Page and Sergey Brin.\",\n                [[0, 6, \"ORG\"], [22, 39, \"DATE\"], [44, 54, \"PERSON\"], [59, 70, \"PERSON\"]],\n            ),\n        ]\n        self.import_dataset(filename, file_format, RELATION_EXTRACTION)\n        self.assert_examples(dataset)",
                                        "Class `TestImportSeq2seqData`\nCode:\nclass TestImportSeq2seqData(TestImportData):\n    task = ProjectType.SEQ2SEQ\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = set(text_label.text for text_label in example.texts.all())\n            self.assertEqual(labels, set(expected_labels))\n\n    def test_jsonl(self):\n        filename = \"seq2seq/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_json(self):\n        filename = \"seq2seq/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_csv(self):\n        filename = \"seq2seq/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `assert_examples`\nCode:\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = set(text_label.text for text_label in example.texts.all())\n            self.assertEqual(labels, set(expected_labels))",
                                        "Function `test_jsonl`\nCode:\n    def test_jsonl(self):\n        filename = \"seq2seq/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_json`\nCode:\n    def test_json(self):\n        filename = \"seq2seq/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_csv`\nCode:\n    def test_csv(self):\n        filename = \"seq2seq/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Class `TestImportIntentDetectionAndSlotFillingData`\nCode:\nclass TestImportIntentDetectionAndSlotFillingData(TestImportData):\n    task = ProjectType.INTENT_DETECTION_AND_SLOT_FILLING\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            cats = set(cat.label.text for cat in example.categories.all())\n            entities = [(span.start_offset, span.end_offset, span.label.text) for span in example.spans.all()]\n            self.assertEqual(cats, set(expected_labels[\"cats\"]))\n            self.assertEqual(entities, expected_labels[\"entities\"])\n\n    def test_entities_and_cats(self):\n        filename = \"intent/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\"exampleA\", {\"cats\": [\"positive\"], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleB\", {\"cats\": [\"positive\"], \"entities\": []}),\n            (\"exampleC\", {\"cats\": [], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleD\", {\"cats\": [], \"entities\": []}),\n        ]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `assert_examples`\nCode:\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            cats = set(cat.label.text for cat in example.categories.all())\n            entities = [(span.start_offset, span.end_offset, span.label.text) for span in example.spans.all()]\n            self.assertEqual(cats, set(expected_labels[\"cats\"]))\n            self.assertEqual(entities, expected_labels[\"entities\"])",
                                        "Function `test_entities_and_cats`\nCode:\n    def test_entities_and_cats(self):\n        filename = \"intent/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\"exampleA\", {\"cats\": [\"positive\"], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleB\", {\"cats\": [\"positive\"], \"entities\": []}),\n            (\"exampleC\", {\"cats\": [], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleD\", {\"cats\": [], \"entities\": []}),\n        ]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Class `TestImportImageClassificationData`\nCode:\nclass TestImportImageClassificationData(TestImportData):\n    task = ProjectType.IMAGE_CLASSIFICATION\n\n    def test_example(self):\n        filename = \"images/1500x500.jpeg\"\n        file_format = \"ImageFile\"\n        self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(Example.objects.count(), 1)",
                                        "Function `test_example`\nCode:\n    def test_example(self):\n        filename = \"images/1500x500.jpeg\"\n        file_format = \"ImageFile\"\n        self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(Example.objects.count(), 1)",
                                        "Class `TestFileTypeChecking`\nCode:\nclass TestFileTypeChecking(TestImportData):\n    task = ProjectType.IMAGE_CLASSIFICATION\n\n    def test_example(self):\n        filename = \"images/example.ico\"\n        file_format = \"ImageFile\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"unexpected\", response[\"error\"][0][\"message\"])",
                                        "Function `test_example`\nCode:\n    def test_example(self):\n        filename = \"images/example.ico\"\n        file_format = \"ImageFile\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"unexpected\", response[\"error\"][0][\"message\"])"
                                    ],
                                    "code": "import os\nimport pathlib\nimport shutil\n\nfrom django.core.files import File\nfrom django.test import TestCase, override_settings\nfrom django_drf_filepond.models import StoredUpload, TemporaryUpload\nfrom django_drf_filepond.utils import _get_file_id\n\nfrom data_import.celery_tasks import import_dataset\nfrom data_import.pipeline.catalog import RELATION_EXTRACTION\nfrom examples.models import Example\nfrom label_types.models import SpanType\nfrom labels.models import Category, Span\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\n@override_settings(MEDIA_ROOT=os.path.join(os.path.dirname(__file__), \"data\"))\nclass TestImportData(TestCase):\n    task = \"Any\"\n    annotation_class = Category\n\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()\n\n    def tearDown(self):\n        try:\n            su = StoredUpload.objects.get(upload_id=self.upload_id)\n            directory = pathlib.Path(su.get_absolute_file_path()).parent\n            shutil.rmtree(directory)\n        except StoredUpload.DoesNotExist:\n            pass\n\n    def import_dataset(self, filename, file_format, task, kwargs=None):\n        file_path = str(self.data_path / filename)\n        TemporaryUpload.objects.create(\n            upload_id=self.upload_id,\n            file_id=\"1\",\n            file=File(open(file_path, mode=\"rb\"), filename.split(\"/\")[-1]),\n            upload_name=filename,\n            upload_type=\"F\",\n        )\n        upload_ids = [self.upload_id]\n        kwargs = kwargs or {}\n        return import_dataset(self.user.id, self.project.item.id, file_format, upload_ids, task, **kwargs)\n\n\n@override_settings(MAX_UPLOAD_SIZE=0)\nclass TestMaxFileSize(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        response = self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"maximum file size\", response[\"error\"][0][\"message\"])\n\n\nclass TestInvalidFileFormat(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_invalid_file_format(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"INVALID_FORMAT\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)\n\n\nclass TestImportClassificationData(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def assert_examples(self, dataset):\n        with self.subTest():\n            self.assertEqual(Example.objects.count(), len(dataset))\n            for text, expected_labels in dataset:\n                example = Example.objects.get(text=text)\n                labels = set(cat.label.text for cat in example.categories.all())\n                self.assertEqual(labels, set(expected_labels))\n\n    def assert_parse_error(self, response):\n        with self.subTest():\n            self.assertGreaterEqual(len(response[\"error\"]), 1)\n            self.assertEqual(Example.objects.count(), 0)\n            self.assertEqual(Category.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assert_examples(dataset)\n\n    def test_csv(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_csv_out_of_order_columns(self):\n        filename = \"text_classification/example_out_of_order_columns.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_fasttext(self):\n        filename = \"text_classification/example_fasttext.txt\"\n        file_format = \"fastText\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_excel(self):\n        filename = \"text_classification/example.xlsx\"\n        file_format = \"Excel\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_json(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_textfile(self):\n        filename = \"example.txt\"\n        file_format = \"TextFile\"\n        dataset = [(\"exampleA\\nexampleB\\n\\nexampleC\\n\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 0)\n\n    def test_textline(self):\n        filename = \"example.txt\"\n        file_format = \"TextLine\"\n        dataset = [(\"exampleA\", []), (\"exampleB\", []), (\"exampleC\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 1)\n\n    def test_wrong_jsonl(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_json(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSON\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_excel(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"Excel\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_csv(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"CSV\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n\nclass TestImportSequenceLabelingData(TestImportData):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(labels, expected_labels)\n\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [[0, 1, \"LOC\"]]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_conll(self):\n        filename = \"sequence_labeling/example.conll\"\n        file_format = \"CoNLL\"\n        dataset = [(\"JAPAN GET\", [[0, 5, \"LOC\"]]), (\"Nadim Ladki\", [[0, 11, \"PER\"]])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_wrong_conll(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"CoNLL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_jsonl_with_overlapping(self):\n        filename = \"sequence_labeling/example_overlapping.jsonl\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 0)\n\n\nclass TestImportRelationExtractionData(TestImportData):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def setUp(self):\n        self.project = prepare_project(self.task, use_relation=True)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_spans in dataset:\n            example = Example.objects.get(text=text)\n            spans = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(spans, expected_spans)\n            self.assertEqual(example.relations.count(), 3)\n\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"relation_extraction/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\n                \"Google was founded on September 4, 1998, by Larry Page and Sergey Brin.\",\n                [[0, 6, \"ORG\"], [22, 39, \"DATE\"], [44, 54, \"PERSON\"], [59, 70, \"PERSON\"]],\n            ),\n        ]\n        self.import_dataset(filename, file_format, RELATION_EXTRACTION)\n        self.assert_examples(dataset)\n\n\nclass TestImportSeq2seqData(TestImportData):\n    task = ProjectType.SEQ2SEQ\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = set(text_label.text for text_label in example.texts.all())\n            self.assertEqual(labels, set(expected_labels))\n\n    def test_jsonl(self):\n        filename = \"seq2seq/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_json(self):\n        filename = \"seq2seq/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_csv(self):\n        filename = \"seq2seq/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n\nclass TestImportIntentDetectionAndSlotFillingData(TestImportData):\n    task = ProjectType.INTENT_DETECTION_AND_SLOT_FILLING\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            cats = set(cat.label.text for cat in example.categories.all())\n            entities = [(span.start_offset, span.end_offset, span.label.text) for span in example.spans.all()]\n            self.assertEqual(cats, set(expected_labels[\"cats\"]))\n            self.assertEqual(entities, expected_labels[\"entities\"])\n\n    def test_entities_and_cats(self):\n        filename = \"intent/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\"exampleA\", {\"cats\": [\"positive\"], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleB\", {\"cats\": [\"positive\"], \"entities\": []}),\n            (\"exampleC\", {\"cats\": [], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleD\", {\"cats\": [], \"entities\": []}),\n        ]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n\nclass TestImportImageClassificationData(TestImportData):\n    task = ProjectType.IMAGE_CLASSIFICATION\n\n    def test_example(self):\n        filename = \"images/1500x500.jpeg\"\n        file_format = \"ImageFile\"\n        self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(Example.objects.count(), 1)\n\n\n@override_settings(ENABLE_FILE_TYPE_CHECK=True)\nclass TestFileTypeChecking(TestImportData):\n    task = ProjectType.IMAGE_CLASSIFICATION\n\n    def test_example(self):\n        filename = \"images/example.ico\"\n        file_format = \"ImageFile\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"unexpected\", response[\"error\"][0][\"message\"])\n",
                                    "summary": "A collection of test classes and functions for importing and validating various types of datasets, such as text classification, sequence labeling, relation extraction, sequence-to-sequence, intent detection, slot filling, and image classification, in different formats like JSONL, JSON, CSV, CoNLL, and Excel, while ensuring the correctness of the imported data and handling errors appropriately.",
                                    "code_element_summaries": [
                                        "Class `TestImportData`: A test case class for importing datasets with specified parameters and cleaning up temporary files after testing.",
                                        "Function `setUp`: Sets up the necessary variables and objects for testing by preparing a project, user, data path, and upload ID.",
                                        "Function `tearDown`: Deletes the directory containing the uploaded file if it exists.",
                                        "Function `import_dataset`: Imports a dataset file into the system and associates it with a specific project and task.",
                                        "Class TestMaxFileSize: A test class for checking the maximum file size limit when importing datasets for document classification tasks.",
                                        "Function `test_jsonl`: A test function that imports a dataset from a JSONL file and checks for errors related to file size limitations.",
                                        "Class TestInvalidFileFormat: A test class that checks for errors when importing a dataset with an invalid file format in text classification tasks.",
                                        "Function `test_invalid_file_format`: Tests importing a dataset with an invalid file format, expecting an error response with one error message.",
                                        "Class `TestImportClassificationData`: A test class for importing and validating text classification data in various formats.",
                                        "Function `assert_examples`: Asserts that the examples in a dataset match the expected labels in a Django model.",
                                        "Function `assert_parse_error`: A method that asserts the presence of parsing errors in a response and checks that Example and Category objects counts are 0.",
                                        "Function `test_jsonl`: Tests the import and assertion of dataset examples from a JSONL file for text classification.",
                                        "Function `test_csv`: Tests the import and assertion of examples from a CSV file for text classification.",
                                        "Function `test_csv_out_of_order_columns`: A test function that checks if CSV files with out-of-order columns are imported correctly for text classification tasks.",
                                        "Function `test_fasttext`: Tests the import and assertion of a dataset for text classification using the fastText format.",
                                        "Function `test_excel`: Tests importing dataset from an Excel file and asserts the examples in the dataset.",
                                        "Function `test_json`: Tests importing a dataset from a JSON file and asserts the examples match the expected dataset.",
                                        "Function `test_textfile`: Tests the import of a text file dataset with specific examples and checks for errors.",
                                        "Function `test_textline`: Tests the import of a dataset in TextLine format, asserts examples, and checks for errors in the response.",
                                        "Function `test_wrong_jsonl`: A test function that checks for parsing errors when importing a dataset in JSONL format.",
                                        "Function `test_wrong_json`: Tests the parsing of a JSON file for text classification and asserts an error if parsing fails.",
                                        "Function `test_wrong_excel`: Tests importing a dataset with an incorrect file format and asserts a parse error response.",
                                        "Function `test_wrong_csv`: A test function that checks for parsing errors when importing a dataset with the wrong file format.",
                                        "Class `TestImportSequenceLabelingData`: A test class for importing and validating sequence labeling data in JSONL and CoNLL formats.",
                                        "Function `assert_examples`: A method to compare the number of examples in a dataset with the number of Example objects, and verify the labels of each example match the expected labels.",
                                        "Function `assert_parse_error`: Asserts that there is at least one error message in the response and that certain database counts are equal to zero.",
                                        "Function `test_jsonl`: Tests the import and assertion of dataset examples in JSONL format for sequence labeling tasks.",
                                        "Function `test_conll`: Tests the import and assertion of dataset examples in CoNLL format for sequence labeling tasks.",
                                        "Function `test_wrong_conll`: Tests the parsing of a CoNLL formatted file for sequence labeling and asserts for a parse error.",
                                        "Function `test_jsonl_with_overlapping`: Tests importing a JSONL file with overlapping annotations and checks for errors.",
                                        "Class `TestImportRelationExtractionData`: A test class for importing relation extraction data and asserting the correctness of the imported dataset.",
                                        "Function `setUp`: Initializes project, user, data path, and upload ID for test setup.",
                                        "Function `assert_examples`: Compares the annotations in the dataset with the annotations in the Example objects in the database.",
                                        "Function `assert_parse_error`: Verifies that the response contains at least one error and that certain database objects have a count of 0.",
                                        "Function `test_jsonl`: Tests the import of a dataset in JSONL format for relation extraction, comparing it with a predefined dataset.",
                                        "Class `TestImportSeq2seqData`: A test class for importing and validating sequence-to-sequence data in JSONL, JSON, and CSV formats.",
                                        "Function `assert_examples`: A method that asserts the equality of example counts and labels in a dataset against the database.",
                                        "Function `test_jsonl`: Tests importing dataset from a JSONL file and asserts the examples in the dataset.",
                                        "Function `test_json`: Tests the importing of a dataset from a JSON file and asserts the examples against expected values.",
                                        "Function `test_csv`: A test function that imports a dataset from a CSV file and asserts the examples in the dataset.",
                                        "Class `TestImportIntentDetectionAndSlotFillingData`: A test class for importing intent detection and slot filling data and asserting examples against expected labels.",
                                        "Function `assert_examples`: Asserts the equality of Example objects count and dataset length, then compares categories and entities of each Example object with expected labels.",
                                        "Function `test_entities_and_cats`: Tests the importing of a dataset from a JSONL file and asserts the examples against expected values.",
                                        "Class TestImportImageClassificationData: A test class for importing image classification data into a project, specifically checking for the creation of an Example object.",
                                        "Function `test_example`: A test function that imports an image dataset and asserts the count of Example objects.",
                                        "Class `TestFileTypeChecking`: A test class for checking file types for image classification projects.",
                                        "Function `test_example`: A test function that imports an image file for a specific task and asserts the presence of an unexpected error message in the response."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestImportCatalog`\nCode:\nclass TestImportCatalog(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"catalog\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)\n\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"catalog\", args=[self.project.item.id])",
                                        "Function `test_allows_project_admin_to_list_catalog`\nCode:\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)",
                                        "Function `test_denies_project_staff_to_list_catalog`\nCode:\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestImportCatalog(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"catalog\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)\n\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Class `TestImportCatalog`: Contains test methods to check access permissions for listing catalog items for project admins and staff.",
                                    "code_element_summaries": [
                                        "Class `TestImportCatalog`: Contains test methods to check if project admins can list catalog items and if project staffs are denied access to listing catalog items.",
                                        "Function `setUp`: Initializes the project and URL for a document classification task.",
                                        "Function `test_allows_project_admin_to_list_catalog`: Tests if project admin is able to list the catalog items and check if each item has a \"name\" attribute.",
                                        "Function `test_denies_project_staff_to_list_catalog`: Tests that project staff members are denied access to list the catalog items."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a class ExportedBoundingBox that serves as a proxy model for BoundingBox, offering methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import include, path\n\nfrom .views import DatasetCatalog, DatasetImportAPI\n\nurlpatterns = [\n    path(\"fp/\", include(\"django_drf_filepond.urls\")),\n    path(route=\"projects/<int:project_id>/upload\", view=DatasetImportAPI.as_view(), name=\"upload\"),\n    path(route=\"projects/<int:project_id>/catalog\", view=DatasetCatalog.as_view(), name=\"catalog\"),\n]\n",
                            "summary": "URL patterns for including filepond URLs and handling dataset import and catalog views for specific projects.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `DatasetCatalog`\nCode:\nclass DatasetCatalog(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)",
                                "Class `DatasetImportAPI`\nCode:\nclass DatasetImportAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, request, *args, **kwargs):\n        upload_ids = request.data.pop(\"uploadIds\")\n        file_format = request.data.pop(\"format\")\n        task = request.data.pop(\"task\")\n        celery_task = import_dataset.delay(\n            user_id=request.user.id,\n            project_id=self.kwargs[\"project_id\"],\n            file_format=file_format,\n            upload_ids=upload_ids,\n            task=task,\n            **request.data,\n        )\n        return Response({\"task_id\": celery_task.task_id})",
                                "Function `post`\nCode:\n    def post(self, request, *args, **kwargs):\n        upload_ids = request.data.pop(\"uploadIds\")\n        file_format = request.data.pop(\"format\")\n        task = request.data.pop(\"task\")\n        celery_task = import_dataset.delay(\n            user_id=request.user.id,\n            project_id=self.kwargs[\"project_id\"],\n            file_format=file_format,\n            upload_ids=upload_ids,\n            task=task,\n            **request.data,\n        )\n        return Response({\"task_id\": celery_task.task_id})"
                            ],
                            "code": "from django.shortcuts import get_object_or_404\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom .celery_tasks import import_dataset\nfrom .pipeline.catalog import Options\nfrom projects.models import Project\nfrom projects.permissions import IsProjectAdmin\n\n\nclass DatasetCatalog(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)\n\n\nclass DatasetImportAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, request, *args, **kwargs):\n        upload_ids = request.data.pop(\"uploadIds\")\n        file_format = request.data.pop(\"format\")\n        task = request.data.pop(\"task\")\n        celery_task = import_dataset.delay(\n            user_id=request.user.id,\n            project_id=self.kwargs[\"project_id\"],\n            file_format=file_format,\n            upload_ids=upload_ids,\n            task=task,\n            **request.data,\n        )\n        return Response({\"task_id\": celery_task.task_id})\n",
                            "summary": "Class `DatasetCatalog`: An API view that provides project-specific options based on project type and relation settings, with a `get` function to retrieve options for a specified project ID, and `DatasetImportAPI` class for importing datasets through Celery tasks triggered by the `post` function.",
                            "code_element_summaries": [
                                "Class `DatasetCatalog`: An API view that retrieves options for a project based on project type and relation settings.",
                                "Function `get`: Retrieves options based on project type and relation settings for a specified project ID.",
                                "Class `DatasetImportAPI`: An API view that handles importing datasets by extracting necessary data from the request and initiating a Celery task for dataset import.",
                                "Function `post`: Handles POST requests by extracting necessary data, triggering a Celery task to import a dataset, and returning the task ID."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content defines a class ExportedBoundingBox that extends BoundingBox and provides methods to convert bounding box annotations into dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "examples",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "Class ExtendedUser: A proxy model of User that includes a method to retrieve the full name of the user by combining the first and last names.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ExampleAdmin`\nCode:\nclass ExampleAdmin(admin.ModelAdmin):\n    list_display = (\"text\", \"project\", \"meta\")\n    ordering = (\"project\",)\n    search_fields = (\"text\",)",
                                "Class `CommentAdmin`\nCode:\nclass CommentAdmin(admin.ModelAdmin):\n    list_display = (\n        \"user\",\n        \"example\",\n        \"text\",\n        \"created_at\",\n    )\n    ordering = (\n        \"user\",\n        \"created_at\",\n    )\n    search_fields = (\"user\",)"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import Comment, Example\n\n\nclass ExampleAdmin(admin.ModelAdmin):\n    list_display = (\"text\", \"project\", \"meta\")\n    ordering = (\"project\",)\n    search_fields = (\"text\",)\n\n\nclass CommentAdmin(admin.ModelAdmin):\n    list_display = (\n        \"user\",\n        \"example\",\n        \"text\",\n        \"created_at\",\n    )\n    ordering = (\n        \"user\",\n        \"created_at\",\n    )\n    search_fields = (\"user\",)\n\n\nadmin.site.register(Example, ExampleAdmin)\nadmin.site.register(Comment, CommentAdmin)\n",
                            "summary": "Class ExampleAdmin and Class CommentAdmin are model admin classes that customize the display, ordering, and search fields for the Example and Comment models, respectively.",
                            "code_element_summaries": [
                                "Class ExampleAdmin: Admin model with specified display fields, ordering, and search fields for the Example model.",
                                "Class CommentAdmin: A model admin for managing comments with specified list display, ordering, and search fields."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ExamplesConfig`\nCode:\nclass ExamplesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"examples\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass ExamplesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"examples\"\n",
                            "summary": "Class ExamplesConfig: A Django application configuration class for the \"examples\" app with specific field configurations.",
                            "code_element_summaries": [
                                "Class ExamplesConfig: A Django application configuration class for the \"examples\" app with a specified auto field and name."
                            ],
                            "children": []
                        },
                        {
                            "name": "assignment",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\assignment",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Content includes classes and functions for creating and assigning assignments with various strategies, such as weighted sequential, weighted random, and sampling without replacement, along with a function `bulk_assign` for assigning unassigned examples to members based on specified criteria and a class Workload for workload data management.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "strategies.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\assignment\\strategies.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Assignment`\nCode:\nclass Assignment:\n    user: int\n    example: int",
                                        "Class `StrategyName`\nCode:\nclass StrategyName(enum.Enum):\n    weighted_sequential = enum.auto()\n    weighted_random = enum.auto()\n    sampling_without_replacement = enum.auto()",
                                        "Function `create_assignment_strategy`\nCode:\ndef create_assignment_strategy(strategy_name: StrategyName, dataset_size: int, weights: List[int]) -> \"BaseStrategy\":\n    if strategy_name == StrategyName.weighted_sequential:\n        return WeightedSequentialStrategy(dataset_size, weights)\n    elif strategy_name == StrategyName.weighted_random:\n        return WeightedRandomStrategy(dataset_size, weights)\n    elif strategy_name == StrategyName.sampling_without_replacement:\n        return SamplingWithoutReplacementStrategy(dataset_size, weights)\n    else:\n        raise ValueError(f\"Unknown strategy name: {strategy_name}\")",
                                        "Class `BaseStrategy`\nCode:\nclass BaseStrategy(abc.ABC):\n    @abc.abstractmethod\n    def assign(self) -> List[Assignment]:\n        ...",
                                        "Function `assign`\nCode:\n    def assign(self) -> List[Assignment]:\n        ...",
                                        "Class `WeightedSequentialStrategy`\nCode:\nclass WeightedSequentialStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        cumsum = np.cumsum([0] + self.weights)\n        ratio = np.round(cumsum / 100 * self.dataset_size).astype(int)\n        for user, (start, end) in enumerate(zip(ratio, ratio[1:])):  # Todo: use itertools.pairwise\n            assignments.extend([Assignment(user=user, example=example) for example in range(start, end)])\n        return assignments",
                                        "Function `__init__`\nCode:\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights",
                                        "Function `assign`\nCode:\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        cumsum = np.cumsum([0] + self.weights)\n        ratio = np.round(cumsum / 100 * self.dataset_size).astype(int)\n        for user, (start, end) in enumerate(zip(ratio, ratio[1:])):  # Todo: use itertools.pairwise\n            assignments.extend([Assignment(user=user, example=example) for example in range(start, end)])\n        return assignments",
                                        "Class `WeightedRandomStrategy`\nCode:\nclass WeightedRandomStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        proba = np.array(self.weights) / 100\n        assignees = np.random.choice(range(len(self.weights)), size=self.dataset_size, p=proba)\n        return [Assignment(user=user, example=example) for example, user in enumerate(assignees)]",
                                        "Function `__init__`\nCode:\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights",
                                        "Function `assign`\nCode:\n    def assign(self) -> List[Assignment]:\n        proba = np.array(self.weights) / 100\n        assignees = np.random.choice(range(len(self.weights)), size=self.dataset_size, p=proba)\n        return [Assignment(user=user, example=example) for example, user in enumerate(assignees)]",
                                        "Class `SamplingWithoutReplacementStrategy`\nCode:\nclass SamplingWithoutReplacementStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if not (0 <= sum(weights) <= 100 * len(weights)):\n            raise ValueError(\"Sum of weights must be between 0 and 100 x number of members\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        proba = np.array(self.weights) / 100\n        for user, p in enumerate(proba):\n            count = int(self.dataset_size * p)\n            examples = random.sample(range(self.dataset_size), count)\n            assignments.extend([Assignment(user=user, example=example) for example in examples])\n        return assignments",
                                        "Function `__init__`\nCode:\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if not (0 <= sum(weights) <= 100 * len(weights)):\n            raise ValueError(\"Sum of weights must be between 0 and 100 x number of members\")\n        self.dataset_size = dataset_size\n        self.weights = weights",
                                        "Function `assign`\nCode:\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        proba = np.array(self.weights) / 100\n        for user, p in enumerate(proba):\n            count = int(self.dataset_size * p)\n            examples = random.sample(range(self.dataset_size), count)\n            assignments.extend([Assignment(user=user, example=example) for example in examples])\n        return assignments"
                                    ],
                                    "code": "import abc\nimport dataclasses\nimport enum\nimport random\nfrom typing import List\n\nimport numpy as np\n\n\n@dataclasses.dataclass\nclass Assignment:\n    user: int\n    example: int\n\n\nclass StrategyName(enum.Enum):\n    weighted_sequential = enum.auto()\n    weighted_random = enum.auto()\n    sampling_without_replacement = enum.auto()\n\n\ndef create_assignment_strategy(strategy_name: StrategyName, dataset_size: int, weights: List[int]) -> \"BaseStrategy\":\n    if strategy_name == StrategyName.weighted_sequential:\n        return WeightedSequentialStrategy(dataset_size, weights)\n    elif strategy_name == StrategyName.weighted_random:\n        return WeightedRandomStrategy(dataset_size, weights)\n    elif strategy_name == StrategyName.sampling_without_replacement:\n        return SamplingWithoutReplacementStrategy(dataset_size, weights)\n    else:\n        raise ValueError(f\"Unknown strategy name: {strategy_name}\")\n\n\nclass BaseStrategy(abc.ABC):\n    @abc.abstractmethod\n    def assign(self) -> List[Assignment]:\n        ...\n\n\nclass WeightedSequentialStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        cumsum = np.cumsum([0] + self.weights)\n        ratio = np.round(cumsum / 100 * self.dataset_size).astype(int)\n        for user, (start, end) in enumerate(zip(ratio, ratio[1:])):  # Todo: use itertools.pairwise\n            assignments.extend([Assignment(user=user, example=example) for example in range(start, end)])\n        return assignments\n\n\nclass WeightedRandomStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        proba = np.array(self.weights) / 100\n        assignees = np.random.choice(range(len(self.weights)), size=self.dataset_size, p=proba)\n        return [Assignment(user=user, example=example) for example, user in enumerate(assignees)]\n\n\nclass SamplingWithoutReplacementStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if not (0 <= sum(weights) <= 100 * len(weights)):\n            raise ValueError(\"Sum of weights must be between 0 and 100 x number of members\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        proba = np.array(self.weights) / 100\n        for user, p in enumerate(proba):\n            count = int(self.dataset_size * p)\n            examples = random.sample(range(self.dataset_size), count)\n            assignments.extend([Assignment(user=user, example=example) for example in examples])\n        return assignments\n",
                                    "summary": "Classes and functions for creating and assigning assignments with different strategies, including weighted sequential, weighted random, and sampling without replacement.",
                                    "code_element_summaries": [
                                        "Class Assignment: Represents an assignment with user and example attributes.",
                                        "Class StrategyName: An enumeration representing different strategies, including weighted sequential, weighted random, and sampling without replacement.",
                                        "Function `create_assignment_strategy`: A function that creates and returns a specific assignment strategy based on the input strategy name, dataset size, and weights.",
                                        "Class BaseStrategy: An abstract base class representing a strategy with an abstract method for assigning tasks.",
                                        "Function `assign`: A method that returns a list of Assignment objects.",
                                        "Class `WeightedSequentialStrategy`: A strategy class that assigns examples to users based on weighted sequential distribution.",
                                        "Function `__init__`: Initializes the dataset size and weights list, ensuring that the sum of weights is 100.",
                                        "Function `assign`: Generates a list of assignments based on user weights and dataset size.",
                                        "Class WeightedRandomStrategy: A strategy class that assigns examples to users based on weighted probabilities.",
                                        "Function `__init__`: Initializes the dataset size and weights list, ensuring that the sum of weights is 100.",
                                        "Function `assign`: Generates a list of Assignment objects based on weighted probabilities for assigning users to examples.",
                                        "Class SamplingWithoutReplacementStrategy: A strategy class for assigning examples to users based on given weights without replacement.",
                                        "Function `__init__`: Initializes the dataset size and weights list, ensuring the sum of weights falls within a valid range.",
                                        "Function `assign`: Generates assignments based on user weights and dataset size, returning a list of Assignment objects."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "usecase.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\assignment\\usecase.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `bulk_assign`\nCode:\ndef bulk_assign(project_id: int, strategy_name: StrategyName, member_ids: List[int], weights: List[int]) -> None:\n    project = get_object_or_404(Project, pk=project_id)\n    members = Member.objects.filter(project=project, pk__in=member_ids)\n    if len(members) != len(member_ids):\n        raise ValueError(\"Invalid member ids\")\n    # Sort members by member_ids\n    members = sorted(members, key=lambda m: member_ids.index(m.id))\n    index_to_user = {i: member.user for i, member in enumerate(members)}\n\n    unassigned_examples = Example.objects.filter(project=project, assignments__isnull=True)\n    index_to_example = {i: example for i, example in enumerate(unassigned_examples)}\n    dataset_size = unassigned_examples.count()\n\n    strategy = create_assignment_strategy(strategy_name, dataset_size, weights)\n    assignments = strategy.assign()\n    assignments = [\n        Assignment(\n            project=project,\n            example=index_to_example[assignment.example],\n            assignee=index_to_user[assignment.user],\n        )\n        for assignment in assignments\n    ]\n    Assignment.objects.bulk_create(assignments)"
                                    ],
                                    "code": "from typing import List\n\nfrom django.shortcuts import get_object_or_404\n\nfrom examples.assignment.strategies import StrategyName, create_assignment_strategy\nfrom examples.models import Assignment, Example\nfrom projects.models import Member, Project\n\n\ndef bulk_assign(project_id: int, strategy_name: StrategyName, member_ids: List[int], weights: List[int]) -> None:\n    project = get_object_or_404(Project, pk=project_id)\n    members = Member.objects.filter(project=project, pk__in=member_ids)\n    if len(members) != len(member_ids):\n        raise ValueError(\"Invalid member ids\")\n    # Sort members by member_ids\n    members = sorted(members, key=lambda m: member_ids.index(m.id))\n    index_to_user = {i: member.user for i, member in enumerate(members)}\n\n    unassigned_examples = Example.objects.filter(project=project, assignments__isnull=True)\n    index_to_example = {i: example for i, example in enumerate(unassigned_examples)}\n    dataset_size = unassigned_examples.count()\n\n    strategy = create_assignment_strategy(strategy_name, dataset_size, weights)\n    assignments = strategy.assign()\n    assignments = [\n        Assignment(\n            project=project,\n            example=index_to_example[assignment.example],\n            assignee=index_to_user[assignment.user],\n        )\n        for assignment in assignments\n    ]\n    Assignment.objects.bulk_create(assignments)\n",
                                    "summary": "Function `bulk_assign`: Assigns unassigned examples in a project to members using specified criteria such as assignment strategy, weights, and member IDs.",
                                    "code_element_summaries": [
                                        "Function `bulk_assign`: Assigns unassigned examples in a project to members based on a specified assignment strategy, weights, and member IDs."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "workload.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\assignment\\workload.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Workload`\nCode:\nclass Workload(BaseModel):\n    weight: NonNegativeInt\n    member_id: int",
                                        "Class `WorkloadAllocation`\nCode:\nclass WorkloadAllocation(BaseModel):\n    workloads: List[Workload]\n\n    @property\n    def member_ids(self) -> List[int]:\n        return [w.member_id for w in self.workloads]\n\n    @property\n    def weights(self) -> List[int]:\n        return [w.weight for w in self.workloads]",
                                        "Function `member_ids`\nCode:\n    def member_ids(self) -> List[int]:\n        return [w.member_id for w in self.workloads]",
                                        "Function `weights`\nCode:\n    def weights(self) -> List[int]:\n        return [w.weight for w in self.workloads]"
                                    ],
                                    "code": "from typing import List\n\nfrom pydantic import BaseModel, NonNegativeInt\n\n\nclass Workload(BaseModel):\n    weight: NonNegativeInt\n    member_id: int\n\n\nclass WorkloadAllocation(BaseModel):\n    workloads: List[Workload]\n\n    @property\n    def member_ids(self) -> List[int]:\n        return [w.member_id for w in self.workloads]\n\n    @property\n    def weights(self) -> List[int]:\n        return [w.weight for w in self.workloads]\n",
                                    "summary": "Class Workload: A model for workload data containing weight and member ID attributes, with accompanying functions to extract member IDs and weights from workload allocations.",
                                    "code_element_summaries": [
                                        "Class Workload: Represents workload data with weight and member ID attributes.",
                                        "Class `WorkloadAllocation`: A model representing workload allocations with properties for member IDs and weights extracted from a list of workloads.",
                                        "Function `member_ids`: Returns a list of member IDs extracted from the member_id attribute of each workload in the workloads list.",
                                        "Function `weights`: Returns a list of weights extracted from the workloads associated with the object."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\assignment\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a class ExportedBoundingBox with methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "filters.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\filters.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ExampleFilter`\nCode:\nclass ExampleFilter(FilterSet):\n    confirmed = BooleanFilter(field_name=\"states\", method=\"filter_by_state\")\n    label = CharFilter(method=\"filter_by_label\")\n    assignee = CharFilter(method=\"filter_by_assignee\")\n\n    def filter_by_state(self, queryset, field_name, is_confirmed: bool):\n        queryset = queryset.annotate(\n            num_confirm=Count(\n                expression=field_name,\n                filter=Q(**{f\"{field_name}__confirmed_by\": self.request.user})\n                | Q(project__collaborative_annotation=True),\n            )\n        )\n        if is_confirmed:\n            queryset = queryset.filter(num_confirm__gte=1)\n        else:\n            queryset = queryset.filter(num_confirm__lte=0)\n        return queryset\n\n    def filter_by_label(self, queryset: QuerySet, field_name: str, label: str) -> QuerySet:\n        \"\"\"Filter examples by a given label name.\n\n        This performs filtering on all of the following labels at once:\n        - categories\n        - spans\n        - relations\n        - bboxes\n        - segmentations\n\n        Todo: Consider project type to make filtering more efficient.\n\n        Args:\n            queryset (QuerySet): QuerySet to filter.\n            field_name (str): This equals to `label`.\n            label (str): The label name to filter.\n\n        Returns:\n            QuerySet: Filtered examples.\n        \"\"\"\n        queryset = queryset.filter(\n            Q(categories__label__text=label)\n            | Q(spans__label__text=label)\n            | Q(relations__type__text=label)\n            | Q(bboxes__label__text=label)\n            | Q(segmentations__label__text=label)\n        )\n        return queryset\n\n    def filter_by_assignee(self, queryset: QuerySet, field_name: str, assignee: str) -> QuerySet:\n        return queryset.filter(assignments__assignee__username=assignee)\n\n    class Meta:\n        model = Example\n        fields = (\"project\", \"text\", \"created_at\", \"updated_at\", \"label\", \"assignee\")",
                                "Function `filter_by_state`\nCode:\n    def filter_by_state(self, queryset, field_name, is_confirmed: bool):\n        queryset = queryset.annotate(\n            num_confirm=Count(\n                expression=field_name,\n                filter=Q(**{f\"{field_name}__confirmed_by\": self.request.user})\n                | Q(project__collaborative_annotation=True),\n            )\n        )\n        if is_confirmed:\n            queryset = queryset.filter(num_confirm__gte=1)\n        else:\n            queryset = queryset.filter(num_confirm__lte=0)\n        return queryset",
                                "Function `filter_by_label`: Filter examples by a given label name.\nCode:\n    def filter_by_label(self, queryset: QuerySet, field_name: str, label: str) -> QuerySet:\n        \"\"\"Filter examples by a given label name.\n\n        This performs filtering on all of the following labels at once:\n        - categories\n        - spans\n        - relations\n        - bboxes\n        - segmentations\n\n        Todo: Consider project type to make filtering more efficient.\n\n        Args:\n            queryset (QuerySet): QuerySet to filter.\n            field_name (str): This equals to `label`.\n            label (str): The label name to filter.\n\n        Returns:\n            QuerySet: Filtered examples.\n        \"\"\"\n        queryset = queryset.filter(\n            Q(categories__label__text=label)\n            | Q(spans__label__text=label)\n            | Q(relations__type__text=label)\n            | Q(bboxes__label__text=label)\n            | Q(segmentations__label__text=label)\n        )\n        return queryset",
                                "Function `filter_by_assignee`\nCode:\n    def filter_by_assignee(self, queryset: QuerySet, field_name: str, assignee: str) -> QuerySet:\n        return queryset.filter(assignments__assignee__username=assignee)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Example\n        fields = (\"project\", \"text\", \"created_at\", \"updated_at\", \"label\", \"assignee\")"
                            ],
                            "code": "from django.db.models import Count, Q, QuerySet\nfrom django_filters.rest_framework import BooleanFilter, CharFilter, FilterSet\n\nfrom .models import Example\n\n\nclass ExampleFilter(FilterSet):\n    confirmed = BooleanFilter(field_name=\"states\", method=\"filter_by_state\")\n    label = CharFilter(method=\"filter_by_label\")\n    assignee = CharFilter(method=\"filter_by_assignee\")\n\n    def filter_by_state(self, queryset, field_name, is_confirmed: bool):\n        queryset = queryset.annotate(\n            num_confirm=Count(\n                expression=field_name,\n                filter=Q(**{f\"{field_name}__confirmed_by\": self.request.user})\n                | Q(project__collaborative_annotation=True),\n            )\n        )\n        if is_confirmed:\n            queryset = queryset.filter(num_confirm__gte=1)\n        else:\n            queryset = queryset.filter(num_confirm__lte=0)\n        return queryset\n\n    def filter_by_label(self, queryset: QuerySet, field_name: str, label: str) -> QuerySet:\n        \"\"\"Filter examples by a given label name.\n\n        This performs filtering on all of the following labels at once:\n        - categories\n        - spans\n        - relations\n        - bboxes\n        - segmentations\n\n        Todo: Consider project type to make filtering more efficient.\n\n        Args:\n            queryset (QuerySet): QuerySet to filter.\n            field_name (str): This equals to `label`.\n            label (str): The label name to filter.\n\n        Returns:\n            QuerySet: Filtered examples.\n        \"\"\"\n        queryset = queryset.filter(\n            Q(categories__label__text=label)\n            | Q(spans__label__text=label)\n            | Q(relations__type__text=label)\n            | Q(bboxes__label__text=label)\n            | Q(segmentations__label__text=label)\n        )\n        return queryset\n\n    def filter_by_assignee(self, queryset: QuerySet, field_name: str, assignee: str) -> QuerySet:\n        return queryset.filter(assignments__assignee__username=assignee)\n\n    class Meta:\n        model = Example\n        fields = (\"project\", \"text\", \"created_at\", \"updated_at\", \"label\", \"assignee\")\n",
                            "summary": "Class `ExampleFilter`: A FilterSet class for filtering Example instances based on states, labels, and assignees, with methods to filter by state, label, and assignee fields, and metadata defined for the Example model.",
                            "code_element_summaries": [
                                "Class `ExampleFilter`: A FilterSet class for filtering Example instances based on states, labels, and assignees.",
                                "Function `filter_by_state`: A method to filter a queryset based on whether a field is confirmed or not.",
                                "Function `filter_by_label`: A function that filters examples by a given label name across multiple fields in a QuerySet.",
                                "Function `filter_by_assignee`: Filters a queryset based on the assignee's username.",
                                "Class Meta: Defines metadata for the Example model including specific fields to be included in queries and representations."
                            ],
                            "children": []
                        },
                        {
                            "name": "managers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\managers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ExampleManager`\nCode:\nclass ExampleManager(Manager):\n    def bulk_create(self, objs, batch_size=None, ignore_conflicts=False):\n        super().bulk_create(objs, batch_size=batch_size, ignore_conflicts=ignore_conflicts)\n        uuids = [data.uuid for data in objs]\n        examples = self.in_bulk(uuids, field_name=\"uuid\")\n        return [examples[uid] for uid in uuids]",
                                "Function `bulk_create`\nCode:\n    def bulk_create(self, objs, batch_size=None, ignore_conflicts=False):\n        super().bulk_create(objs, batch_size=batch_size, ignore_conflicts=ignore_conflicts)\n        uuids = [data.uuid for data in objs]\n        examples = self.in_bulk(uuids, field_name=\"uuid\")\n        return [examples[uid] for uid in uuids]",
                                "Class `ExampleStateManager`\nCode:\nclass ExampleStateManager(Manager):\n    def count_done(self, examples, user=None):\n        if user:\n            queryset = self.filter(example_id__in=examples, confirmed_by=user)\n        else:\n            queryset = self.filter(example_id__in=examples)\n        return queryset.distinct().values(\"example\").count()\n\n    def measure_member_progress(self, examples, members):\n        done_count = (\n            self.filter(example_id__in=examples).values(\"confirmed_by__username\").annotate(total=Count(\"confirmed_by\"))\n        )\n        response = {\n            \"total\": examples.count(),\n            \"progress\": [{\"user\": obj[\"confirmed_by__username\"], \"done\": obj[\"total\"]} for obj in done_count],\n        }\n        members_with_progress = {o[\"confirmed_by__username\"] for o in done_count}\n        for member in members:\n            if member.username not in members_with_progress:\n                response[\"progress\"].append({\"user\": member.username, \"done\": 0})\n        return response",
                                "Function `count_done`\nCode:\n    def count_done(self, examples, user=None):\n        if user:\n            queryset = self.filter(example_id__in=examples, confirmed_by=user)\n        else:\n            queryset = self.filter(example_id__in=examples)\n        return queryset.distinct().values(\"example\").count()",
                                "Function `measure_member_progress`\nCode:\n    def measure_member_progress(self, examples, members):\n        done_count = (\n            self.filter(example_id__in=examples).values(\"confirmed_by__username\").annotate(total=Count(\"confirmed_by\"))\n        )\n        response = {\n            \"total\": examples.count(),\n            \"progress\": [{\"user\": obj[\"confirmed_by__username\"], \"done\": obj[\"total\"]} for obj in done_count],\n        }\n        members_with_progress = {o[\"confirmed_by__username\"] for o in done_count}\n        for member in members:\n            if member.username not in members_with_progress:\n                response[\"progress\"].append({\"user\": member.username, \"done\": 0})\n        return response"
                            ],
                            "code": "from django.db.models import Count, Manager\n\n\nclass ExampleManager(Manager):\n    def bulk_create(self, objs, batch_size=None, ignore_conflicts=False):\n        super().bulk_create(objs, batch_size=batch_size, ignore_conflicts=ignore_conflicts)\n        uuids = [data.uuid for data in objs]\n        examples = self.in_bulk(uuids, field_name=\"uuid\")\n        return [examples[uid] for uid in uuids]\n\n\nclass ExampleStateManager(Manager):\n    def count_done(self, examples, user=None):\n        if user:\n            queryset = self.filter(example_id__in=examples, confirmed_by=user)\n        else:\n            queryset = self.filter(example_id__in=examples)\n        return queryset.distinct().values(\"example\").count()\n\n    def measure_member_progress(self, examples, members):\n        done_count = (\n            self.filter(example_id__in=examples).values(\"confirmed_by__username\").annotate(total=Count(\"confirmed_by\"))\n        )\n        response = {\n            \"total\": examples.count(),\n            \"progress\": [{\"user\": obj[\"confirmed_by__username\"], \"done\": obj[\"total\"]} for obj in done_count],\n        }\n        members_with_progress = {o[\"confirmed_by__username\"] for o in done_count}\n        for member in members:\n            if member.username not in members_with_progress:\n                response[\"progress\"].append({\"user\": member.username, \"done\": 0})\n        return response\n",
                            "summary": "Class `ExampleManager`: A custom manager for bulk creating and retrieving objects by UUIDs, and `ExampleStateManager`: A manager for tracking progress and counting confirmed examples within a group.",
                            "code_element_summaries": [
                                "Class `ExampleManager`: A custom manager that provides a method for bulk creating objects and retrieving them based on UUIDs.",
                                "Function `bulk_create`: A method that bulk creates objects, retrieves their UUIDs, and returns examples based on those UUIDs.",
                                "Class `ExampleStateManager`: A manager class that provides methods for counting done examples and measuring member progress within a group of examples.",
                                "Function `count_done`: A function that counts the number of confirmed examples by a specific user or all users.",
                                "Function `measure_member_progress`: Calculates the progress of members based on confirmed examples and returns a response with the total number of examples and progress for each member."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: Various migration classes that handle database schema changes, including modifying fields, adding new fields, and creating new models.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0034_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Example\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"uuid\", models.UUIDField(db_index=True, default=uuid.uuid4, editable=False, unique=True)),\n                        (\"meta\", models.JSONField(default=dict)),\n                        (\"filename\", models.FileField(default=\".\", max_length=1024, upload_to=\"\")),\n                        (\"text\", models.TextField(blank=True, null=True)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"annotations_approved_by\",\n                            models.ForeignKey(\n                                blank=True,\n                                null=True,\n                                on_delete=django.db.models.deletion.SET_NULL,\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"api.project\"\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"Comment\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.TextField()),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"comments\",\n                                to=\"examples.example\",\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"ExampleState\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"confirmed_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"confirmed_by\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"states\",\n                                to=\"examples.example\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"example\", \"confirmed_by\")},\n                    },\n                ),\n            ]\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-28 02:46\n\nimport uuid\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0034_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Example\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"uuid\", models.UUIDField(db_index=True, default=uuid.uuid4, editable=False, unique=True)),\n                        (\"meta\", models.JSONField(default=dict)),\n                        (\"filename\", models.FileField(default=\".\", max_length=1024, upload_to=\"\")),\n                        (\"text\", models.TextField(blank=True, null=True)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"annotations_approved_by\",\n                            models.ForeignKey(\n                                blank=True,\n                                null=True,\n                                on_delete=django.db.models.deletion.SET_NULL,\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"api.project\"\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"Comment\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.TextField()),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"comments\",\n                                to=\"examples.example\",\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"ExampleState\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"confirmed_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"confirmed_by\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"states\",\n                                to=\"examples.example\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"example\", \"confirmed_by\")},\n                    },\n                ),\n            ]\n        )\n    ]\n",
                                    "summary": "Class Migration: A file defining the initial database schema for models Example, Comment, and ExampleState including fields and relationships.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration file that defines the initial database schema for models Example, Comment, and ExampleState with specific fields and relationships."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_alter_example_project.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0002_alter_example_project.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"examples\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"example\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"examples\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"example\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class responsible for managing database schema changes associated with separating database and state operations.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that handles database schema changes related to separating database and state operations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_alter_example_filename.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0003_alter_example_filename.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0002_alter_example_project\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"filename\",\n            field=models.FileField(\n                default=\".\",\n                max_length=1024,\n                storage=django_drf_filepond.models.FilePondLocalStoredStorage(),\n                upload_to=\"\",\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-04-05 02:46\n\nimport django_drf_filepond.models\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0002_alter_example_project\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"filename\",\n            field=models.FileField(\n                default=\".\",\n                max_length=1024,\n                storage=django_drf_filepond.models.FilePondLocalStoredStorage(),\n                upload_to=\"\",\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that modifies the \"filename\" field in the \"example\" model with changes to default value, max length, storage, and upload location.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that alters the field \"filename\" in the \"example\" model by changing its default value, max length, storage, and upload location."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_example_upload_name.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0004_example_upload_name.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0003_alter_example_filename\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"upload_name\",\n            field=models.CharField(blank=True, max_length=512, null=True),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-04-05 02:46\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0003_alter_example_filename\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"upload_name\",\n            field=models.CharField(blank=True, max_length=512, null=True),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class adding a new field \"upload_name\" to the \"example\" model with specified dependencies.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that adds a new field \"upload_name\" to the \"example\" model with specified dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_auto_20220405_0252.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0005_auto_20220405_0252.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `store_filename`\nCode:\ndef store_filename(apps, schema_editor):\n    Example = apps.get_model(\"examples\", \"Example\")\n    for example in Example.objects.all():\n        example.upload_name = os.path.basename(example.filename.name)\n        example.save()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0004_example_upload_name\"),\n    ]\n\n    operations = [migrations.RunPython(code=store_filename, reverse_code=migrations.RunPython.noop)]"
                                    ],
                                    "code": "import os\n\nfrom django.db import migrations\n\n\ndef store_filename(apps, schema_editor):\n    Example = apps.get_model(\"examples\", \"Example\")\n    for example in Example.objects.all():\n        example.upload_name = os.path.basename(example.filename.name)\n        example.save()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0004_example_upload_name\"),\n    ]\n\n    operations = [migrations.RunPython(code=store_filename, reverse_code=migrations.RunPython.noop)]\n",
                                    "summary": "Class Migration: Represents a migration operation with dependencies and includes a function to store filenames retrieved from the Example model.",
                                    "code_element_summaries": [
                                        "Function `store_filename`: A function that retrieves the base name of the file from the Example model's filename field and saves it to the upload_name field.",
                                        "Class Migration: Represents a migration operation with dependencies and a function to store filenames."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0006_alter_example_upload_name.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0006_alter_example_upload_name.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0005_auto_20220405_0252\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"upload_name\",\n            field=models.CharField(max_length=512),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-04-05 02:59\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0005_auto_20220405_0252\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"upload_name\",\n            field=models.CharField(max_length=512),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that modifies the \"upload_name\" field in the \"example\" model to have a maximum length of 512 characters.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that alters the field \"upload_name\" in the \"example\" model with a maximum length of 512 characters."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0007_example_score.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0007_example_score.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"score\",\n            field=models.FloatField(default=100),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.7 on 2022-10-21 07:37\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"score\",\n            field=models.FloatField(default=100),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that adds a new field \"score\" with a default value of 100 to the Example model.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that adds a new field \"score\" with a default value of 100 to the Example model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0008_assignment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0008_assignment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0008_project_allow_member_to_create_label_type_and_more\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"examples\", \"0007_example_score\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Assignment\",\n            fields=[\n                (\"id\", models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"assignee\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"assignments\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"assignments\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"assignee\")},\n            },\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.1.10 on 2023-07-24 05:39\n\nfrom django.conf import settings\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport uuid\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0008_project_allow_member_to_create_label_type_and_more\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"examples\", \"0007_example_score\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Assignment\",\n            fields=[\n                (\"id\", models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"assignee\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"assignments\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"assignments\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"assignee\")},\n            },\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration file that creates a model for Assignments with specific fields for tracking assignment details.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration file that creates a model for Assignments with fields such as id, created_at, updated_at, assignee, example, and project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a proxy model ExportedBoundingBox that includes methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Example`\nCode:\nclass Example(models.Model):\n    objects = ExampleManager()\n\n    uuid = models.UUIDField(default=uuid.uuid4, editable=False, db_index=True, unique=True)\n    meta = models.JSONField(default=dict)\n    filename = models.FileField(default=\".\", max_length=1024, storage=DrfFilePondStoredStorage())\n    upload_name = models.CharField(max_length=512)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"examples\")\n    annotations_approved_by = models.ForeignKey(to=User, on_delete=models.SET_NULL, null=True, blank=True)\n    text = models.TextField(null=True, blank=True)\n    score = models.FloatField(default=100)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    @property\n    def comment_count(self):\n        return Comment.objects.filter(example=self.id).count()\n\n    @property\n    def data(self):\n        if self.project.is_text_project:\n            return self.text\n        else:\n            return str(self.filename)\n\n    class Meta:\n        ordering = [\"created_at\"]",
                                "Function `comment_count`\nCode:\n    def comment_count(self):\n        return Comment.objects.filter(example=self.id).count()",
                                "Function `data`\nCode:\n    def data(self):\n        if self.project.is_text_project:\n            return self.text\n        else:\n            return str(self.filename)",
                                "Class `Meta`\nCode:\n    class Meta:\n        ordering = [\"created_at\"]",
                                "Class `Assignment`\nCode:\nclass Assignment(models.Model):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"assignments\")\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"assignments\")\n    assignee = models.ForeignKey(to=User, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = ((\"example\", \"assignee\"),)\n\n    def clean(self):\n        # assignee must be a member of the project\n        if not self.project.members.filter(id=self.assignee.id).exists():\n            raise ValidationError(\"Assignee must be a member of the project\")\n\n        # example must be in the project\n        if not self.project.examples.filter(id=self.example.id).exists():\n            raise ValidationError(\"Example must be in the project\")\n\n        return super().clean()",
                                "Class `Meta`\nCode:\n    class Meta:\n        unique_together = ((\"example\", \"assignee\"),)",
                                "Function `clean`\nCode:\n    def clean(self):\n        # assignee must be a member of the project\n        if not self.project.members.filter(id=self.assignee.id).exists():\n            raise ValidationError(\"Assignee must be a member of the project\")\n\n        # example must be in the project\n        if not self.project.examples.filter(id=self.example.id).exists():\n            raise ValidationError(\"Example must be in the project\")\n\n        return super().clean()",
                                "Class `ExampleState`\nCode:\nclass ExampleState(models.Model):\n    objects = ExampleStateManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"states\")\n    confirmed_by = models.ForeignKey(to=User, on_delete=models.CASCADE)\n    confirmed_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = ((\"example\", \"confirmed_by\"),)",
                                "Class `Meta`\nCode:\n    class Meta:\n        unique_together = ((\"example\", \"confirmed_by\"),)",
                                "Class `Comment`\nCode:\nclass Comment(models.Model):\n    text = models.TextField()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"comments\")\n    user = models.ForeignKey(to=User, on_delete=models.CASCADE, null=True)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    @property\n    def username(self):\n        return self.user.username\n\n    class Meta:\n        ordering = [\"created_at\"]",
                                "Function `username`\nCode:\n    def username(self):\n        return self.user.username",
                                "Class `Meta`\nCode:\n    class Meta:\n        ordering = [\"created_at\"]"
                            ],
                            "code": "import uuid\n\nfrom django.contrib.auth.models import User\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django_drf_filepond.models import DrfFilePondStoredStorage\n\nfrom .managers import ExampleManager, ExampleStateManager\nfrom projects.models import Project\n\n\nclass Example(models.Model):\n    objects = ExampleManager()\n\n    uuid = models.UUIDField(default=uuid.uuid4, editable=False, db_index=True, unique=True)\n    meta = models.JSONField(default=dict)\n    filename = models.FileField(default=\".\", max_length=1024, storage=DrfFilePondStoredStorage())\n    upload_name = models.CharField(max_length=512)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"examples\")\n    annotations_approved_by = models.ForeignKey(to=User, on_delete=models.SET_NULL, null=True, blank=True)\n    text = models.TextField(null=True, blank=True)\n    score = models.FloatField(default=100)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    @property\n    def comment_count(self):\n        return Comment.objects.filter(example=self.id).count()\n\n    @property\n    def data(self):\n        if self.project.is_text_project:\n            return self.text\n        else:\n            return str(self.filename)\n\n    class Meta:\n        ordering = [\"created_at\"]\n\n\nclass Assignment(models.Model):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"assignments\")\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"assignments\")\n    assignee = models.ForeignKey(to=User, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = ((\"example\", \"assignee\"),)\n\n    def clean(self):\n        # assignee must be a member of the project\n        if not self.project.members.filter(id=self.assignee.id).exists():\n            raise ValidationError(\"Assignee must be a member of the project\")\n\n        # example must be in the project\n        if not self.project.examples.filter(id=self.example.id).exists():\n            raise ValidationError(\"Example must be in the project\")\n\n        return super().clean()\n\n\nclass ExampleState(models.Model):\n    objects = ExampleStateManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"states\")\n    confirmed_by = models.ForeignKey(to=User, on_delete=models.CASCADE)\n    confirmed_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = ((\"example\", \"confirmed_by\"),)\n\n\nclass Comment(models.Model):\n    text = models.TextField()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"comments\")\n    user = models.ForeignKey(to=User, on_delete=models.CASCADE, null=True)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    @property\n    def username(self):\n        return self.user.username\n\n    class Meta:\n        ordering = [\"created_at\"]\n",
                            "summary": "Class Example: Represents examples with various fields and methods for retrieving comment count and data based on project type, with Meta defining instance ordering based on creation timestamp. \nClass Assignment: Represents assignments with specific project, example, assignee, and validation rules, with Meta defining unique constraints and function `clean` for validation. \nClass ExampleState: Represents example states with references to example, confirming user, and confirmation timestamp, with Meta specifying unique combination of fields. \nClass Comment: Represents comments with text, example reference, user reference, creation and update timestamps, and a method for retrieving username, with Meta defining instance ordering based on creation timestamp.",
                            "code_element_summaries": [
                                "Class Example: Represents examples with various fields like UUID, metadata, filename, project, annotations, text, score, creation/update timestamps, and methods to retrieve comment count and data based on project type.",
                                "Function `comment_count`: Returns the total number of comments associated with a specific example.",
                                "Function `data`: Returns the text if the project is a text project, otherwise returns the filename as a string.",
                                "Class Meta: Defines the ordering of instances based on the \"created_at\" attribute.",
                                "Class Assignment: Represents an assignment with specific project, example, assignee, creation and update timestamps, and validation rules for assignee and example membership in the project.",
                                "Class Meta: Defines unique constraints for the fields \"example\" and \"assignee\" in the model.",
                                "Function `clean`: Validates that the assignee and example belong to the project before saving.",
                                "Class ExampleState: Represents the state of an example with references to the example itself, the user who confirmed it, and the confirmation timestamp.",
                                "Class Meta: Specifies that the combination of \"example\" and \"confirmed_by\" fields should be unique together.",
                                "Class Comment: Represents comments with text, example reference, user reference, creation and update timestamps, and a property for the username of the user.",
                                "Function `username`: Returns the username of a user associated with the object.",
                                "Class Meta: Defines the ordering of instances based on the 'created_at' attribute."
                            ],
                            "children": []
                        },
                        {
                            "name": "permissions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\permissions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `IsOwnComment`\nCode:\nclass IsOwnComment(BasePermission):\n    @classmethod\n    def has_object_permission(cls, request, view, obj):\n        if request.user.is_superuser:\n            return True\n\n        return obj.user.id == request.user.id",
                                "Function `has_object_permission`\nCode:\n    def has_object_permission(cls, request, view, obj):\n        if request.user.is_superuser:\n            return True\n\n        return obj.user.id == request.user.id"
                            ],
                            "code": "from rest_framework.permissions import BasePermission\n\n\nclass IsOwnComment(BasePermission):\n    @classmethod\n    def has_object_permission(cls, request, view, obj):\n        if request.user.is_superuser:\n            return True\n\n        return obj.user.id == request.user.id\n",
                            "summary": "Class IsOwnComment: A permission class for verifying if the requesting user owns the comment, with a function to check object permissions based on user roles and ownership.",
                            "code_element_summaries": [
                                "Class IsOwnComment: A permission class that checks if the user making the request is the owner of the comment.",
                                "Function `has_object_permission`: Determines whether a user has permission to access an object based on user roles and ownership."
                            ],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `CommentSerializer`\nCode:\nclass CommentSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Comment\n        fields = (\n            \"id\",\n            \"user\",\n            \"username\",\n            \"example\",\n            \"text\",\n            \"created_at\",\n        )\n        read_only_fields = (\"user\", \"example\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Comment\n        fields = (\n            \"id\",\n            \"user\",\n            \"username\",\n            \"example\",\n            \"text\",\n            \"created_at\",\n        )\n        read_only_fields = (\"user\", \"example\")",
                                "Class `AssignmentSerializer`\nCode:\nclass AssignmentSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Assignment\n        fields = (\"id\", \"assignee\", \"example\", \"created_at\", \"updated_at\")\n        read_only_fields = (\"id\", \"created_at\", \"updated_at\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Assignment\n        fields = (\"id\", \"assignee\", \"example\", \"created_at\", \"updated_at\")\n        read_only_fields = (\"id\", \"created_at\", \"updated_at\")",
                                "Class `ExampleSerializer`\nCode:\nclass ExampleSerializer(serializers.ModelSerializer):\n    annotation_approver = serializers.SerializerMethodField()\n    is_confirmed = serializers.SerializerMethodField()\n    assignments = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_annotation_approver(cls, instance):\n        approver = instance.annotations_approved_by\n        return approver.username if approver else None\n\n    def get_is_confirmed(self, instance):\n        user = self.context.get(\"request\").user\n        if instance.project.collaborative_annotation:\n            states = instance.states.all()\n        else:\n            states = instance.states.filter(confirmed_by_id=user.id)\n        return states.count() > 0\n\n    def get_assignments(self, instance):\n        return [\n            {\n                \"id\": assignment.id,\n                \"assignee\": assignment.assignee.username,\n                \"assignee_id\": assignment.assignee.id,\n            }\n            for assignment in instance.assignments.all()\n        ]\n\n    class Meta:\n        model = Example\n        fields = [\n            \"id\",\n            \"filename\",\n            \"meta\",\n            \"annotation_approver\",\n            \"comment_count\",\n            \"text\",\n            \"is_confirmed\",\n            \"upload_name\",\n            \"score\",\n            \"assignments\",\n        ]\n        read_only_fields = [\"filename\", \"is_confirmed\", \"upload_name\", \"assignments\"]",
                                "Function `get_annotation_approver`\nCode:\n    def get_annotation_approver(cls, instance):\n        approver = instance.annotations_approved_by\n        return approver.username if approver else None",
                                "Function `get_is_confirmed`\nCode:\n    def get_is_confirmed(self, instance):\n        user = self.context.get(\"request\").user\n        if instance.project.collaborative_annotation:\n            states = instance.states.all()\n        else:\n            states = instance.states.filter(confirmed_by_id=user.id)\n        return states.count() > 0",
                                "Function `get_assignments`\nCode:\n    def get_assignments(self, instance):\n        return [\n            {\n                \"id\": assignment.id,\n                \"assignee\": assignment.assignee.username,\n                \"assignee_id\": assignment.assignee.id,\n            }\n            for assignment in instance.assignments.all()\n        ]",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Example\n        fields = [\n            \"id\",\n            \"filename\",\n            \"meta\",\n            \"annotation_approver\",\n            \"comment_count\",\n            \"text\",\n            \"is_confirmed\",\n            \"upload_name\",\n            \"score\",\n            \"assignments\",\n        ]\n        read_only_fields = [\"filename\", \"is_confirmed\", \"upload_name\", \"assignments\"]",
                                "Class `ExampleStateSerializer`\nCode:\nclass ExampleStateSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = ExampleState\n        fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")\n        read_only_fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = ExampleState\n        fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")\n        read_only_fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")"
                            ],
                            "code": "from rest_framework import serializers\n\nfrom .models import Assignment, Comment, Example, ExampleState\n\n\nclass CommentSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Comment\n        fields = (\n            \"id\",\n            \"user\",\n            \"username\",\n            \"example\",\n            \"text\",\n            \"created_at\",\n        )\n        read_only_fields = (\"user\", \"example\")\n\n\nclass AssignmentSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Assignment\n        fields = (\"id\", \"assignee\", \"example\", \"created_at\", \"updated_at\")\n        read_only_fields = (\"id\", \"created_at\", \"updated_at\")\n\n\nclass ExampleSerializer(serializers.ModelSerializer):\n    annotation_approver = serializers.SerializerMethodField()\n    is_confirmed = serializers.SerializerMethodField()\n    assignments = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_annotation_approver(cls, instance):\n        approver = instance.annotations_approved_by\n        return approver.username if approver else None\n\n    def get_is_confirmed(self, instance):\n        user = self.context.get(\"request\").user\n        if instance.project.collaborative_annotation:\n            states = instance.states.all()\n        else:\n            states = instance.states.filter(confirmed_by_id=user.id)\n        return states.count() > 0\n\n    def get_assignments(self, instance):\n        return [\n            {\n                \"id\": assignment.id,\n                \"assignee\": assignment.assignee.username,\n                \"assignee_id\": assignment.assignee.id,\n            }\n            for assignment in instance.assignments.all()\n        ]\n\n    class Meta:\n        model = Example\n        fields = [\n            \"id\",\n            \"filename\",\n            \"meta\",\n            \"annotation_approver\",\n            \"comment_count\",\n            \"text\",\n            \"is_confirmed\",\n            \"upload_name\",\n            \"score\",\n            \"assignments\",\n        ]\n        read_only_fields = [\"filename\", \"is_confirmed\", \"upload_name\", \"assignments\"]\n\n\nclass ExampleStateSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = ExampleState\n        fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")\n        read_only_fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")\n",
                            "summary": "Class CommentSerializer: A serializer for the Comment model with specified fields and read-only attributes, along with metadata defining the model and its fields.\nClass AssignmentSerializer: A serializer for the Assignment model with specified fields and read-only attributes, including metadata defining the model and its fields.\nClass ExampleSerializer: A model serializer for the Example model that includes annotation_approver, is_confirmed, and assignments fields in JSON format, along with functions to retrieve approver, confirmation status, and assignments information.\nClass ExampleStateSerializer: A serializer for the ExampleState model with specified fields and read-only attributes, including metadata defining the model and its fields.",
                            "code_element_summaries": [
                                "Class CommentSerializer: A serializer class for Comment model with specified fields and read-only fields.",
                                "Class Meta: Defines metadata for the Comment model including fields, read-only fields, and the model itself.",
                                "Class AssignmentSerializer: A serializer for the Assignment model with specified fields and read-only attributes.",
                                "Class Meta: Defines metadata for the Assignment model including fields to include in serialization and read-only fields.",
                                "Class `ExampleSerializer`: A model serializer that serializes instances of Example model into a JSON format including fields like annotation_approver, is_confirmed, and assignments.",
                                "Function get_annotation_approver: Returns the username of the approver for a given instance's annotations or None if no approver is found.",
                                "Function `get_is_confirmed`: Returns a boolean value indicating whether the annotation instance has been confirmed by a user in a collaborative annotation project.",
                                "Function `get_assignments`: Retrieves a list of assignments with their IDs and assignees' usernames and IDs from a given instance.",
                                "Class Meta: Defines the model and fields for the Example class with specified read-only fields.",
                                "Class `ExampleStateSerializer`: A serializer class for the ExampleState model that specifies fields and read-only fields for serialization.",
                                "Class Meta: Defines metadata options for the ExampleState model, specifying the model, fields, and read-only fields."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content includes various test classes and functions related to CRUD operations, permissions, and collaborative annotation in a project, with a focus on example lists, comments, and assignments.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_assignment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_assignment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestAssignmentList`\nCode:\nclass TestAssignmentList(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        make_assignment(self.project.item, self.example, self.project.admin)\n        self.data = {\"example\": self.example.id, \"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_list\", args=[self.project.item.id])\n\n    def test_allow_project_member_to_list_assignments(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_denies_non_project_member_to_list_assignments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_assignments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_assign(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"example\"], self.data[\"example\"])\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])\n\n    def test_denies_non_admin_to_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        make_assignment(self.project.item, self.example, self.project.admin)\n        self.data = {\"example\": self.example.id, \"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_list\", args=[self.project.item.id])",
                                        "Function `test_allow_project_member_to_list_assignments`\nCode:\n    def test_allow_project_member_to_list_assignments(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)",
                                        "Function `test_denies_non_project_member_to_list_assignments`\nCode:\n    def test_denies_non_project_member_to_list_assignments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_list_assignments`\nCode:\n    def test_denies_unauthenticated_user_to_list_assignments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_assign`\nCode:\n    def test_allows_project_admin_to_assign(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"example\"], self.data[\"example\"])\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])",
                                        "Function `test_denies_non_admin_to_assign`\nCode:\n    def test_denies_non_admin_to_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_assign`\nCode:\n    def test_denies_non_project_member_to_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_assign`\nCode:\n    def test_denies_unauthenticated_user_to_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestAssignmentDetail`\nCode:\nclass TestAssignmentDetail(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        assignment = make_assignment(self.project.item, example, self.project.admin)\n        self.data = {\"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_detail\", args=[self.project.item.id, assignment.id])\n\n    def test_allows_project_member_to_get_assignment(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_denies_non_project_member_to_get_assignment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_assignment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_reassign(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])\n\n    def test_denies_non_admin_to_reassign(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_reassign(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_reassign(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_unassign(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_admin_to_unassign(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_unassign(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_unassign(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        assignment = make_assignment(self.project.item, example, self.project.admin)\n        self.data = {\"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_detail\", args=[self.project.item.id, assignment.id])",
                                        "Function `test_allows_project_member_to_get_assignment`\nCode:\n    def test_allows_project_member_to_get_assignment(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)",
                                        "Function `test_denies_non_project_member_to_get_assignment`\nCode:\n    def test_denies_non_project_member_to_get_assignment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_get_assignment`\nCode:\n    def test_denies_unauthenticated_user_to_get_assignment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_reassign`\nCode:\n    def test_allows_project_admin_to_reassign(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])",
                                        "Function `test_denies_non_admin_to_reassign`\nCode:\n    def test_denies_non_admin_to_reassign(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_reassign`\nCode:\n    def test_denies_non_project_member_to_reassign(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_reassign`\nCode:\n    def test_denies_unauthenticated_user_to_reassign(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_unassign`\nCode:\n    def test_allows_project_admin_to_unassign(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_non_admin_to_unassign`\nCode:\n    def test_denies_non_admin_to_unassign(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_unassign`\nCode:\n    def test_denies_non_project_member_to_unassign(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_unassign`\nCode:\n    def test_denies_unauthenticated_user_to_unassign(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestAssignmentBulk`\nCode:\nclass TestAssignmentBulk(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        members = Member.objects.filter(project=self.project.item)\n        workloads = [{\"member_id\": member.id, \"weight\": 100} for member in members]\n        self.data = {\"strategy_name\": \"sampling_without_replacement\", \"workloads\": workloads}\n        self.url = reverse(viewname=\"bulk_assignment\", args=[self.project.item.id])\n\n    def test_denies_non_admin_to_bulk_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_bulk_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_bulk_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_bulk_assign(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        expected = self.project.item.examples.count() * len(self.project.members)\n        self.assertEqual(Assignment.objects.count(), expected)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        members = Member.objects.filter(project=self.project.item)\n        workloads = [{\"member_id\": member.id, \"weight\": 100} for member in members]\n        self.data = {\"strategy_name\": \"sampling_without_replacement\", \"workloads\": workloads}\n        self.url = reverse(viewname=\"bulk_assignment\", args=[self.project.item.id])",
                                        "Function `test_denies_non_admin_to_bulk_assign`\nCode:\n    def test_denies_non_admin_to_bulk_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_bulk_assign`\nCode:\n    def test_denies_non_project_member_to_bulk_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_bulk_assign`\nCode:\n    def test_denies_unauthenticated_user_to_bulk_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_bulk_assign`\nCode:\n    def test_allows_project_admin_to_bulk_assign(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        expected = self.project.item.examples.count() * len(self.project.members)\n        self.assertEqual(Assignment.objects.count(), expected)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import make_assignment, make_doc\nfrom api.tests.utils import CRUDMixin\nfrom examples.models import Assignment\nfrom projects.models import Member\nfrom projects.tests.utils import prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestAssignmentList(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        make_assignment(self.project.item, self.example, self.project.admin)\n        self.data = {\"example\": self.example.id, \"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_list\", args=[self.project.item.id])\n\n    def test_allow_project_member_to_list_assignments(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_denies_non_project_member_to_list_assignments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_assignments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_assign(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"example\"], self.data[\"example\"])\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])\n\n    def test_denies_non_admin_to_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestAssignmentDetail(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        assignment = make_assignment(self.project.item, example, self.project.admin)\n        self.data = {\"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_detail\", args=[self.project.item.id, assignment.id])\n\n    def test_allows_project_member_to_get_assignment(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_denies_non_project_member_to_get_assignment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_assignment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_reassign(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])\n\n    def test_denies_non_admin_to_reassign(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_reassign(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_reassign(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_unassign(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_admin_to_unassign(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_unassign(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_unassign(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestAssignmentBulk(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        members = Member.objects.filter(project=self.project.item)\n        workloads = [{\"member_id\": member.id, \"weight\": 100} for member in members]\n        self.data = {\"strategy_name\": \"sampling_without_replacement\", \"workloads\": workloads}\n        self.url = reverse(viewname=\"bulk_assignment\", args=[self.project.item.id])\n\n    def test_denies_non_admin_to_bulk_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_bulk_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_bulk_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_bulk_assign(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        expected = self.project.item.examples.count() * len(self.project.members)\n        self.assertEqual(Assignment.objects.count(), expected)\n",
                                    "summary": "Class `TestAssignmentList`: A test suite for CRUD operations related to assignments, including permission checks for project members and administrators, with specific tests for listing and assigning tasks.",
                                    "code_element_summaries": [
                                        "Class `TestAssignmentList`: A test suite for CRUD operations related to assignments, including listing, creating, and permission checks for project members and administrators.",
                                        "Function `setUp`: Sets up necessary data for testing assignments in a project.",
                                        "Function `test_allow_project_member_to_list_assignments`: Tests whether project members can successfully list assignments with a status code of 200 OK.",
                                        "Function test_denies_non_project_member_to_list_assignments: Tests that non-project members are denied access to list assignments with a HTTP 403 Forbidden status.",
                                        "Function `test_denies_unauthenticated_user_to_list_assignments`: Tests that an unauthenticated user is denied access to list assignments.",
                                        "Function `test_allows_project_admin_to_assign`: Verifies that a project admin is able to assign certain values during creation.",
                                        "Function `test_denies_non_admin_to_assign`: Tests that non-admin users are denied permission to assign tasks to project staff members.",
                                        "Function test_denies_non_project_member_to_assign: Tests that a non-project member is denied permission to assign a task.",
                                        "Function `test_denies_unauthenticated_user_to_assign`: Tests that an unauthenticated user is denied permission to assign a task.",
                                        "Class `TestAssignmentDetail`: A set of test cases for CRUD operations on assignment details, including permission checks for project members and admins.",
                                        "Function `setUp`: Sets up necessary data and objects for testing assignment details in a project.",
                                        "Function `test_allows_project_member_to_get_assignment`: Tests that project members can retrieve their assignments successfully with a status code of 200.",
                                        "Function test_denies_non_project_member_to_get_assignment: Tests that a non-member of a project is denied access to get an assignment.",
                                        "Function `test_denies_unauthenticated_user_to_get_assignment`: Tests that unauthenticated users are denied access to get assignment data.",
                                        "Function `test_allows_project_admin_to_reassign`: Verifies that a project admin can reassign a task successfully.",
                                        "Function `test_denies_non_admin_to_reassign`: Tests that non-admin users are denied permission to reassign staff members in a project.",
                                        "Function test_denies_non_project_member_to_reassign: Tests that a non-project member is denied permission to reassign a task.",
                                        "Function `test_denies_unauthenticated_user_to_reassign`: Tests that unauthenticated users are denied permission to reassign.",
                                        "Function `test_allows_project_admin_to_unassign`: Verifies that a project admin is able to unassign a task.",
                                        "Function `test_denies_non_admin_to_unassign`: Tests that non-admin users are denied permission to unassign staff members from a project.",
                                        "Function `test_denies_non_project_member_to_unassign`: Tests that a non-project member is denied permission to unassign a task.",
                                        "Function `test_denies_unauthenticated_user_to_unassign`: Tests that an unauthenticated user is denied access to unassign a resource.",
                                        "Class `TestAssignmentBulk`: A class that tests bulk assignment functionality, including denying access to non-admin users and allowing project admins to perform bulk assignments.",
                                        "Function `setUp`: Sets up data and variables needed for testing bulk assignment functionality in a project.",
                                        "Function `test_denies_non_admin_to_bulk_assign`: Tests whether non-admin members are denied access to bulk assignment in a project.",
                                        "Function test_denies_non_project_member_to_bulk_assign: Tests that a non-project member is denied access to bulk assign action with a 403 Forbidden status.",
                                        "Function `test_denies_unauthenticated_user_to_bulk_assign`: Tests that unauthenticated users are denied access to bulk assignment functionality.",
                                        "Function `test_allows_project_admin_to_bulk_assign`: Test function to verify that project admins can bulk assign tasks to project members successfully."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_comment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_comment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestCommentListDocAPI`\nCode:\nclass TestCommentListDocAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        doc1 = make_doc(cls.project.item)\n        doc2 = make_doc(cls.project.item)\n        make_comment(doc1, cls.project.admin)\n        make_comment(doc2, cls.project.admin)\n        cls.data = {\"text\": \"example\"}\n        cls.url = reverse(viewname=\"comment_list\", args=[cls.project.item.id])\n        cls.url += f\"?example={doc1.id}\"\n\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_member_to_create_comment(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_non_project_member_to_create_comment(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_comment(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        doc1 = make_doc(cls.project.item)\n        doc2 = make_doc(cls.project.item)\n        make_comment(doc1, cls.project.admin)\n        make_comment(doc2, cls.project.admin)\n        cls.data = {\"text\": \"example\"}\n        cls.url = reverse(viewname=\"comment_list\", args=[cls.project.item.id])\n        cls.url += f\"?example={doc1.id}\"",
                                        "Function `test_allows_project_member_to_list_comments`\nCode:\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)",
                                        "Function `test_denies_non_project_member_to_list_comments`\nCode:\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_list_comments`\nCode:\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_member_to_create_comment`\nCode:\n    def test_allows_project_member_to_create_comment(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Function `test_denies_non_project_member_to_create_comment`\nCode:\n    def test_denies_non_project_member_to_create_comment(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_create_comment`\nCode:\n    def test_denies_unauthenticated_user_to_create_comment(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestCommentListProjectAPI`\nCode:\nclass TestCommentListProjectAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        make_comment(self.doc, self.project.admin)\n        self.url = reverse(viewname=\"comment_list\", args=[self.project.item.id])\n\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        ids = [item.id for item in self.doc.comments.all()]\n        if user:\n            self.client.force_login(user)\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n\n    def test_allows_project_member_to_delete_comments(self):\n        # Todo: Disallow non admin to delete comments.\n        for member in self.project.members:\n            self.assert_bulk_delete(member, status.HTTP_204_NO_CONTENT)\n            response = self.client.get(self.url)\n            self.assertEqual(response.data[\"count\"], 0)\n\n    def test_denies_non_project_member_to_delete_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        make_comment(self.doc, self.project.admin)\n        self.url = reverse(viewname=\"comment_list\", args=[self.project.item.id])",
                                        "Function `test_allows_project_member_to_list_comments`\nCode:\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)",
                                        "Function `test_denies_non_project_member_to_list_comments`\nCode:\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_list_comments`\nCode:\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `assert_bulk_delete`\nCode:\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        ids = [item.id for item in self.doc.comments.all()]\n        if user:\n            self.client.force_login(user)\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)",
                                        "Function `test_allows_project_member_to_delete_comments`\nCode:\n    def test_allows_project_member_to_delete_comments(self):\n        # Todo: Disallow non admin to delete comments.\n        for member in self.project.members:\n            self.assert_bulk_delete(member, status.HTTP_204_NO_CONTENT)\n            response = self.client.get(self.url)\n            self.assertEqual(response.data[\"count\"], 0)",
                                        "Function `test_denies_non_project_member_to_delete_comments`\nCode:\n    def test_denies_non_project_member_to_delete_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_delete_comments`\nCode:\n    def test_denies_unauthenticated_user_to_delete_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestCommentDetailAPI`\nCode:\nclass TestCommentDetailAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        comment = make_comment(doc, self.project.admin)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"comment_detail\", args=[self.project.item.id, comment.id])\n\n    def test_allows_comment_owner_to_get_comment(self):\n        # Todo: Allows project member to get comment.\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_comment_owner_to_get_comment(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_get_comment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_comment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_comment_owner_to_update_comment(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_comment_owner_to_update_comment(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_comment(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_update_comment(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_comment_owner_to_delete_comment(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_comment_owner_to_delete_comment(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_comment(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_comment(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        comment = make_comment(doc, self.project.admin)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"comment_detail\", args=[self.project.item.id, comment.id])",
                                        "Function `test_allows_comment_owner_to_get_comment`\nCode:\n    def test_allows_comment_owner_to_get_comment(self):\n        # Todo: Allows project member to get comment.\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_non_comment_owner_to_get_comment`\nCode:\n    def test_denies_non_comment_owner_to_get_comment(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_get_comment`\nCode:\n    def test_denies_non_project_member_to_get_comment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_get_comment`\nCode:\n    def test_denies_unauthenticated_user_to_get_comment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_comment_owner_to_update_comment`\nCode:\n    def test_allows_comment_owner_to_update_comment(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])",
                                        "Function `test_denies_non_comment_owner_to_update_comment`\nCode:\n    def test_denies_non_comment_owner_to_update_comment(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_update_comment`\nCode:\n    def test_denies_non_project_member_to_update_comment(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_update_comment`\nCode:\n    def test_denies_unauthenticated_user_to_update_comment(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_comment_owner_to_delete_comment`\nCode:\n    def test_allows_comment_owner_to_delete_comment(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_non_comment_owner_to_delete_comment`\nCode:\n    def test_denies_non_comment_owner_to_delete_comment(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_delete_comment`\nCode:\n    def test_denies_non_project_member_to_delete_comment(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_delete_comment`\nCode:\n    def test_denies_unauthenticated_user_to_delete_comment(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import make_comment, make_doc\nfrom api.tests.utils import CRUDMixin\nfrom projects.tests.utils import prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestCommentListDocAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        doc1 = make_doc(cls.project.item)\n        doc2 = make_doc(cls.project.item)\n        make_comment(doc1, cls.project.admin)\n        make_comment(doc2, cls.project.admin)\n        cls.data = {\"text\": \"example\"}\n        cls.url = reverse(viewname=\"comment_list\", args=[cls.project.item.id])\n        cls.url += f\"?example={doc1.id}\"\n\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_member_to_create_comment(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_non_project_member_to_create_comment(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_comment(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestCommentListProjectAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        make_comment(self.doc, self.project.admin)\n        self.url = reverse(viewname=\"comment_list\", args=[self.project.item.id])\n\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        ids = [item.id for item in self.doc.comments.all()]\n        if user:\n            self.client.force_login(user)\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n\n    def test_allows_project_member_to_delete_comments(self):\n        # Todo: Disallow non admin to delete comments.\n        for member in self.project.members:\n            self.assert_bulk_delete(member, status.HTTP_204_NO_CONTENT)\n            response = self.client.get(self.url)\n            self.assertEqual(response.data[\"count\"], 0)\n\n    def test_denies_non_project_member_to_delete_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestCommentDetailAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        comment = make_comment(doc, self.project.admin)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"comment_detail\", args=[self.project.item.id, comment.id])\n\n    def test_allows_comment_owner_to_get_comment(self):\n        # Todo: Allows project member to get comment.\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_comment_owner_to_get_comment(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_get_comment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_comment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_comment_owner_to_update_comment(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_comment_owner_to_update_comment(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_comment(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_update_comment(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_comment_owner_to_delete_comment(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_comment_owner_to_delete_comment(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_comment(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_comment(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Class TestCommentListDocAPI: A test class for verifying the functionality of listing and creating comments for project members and non-members, including tests for access permissions and CRUD operations on comments.",
                                    "code_element_summaries": [
                                        "Class TestCommentListDocAPI: Contains test methods to verify the functionality of listing and creating comments for project members and non-members.",
                                        "Function `setUpTestData`: Sets up test data including a project, users, documents, comments, and URLs for testing purposes.",
                                        "Function `test_allows_project_member_to_list_comments`: Tests that project members can list comments, checking if each member can fetch the comments with a status of 200 OK and ensuring that the count of comments is 1.",
                                        "Function `test_denies_non_project_member_to_list_comments`: Tests that non-project members are denied access to list comments.",
                                        "Function test_denies_unauthenticated_user_to_list_comments: Tests that an unauthenticated user is denied access to list comments with an expected 403 Forbidden status.",
                                        "Function `test_allows_project_member_to_create_comment`: Tests that project members can create comments with a status code of 201.",
                                        "Function `test_denies_non_project_member_to_create_comment`: Tests that a non-project member is denied permission to create a comment.",
                                        "Function `test_denies_unauthenticated_user_to_create_comment`: Asserts that an unauthenticated user is denied permission to create a comment.",
                                        "Class `TestCommentListProjectAPI`: A test class that checks the functionality of listing and deleting comments for project members and non-members.",
                                        "Function `setUp`: Sets up necessary data for testing by creating a project, a non-member user, a document, a comment, and a URL for comment listing.",
                                        "Function `test_allows_project_member_to_list_comments`: Tests whether a project member can successfully list comments associated with the project.",
                                        "Function `test_denies_non_project_member_to_list_comments`: Tests that non-project members are denied access to list comments with a 403 Forbidden status.",
                                        "Function `test_denies_unauthenticated_user_to_list_comments`: Tests that an unauthenticated user is denied access to list comments.",
                                        "Function `assert_bulk_delete`: A method to assert the bulk deletion of comments with specified user authentication and expected status code.",
                                        "Function `test_allows_project_member_to_delete_comments`: Tests if project members are able to delete comments in bulk and verifies that the comments are successfully deleted.",
                                        "Function `test_denies_non_project_member_to_delete_comments`: Tests that non-project members are denied access to delete comments.",
                                        "Function `test_denies_unauthenticated_user_to_delete_comments`: Tests that unauthenticated users are denied access to delete comments.",
                                        "Class `TestCommentDetailAPI`: A test class for CRUD operations on comments with different user permissions.",
                                        "Function `setUp`: Sets up necessary data and objects for testing comment details in a project.",
                                        "Function `test_allows_comment_owner_to_get_comment`: Tests if the comment owner is allowed to retrieve their own comment within a project.",
                                        "Function `test_denies_non_comment_owner_to_get_comment`: Tests that non-comment owners are denied access to get comments on a project.",
                                        "Function `test_denies_non_project_member_to_get_comment`: Tests that non-project members are denied access to retrieve comments.",
                                        "Function `test_denies_unauthenticated_user_to_get_comment`: Tests that deny unauthenticated users from accessing comments return a 403 Forbidden status code.",
                                        "Function `test_allows_comment_owner_to_update_comment`: Tests if the comment owner is allowed to update their own comment.",
                                        "Function `test_denies_non_comment_owner_to_update_comment`: Tests that non-comment owners are denied permission to update comments by iterating through project staff members and asserting the update status as forbidden.",
                                        "Function `test_denies_non_project_member_to_update_comment`: Tests that non-project members are denied permission to update comments.",
                                        "Function `test_denies_unauthenticated_user_to_update_comment`: Tests that an unauthenticated user is denied access to update a comment with an expected status code of 403 Forbidden.",
                                        "Function `test_allows_comment_owner_to_delete_comment`: Tests if the comment owner is allowed to delete their own comment and expects a 204 NO CONTENT status.",
                                        "Function `test_denies_non_comment_owner_to_delete_comment`: Tests that non-comment owners are denied permission to delete comments by asserting a 403 Forbidden status for each staff member in the project.",
                                        "Function `test_denies_non_project_member_to_delete_comment`: Tests if a non-project member is denied access to delete a comment.",
                                        "Function `test_denies_unauthenticated_user_to_delete_comment`: Tests that an unauthenticated user is denied access to delete a comment."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_example.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_example.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExampleListAPI`\nCode:\nclass TestExampleListAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n\n    def test_allows_project_member_to_list_examples(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertIn(\"results\", response.data)\n            for item in response.data[\"results\"]:\n                self.assertIn(\"text\", item)\n\n    def test_denies_non_project_member_to_list_examples(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_examples(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_create_example(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_admin_to_create_example(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_example(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_example_is_not_approved_if_another_user_approve_it(self):\n        make_example_state(self.example, self.project.admin)\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertFalse(response.data[\"results\"][0][\"is_confirmed\"])",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])",
                                        "Function `test_allows_project_member_to_list_examples`\nCode:\n    def test_allows_project_member_to_list_examples(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertIn(\"results\", response.data)\n            for item in response.data[\"results\"]:\n                self.assertIn(\"text\", item)",
                                        "Function `test_denies_non_project_member_to_list_examples`\nCode:\n    def test_denies_non_project_member_to_list_examples(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_list_examples`\nCode:\n    def test_denies_unauthenticated_user_to_list_examples(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_create_example`\nCode:\n    def test_allows_project_admin_to_create_example(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])",
                                        "Function `test_denies_non_admin_to_create_example`\nCode:\n    def test_denies_non_admin_to_create_example(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_create_example`\nCode:\n    def test_denies_unauthenticated_user_to_create_example(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_example_is_not_approved_if_another_user_approve_it`\nCode:\n    def test_example_is_not_approved_if_another_user_approve_it(self):\n        make_example_state(self.example, self.project.admin)\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertFalse(response.data[\"results\"][0][\"is_confirmed\"])",
                                        "Class `TestExampleListCollaborative`\nCode:\nclass TestExampleListCollaborative(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n\n    def test_example_is_approved_if_someone_approve_it(self):\n        admin = self.project.admin\n        approver = self.project.approver\n\n        make_example_state(self.example, admin)\n        response = self.assert_fetch(admin, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])\n        response = self.assert_fetch(approver, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])",
                                        "Function `test_example_is_approved_if_someone_approve_it`\nCode:\n    def test_example_is_approved_if_someone_approve_it(self):\n        admin = self.project.admin\n        approver = self.project.approver\n\n        make_example_state(self.example, admin)\n        response = self.assert_fetch(admin, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])\n        response = self.assert_fetch(approver, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])",
                                        "Class `TestExampleListFilter`\nCode:\nclass TestExampleListFilter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        example1 = make_doc(self.project.item)\n        example2 = make_doc(self.project.item)\n        example3 = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, example1, member)\n            make_assignment(self.project.item, example2, member)\n            make_assignment(self.project.item, example3, member)\n        make_example_state(example1, self.project.admin)\n\n    def reverse(self, query_kwargs=None):\n        base_url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n        self.url = \"{}?{}\".format(base_url, urlencode(query_kwargs))\n\n    def assert_filter(self, data, user, expected):\n        self.reverse(query_kwargs=data)\n        response = self.assert_fetch(user, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], expected)\n\n    def test_returns_only_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=1)\n\n    def test_returns_only_non_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"False\"}, user=user, expected=2)\n\n    def test_returns_all_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"\"}, user=user, expected=3)\n\n    def test_does_not_return_approved_example_to_another_user(self):\n        user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=0)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        example1 = make_doc(self.project.item)\n        example2 = make_doc(self.project.item)\n        example3 = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, example1, member)\n            make_assignment(self.project.item, example2, member)\n            make_assignment(self.project.item, example3, member)\n        make_example_state(example1, self.project.admin)",
                                        "Function `reverse`\nCode:\n    def reverse(self, query_kwargs=None):\n        base_url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n        self.url = \"{}?{}\".format(base_url, urlencode(query_kwargs))",
                                        "Function `assert_filter`\nCode:\n    def assert_filter(self, data, user, expected):\n        self.reverse(query_kwargs=data)\n        response = self.assert_fetch(user, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], expected)",
                                        "Function `test_returns_only_approved_examples`\nCode:\n    def test_returns_only_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=1)",
                                        "Function `test_returns_only_non_approved_examples`\nCode:\n    def test_returns_only_non_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"False\"}, user=user, expected=2)",
                                        "Function `test_returns_all_examples`\nCode:\n    def test_returns_all_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"\"}, user=user, expected=3)",
                                        "Function `test_does_not_return_approved_example_to_another_user`\nCode:\n    def test_does_not_return_approved_example_to_another_user(self):\n        user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=0)",
                                        "Class `TestExampleDetail`\nCode:\nclass TestExampleDetail(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_detail\", args=[self.project.item.id, example.id])\n\n    def test_allows_project_member_to_get_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertIn(\"text\", response.data)\n\n    def test_denies_non_project_member_to_get_example(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_example(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_update_example(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_admin_to_update_example(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_example(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_delete_example(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_admin_to_delete_example(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_example(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_detail\", args=[self.project.item.id, example.id])",
                                        "Function `test_allows_project_member_to_get_example`\nCode:\n    def test_allows_project_member_to_get_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertIn(\"text\", response.data)",
                                        "Function `test_denies_non_project_member_to_get_example`\nCode:\n    def test_denies_non_project_member_to_get_example(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_get_example`\nCode:\n    def test_denies_unauthenticated_user_to_get_example(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_update_example`\nCode:\n    def test_allows_project_admin_to_update_example(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])",
                                        "Function `test_denies_non_admin_to_update_example`\nCode:\n    def test_denies_non_admin_to_update_example(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_update_example`\nCode:\n    def test_denies_non_project_member_to_update_example(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_delete_example`\nCode:\n    def test_allows_project_admin_to_delete_example(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_non_admin_to_delete_example`\nCode:\n    def test_denies_non_admin_to_delete_example(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_delete_example`\nCode:\n    def test_denies_non_project_member_to_delete_example(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from django.utils.http import urlencode\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import make_assignment, make_doc, make_example_state\nfrom api.tests.utils import CRUDMixin\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestExampleListAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n\n    def test_allows_project_member_to_list_examples(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertIn(\"results\", response.data)\n            for item in response.data[\"results\"]:\n                self.assertIn(\"text\", item)\n\n    def test_denies_non_project_member_to_list_examples(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_examples(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_create_example(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_admin_to_create_example(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_example(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_example_is_not_approved_if_another_user_approve_it(self):\n        make_example_state(self.example, self.project.admin)\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertFalse(response.data[\"results\"][0][\"is_confirmed\"])\n\n\nclass TestExampleListCollaborative(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n\n    def test_example_is_approved_if_someone_approve_it(self):\n        admin = self.project.admin\n        approver = self.project.approver\n\n        make_example_state(self.example, admin)\n        response = self.assert_fetch(admin, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])\n        response = self.assert_fetch(approver, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])\n\n\nclass TestExampleListFilter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        example1 = make_doc(self.project.item)\n        example2 = make_doc(self.project.item)\n        example3 = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, example1, member)\n            make_assignment(self.project.item, example2, member)\n            make_assignment(self.project.item, example3, member)\n        make_example_state(example1, self.project.admin)\n\n    def reverse(self, query_kwargs=None):\n        base_url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n        self.url = \"{}?{}\".format(base_url, urlencode(query_kwargs))\n\n    def assert_filter(self, data, user, expected):\n        self.reverse(query_kwargs=data)\n        response = self.assert_fetch(user, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], expected)\n\n    def test_returns_only_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=1)\n\n    def test_returns_only_non_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"False\"}, user=user, expected=2)\n\n    def test_returns_all_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"\"}, user=user, expected=3)\n\n    def test_does_not_return_approved_example_to_another_user(self):\n        user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=0)\n\n\nclass TestExampleDetail(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_detail\", args=[self.project.item.id, example.id])\n\n    def test_allows_project_member_to_get_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertIn(\"text\", response.data)\n\n    def test_denies_non_project_member_to_get_example(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_example(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_update_example(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_admin_to_update_example(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_example(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_delete_example(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_admin_to_delete_example(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_example(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Class `TestExampleListAPI`: A test class for CRUD operations on example lists with specific permission checks for project members and admins, including tests for listing, creating, and approving examples.\nClass `TestExampleListCollaborative`: A test class for collaborative annotation approval of examples in a project, with a focus on approval functionality.\nClass `TestExampleListFilter`: Contains test methods to filter and assert the number of examples based on approval status for a project, including tests for filtering approved and non-approved examples.\nClass `TestExampleDetail`: A set of test cases to verify permissions for accessing, updating, and deleting examples within a project, covering scenarios for project members, admins, and non-admin users.",
                                    "code_element_summaries": [
                                        "Class `TestExampleListAPI`: A test class for CRUD operations on example lists with specific permission checks for project members and admins.",
                                        "Function `setUp`: Initializes variables and objects for testing a document classification project with example data and URLs.",
                                        "Function `test_allows_project_member_to_list_examples`: Tests if project members can list examples, checking for expected response status, count, and presence of text in each item.",
                                        "Function test_denies_non_project_member_to_list_examples: Tests that non-project members are denied access to list examples with a HTTP 403 Forbidden status.",
                                        "Function test_denies_unauthenticated_user_to_list_examples: Tests that unauthenticated users are denied access to list examples with an expected status code of 403 Forbidden.",
                                        "Function `test_allows_project_admin_to_create_example`: Tests if a project admin is able to create an example and checks if the response data matches the input data.",
                                        "Function `test_denies_non_admin_to_create_example`: Tests that non-admin users are denied permission to create examples for the project staff.",
                                        "Function `test_denies_unauthenticated_user_to_create_example`: Tests that an unauthenticated user is denied permission to create an example.",
                                        "Function `test_example_is_not_approved_if_another_user_approve_it`: Tests that an example is not approved if another user approves it.",
                                        "Class TestExampleListCollaborative: A test class for collaborative annotation approval of examples in a project.",
                                        "Function `setUp`: Sets up the necessary data for testing document classification with collaborative annotation.",
                                        "Function `test_example_is_approved_if_someone_approve_it`: A test function to check if an example is marked as approved when someone approves it.",
                                        "Class `TestExampleListFilter`: Contains test methods to filter and assert the number of examples based on approval status for a project.",
                                        "Function `setUp`: Sets up a project with document classification task, creates examples and assignments for project members.",
                                        "Function `reverse`: A method that generates a URL by reversing the view name \"example_list\" with optional query parameters.",
                                        "Function `assert_filter`: A method that asserts the filtering of data based on specified criteria and expected results.",
                                        "Function `test_returns_only_approved_examples`: A test function that checks if only approved examples are returned for a specific user.",
                                        "Function `test_returns_only_non_approved_examples`: Tests that only non-approved examples are returned when filtering by confirmed status.",
                                        "Function `test_returns_all_examples`: A test function that checks if the filter returns the expected number of examples for a specific user.",
                                        "Function `test_does_not_return_approved_example_to_another_user`: Tests that approved examples are not returned to another user.",
                                        "Class `TestExampleDetail`: A set of test cases to verify permissions for accessing, updating, and deleting examples within a project.",
                                        "Function `setUp`: Sets up necessary objects and data for testing document classification project.",
                                        "Function `test_allows_project_member_to_get_example`: Tests if project members can successfully retrieve an example with text data.",
                                        "Function `test_denies_non_project_member_to_get_example`: Tests that a non-project member is denied access to retrieve an example.",
                                        "Function `test_denies_unauthenticated_user_to_get_example`: A test function that checks if unauthenticated users are denied access to retrieve an example.",
                                        "Function `test_allows_project_admin_to_update_example`: Tests that project admin can update an example with expected text data.",
                                        "Function `test_denies_non_admin_to_update_example`: Tests that non-admin users are denied permission to update examples for project staff members.",
                                        "Function `test_denies_non_project_member_to_update_example`: Tests that non-project members are denied permission to update an example, asserting a 403 Forbidden status.",
                                        "Function test_allows_project_admin_to_delete_example: Asserts that a project admin can delete an example with a status code of 204.",
                                        "Function test_denies_non_admin_to_delete_example: Tests that non-admin users are denied permission to delete examples in a project.",
                                        "Function `test_denies_non_project_member_to_delete_example`: Tests that a non-project member is denied permission to delete an example."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_example_state.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_example_state.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExampleStateList`\nCode:\nclass TestExampleStateList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project()\n        cls.example = make_doc(cls.project.item)\n        for member in cls.project.members:\n            make_example_state(cls.example, member)\n        cls.url = reverse(viewname=\"example_state_list\", args=[cls.project.item.id, cls.example.id])\n\n    def test_returns_example_state_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_does_not_return_example_state_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_example_state_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project()\n        cls.example = make_doc(cls.project.item)\n        for member in cls.project.members:\n            make_example_state(cls.example, member)\n        cls.url = reverse(viewname=\"example_state_list\", args=[cls.project.item.id, cls.example.id])",
                                        "Function `test_returns_example_state_to_project_member`\nCode:\n    def test_returns_example_state_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)",
                                        "Function `test_does_not_return_example_state_to_non_project_member`\nCode:\n    def test_does_not_return_example_state_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_does_not_return_example_state_to_unauthenticated_user`\nCode:\n    def test_does_not_return_example_state_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestExampleStateConfirm`\nCode:\nclass TestExampleStateConfirm(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])\n\n    def test_allows_member_to_confirm_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n            self.assert_create(member, status.HTTP_201_CREATED)  # confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assert_create(member, status.HTTP_201_CREATED)  # toggle confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])",
                                        "Function `test_allows_member_to_confirm_example`\nCode:\n    def test_allows_member_to_confirm_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n            self.assert_create(member, status.HTTP_201_CREATED)  # confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assert_create(member, status.HTTP_201_CREATED)  # toggle confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)",
                                        "Class `TestExampleStateConfirmCollaborative`\nCode:\nclass TestExampleStateConfirmCollaborative(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])\n\n    def test_initial_state(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n\n    def test_can_approve_state(self):\n        admin = self.project.admin\n        self.assert_create(admin, status.HTTP_201_CREATED)\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])",
                                        "Function `test_initial_state`\nCode:\n    def test_initial_state(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)",
                                        "Function `test_can_approve_state`\nCode:\n    def test_can_approve_state(self):\n        admin = self.project.admin\n        self.assert_create(admin, status.HTTP_201_CREATED)\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import make_doc, make_example_state\nfrom api.tests.utils import CRUDMixin\nfrom projects.tests.utils import prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestExampleStateList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project()\n        cls.example = make_doc(cls.project.item)\n        for member in cls.project.members:\n            make_example_state(cls.example, member)\n        cls.url = reverse(viewname=\"example_state_list\", args=[cls.project.item.id, cls.example.id])\n\n    def test_returns_example_state_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_does_not_return_example_state_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_example_state_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestExampleStateConfirm(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])\n\n    def test_allows_member_to_confirm_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n            self.assert_create(member, status.HTTP_201_CREATED)  # confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assert_create(member, status.HTTP_201_CREATED)  # toggle confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n\n\nclass TestExampleStateConfirmCollaborative(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])\n\n    def test_initial_state(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n\n    def test_can_approve_state(self):\n        admin = self.project.admin\n        self.assert_create(admin, status.HTTP_201_CREATED)\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n",
                                    "summary": "Class `TestExampleStateList`: A test class that checks the functionality of returning example states to project members and restricting access to non-members and unauthenticated users, while Class `TestExampleStateConfirm`: Validates the functionality of allowing project members to confirm and toggle confirmation of examples, and Class `TestExampleStateConfirmCollaborative`: Tests collaborative annotation functionality in a project.",
                                    "code_element_summaries": [
                                        "Class `TestExampleStateList`: A test class that checks the functionality of returning example states to project members and restricting access to non-members and unauthenticated users.",
                                        "Function `setUpTestData`: Sets up test data including a non-member user, a project, an example document, example states for project members, and a URL for accessing example states list.",
                                        "Function test_returns_example_state_to_project_member: Checks if each member of the project receives an example state with a count of 1 when fetched.",
                                        "Function `test_does_not_return_example_state_to_non_project_member`: Verifies that non-project members are denied access to example state information.",
                                        "Function `test_does_not_return_example_state_to_unauthenticated_user`: Asserts that unauthenticated users are forbidden from fetching example state data.",
                                        "Class `TestExampleStateConfirm`: A test class that validates the functionality of allowing project members to confirm and toggle confirmation of examples.",
                                        "Function `setUp`: Initializes necessary objects and data for testing a specific project and example in the context of a Django project.",
                                        "Function `test_allows_member_to_confirm_example`: A test function that verifies the ability of project members to confirm and toggle confirmation of examples.",
                                        "Class `TestExampleStateConfirmCollaborative`: A test class for confirming collaborative states in a project, including initial state and approval testing.",
                                        "Function `setUp`: Initializes necessary objects for testing collaborative annotation functionality.",
                                        "Function `test_initial_state`: Tests the initial state of project members by asserting that the count of data for each member is 0.",
                                        "Function `test_can_approve_state`: Tests the ability to approve state changes for project members and administrators."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_filters.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_filters.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestFilterMixin`\nCode:\nclass TestFilterMixin(TestCase):\n    def prepare(self, project):\n        self.example = make_doc(project.item)\n        self.request = MagicMock()\n        self.queryset = Example.objects.all()\n        make_example_state(self.example, project.admin)\n        self.request.user = project.admin\n\n    def assert_filter(self, data, expected):\n        f = ExampleFilter(data=data, queryset=self.queryset, request=self.request)\n        self.assertEqual(f.qs.count(), expected)",
                                        "Function `prepare`\nCode:\n    def prepare(self, project):\n        self.example = make_doc(project.item)\n        self.request = MagicMock()\n        self.queryset = Example.objects.all()\n        make_example_state(self.example, project.admin)\n        self.request.user = project.admin",
                                        "Function `assert_filter`\nCode:\n    def assert_filter(self, data, expected):\n        f = ExampleFilter(data=data, queryset=self.queryset, request=self.request)\n        self.assertEqual(f.qs.count(), expected)",
                                        "Class `TestExampleFilter`\nCode:\nclass TestExampleFilter(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\")\n        self.prepare(project=self.project)\n\n    def test_returns_example_if_confirmed_is_true(self):\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)\n\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)\n\n    def test_returns_example_if_confirmed_is_empty(self):\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)\n\n    def test_does_not_return_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=0)\n\n    def test_returns_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=1)\n\n    def test_returns_example_if_user_is_different_and_confirmed_is_empty(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\")\n        self.prepare(project=self.project)",
                                        "Function `test_returns_example_if_confirmed_is_true`\nCode:\n    def test_returns_example_if_confirmed_is_true(self):\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)",
                                        "Function `test_does_not_return_example_if_confirmed_is_false`\nCode:\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)",
                                        "Function `test_returns_example_if_confirmed_is_empty`\nCode:\n    def test_returns_example_if_confirmed_is_empty(self):\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)",
                                        "Function `test_does_not_return_example_if_user_is_different`\nCode:\n    def test_does_not_return_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=0)",
                                        "Function `test_returns_example_if_user_is_different`\nCode:\n    def test_returns_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=1)",
                                        "Function `test_returns_example_if_user_is_different_and_confirmed_is_empty`\nCode:\n    def test_returns_example_if_user_is_different_and_confirmed_is_empty(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)",
                                        "Class `TestLabelFilter`\nCode:\nclass TestLabelFilter(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.prepare(project=self.project)\n        self.label_type = mommy.make(\"CategoryType\", project=self.project.item, text=\"positive\")\n        mommy.make(\"Category\", example=self.example, label=self.label_type)\n\n    def test_returns_example_with_positive_label(self):\n        self.assert_filter(data={\"label\": self.label_type.text}, expected=1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.prepare(project=self.project)\n        self.label_type = mommy.make(\"CategoryType\", project=self.project.item, text=\"positive\")\n        mommy.make(\"Category\", example=self.example, label=self.label_type)",
                                        "Function `test_returns_example_with_positive_label`\nCode:\n    def test_returns_example_with_positive_label(self):\n        self.assert_filter(data={\"label\": self.label_type.text}, expected=1)",
                                        "Class `TestExampleFilterOnCollaborative`\nCode:\nclass TestExampleFilterOnCollaborative(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\", collaborative_annotation=True)\n        self.prepare(project=self.project)\n\n    def test_returns_example_if_confirmed_is_true(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)\n\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)\n\n    def test_returns_example_if_confirmed_is_empty(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"\"}, expected=1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\", collaborative_annotation=True)\n        self.prepare(project=self.project)",
                                        "Function `test_returns_example_if_confirmed_is_true`\nCode:\n    def test_returns_example_if_confirmed_is_true(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)",
                                        "Function `test_does_not_return_example_if_confirmed_is_false`\nCode:\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)",
                                        "Function `test_returns_example_if_confirmed_is_empty`\nCode:\n    def test_returns_example_if_confirmed_is_empty(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"\"}, expected=1)"
                                    ],
                                    "code": "from unittest.mock import MagicMock\n\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom .utils import make_doc, make_example_state\nfrom examples.filters import ExampleFilter\nfrom examples.models import Example\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestFilterMixin(TestCase):\n    def prepare(self, project):\n        self.example = make_doc(project.item)\n        self.request = MagicMock()\n        self.queryset = Example.objects.all()\n        make_example_state(self.example, project.admin)\n        self.request.user = project.admin\n\n    def assert_filter(self, data, expected):\n        f = ExampleFilter(data=data, queryset=self.queryset, request=self.request)\n        self.assertEqual(f.qs.count(), expected)\n\n\nclass TestExampleFilter(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\")\n        self.prepare(project=self.project)\n\n    def test_returns_example_if_confirmed_is_true(self):\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)\n\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)\n\n    def test_returns_example_if_confirmed_is_empty(self):\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)\n\n    def test_does_not_return_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=0)\n\n    def test_returns_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=1)\n\n    def test_returns_example_if_user_is_different_and_confirmed_is_empty(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)\n\n\nclass TestLabelFilter(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.prepare(project=self.project)\n        self.label_type = mommy.make(\"CategoryType\", project=self.project.item, text=\"positive\")\n        mommy.make(\"Category\", example=self.example, label=self.label_type)\n\n    def test_returns_example_with_positive_label(self):\n        self.assert_filter(data={\"label\": self.label_type.text}, expected=1)\n\n\nclass TestExampleFilterOnCollaborative(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\", collaborative_annotation=True)\n        self.prepare(project=self.project)\n\n    def test_returns_example_if_confirmed_is_true(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)\n\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)\n\n    def test_returns_example_if_confirmed_is_empty(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"\"}, expected=1)\n",
                                    "summary": "Class `TestFilterMixin`: A mixin class for filtering queryset based on provided data and expected results, with test functions for filtering examples based on confirmation status, user identity, label type, and collaborative annotation in document classification projects.",
                                    "code_element_summaries": [
                                        "Class `TestFilterMixin`: A test mixin class for filtering queryset based on provided data and expected results.",
                                        "Function `prepare`: Sets up example data and state for a project using a mock request and queryset.",
                                        "Function `assert_filter`: A method that asserts the count of queryset filtered by ExampleFilter matches the expected value.",
                                        "Class `TestExampleFilter`: A test class for filtering examples based on confirmation status and user identity.",
                                        "Function `setUp`: Sets up a project for document classification tasks.",
                                        "Function `test_returns_example_if_confirmed_is_true`: A test function that asserts the filter function returns 1 when confirmed is true.",
                                        "Function `test_does_not_return_example_if_confirmed_is_false`: A test function that checks if an example is not returned when the confirmed attribute is set to false.",
                                        "Function `test_returns_example_if_confirmed_is_empty`: A test function that checks if the filter returns the expected value when the 'confirmed' field is empty.",
                                        "Function `test_does_not_return_example_if_user_is_different`: Verifies that the test does not return an example if the user is different from the project approver.",
                                        "Function `test_returns_example_if_user_is_different`: Tests if the function returns the expected result when the user is different from the project approver.",
                                        "Function `test_returns_example_if_user_is_different_and_confirmed_is_empty`: A test function that checks if the expected output is returned when the user is different from the approver and 'confirmed' field is empty.",
                                        "Class `TestLabelFilter`: A test class for filtering examples based on a specific label type.",
                                        "Function `setUp`: Initializes necessary data for testing document classification projects.",
                                        "Function `test_returns_example_with_positive_label`: A test function that asserts the filter method returns 1 when filtering by a positive label type.",
                                        "Class `TestExampleFilterOnCollaborative`: Tests filtering examples based on confirmation status for collaborative annotation in a document classification project.",
                                        "Function `setUp`: Initializes the project for document classification with collaborative annotation enabled.",
                                        "Function `test_returns_example_if_confirmed_is_true`: A test function that asserts the filter result when confirmed is true for project members.",
                                        "Function `test_does_not_return_example_if_confirmed_is_false`: Tests that the function does not return an example if the confirmed attribute is set to false.",
                                        "Function `test_returns_example_if_confirmed_is_empty`: Tests if the function returns an example when the 'confirmed' field is empty."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_models.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_models.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExampleState`\nCode:\nclass TestExampleState(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.other = mommy.make(\"Example\", project=self.project.item)\n        self.examples = self.project.item.examples.all()\n\n    def test_initial_done(self):\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 0)\n\n    def test_done_confirmed_by_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)\n\n    def test_done_confirmed_by_multiple_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)\n\n    def test_done_confirmed_by_different_example(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.other, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples, self.project.admin)\n        self.assertEqual(done, 1)\n\n    def test_initial_user(self):\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})\n\n    def test_user_count_after_confirmation(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})\n\n    def test_user_count_after_multiple_user_confirmation(self):\n        user1 = self.project.admin\n        user2 = self.project.approver\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user1)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user2)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        expected_progress[1][\"done\"] = 1\n        self.assertEqual(progress[\"total\"], 2)\n        self.assertCountEqual(progress[\"progress\"], expected_progress)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.other = mommy.make(\"Example\", project=self.project.item)\n        self.examples = self.project.item.examples.all()",
                                        "Function `test_initial_done`\nCode:\n    def test_initial_done(self):\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 0)",
                                        "Function `test_done_confirmed_by_user`\nCode:\n    def test_done_confirmed_by_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)",
                                        "Function `test_done_confirmed_by_multiple_user`\nCode:\n    def test_done_confirmed_by_multiple_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)",
                                        "Function `test_done_confirmed_by_different_example`\nCode:\n    def test_done_confirmed_by_different_example(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.other, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples, self.project.admin)\n        self.assertEqual(done, 1)",
                                        "Function `test_initial_user`\nCode:\n    def test_initial_user(self):\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})",
                                        "Function `test_user_count_after_confirmation`\nCode:\n    def test_user_count_after_confirmation(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})",
                                        "Function `test_user_count_after_multiple_user_confirmation`\nCode:\n    def test_user_count_after_multiple_user_confirmation(self):\n        user1 = self.project.admin\n        user2 = self.project.approver\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user1)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user2)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        expected_progress[1][\"done\"] = 1\n        self.assertEqual(progress[\"total\"], 2)\n        self.assertCountEqual(progress[\"progress\"], expected_progress)",
                                        "Class `TestExample`\nCode:\nclass TestExample(TestCase):\n    def test_text_project_returns_text_as_data_property(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(example.text, example.data)\n\n    def test_image_project_returns_filename_as_data_property(self):\n        project = prepare_project(ProjectType.IMAGE_CLASSIFICATION)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(str(example.filename), example.data)",
                                        "Function `test_text_project_returns_text_as_data_property`\nCode:\n    def test_text_project_returns_text_as_data_property(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(example.text, example.data)",
                                        "Function `test_image_project_returns_filename_as_data_property`\nCode:\n    def test_image_project_returns_filename_as_data_property(self):\n        project = prepare_project(ProjectType.IMAGE_CLASSIFICATION)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(str(example.filename), example.data)"
                                    ],
                                    "code": "from django.test import TestCase\nfrom model_mommy import mommy\n\nfrom examples.models import ExampleState\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestExampleState(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.other = mommy.make(\"Example\", project=self.project.item)\n        self.examples = self.project.item.examples.all()\n\n    def test_initial_done(self):\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 0)\n\n    def test_done_confirmed_by_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)\n\n    def test_done_confirmed_by_multiple_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)\n\n    def test_done_confirmed_by_different_example(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.other, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples, self.project.admin)\n        self.assertEqual(done, 1)\n\n    def test_initial_user(self):\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})\n\n    def test_user_count_after_confirmation(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})\n\n    def test_user_count_after_multiple_user_confirmation(self):\n        user1 = self.project.admin\n        user2 = self.project.approver\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user1)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user2)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        expected_progress[1][\"done\"] = 1\n        self.assertEqual(progress[\"total\"], 2)\n        self.assertCountEqual(progress[\"progress\"], expected_progress)\n\n\nclass TestExample(TestCase):\n    def test_text_project_returns_text_as_data_property(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(example.text, example.data)\n\n    def test_image_project_returns_filename_as_data_property(self):\n        project = prepare_project(ProjectType.IMAGE_CLASSIFICATION)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(str(example.filename), example.data)\n",
                                    "summary": "Class `TestExampleState` and `TestExample`: Test case classes for testing the functionality of ExampleState and Example models' methods in various project contexts.",
                                    "code_element_summaries": [
                                        "Class `TestExampleState`: A test case class for testing the functionality of ExampleState model methods in a project context.",
                                        "Function `setUp`: Initializes project, example objects, and retrieves all examples associated with the project.",
                                        "Function `test_initial_done`: Checks if the count of done examples in ExampleState is 0.",
                                        "Function `test_done_confirmed_by_user`: A unit test to verify that the count_done function correctly counts the number of examples marked as done and confirmed by a user.",
                                        "Function `test_done_confirmed_by_multiple_user`: Tests the functionality of counting the number of examples that are marked as done and confirmed by multiple users.",
                                        "Function `test_done_confirmed_by_different_example`: Tests the count_done function in ExampleState model with different confirmers.",
                                        "Function `test_initial_user`: Tests the initial progress of users in a project by measuring their progress and comparing it to an expected progress dictionary.",
                                        "Function `test_user_count_after_confirmation`: Tests the progress calculation of users after confirmation in an ExampleState object.",
                                        "Function `test_user_count_after_multiple_user_confirmation`: A test function to verify the progress count after multiple users have confirmed an example state.",
                                        "Class TestExample: A unit test class that tests the data properties of Example instances in different project types.",
                                        "Function `test_text_project_returns_text_as_data_property`: Verifies that the text property of an Example object in a Sequence Labeling project matches its data property.",
                                        "Function `test_image_project_returns_filename_as_data_property`: Verifies that the filename property of an Example object matches its data property."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_usecase.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_usecase.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestBulkAssignment`\nCode:\nclass TestBulkAssignment(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.member_ids = list(Member.objects.values_list(\"id\", flat=True))\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_raise_error_if_weights_is_invalid(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [0] * len(self.member_ids)\n            )\n\n    def test_raise_error_if_passing_wrong_member_ids(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id,\n                StrategyName.weighted_sequential,\n                self.member_ids + [100],\n                [0] * len(self.member_ids),\n            )\n\n    def test_assign_examples(self):\n        bulk_assign(self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [100, 0, 0])\n        self.assertEqual(self.example.assignments.count(), 1)\n        self.assertEqual(self.example.assignments.first().assignee, self.project.admin)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.member_ids = list(Member.objects.values_list(\"id\", flat=True))\n        self.example = mommy.make(\"Example\", project=self.project.item)",
                                        "Function `test_raise_error_if_weights_is_invalid`\nCode:\n    def test_raise_error_if_weights_is_invalid(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [0] * len(self.member_ids)\n            )",
                                        "Function `test_raise_error_if_passing_wrong_member_ids`\nCode:\n    def test_raise_error_if_passing_wrong_member_ids(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id,\n                StrategyName.weighted_sequential,\n                self.member_ids + [100],\n                [0] * len(self.member_ids),\n            )",
                                        "Function `test_assign_examples`\nCode:\n    def test_assign_examples(self):\n        bulk_assign(self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [100, 0, 0])\n        self.assertEqual(self.example.assignments.count(), 1)\n        self.assertEqual(self.example.assignments.first().assignee, self.project.admin)"
                                    ],
                                    "code": "from django.test import TestCase\nfrom model_mommy import mommy\n\nfrom examples.assignment.usecase import StrategyName, bulk_assign\nfrom projects.models import Member, ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestBulkAssignment(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.member_ids = list(Member.objects.values_list(\"id\", flat=True))\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_raise_error_if_weights_is_invalid(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [0] * len(self.member_ids)\n            )\n\n    def test_raise_error_if_passing_wrong_member_ids(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id,\n                StrategyName.weighted_sequential,\n                self.member_ids + [100],\n                [0] * len(self.member_ids),\n            )\n\n    def test_assign_examples(self):\n        bulk_assign(self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [100, 0, 0])\n        self.assertEqual(self.example.assignments.count(), 1)\n        self.assertEqual(self.example.assignments.first().assignee, self.project.admin)\n",
                                    "summary": "Class `TestBulkAssignment`: Contains test cases for bulk assigning examples to project members with error handling for invalid weights and member IDs, and tests the assignment of examples using the bulk_assign function.",
                                    "code_element_summaries": [
                                        "Class `TestBulkAssignment`: Contains test cases for bulk assigning examples to project members with error handling for invalid weights and member IDs.",
                                        "Function `setUp`: Initializes necessary data for testing sequence labeling projects using project preparation, member IDs retrieval, and example creation.",
                                        "Function `test_raise_error_if_weights_is_invalid`: Tests if an error is raised when invalid weights are passed to the bulk_assign function.",
                                        "Function `test_raise_error_if_passing_wrong_member_ids`: Tests if an error is raised when passing incorrect member IDs to the bulk_assign function.",
                                        "Function `test_assign_examples`: Tests the assignment of examples using bulk_assign function and asserts the count and assignee of the example's assignments."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `make_comment`\nCode:\ndef make_comment(doc, user):\n    return mommy.make(\"Comment\", example=doc, user=user)",
                                        "Function `make_doc`\nCode:\ndef make_doc(project):\n    return mommy.make(\"Example\", text=\"example\", project=project)",
                                        "Function `make_image`\nCode:\ndef make_image(project, filepath):\n    return mommy.make(\"Example\", filename=filepath, project=project)",
                                        "Function `make_example_state`\nCode:\ndef make_example_state(example, user):\n    return mommy.make(\"ExampleState\", example=example, confirmed_by=user)",
                                        "Function `make_assignment`\nCode:\ndef make_assignment(project, example, user):\n    return mommy.make(\"Assignment\", project=project, example=example, assignee=user)"
                                    ],
                                    "code": "from model_mommy import mommy\n\n\ndef make_comment(doc, user):\n    return mommy.make(\"Comment\", example=doc, user=user)\n\n\ndef make_doc(project):\n    return mommy.make(\"Example\", text=\"example\", project=project)\n\n\ndef make_image(project, filepath):\n    return mommy.make(\"Example\", filename=filepath, project=project)\n\n\ndef make_example_state(example, user):\n    return mommy.make(\"ExampleState\", example=example, confirmed_by=user)\n\n\ndef make_assignment(project, example, user):\n    return mommy.make(\"Assignment\", project=project, example=example, assignee=user)\n",
                                    "summary": "Functions that utilize the mommy library to create instances of various models such as Comment, Example, ExampleState, and Assignment with specific attributes.",
                                    "code_element_summaries": [
                                        "Function `make_comment`: A function that creates a Comment object with specified document and user attributes using the mommy library.",
                                        "Function `make_doc`: A function that creates a new \"Example\" object with the text \"example\" and assigns it to a specific project.",
                                        "Function `make_image`: A function that creates an \"Example\" object with a specified filename and project using the mommy library.",
                                        "Function `make_example_state`: A function that creates an ExampleState instance associated with a specific example and confirmed by a user using the mommy library.",
                                        "Function `make_assignment`: A function that creates an assignment instance with specified project, example, and assignee using the mommy library."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a proxy model ExportedBoundingBox that represents bounding box annotations in dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views.assignment import (\n    AssignmentDetail,\n    AssignmentList,\n    BulkAssignment,\n    ResetAssignment,\n)\nfrom .views.comment import CommentDetail, CommentList\nfrom .views.example import ExampleDetail, ExampleList\nfrom .views.example_state import ExampleStateList\n\nurlpatterns = [\n    path(route=\"assignments\", view=AssignmentList.as_view(), name=\"assignment_list\"),\n    path(route=\"assignments/<uuid:assignment_id>\", view=AssignmentDetail.as_view(), name=\"assignment_detail\"),\n    path(route=\"assignments/reset\", view=ResetAssignment.as_view(), name=\"assignment_reset\"),\n    path(route=\"assignments/bulk_assign\", view=BulkAssignment.as_view(), name=\"bulk_assignment\"),\n    path(route=\"examples\", view=ExampleList.as_view(), name=\"example_list\"),\n    path(route=\"examples/<int:example_id>\", view=ExampleDetail.as_view(), name=\"example_detail\"),\n    path(route=\"comments\", view=CommentList.as_view(), name=\"comment_list\"),\n    path(route=\"comments/<int:comment_id>\", view=CommentDetail.as_view(), name=\"comment_detail\"),\n    path(route=\"examples/<int:example_id>/states\", view=ExampleStateList.as_view(), name=\"example_state_list\"),\n]\n",
                            "summary": "URL patterns for different views related to assignments, comments, examples, and example states in a Django application.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Classes `AssignmentList`, `CommentList`, `CommentDetail`, `ExampleList`, `ExampleDetail`, and `ExampleStateList` are views or managers that handle specific tasks related to assignments, comments, examples, and example states with various permissions, filtering options, and functions for data manipulation.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "assignment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views\\assignment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `AssignmentList`\nCode:\nclass AssignmentList(generics.ListCreateAPIView):\n    serializer_class = AssignmentSerializer\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    filter_backends = (DjangoFilterBackend, filters.OrderingFilter)\n    ordering_fields = (\"created_at\", \"updated_at\")\n    model = Assignment\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        queryset = self.model.objects.filter(project=self.project, assignee=self.request.user)\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)",
                                        "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        queryset = self.model.objects.filter(project=self.project, assignee=self.request.user)\n        return queryset",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)",
                                        "Class `AssignmentDetail`\nCode:\nclass AssignmentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Assignment.objects.all()\n    serializer_class = AssignmentSerializer\n    lookup_url_kwarg = \"assignment_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]",
                                        "Class `ResetAssignment`\nCode:\nclass ResetAssignment(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def delete(self, *args, **kwargs):\n        Assignment.objects.filter(project=self.project).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                        "Function `delete`\nCode:\n    def delete(self, *args, **kwargs):\n        Assignment.objects.filter(project=self.project).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Class `BulkAssignment`\nCode:\nclass BulkAssignment(APIView):\n    serializer_class = AssignmentSerializer\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        try:\n            strategy_name = StrategyName[self.request.data[\"strategy_name\"]]\n        except KeyError:\n            return Response(\n                {\"detail\": \"Invalid strategy name\"},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            workload_allocation = WorkloadAllocation(workloads=self.request.data[\"workloads\"])\n        except ValidationError as e:\n            return Response(\n                {\"detail\": e.errors()},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            bulk_assign(\n                project_id=self.kwargs[\"project_id\"],\n                strategy_name=strategy_name,\n                member_ids=workload_allocation.member_ids,\n                weights=workload_allocation.weights,\n            )\n        except ValueError as e:\n            return Response(\n                {\"detail\": str(e)},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n        return Response(status=status.HTTP_201_CREATED)",
                                        "Function `post`\nCode:\n    def post(self, *args, **kwargs):\n        try:\n            strategy_name = StrategyName[self.request.data[\"strategy_name\"]]\n        except KeyError:\n            return Response(\n                {\"detail\": \"Invalid strategy name\"},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            workload_allocation = WorkloadAllocation(workloads=self.request.data[\"workloads\"])\n        except ValidationError as e:\n            return Response(\n                {\"detail\": e.errors()},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            bulk_assign(\n                project_id=self.kwargs[\"project_id\"],\n                strategy_name=strategy_name,\n                member_ids=workload_allocation.member_ids,\n                weights=workload_allocation.weights,\n            )\n        except ValueError as e:\n            return Response(\n                {\"detail\": str(e)},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n        return Response(status=status.HTTP_201_CREATED)"
                                    ],
                                    "code": "from django.shortcuts import get_object_or_404\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom pydantic import ValidationError\nfrom rest_framework import filters, generics, status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.views import APIView, Response\n\nfrom examples.assignment.strategies import StrategyName\nfrom examples.assignment.usecase import bulk_assign\nfrom examples.assignment.workload import WorkloadAllocation\nfrom examples.models import Assignment\nfrom examples.serializers import AssignmentSerializer\nfrom projects.models import Project\nfrom projects.permissions import IsProjectAdmin, IsProjectStaffAndReadOnly\n\n\nclass AssignmentList(generics.ListCreateAPIView):\n    serializer_class = AssignmentSerializer\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    filter_backends = (DjangoFilterBackend, filters.OrderingFilter)\n    ordering_fields = (\"created_at\", \"updated_at\")\n    model = Assignment\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        queryset = self.model.objects.filter(project=self.project, assignee=self.request.user)\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)\n\n\nclass AssignmentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Assignment.objects.all()\n    serializer_class = AssignmentSerializer\n    lookup_url_kwarg = \"assignment_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n\nclass ResetAssignment(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def delete(self, *args, **kwargs):\n        Assignment.objects.filter(project=self.project).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass BulkAssignment(APIView):\n    serializer_class = AssignmentSerializer\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        try:\n            strategy_name = StrategyName[self.request.data[\"strategy_name\"]]\n        except KeyError:\n            return Response(\n                {\"detail\": \"Invalid strategy name\"},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            workload_allocation = WorkloadAllocation(workloads=self.request.data[\"workloads\"])\n        except ValidationError as e:\n            return Response(\n                {\"detail\": e.errors()},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            bulk_assign(\n                project_id=self.kwargs[\"project_id\"],\n                strategy_name=strategy_name,\n                member_ids=workload_allocation.member_ids,\n                weights=workload_allocation.weights,\n            )\n        except ValueError as e:\n            return Response(\n                {\"detail\": str(e)},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n        return Response(status=status.HTTP_201_CREATED)\n",
                                    "summary": "Class `AssignmentList`: A view for managing assignments with specific permissions and filtering options, along with functions for retrieving project details and handling assignment creation.",
                                    "code_element_summaries": [
                                        "Class `AssignmentList`: A view that handles listing and creating assignments with specific permissions and filtering options.",
                                        "Function `project`: Retrieves a specific Project object based on the project_id parameter.",
                                        "Function `get_queryset`: Retrieves queryset based on the model, project, and assignee for the current user.",
                                        "Function `perform_create`: Saves the serializer data with the associated project.",
                                        "Class `AssignmentDetail`: A view that allows for retrieving, updating, and deleting assignment details with specific permissions based on user roles.",
                                        "Class ResetAssignment: An API view class that allows project admins to reset assignments by deleting all assignments related to a specific project.",
                                        "Function `project`: Retrieves a Project object based on the project_id parameter from the request.",
                                        "Function `delete`: Deletes all assignments related to a specific project and returns a HTTP 204 No Content response.",
                                        "Class BulkAssignment: An API view for bulk assignment of workloads to project members based on a specified strategy and workload allocation.",
                                        "Function `post`: Handles POST requests by validating strategy name, workload allocation, and bulk assigning workloads to project members."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "comment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views\\comment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `CommentList`\nCode:\nclass CommentList(generics.ListCreateAPIView):\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    serializer_class = CommentSerializer\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    filterset_fields = [\"example\"]\n    search_fields = (\"text\",)\n    ordering_fields = (\"created_at\", \"example\")\n\n    def get_queryset(self):\n        queryset = Comment.objects.filter(example__project_id=self.kwargs[\"project_id\"])\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.request.query_params.get(\"example\"), user=self.request.user)\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        Comment.objects.filter(user=request.user, pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        queryset = Comment.objects.filter(example__project_id=self.kwargs[\"project_id\"])\n        return queryset",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.request.query_params.get(\"example\"), user=self.request.user)",
                                        "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        Comment.objects.filter(user=request.user, pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Class `CommentDetail`\nCode:\nclass CommentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Comment.objects.all()\n    serializer_class = CommentSerializer\n    lookup_url_kwarg = \"comment_id\"\n    permission_classes = [IsAuthenticated & IsProjectMember & IsOwnComment]"
                                    ],
                                    "code": "from django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import filters, generics, status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom examples.models import Comment\nfrom examples.permissions import IsOwnComment\nfrom examples.serializers import CommentSerializer\nfrom projects.permissions import IsProjectMember\n\n\nclass CommentList(generics.ListCreateAPIView):\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    serializer_class = CommentSerializer\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    filterset_fields = [\"example\"]\n    search_fields = (\"text\",)\n    ordering_fields = (\"created_at\", \"example\")\n\n    def get_queryset(self):\n        queryset = Comment.objects.filter(example__project_id=self.kwargs[\"project_id\"])\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.request.query_params.get(\"example\"), user=self.request.user)\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        Comment.objects.filter(user=request.user, pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass CommentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Comment.objects.all()\n    serializer_class = CommentSerializer\n    lookup_url_kwarg = \"comment_id\"\n    permission_classes = [IsAuthenticated & IsProjectMember & IsOwnComment]\n",
                                    "summary": "Class `CommentList` and `CommentDetail`: Views for managing comments with filtering, searching, ordering, and permissions, along with functions for retrieving, creating, updating, and deleting comments.",
                                    "code_element_summaries": [
                                        "Class `CommentList`: A view that handles listing, creating, and deleting comments with specific filtering, searching, and ordering capabilities.",
                                        "Function `get_queryset`: Retrieves comments related to a specific project ID from the database.",
                                        "Function `perform_create`: Saves the serializer data with additional parameters like example_id and user based on request query parameters and user information.",
                                        "Function `delete`: Deletes comments based on user and specified IDs from the request data.",
                                        "Class CommentDetail: A view for retrieving, updating, and deleting comment objects with specific permissions and serializer."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "example.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views\\example.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ExampleList`\nCode:\nclass ExampleList(generics.ListCreateAPIView):\n    serializer_class = ExampleSerializer\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    ordering_fields = (\"created_at\", \"updated_at\", \"score\")\n    search_fields = (\"text\", \"filename\")\n    model = Example\n    filterset_class = ExampleFilter\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        member = get_object_or_404(Member, project=self.project, user=self.request.user)\n        if member.is_admin():\n            return self.model.objects.filter(project=self.project)\n\n        queryset = self.model.objects.filter(project=self.project, assignments__assignee=self.request.user)\n        if self.project.random_order:\n            queryset = queryset.order_by(\"assignments__id\")\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)\n\n    def delete(self, request, *args, **kwargs):\n        queryset = self.project.examples\n        delete_ids = request.data[\"ids\"]\n        if delete_ids:\n            queryset.filter(pk__in=delete_ids).delete()\n        else:\n            queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        member = get_object_or_404(Member, project=self.project, user=self.request.user)\n        if member.is_admin():\n            return self.model.objects.filter(project=self.project)\n\n        queryset = self.model.objects.filter(project=self.project, assignments__assignee=self.request.user)\n        if self.project.random_order:\n            queryset = queryset.order_by(\"assignments__id\")\n        return queryset",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)",
                                        "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        queryset = self.project.examples\n        delete_ids = request.data[\"ids\"]\n        if delete_ids:\n            queryset.filter(pk__in=delete_ids).delete()\n        else:\n            queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Class `ExampleDetail`\nCode:\nclass ExampleDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Example.objects.all()\n    serializer_class = ExampleSerializer\n    lookup_url_kwarg = \"example_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]"
                                    ],
                                    "code": "from django.shortcuts import get_object_or_404\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import filters, generics, status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom examples.filters import ExampleFilter\nfrom examples.models import Example\nfrom examples.serializers import ExampleSerializer\nfrom projects.models import Member, Project\nfrom projects.permissions import IsProjectAdmin, IsProjectStaffAndReadOnly\n\n\nclass ExampleList(generics.ListCreateAPIView):\n    serializer_class = ExampleSerializer\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    ordering_fields = (\"created_at\", \"updated_at\", \"score\")\n    search_fields = (\"text\", \"filename\")\n    model = Example\n    filterset_class = ExampleFilter\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        member = get_object_or_404(Member, project=self.project, user=self.request.user)\n        if member.is_admin():\n            return self.model.objects.filter(project=self.project)\n\n        queryset = self.model.objects.filter(project=self.project, assignments__assignee=self.request.user)\n        if self.project.random_order:\n            queryset = queryset.order_by(\"assignments__id\")\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)\n\n    def delete(self, request, *args, **kwargs):\n        queryset = self.project.examples\n        delete_ids = request.data[\"ids\"]\n        if delete_ids:\n            queryset.filter(pk__in=delete_ids).delete()\n        else:\n            queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass ExampleDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Example.objects.all()\n    serializer_class = ExampleSerializer\n    lookup_url_kwarg = \"example_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n",
                                    "summary": "Class `ExampleList` and `ExampleDetail`: API views for handling listing, creation, deletion, retrieval, updating, and deletion of instances of the Example model with specific permissions and filtering options.",
                                    "code_element_summaries": [
                                        "Class `ExampleList`: A view that handles listing, creation, and deletion of examples with specific permissions and filtering options.",
                                        "Function `project`: Retrieves a Project object based on the project_id parameter.",
                                        "Function `get_queryset`: Retrieves the queryset based on user permissions and project settings.",
                                        "Function `perform_create`: Saves the serializer data with the associated project.",
                                        "Function `delete`: Deletes examples from the project based on provided IDs or deletes all examples if no IDs are provided.",
                                        "Class `ExampleDetail`: An API view for retrieving, updating, and deleting instances of the Example model with specific permissions."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "example_state.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views\\example_state.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ExampleStateList`\nCode:\nclass ExampleStateList(generics.ListCreateAPIView):\n    serializer_class = ExampleStateSerializer\n    permission_classes = [IsAuthenticated & IsProjectMember]\n\n    @property\n    def can_confirm_per_user(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        return not project.collaborative_annotation\n\n    def get_queryset(self):\n        queryset = ExampleState.objects.filter(example=self.kwargs[\"example_id\"])\n        if self.can_confirm_per_user:\n            queryset = queryset.filter(confirmed_by=self.request.user)\n        return queryset\n\n    def perform_create(self, serializer):\n        queryset = self.get_queryset()\n        if queryset.exists():\n            queryset.delete()\n        else:\n            example = get_object_or_404(Example, pk=self.kwargs[\"example_id\"])\n            serializer.save(example=example, confirmed_by=self.request.user)",
                                        "Function `can_confirm_per_user`\nCode:\n    def can_confirm_per_user(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        return not project.collaborative_annotation",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        queryset = ExampleState.objects.filter(example=self.kwargs[\"example_id\"])\n        if self.can_confirm_per_user:\n            queryset = queryset.filter(confirmed_by=self.request.user)\n        return queryset",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        queryset = self.get_queryset()\n        if queryset.exists():\n            queryset.delete()\n        else:\n            example = get_object_or_404(Example, pk=self.kwargs[\"example_id\"])\n            serializer.save(example=example, confirmed_by=self.request.user)"
                                    ],
                                    "code": "from django.shortcuts import get_object_or_404\nfrom rest_framework import generics\nfrom rest_framework.permissions import IsAuthenticated\n\nfrom examples.models import Example, ExampleState\nfrom examples.serializers import ExampleStateSerializer\nfrom projects.models import Project\nfrom projects.permissions import IsProjectMember\n\n\nclass ExampleStateList(generics.ListCreateAPIView):\n    serializer_class = ExampleStateSerializer\n    permission_classes = [IsAuthenticated & IsProjectMember]\n\n    @property\n    def can_confirm_per_user(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        return not project.collaborative_annotation\n\n    def get_queryset(self):\n        queryset = ExampleState.objects.filter(example=self.kwargs[\"example_id\"])\n        if self.can_confirm_per_user:\n            queryset = queryset.filter(confirmed_by=self.request.user)\n        return queryset\n\n    def perform_create(self, serializer):\n        queryset = self.get_queryset()\n        if queryset.exists():\n            queryset.delete()\n        else:\n            example = get_object_or_404(Example, pk=self.kwargs[\"example_id\"])\n            serializer.save(example=example, confirmed_by=self.request.user)\n",
                                    "summary": "Class `ExampleStateList`: Manages the creation and listing of ExampleState objects with project and user permissions, along with functions for checking confirmation settings and manipulating queryset data.",
                                    "code_element_summaries": [
                                        "Class `ExampleStateList`: A view that handles the creation and listing of ExampleState objects based on project and user permissions.",
                                        "Function `can_confirm_per_user`: Checks if a project allows individual user confirmation based on collaborative annotation setting.",
                                        "Function `get_queryset`: Retrieves a queryset of ExampleState objects filtered by example ID and user confirmation status.",
                                        "Function `perform_create`: Deletes existing queryset if it exists, otherwise saves serializer data with example and user confirmation."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a proxy model ExportedBoundingBox with methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "Content: \nclass ExtendedUser(User):\n    def get_full_name(self):\n        return f\"{self.first_name} {self.last_name}\"\n\n    class Meta:\n        proxy = True\n\nSummary:\nClass ExtendedUser: A proxy model of User that adds a method to get the full name of the user by combining the first and last names.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "labels",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content covers admin models, configuration classes, migration management, permission classes, serializer classes, test cases, API views, and functions related to text and image annotation, including labels, categories, spans, text labels, relations, bounding boxes, and segmentations.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `SpanAdmin`\nCode:\nclass SpanAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"start_offset\", \"user\")\n    ordering = (\"example\",)",
                                "Class `CategoryAdmin`\nCode:\nclass CategoryAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\")\n    ordering = (\"example\",)",
                                "Class `TextLabelAdmin`\nCode:\nclass TextLabelAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"text\", \"user\")\n    ordering = (\"example\",)",
                                "Class `BoundingBoxAdmin`\nCode:\nclass BoundingBoxAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\", \"x\", \"y\", \"width\", \"height\")\n    ordering = (\"example\",)",
                                "Class `SegmentationAdmin`\nCode:\nclass SegmentationAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\", \"points\")\n    ordering = (\"example\",)"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import BoundingBox, Category, Segmentation, Span, TextLabel\n\n\nclass SpanAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"start_offset\", \"user\")\n    ordering = (\"example\",)\n\n\nclass CategoryAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\")\n    ordering = (\"example\",)\n\n\nclass TextLabelAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"text\", \"user\")\n    ordering = (\"example\",)\n\n\nclass BoundingBoxAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\", \"x\", \"y\", \"width\", \"height\")\n    ordering = (\"example\",)\n\n\nclass SegmentationAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\", \"points\")\n    ordering = (\"example\",)\n\n\nadmin.site.register(Category, CategoryAdmin)\nadmin.site.register(Span, SpanAdmin)\nadmin.site.register(TextLabel, TextLabelAdmin)\nadmin.site.register(BoundingBox, BoundingBoxAdmin)\nadmin.site.register(Segmentation, SegmentationAdmin)\n",
                            "summary": "Admin models for managing Span, Category, TextLabel, BoundingBox, and Segmentation annotations with specific fields and ordering.",
                            "code_element_summaries": [
                                "Class SpanAdmin: An admin model for managing Span objects with specified fields for display and ordering.",
                                "Class CategoryAdmin: An admin model that displays examples, labels, and users in a specific order.",
                                "Class TextLabelAdmin: A model admin class for managing text label annotations with fields for example, text, and user.",
                                "Class BoundingBoxAdmin: A model admin class that displays bounding box annotations with specified fields and ordering.",
                                "Class SegmentationAdmin: A model admin class for managing segmentation annotations with specified list display fields and ordering."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelsConfig`\nCode:\nclass LabelsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"labels\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass LabelsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"labels\"\n",
                            "summary": "Class LabelsConfig: A configuration class in Django for managing label configurations within an application.",
                            "code_element_summaries": [
                                "Class LabelsConfig: A Django application configuration class for managing label configurations."
                            ],
                            "children": []
                        },
                        {
                            "name": "managers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\managers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelManager`\nCode:\nclass LabelManager(Manager):\n    label_type_field = \"label\"\n\n    def calc_label_distribution(self, examples, members, labels):\n        \"\"\"Calculate label distribution.\n\n        Args:\n            examples: example queryset.\n            members: user queryset.\n            labels: label queryset.\n\n        Returns:\n            label distribution per user.\n\n        Examples:\n            >>> self.calc_label_distribution(examples, members, labels)\n            {'admin': {'positive': 10, 'negative': 5}}\n        \"\"\"\n        distribution = {member.username: {label.text: 0 for label in labels} for member in members}\n        items = (\n            self.filter(example_id__in=examples)\n            .values(\"user__username\", f\"{self.label_type_field}__text\")\n            .annotate(count=Count(f\"{self.label_type_field}__text\"))\n        )\n        for item in items:\n            username = item[\"user__username\"]\n            label = item[f\"{self.label_type_field}__text\"]\n            count = item[\"count\"]\n            distribution[username][label] = count\n        return distribution\n\n    def get_labels(self, label, project):\n        if project.collaborative_annotation:\n            return self.filter(example=label.example)\n        else:\n            return self.filter(example=label.example, user=label.user)\n\n    def can_annotate(self, label, project) -> bool:\n        raise NotImplementedError(\"Please implement this method in the subclass\")\n\n    def filter_annotatable_labels(self, labels, project):\n        return [label for label in labels if self.can_annotate(label, project)]",
                                "Function `calc_label_distribution`: Calculate label distribution.\nCode:\n    def calc_label_distribution(self, examples, members, labels):\n        \"\"\"Calculate label distribution.\n\n        Args:\n            examples: example queryset.\n            members: user queryset.\n            labels: label queryset.\n\n        Returns:\n            label distribution per user.\n\n        Examples:\n            >>> self.calc_label_distribution(examples, members, labels)\n            {'admin': {'positive': 10, 'negative': 5}}\n        \"\"\"\n        distribution = {member.username: {label.text: 0 for label in labels} for member in members}\n        items = (\n            self.filter(example_id__in=examples)\n            .values(\"user__username\", f\"{self.label_type_field}__text\")\n            .annotate(count=Count(f\"{self.label_type_field}__text\"))\n        )\n        for item in items:\n            username = item[\"user__username\"]\n            label = item[f\"{self.label_type_field}__text\"]\n            count = item[\"count\"]\n            distribution[username][label] = count\n        return distribution",
                                "Function `get_labels`\nCode:\n    def get_labels(self, label, project):\n        if project.collaborative_annotation:\n            return self.filter(example=label.example)\n        else:\n            return self.filter(example=label.example, user=label.user)",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        raise NotImplementedError(\"Please implement this method in the subclass\")",
                                "Function `filter_annotatable_labels`\nCode:\n    def filter_annotatable_labels(self, labels, project):\n        return [label for label in labels if self.can_annotate(label, project)]",
                                "Class `CategoryManager`\nCode:\nclass CategoryManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        is_exclusive = project.single_class_classification\n        categories = self.get_labels(label, project)\n        if is_exclusive:\n            return not categories.exists()\n        else:\n            return not categories.filter(label=label.label).exists()",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        is_exclusive = project.single_class_classification\n        categories = self.get_labels(label, project)\n        if is_exclusive:\n            return not categories.exists()\n        else:\n            return not categories.filter(label=label.label).exists()",
                                "Class `SpanManager`\nCode:\nclass SpanManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        overlapping = getattr(project, \"allow_overlapping\", False)\n        spans = self.get_labels(label, project)\n        if overlapping:\n            return True\n        for span in spans:\n            if span.is_overlapping(label):\n                return False\n        return True",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        overlapping = getattr(project, \"allow_overlapping\", False)\n        spans = self.get_labels(label, project)\n        if overlapping:\n            return True\n        for span in spans:\n            if span.is_overlapping(label):\n                return False\n        return True",
                                "Class `TextLabelManager`\nCode:\nclass TextLabelManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        texts = self.get_labels(label, project)\n        for text in texts:\n            if text.is_same_text(label):\n                return False\n        return True",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        texts = self.get_labels(label, project)\n        for text in texts:\n            if text.is_same_text(label):\n                return False\n        return True",
                                "Class `RelationManager`\nCode:\nclass RelationManager(LabelManager):\n    label_type_field = \"type\"\n\n    def can_annotate(self, label, project) -> bool:\n        return True",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        return True",
                                "Class `BoundingBoxManager`\nCode:\nclass BoundingBoxManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        return True",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        return True",
                                "Class `SegmentationManager`\nCode:\nclass SegmentationManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        return True",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        return True"
                            ],
                            "code": "from django.db.models import Count, Manager\n\n\nclass LabelManager(Manager):\n    label_type_field = \"label\"\n\n    def calc_label_distribution(self, examples, members, labels):\n        \"\"\"Calculate label distribution.\n\n        Args:\n            examples: example queryset.\n            members: user queryset.\n            labels: label queryset.\n\n        Returns:\n            label distribution per user.\n\n        Examples:\n            >>> self.calc_label_distribution(examples, members, labels)\n            {'admin': {'positive': 10, 'negative': 5}}\n        \"\"\"\n        distribution = {member.username: {label.text: 0 for label in labels} for member in members}\n        items = (\n            self.filter(example_id__in=examples)\n            .values(\"user__username\", f\"{self.label_type_field}__text\")\n            .annotate(count=Count(f\"{self.label_type_field}__text\"))\n        )\n        for item in items:\n            username = item[\"user__username\"]\n            label = item[f\"{self.label_type_field}__text\"]\n            count = item[\"count\"]\n            distribution[username][label] = count\n        return distribution\n\n    def get_labels(self, label, project):\n        if project.collaborative_annotation:\n            return self.filter(example=label.example)\n        else:\n            return self.filter(example=label.example, user=label.user)\n\n    def can_annotate(self, label, project) -> bool:\n        raise NotImplementedError(\"Please implement this method in the subclass\")\n\n    def filter_annotatable_labels(self, labels, project):\n        return [label for label in labels if self.can_annotate(label, project)]\n\n\nclass CategoryManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        is_exclusive = project.single_class_classification\n        categories = self.get_labels(label, project)\n        if is_exclusive:\n            return not categories.exists()\n        else:\n            return not categories.filter(label=label.label).exists()\n\n\nclass SpanManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        overlapping = getattr(project, \"allow_overlapping\", False)\n        spans = self.get_labels(label, project)\n        if overlapping:\n            return True\n        for span in spans:\n            if span.is_overlapping(label):\n                return False\n        return True\n\n\nclass TextLabelManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        texts = self.get_labels(label, project)\n        for text in texts:\n            if text.is_same_text(label):\n                return False\n        return True\n\n\nclass RelationManager(LabelManager):\n    label_type_field = \"type\"\n\n    def can_annotate(self, label, project) -> bool:\n        return True\n\n\nclass BoundingBoxManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        return True\n\n\nclass SegmentationManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        return True\n",
                            "summary": "A collection of classes and functions within a label management system that determine the ability to annotate labels, categories, spans, text labels, relationships, bounding boxes, and segmentations in a collaborative annotation project.",
                            "code_element_summaries": [
                                "Class `LabelManager`: Manages label distribution, retrieval, and annotation capabilities for a project with collaborative annotation support.",
                                "Function `calc_label_distribution`: Calculates the label distribution per user based on examples, members, and labels provided.",
                                "Function `get_labels`: Retrieves labels based on the project's collaborative annotation setting and label information.",
                                "Function `can_annotate`: A placeholder method that checks if the subclass can annotate a given label in a project.",
                                "Function `filter_annotatable_labels`: Filters out labels that cannot be annotated in a given project.",
                                "Class CategoryManager: Manages category annotations by checking if a label can be annotated based on project settings.",
                                "Function `can_annotate`: Determines if a label can be annotated based on project settings and existing categories.",
                                "Class SpanManager: Manages the annotation of spans with consideration for overlapping labels within a project.",
                                "Function `can_annotate`: Determines if a label can be annotated on a project based on overlapping constraints.",
                                "Class TextLabelManager: Manages text labels and checks if a label can be annotated in a project based on existing text labels.",
                                "Function `can_annotate`: Determines if a label can be annotated for a project based on existing labels.",
                                "Class RelationManager: A subclass of LabelManager that manages relationships between labels and projects, with a method to determine if annotation is allowed.",
                                "Function `can_annotate`: Returns True indicating that the user is allowed to annotate the specified label in the project.",
                                "Class BoundingBoxManager: A subclass of LabelManager that determines if a label can be annotated in a project.",
                                "Function can_annotate: Returns True indicating that the user can annotate the given label in the specified project.",
                                "Class SegmentationManager: A subclass of LabelManager that determines if a given label can be annotated in a project.",
                                "Function `can_annotate`: A function that always returns True, indicating that annotations can be made with any label in a project."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A class designed to manage database schema changes and data migrations for various models, including creating new models and altering existing fields.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0031_auto_20220127_0032\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Span\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"start_offset\", models.IntegerField()),\n                        (\"end_offset\", models.IntegerField()),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"api.example\"\n                            ),\n                        ),\n                        (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.spantype\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"Category\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"api.example\"\n                            ),\n                        ),\n                        (\n                            \"label\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.categorytype\"),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"AnnotationRelations\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"annotation_id_1\", models.IntegerField()),\n                        (\"annotation_id_2\", models.IntegerField()),\n                        (\"timestamp\", models.DateTimeField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\n                            \"type\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=\"api.relationtypes\",\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"TextLabel\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"text\", models.TextField()),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"api.example\"\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"example\", \"user\", \"text\")},\n                    },\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(\n                        check=models.Q((\"start_offset__gte\", 0)), name=\"startOffset >= 0\"\n                    ),\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(check=models.Q((\"end_offset__gte\", 0)), name=\"endOffset >= 0\"),\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(\n                        check=models.Q((\"start_offset__lt\", django.db.models.expressions.F(\"end_offset\"))),\n                        name=\"start < end\",\n                    ),\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"category\",\n                    unique_together={(\"example\", \"user\", \"label\")},\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"annotationrelations\",\n                    unique_together={(\"annotation_id_1\", \"annotation_id_2\", \"type\", \"project\")},\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 00:32\n\nfrom django.conf import settings\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport django.db.models.expressions\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0031_auto_20220127_0032\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Span\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"start_offset\", models.IntegerField()),\n                        (\"end_offset\", models.IntegerField()),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"api.example\"\n                            ),\n                        ),\n                        (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.spantype\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"Category\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"api.example\"\n                            ),\n                        ),\n                        (\n                            \"label\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.categorytype\"),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"AnnotationRelations\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"annotation_id_1\", models.IntegerField()),\n                        (\"annotation_id_2\", models.IntegerField()),\n                        (\"timestamp\", models.DateTimeField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\n                            \"type\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=\"api.relationtypes\",\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"TextLabel\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"text\", models.TextField()),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"api.example\"\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"example\", \"user\", \"text\")},\n                    },\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(\n                        check=models.Q((\"start_offset__gte\", 0)), name=\"startOffset >= 0\"\n                    ),\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(check=models.Q((\"end_offset__gte\", 0)), name=\"endOffset >= 0\"),\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(\n                        check=models.Q((\"start_offset__lt\", django.db.models.expressions.F(\"end_offset\"))),\n                        name=\"start < end\",\n                    ),\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"category\",\n                    unique_together={(\"example\", \"user\", \"label\")},\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"annotationrelations\",\n                    unique_together={(\"annotation_id_1\", \"annotation_id_2\", \"type\", \"project\")},\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class defining database schema changes for creating models related to annotations and relationships.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that defines the database schema changes for creating models related to annotations and relationships."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_rename_annotationrelations_relation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0002_rename_annotationrelations_relation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0031_auto_20220127_0032\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"AnnotationRelations\",\n            new_name=\"Relation\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 02:39\n\nfrom django.conf import settings\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0031_auto_20220127_0032\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"AnnotationRelations\",\n            new_name=\"Relation\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class designed to manage database schema changes, including model renaming, by handling dependencies and operations.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that handles dependencies and operations for database schema changes, including renaming a model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_auto_20220127_0654.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0003_auto_20220127_0654.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0001_initial\"),\n        (\"labels\", \"0002_rename_annotationrelations_relation\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"category\",\n                    name=\"label\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                migrations.AlterField(\n                    model_name=\"relation\",\n                    name=\"type\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"label_types.relationtypes\",\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"span\",\n                    name=\"label\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.spantype\"),\n                ),\n            ]\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 06:54\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0001_initial\"),\n        (\"labels\", \"0002_rename_annotationrelations_relation\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"category\",\n                    name=\"label\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                migrations.AlterField(\n                    model_name=\"relation\",\n                    name=\"type\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"label_types.relationtypes\",\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"span\",\n                    name=\"label\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.spantype\"),\n                ),\n            ]\n        )\n    ]\n",
                                    "summary": "Class Migration: A class designed to handle database operations and state operations separately for altering fields in various models.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that separates database operations and state operations for altering fields in different models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_auto_20220128_0246.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0004_auto_20220128_0246.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0001_initial\"),\n        (\"labels\", \"0003_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"category\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"examples.example\"\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"span\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"examples.example\"\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"textlabel\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"examples.example\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-28 02:46\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0001_initial\"),\n        (\"labels\", \"0003_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"category\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"examples.example\"\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"span\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"examples.example\"\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"textlabel\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"examples.example\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class designed for handling database and state operations to alter fields in specific models related to the 'example' model.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that separates database and state operations for altering fields in the 'category', 'span', and 'textlabel' models related to the 'example' model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_alter_relation_project.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0005_alter_relation_project.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"labels\", \"0004_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"relation\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"labels\", \"0004_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"relation\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class designed to handle database and state operations for altering a field in the relation model.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that separates database and state operations for altering a field in the relation model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0006_rename_relation_relationold.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0006_rename_relation_relationold.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0005_alter_relation_project\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"Relation\",\n            new_name=\"RelationOld\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 05:29\n\nfrom django.conf import settings\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0005_alter_relation_project\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"Relation\",\n            new_name=\"RelationOld\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class designed to manage database schema changes and data migrations.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that handles changes to database schema and data migrations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0007_relationnew.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0007_relationnew.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0006_rename_relation_relationold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"RelationNew\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"direction\",\n                    models.CharField(\n                        choices=[(\"left\", \"left\"), (\"right\", \"right\"), (\"undirected\", \"undirected\")],\n                        default=\"undirected\",\n                        max_length=10,\n                    ),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"relations\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"from_id\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"from_relations\", to=\"labels.span\"\n                    ),\n                ),\n                (\n                    \"to_id\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"to_relations\", to=\"labels.span\"\n                    ),\n                ),\n                (\"type\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.relationtype\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"abstract\": False,\n            },\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 06:15\n\nfrom django.conf import settings\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0006_rename_relation_relationold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"RelationNew\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"direction\",\n                    models.CharField(\n                        choices=[(\"left\", \"left\"), (\"right\", \"right\"), (\"undirected\", \"undirected\")],\n                        default=\"undirected\",\n                        max_length=10,\n                    ),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"relations\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"from_id\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"from_relations\", to=\"labels.span\"\n                    ),\n                ),\n                (\n                    \"to_id\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"to_relations\", to=\"labels.span\"\n                    ),\n                ),\n                (\"type\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.relationtype\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"abstract\": False,\n            },\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a new model \"RelationNew\" with defined fields and dependencies.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a new model \"RelationNew\" with various fields and dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0008_auto_20220222_0630.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0008_auto_20220222_0630.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `copy_relation`\nCode:\ndef copy_relation(apps, schema_editor):\n    RelationTypeNew = apps.get_model(\"label_types\", \"RelationType\")\n    RelationOld = apps.get_model(\"labels\", \"RelationOld\")\n    RelationNew = apps.get_model(\"labels\", \"RelationNew\")\n    Span = apps.get_model(\"labels\", \"Span\")\n    for relation_old in RelationOld.objects.all():\n        from_id = Span.objects.get(id=relation_old.annotation_id_1)\n        to_id = Span.objects.get(id=relation_old.annotation_id_2)\n        relation_type = RelationTypeNew.objects.get(project=relation_old.type.project, text=relation_old.type.name)\n        RelationNew(\n            from_id=from_id, to_id=to_id, user=relation_old.user, type=relation_type, example=from_id.example\n        ).save()",
                                        "Function `delete_new_relation`\nCode:\ndef delete_new_relation(apps, schema_editor):\n    RelationNew = apps.get_model(\"labels\", \"RelationNew\")\n    RelationOld = apps.get_model(\"labels\", \"RelationOld\")\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    for relation in RelationNew.objects.all():\n        relation_type, _ = RelationTypeOld.objects.get_or_create(\n            project=relation.type.project, name=relation.type.text, color=relation.type.background_color\n        )\n        RelationOld(\n            annotation_id_1=relation.from_id.id,\n            annotation_id_2=relation.to_id.id,\n            timestamp=relation.created_at,\n            user=relation.user,\n            project=relation.example.project,\n            type=relation_type,\n        ).save()\n        relation.delete()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0007_relationnew\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_relation, reverse_code=delete_new_relation),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 06:30\n\nfrom django.db import migrations\n\n\ndef copy_relation(apps, schema_editor):\n    RelationTypeNew = apps.get_model(\"label_types\", \"RelationType\")\n    RelationOld = apps.get_model(\"labels\", \"RelationOld\")\n    RelationNew = apps.get_model(\"labels\", \"RelationNew\")\n    Span = apps.get_model(\"labels\", \"Span\")\n    for relation_old in RelationOld.objects.all():\n        from_id = Span.objects.get(id=relation_old.annotation_id_1)\n        to_id = Span.objects.get(id=relation_old.annotation_id_2)\n        relation_type = RelationTypeNew.objects.get(project=relation_old.type.project, text=relation_old.type.name)\n        RelationNew(\n            from_id=from_id, to_id=to_id, user=relation_old.user, type=relation_type, example=from_id.example\n        ).save()\n\n\ndef delete_new_relation(apps, schema_editor):\n    RelationNew = apps.get_model(\"labels\", \"RelationNew\")\n    RelationOld = apps.get_model(\"labels\", \"RelationOld\")\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    for relation in RelationNew.objects.all():\n        relation_type, _ = RelationTypeOld.objects.get_or_create(\n            project=relation.type.project, name=relation.type.text, color=relation.type.background_color\n        )\n        RelationOld(\n            annotation_id_1=relation.from_id.id,\n            annotation_id_2=relation.to_id.id,\n            timestamp=relation.created_at,\n            user=relation.user,\n            project=relation.example.project,\n            type=relation_type,\n        ).save()\n        relation.delete()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0007_relationnew\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_relation, reverse_code=delete_new_relation),\n    ]\n",
                                    "summary": "Class Migration: A class that manages database schema changes for labels, including functions to copy and delete relations between old and new models.",
                                    "code_element_summaries": [
                                        "Function `copy_relation`: Copies relations from an old model to a new model by mapping IDs and types.",
                                        "Function `delete_new_relation`: A function that migrates data from a new relation model to an old relation model in a database.",
                                        "Class Migration: A migration class that handles the dependencies and operations for database schema changes related to labels."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0009_delete_relationold.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0009_delete_relationold.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0008_auto_20220222_0630\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"RelationOld\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 06:46\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0008_auto_20220222_0630\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"RelationOld\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that removes the \"RelationOld\" model during the migration process.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that deletes the model \"RelationOld\" as part of the migration process."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0010_rename_relationnew_relation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0010_rename_relationnew_relation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0009_delete_relationold\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationNew\",\n            new_name=\"Relation\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 07:04\n\nfrom django.conf import settings\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0009_delete_relationold\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationNew\",\n            new_name=\"Relation\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class that manages database schema changes by handling dependencies and operations.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that handles dependencies and operations for database schema changes."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0011_remove_relation_direction.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0011_remove_relation_direction.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0010_rename_relationnew_relation\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"relation\",\n            name=\"direction\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-03-02 01:30\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0010_rename_relationnew_relation\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"relation\",\n            name=\"direction\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that removes a specific field from a model in the database.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that removes the \"direction\" field from the \"relation\" model in the database."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0012_add_uuid_field.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0012_add_uuid_field.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0011_remove_relation_direction\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"relation\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"span\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"textlabel\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-05-12 02:27\n\nfrom django.db import migrations, models\nimport uuid\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0011_remove_relation_direction\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"relation\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"span\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"textlabel\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that adds UUID fields to specific models in the database schema.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that adds UUID fields to the Category, Relation, Span, and TextLabel models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0013_populate_uuid_values.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0013_populate_uuid_values.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `gen_uuid`\nCode:\ndef gen_uuid(apps, schema_editor):\n    Category = apps.get_model(\"labels\", \"Category\")\n    Span = apps.get_model(\"labels\", \"Span\")\n    Relation = apps.get_model(\"labels\", \"Relation\")\n    TextLabel = apps.get_model(\"labels\", \"TextLabel\")\n    for label in [Category, Span, Relation, TextLabel]:\n        for row in label.objects.all():\n            row.uuid = uuid.uuid4()\n            row.save(update_fields=[\"uuid\"])",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0012_add_uuid_field\"),\n    ]\n\n    operations = [\n        migrations.RunPython(gen_uuid, reverse_code=migrations.RunPython.noop),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-05-12 02:28\n\nfrom django.db import migrations\n\nimport uuid\n\n\ndef gen_uuid(apps, schema_editor):\n    Category = apps.get_model(\"labels\", \"Category\")\n    Span = apps.get_model(\"labels\", \"Span\")\n    Relation = apps.get_model(\"labels\", \"Relation\")\n    TextLabel = apps.get_model(\"labels\", \"TextLabel\")\n    for label in [Category, Span, Relation, TextLabel]:\n        for row in label.objects.all():\n            row.uuid = uuid.uuid4()\n            row.save(update_fields=[\"uuid\"])\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0012_add_uuid_field\"),\n    ]\n\n    operations = [\n        migrations.RunPython(gen_uuid, reverse_code=migrations.RunPython.noop),\n    ]\n",
                                    "summary": "Function `gen_uuid`: Generates UUIDs for models Category, Span, Relation, and TextLabel in the \"labels\" app, while Class Migration runs a custom Python function to incorporate UUID generation during the migration process.",
                                    "code_element_summaries": [
                                        "Function `gen_uuid`: A function that generates UUIDs for models Category, Span, Relation, and TextLabel in the \"labels\" app.",
                                        "Class Migration: A migration class that depends on the \"labels\" app and runs a custom Python function to generate UUIDs during the migration process."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0014_remove_uuid_null.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0014_remove_uuid_null.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0013_populate_uuid_values\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"relation\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"textlabel\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n    ]"
                                    ],
                                    "code": "import uuid\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0013_populate_uuid_values\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"relation\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"textlabel\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that updates UUID fields in various models with default unique values.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that alters the UUID fields in different models to have default unique values."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0015_create_boundingbox_table.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0015_create_boundingbox_table.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"labels\", \"0014_remove_uuid_null\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"BoundingBox\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"uuid\", models.UUIDField(default=uuid.uuid4, unique=True)),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"x\", models.FloatField()),\n                (\"y\", models.FloatField()),\n                (\"width\", models.FloatField()),\n                (\"height\", models.FloatField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"bboxes\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"label\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"x__gte\", 0)), name=\"x >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"y__gte\", 0)), name=\"y >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"width__gte\", 0)), name=\"width >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"height__gte\", 0)), name=\"height >= 0\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-29 06:19\n\nfrom django.conf import settings\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport uuid\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"labels\", \"0014_remove_uuid_null\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"BoundingBox\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"uuid\", models.UUIDField(default=uuid.uuid4, unique=True)),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"x\", models.FloatField()),\n                (\"y\", models.FloatField()),\n                (\"width\", models.FloatField()),\n                (\"height\", models.FloatField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"bboxes\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"label\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"x__gte\", 0)), name=\"x >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"y__gte\", 0)), name=\"y >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"width__gte\", 0)), name=\"width >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"height__gte\", 0)), name=\"height >= 0\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class responsible for creating a BoundingBox model with defined fields and constraints.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a BoundingBox model with various fields and constraints."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0016_segmentation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0016_segmentation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0015_create_boundingbox_table\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Segmentation\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"uuid\", models.UUIDField(default=uuid.uuid4, unique=True)),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"points\", models.JSONField(default=list)),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"segmentations\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"label\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"abstract\": False,\n            },\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 05:24\n\nimport uuid\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0015_create_boundingbox_table\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Segmentation\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"uuid\", models.UUIDField(default=uuid.uuid4, unique=True)),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"points\", models.JSONField(default=list)),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"segmentations\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"label\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"abstract\": False,\n            },\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that sets up a new model for segmentation with multiple fields and dependencies.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a new model for segmentation with various fields and dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content describes a class ExportedBoundingBox which acts as a proxy model for BoundingBox, providing methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Label`\nCode:\nclass Label(models.Model):\n    objects = LabelManager()\n\n    uuid = models.UUIDField(default=uuid.uuid4, unique=True)\n    prob = models.FloatField(default=0.0)\n    manual = models.BooleanField(default=False)\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        abstract = True",
                                "Class `Meta`\nCode:\n    class Meta:\n        abstract = True",
                                "Class `Category`\nCode:\nclass Category(Label):\n    objects = CategoryManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"categories\")\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = (\"example\", \"user\", \"label\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        unique_together = (\"example\", \"user\", \"label\")",
                                "Class `Span`\nCode:\nclass Span(Label):\n    objects = SpanManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"spans\")\n    label = models.ForeignKey(to=SpanType, on_delete=models.CASCADE)\n    start_offset = models.IntegerField()\n    end_offset = models.IntegerField()\n\n    def __str__(self):\n        text = self.example.text[self.start_offset : self.end_offset]\n        return f\"({text}, {self.start_offset}, {self.end_offset}, {self.label.text})\"\n\n    def validate_unique(self, exclude=None):\n        allow_overlapping = getattr(self.example.project, \"allow_overlapping\", False)\n        is_collaborative = self.example.project.collaborative_annotation\n        if allow_overlapping:\n            super().validate_unique(exclude=exclude)\n            return\n\n        overlapping_span = (\n            Span.objects.exclude(id=self.id)\n            .filter(example=self.example)\n            .filter(\n                models.Q(start_offset__gte=self.start_offset, start_offset__lt=self.end_offset)\n                | models.Q(end_offset__gt=self.start_offset, end_offset__lte=self.end_offset)\n                | models.Q(start_offset__lte=self.start_offset, end_offset__gte=self.end_offset)\n            )\n        )\n        if is_collaborative:\n            if overlapping_span.exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")\n        else:\n            if overlapping_span.filter(user=self.user).exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")\n\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)\n\n    def is_overlapping(self, other: \"Span\"):\n        return (\n            (other.start_offset <= self.start_offset < other.end_offset)\n            or (other.start_offset < self.end_offset <= other.end_offset)\n            or (self.start_offset < other.start_offset and other.end_offset < self.end_offset)\n        )\n\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(start_offset__gte=0), name=\"startOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(end_offset__gte=0), name=\"endOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(start_offset__lt=models.F(\"end_offset\")), name=\"start < end\"),\n        ]",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        text = self.example.text[self.start_offset : self.end_offset]\n        return f\"({text}, {self.start_offset}, {self.end_offset}, {self.label.text})\"",
                                "Function `validate_unique`\nCode:\n    def validate_unique(self, exclude=None):\n        allow_overlapping = getattr(self.example.project, \"allow_overlapping\", False)\n        is_collaborative = self.example.project.collaborative_annotation\n        if allow_overlapping:\n            super().validate_unique(exclude=exclude)\n            return\n\n        overlapping_span = (\n            Span.objects.exclude(id=self.id)\n            .filter(example=self.example)\n            .filter(\n                models.Q(start_offset__gte=self.start_offset, start_offset__lt=self.end_offset)\n                | models.Q(end_offset__gt=self.start_offset, end_offset__lte=self.end_offset)\n                | models.Q(start_offset__lte=self.start_offset, end_offset__gte=self.end_offset)\n            )\n        )\n        if is_collaborative:\n            if overlapping_span.exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")\n        else:\n            if overlapping_span.filter(user=self.user).exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")",
                                "Function `save`\nCode:\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)",
                                "Function `is_overlapping`\nCode:\n    def is_overlapping(self, other: \"Span\"):\n        return (\n            (other.start_offset <= self.start_offset < other.end_offset)\n            or (other.start_offset < self.end_offset <= other.end_offset)\n            or (self.start_offset < other.start_offset and other.end_offset < self.end_offset)\n        )",
                                "Class `Meta`\nCode:\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(start_offset__gte=0), name=\"startOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(end_offset__gte=0), name=\"endOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(start_offset__lt=models.F(\"end_offset\")), name=\"start < end\"),\n        ]",
                                "Class `TextLabel`\nCode:\nclass TextLabel(Label):\n    objects = TextLabelManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"texts\")\n    text = models.TextField()\n\n    def is_same_text(self, other: \"TextLabel\"):\n        return self.text == other.text\n\n    class Meta:\n        unique_together = (\"example\", \"user\", \"text\")",
                                "Function `is_same_text`\nCode:\n    def is_same_text(self, other: \"TextLabel\"):\n        return self.text == other.text",
                                "Class `Meta`\nCode:\n    class Meta:\n        unique_together = (\"example\", \"user\", \"text\")",
                                "Class `Relation`\nCode:\nclass Relation(Label):\n    objects = RelationManager()\n    from_id = models.ForeignKey(Span, on_delete=models.CASCADE, related_name=\"from_relations\")\n    to_id = models.ForeignKey(Span, on_delete=models.CASCADE, related_name=\"to_relations\")\n    type = models.ForeignKey(RelationType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"relations\")\n\n    def __str__(self):\n        text = self.example.text\n        from_span = text[self.from_id.start_offset : self.from_id.end_offset]\n        to_span = text[self.to_id.start_offset : self.to_id.end_offset]\n        type_text = self.type.text\n        return f\"{from_span} - ({type_text}) -> {to_span}\"\n\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)\n\n    def clean(self):\n        same_example = self.from_id.example == self.to_id.example == self.example\n        if not same_example:\n            raise ValidationError(\"You need to label the same example.\")\n        return super().clean()",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        text = self.example.text\n        from_span = text[self.from_id.start_offset : self.from_id.end_offset]\n        to_span = text[self.to_id.start_offset : self.to_id.end_offset]\n        type_text = self.type.text\n        return f\"{from_span} - ({type_text}) -> {to_span}\"",
                                "Function `save`\nCode:\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)",
                                "Function `clean`\nCode:\n    def clean(self):\n        same_example = self.from_id.example == self.to_id.example == self.example\n        if not same_example:\n            raise ValidationError(\"You need to label the same example.\")\n        return super().clean()",
                                "Class `BoundingBox`\nCode:\nclass BoundingBox(Label):\n    objects = BoundingBoxManager()\n    x = models.FloatField()\n    y = models.FloatField()\n    width = models.FloatField()\n    height = models.FloatField()\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"bboxes\")\n\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(x__gte=0), name=\"x >= 0\"),\n            models.CheckConstraint(check=models.Q(y__gte=0), name=\"y >= 0\"),\n            models.CheckConstraint(check=models.Q(width__gte=0), name=\"width >= 0\"),\n            models.CheckConstraint(check=models.Q(height__gte=0), name=\"height >= 0\"),\n        ]",
                                "Class `Meta`\nCode:\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(x__gte=0), name=\"x >= 0\"),\n            models.CheckConstraint(check=models.Q(y__gte=0), name=\"y >= 0\"),\n            models.CheckConstraint(check=models.Q(width__gte=0), name=\"width >= 0\"),\n            models.CheckConstraint(check=models.Q(height__gte=0), name=\"height >= 0\"),\n        ]",
                                "Class `Segmentation`\nCode:\nclass Segmentation(Label):\n    objects = SegmentationManager()\n    points = models.JSONField(default=list)\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"segmentations\")"
                            ],
                            "code": "import uuid\n\nfrom django.contrib.auth.models import User\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\n\nfrom .managers import (\n    BoundingBoxManager,\n    CategoryManager,\n    LabelManager,\n    RelationManager,\n    SegmentationManager,\n    SpanManager,\n    TextLabelManager,\n)\nfrom examples.models import Example\nfrom label_types.models import CategoryType, RelationType, SpanType\n\n\nclass Label(models.Model):\n    objects = LabelManager()\n\n    uuid = models.UUIDField(default=uuid.uuid4, unique=True)\n    prob = models.FloatField(default=0.0)\n    manual = models.BooleanField(default=False)\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        abstract = True\n\n\nclass Category(Label):\n    objects = CategoryManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"categories\")\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = (\"example\", \"user\", \"label\")\n\n\nclass Span(Label):\n    objects = SpanManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"spans\")\n    label = models.ForeignKey(to=SpanType, on_delete=models.CASCADE)\n    start_offset = models.IntegerField()\n    end_offset = models.IntegerField()\n\n    def __str__(self):\n        text = self.example.text[self.start_offset : self.end_offset]\n        return f\"({text}, {self.start_offset}, {self.end_offset}, {self.label.text})\"\n\n    def validate_unique(self, exclude=None):\n        allow_overlapping = getattr(self.example.project, \"allow_overlapping\", False)\n        is_collaborative = self.example.project.collaborative_annotation\n        if allow_overlapping:\n            super().validate_unique(exclude=exclude)\n            return\n\n        overlapping_span = (\n            Span.objects.exclude(id=self.id)\n            .filter(example=self.example)\n            .filter(\n                models.Q(start_offset__gte=self.start_offset, start_offset__lt=self.end_offset)\n                | models.Q(end_offset__gt=self.start_offset, end_offset__lte=self.end_offset)\n                | models.Q(start_offset__lte=self.start_offset, end_offset__gte=self.end_offset)\n            )\n        )\n        if is_collaborative:\n            if overlapping_span.exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")\n        else:\n            if overlapping_span.filter(user=self.user).exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")\n\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)\n\n    def is_overlapping(self, other: \"Span\"):\n        return (\n            (other.start_offset <= self.start_offset < other.end_offset)\n            or (other.start_offset < self.end_offset <= other.end_offset)\n            or (self.start_offset < other.start_offset and other.end_offset < self.end_offset)\n        )\n\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(start_offset__gte=0), name=\"startOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(end_offset__gte=0), name=\"endOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(start_offset__lt=models.F(\"end_offset\")), name=\"start < end\"),\n        ]\n\n\nclass TextLabel(Label):\n    objects = TextLabelManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"texts\")\n    text = models.TextField()\n\n    def is_same_text(self, other: \"TextLabel\"):\n        return self.text == other.text\n\n    class Meta:\n        unique_together = (\"example\", \"user\", \"text\")\n\n\nclass Relation(Label):\n    objects = RelationManager()\n    from_id = models.ForeignKey(Span, on_delete=models.CASCADE, related_name=\"from_relations\")\n    to_id = models.ForeignKey(Span, on_delete=models.CASCADE, related_name=\"to_relations\")\n    type = models.ForeignKey(RelationType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"relations\")\n\n    def __str__(self):\n        text = self.example.text\n        from_span = text[self.from_id.start_offset : self.from_id.end_offset]\n        to_span = text[self.to_id.start_offset : self.to_id.end_offset]\n        type_text = self.type.text\n        return f\"{from_span} - ({type_text}) -> {to_span}\"\n\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)\n\n    def clean(self):\n        same_example = self.from_id.example == self.to_id.example == self.example\n        if not same_example:\n            raise ValidationError(\"You need to label the same example.\")\n        return super().clean()\n\n\nclass BoundingBox(Label):\n    objects = BoundingBoxManager()\n    x = models.FloatField()\n    y = models.FloatField()\n    width = models.FloatField()\n    height = models.FloatField()\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"bboxes\")\n\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(x__gte=0), name=\"x >= 0\"),\n            models.CheckConstraint(check=models.Q(y__gte=0), name=\"y >= 0\"),\n            models.CheckConstraint(check=models.Q(width__gte=0), name=\"width >= 0\"),\n            models.CheckConstraint(check=models.Q(height__gte=0), name=\"height >= 0\"),\n        ]\n\n\nclass Segmentation(Label):\n    objects = SegmentationManager()\n    points = models.JSONField(default=list)\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"segmentations\")\n",
                            "summary": "The content describes various models and functions related to text and image annotation, including labels, categories, spans, text labels, relations, bounding boxes, and segmentation annotations.",
                            "code_element_summaries": [
                                "Class Label: An abstract model representing labels with fields for probability, manual annotation status, user association, and timestamps.",
                                "Class Meta: A class containing metadata options for models, with the abstract attribute set to True.",
                                "Class Category: Represents a category with a label and example relationship, managed by CategoryManager.",
                                "Class Meta: Defines unique constraints for the example, user, and label fields in the model.",
                                "Class `Span`: A model representing a span of text with start and end offsets, allowing for validation of unique spans and checking for overlapping spans.",
                                "Function `__str__`: Returns a formatted string representation of the text, start offset, end offset, and label of an example.",
                                "Function `validate_unique`: Validates unique annotations based on project settings, allowing or disallowing overlapping spans depending on collaborative annotation and project configuration.",
                                "Function `save`: A method that validates the instance and saves it to the database using the parent class's save method.",
                                "Function `is_overlapping`: Determines if two spans overlap based on their start and end offsets.",
                                "Class `Meta`: Contains constraints for the start and end offsets in the model.",
                                "Class TextLabel: Represents text labels associated with an example, with a method to check if two TextLabels have the same text.",
                                "Function `is_same_text`: Compares the text attribute of two TextLabel objects to determine if they are the same.",
                                "Class Meta: Defines unique constraints for the fields example, user, and text in the model.",
                                "Class `Relation`: Represents a relation between spans within an example, with methods for string representation, saving, and validation.",
                                "Function `__str__`: Returns a string representation of a specific object's attributes.",
                                "Function `save`: A method that validates the instance and saves it using the parent class's save method.",
                                "Function `clean`: Validates if the from_id, to_id, and example are the same and raises a ValidationError if they are not.",
                                "Class BoundingBox: Represents bounding box annotations with x, y, width, height coordinates and associated label and example.",
                                "Class Meta: Contains constraints for ensuring that x, y, width, and height values are greater than or equal to 0.",
                                "Class Segmentation: A model representing segmentation annotations with points, label, and example relationships."
                            ],
                            "children": []
                        },
                        {
                            "name": "permissions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\permissions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `CanEditLabel`\nCode:\nclass CanEditLabel(BasePermission):\n    def __init__(self, queryset):\n        super().__init__()\n        self.queryset = queryset\n\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        annotation_id = view.kwargs.get(\"annotation_id\")\n        return self.queryset.filter(id=annotation_id, user=request.user).exists()",
                                "Function `__init__`\nCode:\n    def __init__(self, queryset):\n        super().__init__()\n        self.queryset = queryset",
                                "Function `has_permission`\nCode:\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        annotation_id = view.kwargs.get(\"annotation_id\")\n        return self.queryset.filter(id=annotation_id, user=request.user).exists()"
                            ],
                            "code": "from rest_framework.permissions import BasePermission\n\n\nclass CanEditLabel(BasePermission):\n    def __init__(self, queryset):\n        super().__init__()\n        self.queryset = queryset\n\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        annotation_id = view.kwargs.get(\"annotation_id\")\n        return self.queryset.filter(id=annotation_id, user=request.user).exists()\n",
                            "summary": "Class CanEditLabel: A custom permission class for checking user permission to edit annotation labels based on role and ownership, with functions for initializing queryset and determining user permission.",
                            "code_element_summaries": [
                                "Class CanEditLabel: A custom permission class that checks if a user has permission to edit a specific annotation label based on user role and ownership.",
                                "Function `__init__`: Initializes the queryset attribute for the class.",
                                "Function `has_permission`: Determines if a user has permission based on whether they are a superuser or if they have a specific annotation ID associated with their user account."
                            ],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `CategorySerializer`\nCode:\nclass CategorySerializer(serializers.ModelSerializer):\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = Category\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Category\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `SpanSerializer`\nCode:\nclass SpanSerializer(serializers.ModelSerializer):\n    label = serializers.PrimaryKeyRelatedField(queryset=SpanType.objects.all())\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = Span\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"start_offset\",\n            \"end_offset\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Span\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"start_offset\",\n            \"end_offset\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `TextLabelSerializer`\nCode:\nclass TextLabelSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = TextLabel\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"text\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = TextLabel\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"text\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `RelationSerializer`\nCode:\nclass RelationSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    type = serializers.PrimaryKeyRelatedField(queryset=RelationType.objects.all())\n\n    class Meta:\n        model = Relation\n        fields = (\"id\", \"prob\", \"user\", \"example\", \"created_at\", \"updated_at\", \"from_id\", \"to_id\", \"type\")\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Relation\n        fields = (\"id\", \"prob\", \"user\", \"example\", \"created_at\", \"updated_at\", \"from_id\", \"to_id\", \"type\")\n        read_only_fields = (\"user\",)",
                                "Class `BoundingBoxSerializer`\nCode:\nclass BoundingBoxSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n\n    class Meta:\n        model = BoundingBox\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"x\",\n            \"y\",\n            \"width\",\n            \"height\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = BoundingBox\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"x\",\n            \"y\",\n            \"width\",\n            \"height\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `SegmentationSerializer`\nCode:\nclass SegmentationSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n\n    class Meta:\n        model = Segmentation\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"points\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Segmentation\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"points\",\n        )\n        read_only_fields = (\"user\",)"
                            ],
                            "code": "from rest_framework import serializers\n\nfrom .models import BoundingBox, Category, Relation, Segmentation, Span, TextLabel\nfrom examples.models import Example\nfrom label_types.models import CategoryType, RelationType, SpanType\n\n\nclass CategorySerializer(serializers.ModelSerializer):\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = Category\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n        )\n        read_only_fields = (\"user\",)\n\n\nclass SpanSerializer(serializers.ModelSerializer):\n    label = serializers.PrimaryKeyRelatedField(queryset=SpanType.objects.all())\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = Span\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"start_offset\",\n            \"end_offset\",\n        )\n        read_only_fields = (\"user\",)\n\n\nclass TextLabelSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = TextLabel\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"text\",\n        )\n        read_only_fields = (\"user\",)\n\n\nclass RelationSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    type = serializers.PrimaryKeyRelatedField(queryset=RelationType.objects.all())\n\n    class Meta:\n        model = Relation\n        fields = (\"id\", \"prob\", \"user\", \"example\", \"created_at\", \"updated_at\", \"from_id\", \"to_id\", \"type\")\n        read_only_fields = (\"user\",)\n\n\nclass BoundingBoxSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n\n    class Meta:\n        model = BoundingBox\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"x\",\n            \"y\",\n            \"width\",\n            \"height\",\n        )\n        read_only_fields = (\"user\",)\n\n\nclass SegmentationSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n\n    class Meta:\n        model = Segmentation\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"points\",\n        )\n        read_only_fields = (\"user\",)\n",
                            "summary": "Classes `CategorySerializer`, `SpanSerializer`, `TextLabelSerializer`, `RelationSerializer`, `BoundingBoxSerializer`, and `SegmentationSerializer` are serializer classes for different models with specified fields and read-only options defined in their respective `Meta` classes.",
                            "code_element_summaries": [
                                "Class `CategorySerializer`: A serializer class for the Category model with fields for id, probability, user, example, creation and update timestamps, and label.",
                                "Class Meta: Defines metadata for the Category model including specified fields and read-only fields.",
                                "Class SpanSerializer: A serializer for the Span model that includes fields for id, probability, user, example, timestamps, label, start and end offsets, with the user field set as read-only.",
                                "Class Meta: Defines metadata for the Span model, specifying fields, read-only fields, and the model it represents.",
                                "Class TextLabelSerializer: A serializer model for TextLabel objects with fields for id, probability, user, example, creation and update timestamps, and text.",
                                "Class Meta: Defines metadata options for the TextLabel model including fields, read-only fields, and the model it represents.",
                                "Class RelationSerializer: A serializer for the Relation model that includes fields for example, type, probability, user, creation and update timestamps, and related IDs.",
                                "Class Meta: Defines metadata for the Relation model with specified fields and read-only fields.",
                                "Class BoundingBoxSerializer: A serializer class for BoundingBox model with fields for various properties like id, uuid, label, coordinates, and timestamps.",
                                "Class `Meta`: Defines the model and fields for BoundingBox along with read-only fields.",
                                "Class SegmentationSerializer: A serializer class for the Segmentation model that includes fields such as id, uuid, probability, user, example, created_at, updated_at, label, and points.",
                                "Class Meta: Defines the model and fields for the Segmentation class with specified read-only fields."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content includes various test case classes and functions for validating different labeling functionalities, setting up test data, and ensuring constraints in annotation projects, as well as a versatile function for generating annotations.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_bbox.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_bbox.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestBoundingBox`\nCode:\nclass TestBoundingBox(TestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin\n\n    def test_cannot_create_label_if_x_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=-1, y=0, width=0, height=0)\n\n    def test_cannot_create_label_if_y_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=-1, width=0, height=0)\n\n    def test_cannot_create_label_if_width_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=-1, height=0)\n\n    def test_cannot_create_label_if_height_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=0, height=-1)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin",
                                        "Function `test_cannot_create_label_if_x_is_less_than_zero`\nCode:\n    def test_cannot_create_label_if_x_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=-1, y=0, width=0, height=0)",
                                        "Function `test_cannot_create_label_if_y_is_less_than_zero`\nCode:\n    def test_cannot_create_label_if_y_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=-1, width=0, height=0)",
                                        "Function `test_cannot_create_label_if_width_is_less_than_zero`\nCode:\n    def test_cannot_create_label_if_width_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=-1, height=0)",
                                        "Function `test_cannot_create_label_if_height_is_less_than_zero`\nCode:\n    def test_cannot_create_label_if_height_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=0, height=-1)"
                                    ],
                                    "code": "from django.db import IntegrityError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom projects.tests.utils import prepare_project\n\n\nclass TestBoundingBox(TestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin\n\n    def test_cannot_create_label_if_x_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=-1, y=0, width=0, height=0)\n\n    def test_cannot_create_label_if_y_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=-1, width=0, height=0)\n\n    def test_cannot_create_label_if_width_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=-1, height=0)\n\n    def test_cannot_create_label_if_height_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=0, height=-1)\n",
                                    "summary": "Class `TestBoundingBox`: Tests to ensure that labels cannot be created if any of the bounding box dimensions are less than zero in a test environment with specific setup data.",
                                    "code_element_summaries": [
                                        "Class `TestBoundingBox`: Tests to ensure that labels cannot be created if any of the bounding box dimensions are less than zero.",
                                        "Function `setUpTestData`: A method that sets up test data by creating a project, an example item, and assigning an admin user.",
                                        "Function test_cannot_create_label_if_x_is_less_than_zero: Verifies that a label cannot be created if the x coordinate is less than zero.",
                                        "Function test_cannot_create_label_if_y_is_less_than_zero: Tests that a label cannot be created if the y-coordinate is less than zero.",
                                        "Function `test_cannot_create_label_if_width_is_less_than_zero`: Tests that a label cannot be created if the width is less than zero.",
                                        "Function `test_cannot_create_label_if_height_is_less_than_zero`: Tests that a label cannot be created if the height of the bounding box is less than zero."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_category.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_category.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestCategoryLabeling`\nCode:\nclass TestCategoryLabeling(abc.ABC, TestCase):\n    exclusive = True\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION,\n            single_class_classification=cls.exclusive,\n            collaborative_annotation=cls.collaborative,\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"CategoryType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.category = Category(example=cls.example, label=cls.label_type, user=cls.user)\n\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION,\n            single_class_classification=cls.exclusive,\n            collaborative_annotation=cls.collaborative,\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"CategoryType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.category = Category(example=cls.example, label=cls.label_type, user=cls.user)",
                                        "Function `test_can_annotate_category_to_unannotated_data`\nCode:\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `NonCollaborativeMixin`\nCode:\nclass NonCollaborativeMixin:\n    def test_cannot_annotate_same_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_allow_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_cannot_annotate_same_category_to_annotated_data`\nCode:\n    def test_cannot_annotate_same_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_same_category`\nCode:\n    def test_allow_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestExclusiveCategoryLabeling`\nCode:\nclass TestExclusiveCategoryLabeling(TestCategoryLabeling, NonCollaborativeMixin):\n    exclusive = True\n    collaborative = False\n\n    def test_cannot_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_cannot_annotate_different_category_to_annotated_data`\nCode:\n    def test_cannot_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Class `TestNonExclusiveCategoryLabeling`\nCode:\nclass TestNonExclusiveCategoryLabeling(TestCategoryLabeling, NonCollaborativeMixin):\n    exclusive = False\n    collaborative = False\n\n    def test_can_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_can_annotate_different_category_to_annotated_data`\nCode:\n    def test_can_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `CollaborativeMixin`\nCode:\nclass CollaborativeMixin:\n    def test_deny_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_deny_another_user_to_annotate_same_category`\nCode:\n    def test_deny_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Class `TestCollaborativeExclusiveCategoryLabeling`\nCode:\nclass TestCollaborativeExclusiveCategoryLabeling(TestCategoryLabeling, CollaborativeMixin):\n    exclusive = True\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_deny_another_user_to_annotate_different_category`\nCode:\n    def test_deny_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Class `TestCollaborativeNonExclusiveCategoryLabeling`\nCode:\nclass TestCollaborativeNonExclusiveCategoryLabeling(TestCategoryLabeling, CollaborativeMixin):\n    exclusive = False\n    collaborative = True\n\n    def test_allow_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_different_category`\nCode:\n    def test_allow_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestCategory`\nCode:\nclass TestCategory(TestCase):\n    def test_uniqueness(self):\n        a = mommy.make(\"Category\")\n        with self.assertRaises(IntegrityError):\n            Category(example=a.example, user=a.user, label=a.label).save()",
                                        "Function `test_uniqueness`\nCode:\n    def test_uniqueness(self):\n        a = mommy.make(\"Category\")\n        with self.assertRaises(IntegrityError):\n            Category(example=a.example, user=a.user, label=a.label).save()"
                                    ],
                                    "code": "import abc\n\nfrom django.db import IntegrityError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom labels.models import Category\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestCategoryLabeling(abc.ABC, TestCase):\n    exclusive = True\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION,\n            single_class_classification=cls.exclusive,\n            collaborative_annotation=cls.collaborative,\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"CategoryType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.category = Category(example=cls.example, label=cls.label_type, user=cls.user)\n\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass NonCollaborativeMixin:\n    def test_cannot_annotate_same_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_allow_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestExclusiveCategoryLabeling(TestCategoryLabeling, NonCollaborativeMixin):\n    exclusive = True\n    collaborative = False\n\n    def test_cannot_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)\n\n\nclass TestNonExclusiveCategoryLabeling(TestCategoryLabeling, NonCollaborativeMixin):\n    exclusive = False\n    collaborative = False\n\n    def test_can_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass CollaborativeMixin:\n    def test_deny_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)\n\n\nclass TestCollaborativeExclusiveCategoryLabeling(TestCategoryLabeling, CollaborativeMixin):\n    exclusive = True\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)\n\n\nclass TestCollaborativeNonExclusiveCategoryLabeling(TestCategoryLabeling, CollaborativeMixin):\n    exclusive = False\n    collaborative = True\n\n    def test_allow_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestCategory(TestCase):\n    def test_uniqueness(self):\n        a = mommy.make(\"Category\")\n        with self.assertRaises(IntegrityError):\n            Category(example=a.example, user=a.user, label=a.label).save()\n",
                                    "summary": "A comprehensive set of test classes and methods for category labeling functionality, including exclusive, non-exclusive, and collaborative scenarios, as well as testing category uniqueness constraints.",
                                    "code_element_summaries": [
                                        "Class `TestCategoryLabeling`: A test case class for category labeling with setup data and a test for annotating categories to unannotated data.",
                                        "Function `setUpTestData`: Sets up test data for a document classification project with example, label type, users, and category.",
                                        "Function `test_can_annotate_category_to_unannotated_data`: Verifies that a category can be annotated to unannotated data within a project.",
                                        "Class `NonCollaborativeMixin`: A mixin class with test methods for annotating data with restrictions on category collaboration.",
                                        "Function `test_cannot_annotate_same_category_to_annotated_data`: Verifies that the system prevents annotating the same category to already annotated data.",
                                        "Function `test_allow_another_user_to_annotate_same_category`: Tests if another user can annotate the same category within a project item.",
                                        "Class `TestExclusiveCategoryLabeling`: A test class for exclusive category labeling functionality that prevents annotating different categories to annotated data.",
                                        "Function `test_cannot_annotate_different_category_to_annotated_data`: Verifies that a different category cannot be annotated to already annotated data in a project.",
                                        "Class `TestNonExclusiveCategoryLabeling`: A test class for non-exclusive category labeling that checks if different categories can be annotated to annotated data.",
                                        "Function `test_can_annotate_different_category_to_annotated_data`: Verifies that a different category can be annotated to the annotated data successfully.",
                                        "Class CollaborativeMixin: Contains a method to test denying another user from annotating the same category.",
                                        "Function `test_deny_another_user_to_annotate_same_category`: Tests whether another user is denied permission to annotate the same category in a project.",
                                        "Class `TestCollaborativeExclusiveCategoryLabeling`: A test class that extends TestCategoryLabeling and CollaborativeMixin to test exclusive and collaborative category labeling functionalities.",
                                        "Function `test_deny_another_user_to_annotate_different_category`: Tests whether another user is denied access to annotate a different category within a project item.",
                                        "Class `TestCollaborativeNonExclusiveCategoryLabeling`: A test class that checks if another user can annotate a different category collaboratively in a non-exclusive category labeling scenario.",
                                        "Function `test_allow_another_user_to_annotate_different_category`: Tests if another user can annotate a different category within a project.",
                                        "Class TestCategory: Tests the uniqueness of Category instances by creating a new instance and asserting an IntegrityError when attempting to save a duplicate.",
                                        "Function `test_uniqueness`: Tests the uniqueness constraint for creating a new Category instance."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_relation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_relation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestRelationLabeling`\nCode:\nclass TestRelationLabeling(TestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"RelationType\", project=cls.project.item)\n        cls.user = cls.project.admin\n\n    def test_can_annotate_relation(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)\n\n    def test_cannot_annotate_relation_if_span_example_is_different(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)\n\n    def test_cannot_annotate_relation_if_relation_example_is_different_from_span_example(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", from_id=from_id, to_id=to_id)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"RelationType\", project=cls.project.item)\n        cls.user = cls.project.admin",
                                        "Function `test_can_annotate_relation`\nCode:\n    def test_can_annotate_relation(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)",
                                        "Function `test_cannot_annotate_relation_if_span_example_is_different`\nCode:\n    def test_cannot_annotate_relation_if_span_example_is_different(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)",
                                        "Function `test_cannot_annotate_relation_if_relation_example_is_different_from_span_example`\nCode:\n    def test_cannot_annotate_relation_if_relation_example_is_different_from_span_example(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", from_id=from_id, to_id=to_id)"
                                    ],
                                    "code": "from django.core.exceptions import ValidationError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestRelationLabeling(TestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"RelationType\", project=cls.project.item)\n        cls.user = cls.project.admin\n\n    def test_can_annotate_relation(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)\n\n    def test_cannot_annotate_relation_if_span_example_is_different(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)\n\n    def test_cannot_annotate_relation_if_relation_example_is_different_from_span_example(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", from_id=from_id, to_id=to_id)\n",
                                    "summary": "Class `TestRelationLabeling`: A test case class for annotating relations between spans in a project, including setup of test data and various test functions to validate relation annotations.",
                                    "code_element_summaries": [
                                        "Class `TestRelationLabeling`: A test case class for annotating relations between spans in a project.",
                                        "Function `setUpTestData`: Sets up test data including a project, example, label type, and user for sequence labeling.",
                                        "Function `test_can_annotate_relation`: Tests the ability to annotate relations between spans in an example.",
                                        "Function `test_cannot_annotate_relation_if_span_example_is_different`: Ensures that a relation cannot be annotated if the span example is different between the from and to spans.",
                                        "Function `test_cannot_annotate_relation_if_relation_example_is_different_from_span_example`: Tests that a relation cannot be annotated if the relation example is different from the span example."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_span.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_span.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestSpanLabeling`\nCode:\nclass TestSpanLabeling(abc.ABC, TestCase):\n    overlapping = False\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, allow_overlapping=cls.overlapping, collaborative_annotation=cls.collaborative\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"SpanType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.span = Span(example=cls.example, label=cls.label_type, user=cls.user, start_offset=0, end_offset=5)\n\n    def test_can_annotate_span_to_unannotated_data(self):\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, allow_overlapping=cls.overlapping, collaborative_annotation=cls.collaborative\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"SpanType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.span = Span(example=cls.example, label=cls.label_type, user=cls.user, start_offset=0, end_offset=5)",
                                        "Function `test_can_annotate_span_to_unannotated_data`\nCode:\n    def test_can_annotate_span_to_unannotated_data(self):\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `NonCollaborativeMixin`\nCode:\nclass NonCollaborativeMixin:\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_same_span`\nCode:\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestNonOverlappingSpanLabeling`\nCode:\nclass TestNonOverlappingSpanLabeling(TestSpanLabeling, NonCollaborativeMixin):\n    overlapping = False\n    collaborative = False\n\n    def test_cannot_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_cannot_annotate_different_span_type_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_cannot_annotate_same_span_to_annotated_data`\nCode:\n    def test_cannot_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_cannot_annotate_different_span_type_to_annotated_data`\nCode:\n    def test_cannot_annotate_different_span_type_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Class `TestOverlappingSpanLabeling`\nCode:\nclass TestOverlappingSpanLabeling(TestSpanLabeling, NonCollaborativeMixin):\n    overlapping = True\n    collaborative = False\n\n    def test_can_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_can_annotate_same_span_to_annotated_data`\nCode:\n    def test_can_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestCollaborativeNonOverlappingSpanLabeling`\nCode:\nclass TestCollaborativeNonOverlappingSpanLabeling(TestSpanLabeling):\n    overlapping = False\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_same_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_deny_another_user_to_annotate_different_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_deny_another_user_to_annotate_same_span_type`\nCode:\n    def test_deny_another_user_to_annotate_same_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_deny_another_user_to_annotate_different_span_type`\nCode:\n    def test_deny_another_user_to_annotate_different_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Class `TestCollaborativeOverlappingSpanLabeling`\nCode:\nclass TestCollaborativeOverlappingSpanLabeling(TestSpanLabeling):\n    overlapping = True\n    collaborative = True\n\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_same_span`\nCode:\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestSpan`\nCode:\nclass TestSpan(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin\n\n    def test_start_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-1, end_offset=0)\n\n    def test_end_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-2, end_offset=-1)\n\n    def test_start_offset_is_less_than_end_offset(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=0, end_offset=0)\n\n    def test_unique_constraint(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user)\n\n    def test_unique_constraint_violated(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            with self.assertRaises(ValidationError):\n                mommy.make(\n                    \"Span\", example=self.example, start_offset=start_offset, end_offset=end_offset, user=self.user\n                )\n\n    def test_unique_constraint_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        user = project.admin\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            mommy.make(\"Span\", example=example, start_offset=start_offset, end_offset=end_offset, user=user)\n\n    def test_update(self):\n        span = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5)\n        span.end_offset = 6\n        span.save()",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin",
                                        "Function `test_start_offset_is_not_negative`\nCode:\n    def test_start_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-1, end_offset=0)",
                                        "Function `test_end_offset_is_not_negative`\nCode:\n    def test_end_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-2, end_offset=-1)",
                                        "Function `test_start_offset_is_less_than_end_offset`\nCode:\n    def test_start_offset_is_less_than_end_offset(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=0, end_offset=0)",
                                        "Function `test_unique_constraint`\nCode:\n    def test_unique_constraint(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user)",
                                        "Function `test_unique_constraint_violated`\nCode:\n    def test_unique_constraint_violated(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            with self.assertRaises(ValidationError):\n                mommy.make(\n                    \"Span\", example=self.example, start_offset=start_offset, end_offset=end_offset, user=self.user\n                )",
                                        "Function `test_unique_constraint_if_overlapping_is_allowed`\nCode:\n    def test_unique_constraint_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        user = project.admin\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            mommy.make(\"Span\", example=example, start_offset=start_offset, end_offset=end_offset, user=user)",
                                        "Function `test_update`\nCode:\n    def test_update(self):\n        span = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5)\n        span.end_offset = 6\n        span.save()",
                                        "Class `TestSpanWithoutCollaborativeMode`\nCode:\nclass TestSpanWithoutCollaborativeMode(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, False, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_allow_users_to_create_same_spans(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.admin)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.approver)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, False, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)",
                                        "Function `test_allow_users_to_create_same_spans`\nCode:\n    def test_allow_users_to_create_same_spans(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.admin)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.approver)",
                                        "Class `TestSpanWithCollaborativeMode`\nCode:\nclass TestSpanWithCollaborativeMode(TestCase):\n    def test_deny_users_to_create_same_spans(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=False)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)\n\n    def test_allow_users_to_create_same_spans_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)",
                                        "Function `test_deny_users_to_create_same_spans`\nCode:\n    def test_deny_users_to_create_same_spans(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=False)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)",
                                        "Function `test_allow_users_to_create_same_spans_if_overlapping_is_allowed`\nCode:\n    def test_allow_users_to_create_same_spans_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)",
                                        "Class `TestLabelDistribution`\nCode:\nclass TestLabelDistribution(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin\n\n    def test_calc_label_distribution(self):\n        label_a = mommy.make(\"SpanType\", text=\"labelA\", project=self.project.item)\n        label_b = mommy.make(\"SpanType\", text=\"labelB\", project=self.project.item)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user, label=label_a)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user, label=label_b)\n        distribution = Span.objects.calc_label_distribution(\n            examples=self.project.item.examples.all(), members=self.project.members, labels=SpanType.objects.all()\n        )\n        expected = {user.username: {label.text: 0 for label in SpanType.objects.all()} for user in self.project.members}\n        expected[self.user.username][label_a.text] = 1\n        expected[self.user.username][label_b.text] = 1\n        self.assertEqual(distribution, expected)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin",
                                        "Function `test_calc_label_distribution`\nCode:\n    def test_calc_label_distribution(self):\n        label_a = mommy.make(\"SpanType\", text=\"labelA\", project=self.project.item)\n        label_b = mommy.make(\"SpanType\", text=\"labelB\", project=self.project.item)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user, label=label_a)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user, label=label_b)\n        distribution = Span.objects.calc_label_distribution(\n            examples=self.project.item.examples.all(), members=self.project.members, labels=SpanType.objects.all()\n        )\n        expected = {user.username: {label.text: 0 for label in SpanType.objects.all()} for user in self.project.members}\n        expected[self.user.username][label_a.text] = 1\n        expected[self.user.username][label_b.text] = 1\n        self.assertEqual(distribution, expected)"
                                    ],
                                    "code": "import abc\n\nfrom django.core.exceptions import ValidationError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom label_types.models import SpanType\nfrom labels.models import Span\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestSpanLabeling(abc.ABC, TestCase):\n    overlapping = False\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, allow_overlapping=cls.overlapping, collaborative_annotation=cls.collaborative\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"SpanType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.span = Span(example=cls.example, label=cls.label_type, user=cls.user, start_offset=0, end_offset=5)\n\n    def test_can_annotate_span_to_unannotated_data(self):\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass NonCollaborativeMixin:\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestNonOverlappingSpanLabeling(TestSpanLabeling, NonCollaborativeMixin):\n    overlapping = False\n    collaborative = False\n\n    def test_cannot_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_cannot_annotate_different_span_type_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n\nclass TestOverlappingSpanLabeling(TestSpanLabeling, NonCollaborativeMixin):\n    overlapping = True\n    collaborative = False\n\n    def test_can_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestCollaborativeNonOverlappingSpanLabeling(TestSpanLabeling):\n    overlapping = False\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_same_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_deny_another_user_to_annotate_different_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n\nclass TestCollaborativeOverlappingSpanLabeling(TestSpanLabeling):\n    overlapping = True\n    collaborative = True\n\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestSpan(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin\n\n    def test_start_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-1, end_offset=0)\n\n    def test_end_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-2, end_offset=-1)\n\n    def test_start_offset_is_less_than_end_offset(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=0, end_offset=0)\n\n    def test_unique_constraint(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user)\n\n    def test_unique_constraint_violated(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            with self.assertRaises(ValidationError):\n                mommy.make(\n                    \"Span\", example=self.example, start_offset=start_offset, end_offset=end_offset, user=self.user\n                )\n\n    def test_unique_constraint_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        user = project.admin\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            mommy.make(\"Span\", example=example, start_offset=start_offset, end_offset=end_offset, user=user)\n\n    def test_update(self):\n        span = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5)\n        span.end_offset = 6\n        span.save()\n\n\nclass TestSpanWithoutCollaborativeMode(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, False, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_allow_users_to_create_same_spans(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.admin)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.approver)\n\n\nclass TestSpanWithCollaborativeMode(TestCase):\n    def test_deny_users_to_create_same_spans(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=False)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)\n\n    def test_allow_users_to_create_same_spans_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)\n\n\nclass TestLabelDistribution(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin\n\n    def test_calc_label_distribution(self):\n        label_a = mommy.make(\"SpanType\", text=\"labelA\", project=self.project.item)\n        label_b = mommy.make(\"SpanType\", text=\"labelB\", project=self.project.item)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user, label=label_a)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user, label=label_b)\n        distribution = Span.objects.calc_label_distribution(\n            examples=self.project.item.examples.all(), members=self.project.members, labels=SpanType.objects.all()\n        )\n        expected = {user.username: {label.text: 0 for label in SpanType.objects.all()} for user in self.project.members}\n        expected[self.user.username][label_a.text] = 1\n        expected[self.user.username][label_b.text] = 1\n        self.assertEqual(distribution, expected)\n",
                                    "summary": "The content includes multiple test case classes and functions related to annotating spans in sequence labeling projects, testing collaborative and non-collaborative annotation modes, unique constraints for span objects, and label distribution among project members.",
                                    "code_element_summaries": [
                                        "Class `TestSpanLabeling`: A test case class for annotating spans in unannotated data within a project setup for sequence labeling.",
                                        "Function `setUpTestData`: Sets up test data for a project involving sequence labeling with specified attributes.",
                                        "Function `test_can_annotate_span_to_unannotated_data`: Tests the ability to annotate a span to unannotated data and asserts the result.",
                                        "Class NonCollaborativeMixin: A mixin class that includes a method for testing if another user can annotate the same span.",
                                        "Function `test_allow_another_user_to_annotate_same_span`: Tests if another user can annotate the same span as the original user.",
                                        "Class `TestNonOverlappingSpanLabeling`: A test class that checks if the same or different span types can be annotated to annotated data.",
                                        "Function `test_cannot_annotate_same_span_to_annotated_data`: Tests that a span cannot be annotated to already annotated data in a project.",
                                        "Function `test_cannot_annotate_different_span_type_to_annotated_data`: Verifies that a different span type cannot be annotated to existing annotated data.",
                                        "Class TestOverlappingSpanLabeling: Inherits from TestSpanLabeling and NonCollaborativeMixin, with overlapping set to True and collaborative set to False, and includes a test to annotate the same span to annotated data.",
                                        "Function `test_can_annotate_same_span_to_annotated_data`: Tests if the same span can be annotated to annotated data and asserts the annotation capability.",
                                        "Class `TestCollaborativeNonOverlappingSpanLabeling`: A test class for collaborative span labeling that ensures denial of another user annotating the same or different span types.",
                                        "Function `test_deny_another_user_to_annotate_same_span_type`: Tests if another user is denied permission to annotate the same span type.",
                                        "Function `test_deny_another_user_to_annotate_different_span_type`: Tests that another user is denied from annotating a different span type.",
                                        "Class `TestCollaborativeOverlappingSpanLabeling`: A test class for collaborative overlapping span labeling that allows another user to annotate the same span.",
                                        "Function `test_allow_another_user_to_annotate_same_span`: Tests if another user can annotate the same span as the original user.",
                                        "Class `TestSpan`: A test case class for validating constraints and uniqueness of Span objects in a project with sequence labeling.",
                                        "Function `setUp`: Initializes a project, example, and user for testing purposes.",
                                        "Function `test_start_offset_is_not_negative`: Tests that the start offset of a Span object cannot be negative.",
                                        "Function `test_end_offset_is_not_negative`: Tests that the end offset of a Span object cannot be negative.",
                                        "Function `test_start_offset_is_less_than_end_offset`: Tests that start offset is less than end offset by creating a Span object with equal start and end offsets.",
                                        "Function `test_unique_constraint`: Tests the unique constraint for creating Span instances with overlapping offsets under the same example and user.",
                                        "Function `test_unique_constraint_violated`: Tests if unique constraint is violated when creating Span objects with overlapping start and end offsets.",
                                        "Function `test_unique_constraint_if_overlapping_is_allowed`: Tests unique constraint behavior when overlapping spans are allowed in a project.",
                                        "Function `test_update`: A test function that updates the end offset of a Span object.",
                                        "Class TestSpanWithoutCollaborativeMode: A test case class that sets up a project and example for testing the creation of spans by different users with overlapping offsets.",
                                        "Function `setUp`: Initializes the project and example objects for testing sequence labeling with non-overlapping annotations.",
                                        "Function `test_allow_users_to_create_same_spans`: Verifies that users can create spans with the same start and end offsets on the same example.",
                                        "Class `TestSpanWithCollaborativeMode`: Contains test cases to ensure that users are denied or allowed to create overlapping spans based on project settings.",
                                        "Function `test_deny_users_to_create_same_spans`: Tests that users are denied to create overlapping spans in a sequence labeling project.",
                                        "Function `test_allow_users_to_create_same_spans_if_overlapping_is_allowed`: Tests the ability for users to create overlapping spans within a project with overlapping allowed.",
                                        "Class `TestLabelDistribution`: A test case class for calculating label distribution among project members for sequence labeling tasks.",
                                        "Function `setUp`: Initializes necessary objects for testing a sequence labeling project with non-overlapping annotations.",
                                        "Function `test_calc_label_distribution`: A test function that calculates the distribution of labels among users in a project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_text_label.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_text_label.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestTextLabeling`\nCode:\nclass TestTextLabeling(abc.ABC, TestCase):\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=cls.collaborative)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.text_label = TextLabel(example=cls.example, user=cls.user, text=\"foo\")\n\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n\n    def test_uniqueness(self):\n        a = mommy.make(\"TextLabel\")\n        with self.assertRaises(IntegrityError):\n            TextLabel(example=a.example, user=a.user, text=a.text).save()",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=cls.collaborative)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.text_label = TextLabel(example=cls.example, user=cls.user, text=\"foo\")",
                                        "Function `test_can_annotate_category_to_unannotated_data`\nCode:\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_uniqueness`\nCode:\n    def test_uniqueness(self):\n        a = mommy.make(\"TextLabel\")\n        with self.assertRaises(IntegrityError):\n            TextLabel(example=a.example, user=a.user, text=a.text).save()",
                                        "Class `TestNonCollaborativeTextLabeling`\nCode:\nclass TestNonCollaborativeTextLabeling(TestTextLabeling):\n    collaborative = False\n\n    def test_cannot_annotate_same_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_can_annotate_different_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n\n    def test_allow_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_cannot_annotate_same_text_to_annotated_data`\nCode:\n    def test_cannot_annotate_same_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_can_annotate_different_text_to_annotated_data`\nCode:\n    def test_can_annotate_different_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_same_text`\nCode:\n    def test_allow_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestCollaborativeTextLabeling`\nCode:\nclass TestCollaborativeTextLabeling(TestTextLabeling):\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_allow_another_user_to_annotate_different_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_deny_another_user_to_annotate_same_text`\nCode:\n    def test_deny_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_different_text`\nCode:\n    def test_allow_another_user_to_annotate_different_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)"
                                    ],
                                    "code": "import abc\n\nfrom django.db import IntegrityError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom labels.models import TextLabel\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestTextLabeling(abc.ABC, TestCase):\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=cls.collaborative)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.text_label = TextLabel(example=cls.example, user=cls.user, text=\"foo\")\n\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n\n    def test_uniqueness(self):\n        a = mommy.make(\"TextLabel\")\n        with self.assertRaises(IntegrityError):\n            TextLabel(example=a.example, user=a.user, text=a.text).save()\n\n\nclass TestNonCollaborativeTextLabeling(TestTextLabeling):\n    collaborative = False\n\n    def test_cannot_annotate_same_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_can_annotate_different_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n\n    def test_allow_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestCollaborativeTextLabeling(TestTextLabeling):\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_allow_another_user_to_annotate_different_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n",
                                    "summary": "Class TestTextLabeling: A test case class for validating text labeling functionality, including annotating categories, checking uniqueness of text labels, and setting up test data for specific attributes and relationships.",
                                    "code_element_summaries": [
                                        "Class TestTextLabeling: A test case class for testing text labeling functionality including annotating categories to unannotated data and checking uniqueness of text labels.",
                                        "Function `setUpTestData`: Sets up test data for a project with specific attributes and relationships.",
                                        "Function `test_can_annotate_category_to_unannotated_data`: Validates the ability to annotate a category to unannotated data.",
                                        "Function `test_uniqueness`: Tests the uniqueness constraint for creating TextLabel instances with the same example, user, and text fields.",
                                        "Class `TestNonCollaborativeTextLabeling`: Contains test cases to verify the behavior of non-collaborative text labeling, allowing or disallowing annotation of the same text by different users.",
                                        "Function `test_cannot_annotate_same_text_to_annotated_data`: Tests that the same text cannot be annotated to already annotated data in a specific project item.",
                                        "Function `test_can_annotate_different_text_to_annotated_data`: Tests the ability to annotate different text to annotated data using TextLabel objects.",
                                        "Function `test_allow_another_user_to_annotate_same_text`: Tests if another user is allowed to annotate the same text label.",
                                        "Class `TestCollaborativeTextLabeling`: Subclass of TestTextLabeling that tests collaborative text labeling functionality for multiple users.",
                                        "Function `test_deny_another_user_to_annotate_same_text`: Tests if another user is denied annotation of the same text as the original user.",
                                        "Function test_allow_another_user_to_annotate_different_text: Tests if another user can annotate different text in a project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestLabelList`\nCode:\nclass TestLabelList:\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task)\n        cls.non_member = make_user()\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)\n\n    def test_allows_project_member_to_fetch_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)  # fetch only own annotation\n\n    def test_denies_non_project_member_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 2)  # delete only own annotation",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task)\n        cls.non_member = make_user()\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)",
                                        "Function `test_allows_project_member_to_fetch_annotation`\nCode:\n    def test_allows_project_member_to_fetch_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)  # fetch only own annotation",
                                        "Function `test_denies_non_project_member_to_fetch_annotation`\nCode:\n    def test_denies_non_project_member_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_fetch_annotation`\nCode:\n    def test_denies_unauthenticated_user_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_member_to_bulk_delete_annotation`\nCode:\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 2)  # delete only own annotation",
                                        "Class `TestCategoryList`\nCode:\nclass TestCategoryList(TestLabelList, CRUDMixin):\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_list\"",
                                        "Class `TestSpanList`\nCode:\nclass TestSpanList(TestLabelList, CRUDMixin):\n    model = Span\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=0, end_offset=1)",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=0, end_offset=1)",
                                        "Class `TestBBoxList`\nCode:\nclass TestBBoxList(TestLabelList, CRUDMixin):\n    model = BoundingBox\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        mommy.make(\"BoundingBox\", example=doc, user=member, x=0, y=0, width=0, height=0)",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        mommy.make(\"BoundingBox\", example=doc, user=member, x=0, y=0, width=0, height=0)",
                                        "Class `TestSegmentationList`\nCode:\nclass TestSegmentationList(TestLabelList, CRUDMixin):\n    model = Segmentation\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        mommy.make(\"Segmentation\", example=doc, user=member, points=[0, 1])",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        mommy.make(\"Segmentation\", example=doc, user=member, points=[0, 1])",
                                        "Class `TestTextList`\nCode:\nclass TestTextList(TestLabelList, CRUDMixin):\n    model = TextLabel\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"",
                                        "Class `TestSharedLabelList`\nCode:\nclass TestSharedLabelList:\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task, collaborative_annotation=True)\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)\n\n    def test_allows_project_member_to_fetch_all_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 3)\n\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 0)  # delete all annotation in the doc",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task, collaborative_annotation=True)\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)",
                                        "Function `test_allows_project_member_to_fetch_all_annotation`\nCode:\n    def test_allows_project_member_to_fetch_all_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 3)",
                                        "Function `test_allows_project_member_to_bulk_delete_annotation`\nCode:\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 0)  # delete all annotation in the doc",
                                        "Class `TestSharedCategoryList`\nCode:\nclass TestSharedCategoryList(TestSharedLabelList, CRUDMixin):\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_list\"",
                                        "Class `TestSharedSpanList`\nCode:\nclass TestSharedSpanList(TestSharedLabelList, CRUDMixin):\n    model = Span\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n    start_offset = 0\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=cls.start_offset, end_offset=cls.start_offset + 1)\n        cls.start_offset += 1",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=cls.start_offset, end_offset=cls.start_offset + 1)\n        cls.start_offset += 1",
                                        "Class `TestSharedTextList`\nCode:\nclass TestSharedTextList(TestSharedLabelList, CRUDMixin):\n    model = TextLabel\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"",
                                        "Class `TestDataLabeling`\nCode:\nclass TestDataLabeling:\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        self.data = self.create_data()\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, self.doc.id])\n\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_non_project_member_to_annotate(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_annotate(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        self.data = self.create_data()\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, self.doc.id])",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id}",
                                        "Function `test_allows_project_member_to_annotate`\nCode:\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Function `test_denies_non_project_member_to_annotate`\nCode:\n    def test_denies_non_project_member_to_annotate(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_annotate`\nCode:\n    def test_denies_unauthenticated_user_to_annotate(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestCategoryCreation`\nCode:\nclass TestCategoryCreation(TestDataLabeling, CRUDMixin):\n    view_name = \"category_list\"",
                                        "Class `TestSpanCreation`\nCode:\nclass TestSpanCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id, \"start_offset\": 0, \"end_offset\": 1}",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id, \"start_offset\": 0, \"end_offset\": 1}",
                                        "Class `TestRelationCreation`\nCode:\nclass TestRelationCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"relation_list\"\n\n    def create_data(self):\n        relation_type = mommy.make(\"RelationType\", project=self.project.item)\n        from_id = mommy.make(\"Span\", example=self.doc, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.doc, start_offset=1, end_offset=2)\n        return {\"type\": relation_type.id, \"from_id\": from_id.id, \"to_id\": to_id.id}",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        relation_type = mommy.make(\"RelationType\", project=self.project.item)\n        from_id = mommy.make(\"Span\", example=self.doc, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.doc, start_offset=1, end_offset=2)\n        return {\"type\": relation_type.id, \"from_id\": from_id.id, \"to_id\": to_id.id}",
                                        "Class `TestTextLabelCreation`\nCode:\nclass TestTextLabelCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"\n\n    def create_data(self):\n        return {\"text\": \"example\"}",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        return {\"text\": \"example\"}",
                                        "Class `TestBoundingBoxCreation`\nCode:\nclass TestBoundingBoxCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_list\"\n\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"x\": 0, \"y\": 0, \"width\": 0, \"height\": 0, \"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"x\": 0, \"y\": 0, \"width\": 0, \"height\": 0, \"label\": label.id}",
                                        "Function `test_allows_project_member_to_annotate`\nCode:\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Class `TestSegmentationCreation`\nCode:\nclass TestSegmentationCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_list\"\n\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"points\": [1, 2], \"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"points\": [1, 2], \"label\": label.id}",
                                        "Function `test_allows_project_member_to_annotate`\nCode:\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Class `TestLabelDetail`\nCode:\nclass TestLabelDetail:\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"annotation_detail\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        label = make_label(self.project.item)\n        annotation = self.create_annotation_data(doc=doc)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin, start_offset=0, end_offset=1)\n\n    def test_allows_owner_to_get_annotation(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_owner_to_get_annotation(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_get_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_annotation(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_owner_to_update_annotation(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_owner_to_update_annotation(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_annotation(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_owner_to_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_owner_to_delete_annotation(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_annotation(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        label = make_label(self.project.item)\n        annotation = self.create_annotation_data(doc=doc)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])",
                                        "Function `create_annotation_data`\nCode:\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin, start_offset=0, end_offset=1)",
                                        "Function `test_allows_owner_to_get_annotation`\nCode:\n    def test_allows_owner_to_get_annotation(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_non_owner_to_get_annotation`\nCode:\n    def test_denies_non_owner_to_get_annotation(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_get_annotation`\nCode:\n    def test_denies_non_project_member_to_get_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_get_annotation`\nCode:\n    def test_denies_unauthenticated_user_to_get_annotation(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_owner_to_update_annotation`\nCode:\n    def test_allows_owner_to_update_annotation(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_non_owner_to_update_annotation`\nCode:\n    def test_denies_non_owner_to_update_annotation(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_update_annotation`\nCode:\n    def test_denies_non_project_member_to_update_annotation(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_owner_to_delete_annotation`\nCode:\n    def test_allows_owner_to_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_non_owner_to_delete_annotation`\nCode:\n    def test_denies_non_owner_to_delete_annotation(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_delete_annotation`\nCode:\n    def test_denies_non_project_member_to_delete_annotation(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Class `TestCategoryDetail`\nCode:\nclass TestCategoryDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_detail\"\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)",
                                        "Function `create_annotation_data`\nCode:\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)",
                                        "Class `TestSpanDetail`\nCode:\nclass TestSpanDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_detail\"",
                                        "Class `TestTextDetail`\nCode:\nclass TestTextDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_detail\"\n\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}",
                                        "Function `create_annotation_data`\nCode:\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)",
                                        "Class `TestBBoxDetail`\nCode:\nclass TestBBoxDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_detail\"\n\n    def create_annotation_data(self, doc):\n        return mommy.make(\"BoundingBox\", example=doc, user=self.project.admin, x=0, y=0, width=0, height=0)",
                                        "Function `create_annotation_data`\nCode:\n    def create_annotation_data(self, doc):\n        return mommy.make(\"BoundingBox\", example=doc, user=self.project.admin, x=0, y=0, width=0, height=0)",
                                        "Class `TestSegmentationDetail`\nCode:\nclass TestSegmentationDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_detail\"\n\n    def create_annotation_data(self, doc):\n        return mommy.make(\"Segmentation\", example=doc, user=self.project.admin, points=[1, 2])",
                                        "Function `create_annotation_data`\nCode:\n    def create_annotation_data(self, doc):\n        return mommy.make(\"Segmentation\", example=doc, user=self.project.admin, points=[1, 2])",
                                        "Class `TestSharedLabelDetail`\nCode:\nclass TestSharedLabelDetail:\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_detail\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task, collaborative_annotation=True)\n        doc = make_doc(self.project.item)\n        annotation = self.make_annotation(doc, self.project.admin)\n        label = make_label(self.project.item)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])\n\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member)\n\n    def test_allows_any_member_to_get_annotation(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_allows_any_member_to_update_annotation(self):\n        for member in self.project.members:\n            self.assert_update(member, status.HTTP_200_OK)\n\n    def test_allows_any_member_to_delete_annotation(self):\n        self.assert_delete(self.project.approver, status.HTTP_204_NO_CONTENT)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=self.task, collaborative_annotation=True)\n        doc = make_doc(self.project.item)\n        annotation = self.make_annotation(doc, self.project.admin)\n        label = make_label(self.project.item)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member)",
                                        "Function `test_allows_any_member_to_get_annotation`\nCode:\n    def test_allows_any_member_to_get_annotation(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)",
                                        "Function `test_allows_any_member_to_update_annotation`\nCode:\n    def test_allows_any_member_to_update_annotation(self):\n        for member in self.project.members:\n            self.assert_update(member, status.HTTP_200_OK)",
                                        "Function `test_allows_any_member_to_delete_annotation`\nCode:\n    def test_allows_any_member_to_delete_annotation(self):\n        self.assert_delete(self.project.approver, status.HTTP_204_NO_CONTENT)",
                                        "Class `TestSharedCategoryDetail`\nCode:\nclass TestSharedCategoryDetail(TestSharedLabelDetail, CRUDMixin):\n    view_name = \"category_detail\"",
                                        "Class `TestSharedSpanDetail`\nCode:\nclass TestSharedSpanDetail(TestSharedLabelDetail, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_detail\"\n\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member, start_offset=0, end_offset=1)",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member, start_offset=0, end_offset=1)",
                                        "Class `TestSharedTextDetail`\nCode:\nclass TestSharedTextDetail(TestSharedLabelDetail, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_detail\"\n\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}"
                                    ],
                                    "code": "import uuid\n\nfrom model_mommy import mommy\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import make_annotation\nfrom api.tests.utils import CRUDMixin\nfrom examples.tests.utils import make_doc\nfrom label_types.tests.utils import make_label\nfrom labels.models import BoundingBox, Category, Segmentation, Span, TextLabel\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestLabelList:\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task)\n        cls.non_member = make_user()\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)\n\n    def test_allows_project_member_to_fetch_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)  # fetch only own annotation\n\n    def test_denies_non_project_member_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 2)  # delete only own annotation\n\n\nclass TestCategoryList(TestLabelList, CRUDMixin):\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_list\"\n\n\nclass TestSpanList(TestLabelList, CRUDMixin):\n    model = Span\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=0, end_offset=1)\n\n\nclass TestBBoxList(TestLabelList, CRUDMixin):\n    model = BoundingBox\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        mommy.make(\"BoundingBox\", example=doc, user=member, x=0, y=0, width=0, height=0)\n\n\nclass TestSegmentationList(TestLabelList, CRUDMixin):\n    model = Segmentation\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        mommy.make(\"Segmentation\", example=doc, user=member, points=[0, 1])\n\n\nclass TestTextList(TestLabelList, CRUDMixin):\n    model = TextLabel\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"\n\n\nclass TestSharedLabelList:\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task, collaborative_annotation=True)\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)\n\n    def test_allows_project_member_to_fetch_all_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 3)\n\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 0)  # delete all annotation in the doc\n\n\nclass TestSharedCategoryList(TestSharedLabelList, CRUDMixin):\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_list\"\n\n\nclass TestSharedSpanList(TestSharedLabelList, CRUDMixin):\n    model = Span\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n    start_offset = 0\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=cls.start_offset, end_offset=cls.start_offset + 1)\n        cls.start_offset += 1\n\n\nclass TestSharedTextList(TestSharedLabelList, CRUDMixin):\n    model = TextLabel\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"\n\n\nclass TestDataLabeling:\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        self.data = self.create_data()\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, self.doc.id])\n\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_non_project_member_to_annotate(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_annotate(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestCategoryCreation(TestDataLabeling, CRUDMixin):\n    view_name = \"category_list\"\n\n\nclass TestSpanCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id, \"start_offset\": 0, \"end_offset\": 1}\n\n\nclass TestRelationCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"relation_list\"\n\n    def create_data(self):\n        relation_type = mommy.make(\"RelationType\", project=self.project.item)\n        from_id = mommy.make(\"Span\", example=self.doc, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.doc, start_offset=1, end_offset=2)\n        return {\"type\": relation_type.id, \"from_id\": from_id.id, \"to_id\": to_id.id}\n\n\nclass TestTextLabelCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"\n\n    def create_data(self):\n        return {\"text\": \"example\"}\n\n\nclass TestBoundingBoxCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_list\"\n\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"x\": 0, \"y\": 0, \"width\": 0, \"height\": 0, \"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n\nclass TestSegmentationCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_list\"\n\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"points\": [1, 2], \"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n\nclass TestLabelDetail:\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"annotation_detail\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        label = make_label(self.project.item)\n        annotation = self.create_annotation_data(doc=doc)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin, start_offset=0, end_offset=1)\n\n    def test_allows_owner_to_get_annotation(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_owner_to_get_annotation(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_get_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_annotation(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_owner_to_update_annotation(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_owner_to_update_annotation(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_annotation(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_owner_to_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_owner_to_delete_annotation(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_annotation(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n\nclass TestCategoryDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_detail\"\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)\n\n\nclass TestSpanDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_detail\"\n\n\nclass TestTextDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_detail\"\n\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)\n\n\nclass TestBBoxDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_detail\"\n\n    def create_annotation_data(self, doc):\n        return mommy.make(\"BoundingBox\", example=doc, user=self.project.admin, x=0, y=0, width=0, height=0)\n\n\nclass TestSegmentationDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_detail\"\n\n    def create_annotation_data(self, doc):\n        return mommy.make(\"Segmentation\", example=doc, user=self.project.admin, points=[1, 2])\n\n\nclass TestSharedLabelDetail:\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_detail\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task, collaborative_annotation=True)\n        doc = make_doc(self.project.item)\n        annotation = self.make_annotation(doc, self.project.admin)\n        label = make_label(self.project.item)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])\n\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member)\n\n    def test_allows_any_member_to_get_annotation(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_allows_any_member_to_update_annotation(self):\n        for member in self.project.members:\n            self.assert_update(member, status.HTTP_200_OK)\n\n    def test_allows_any_member_to_delete_annotation(self):\n        self.assert_delete(self.project.approver, status.HTTP_204_NO_CONTENT)\n\n\nclass TestSharedCategoryDetail(TestSharedLabelDetail, CRUDMixin):\n    view_name = \"category_detail\"\n\n\nclass TestSharedSpanDetail(TestSharedLabelDetail, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_detail\"\n\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member, start_offset=0, end_offset=1)\n\n\nclass TestSharedTextDetail(TestSharedLabelDetail, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_detail\"\n\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}\n",
                                    "summary": "Class `TestLabelList`: A test class for fetching and deleting annotations based on project membership and authentication status, with setup functions and test cases for different scenarios.",
                                    "code_element_summaries": [
                                        "Class `TestLabelList`: A test class for fetching and deleting annotations based on project membership and authentication status.",
                                        "Function `setUpTestData`: Initializes test data including a project, users, document, annotations, and URL for testing purposes.",
                                        "Function `make_annotation`: A function that creates annotations for a task using a specified document and member.",
                                        "Function `test_allows_project_member_to_fetch_annotation`: Tests that project members can fetch their own annotation with status code 200.",
                                        "Function `test_denies_non_project_member_to_fetch_annotation`: Tests that non-project members are denied access to fetch annotations.",
                                        "Function `test_denies_unauthenticated_user_to_fetch_annotation`: Tests that an unauthenticated user is denied access to fetch annotations.",
                                        "Function `test_allows_project_member_to_bulk_delete_annotation`: Tests whether a project member can delete their own annotations in bulk.",
                                        "Class TestCategoryList: A class that represents a list of test categories with specific attributes and behaviors.",
                                        "Class `TestSpanList`: A model that represents a list of spans for sequence labeling tasks with CRUD operations.",
                                        "Function `make_annotation`: A function that creates an annotation for a given document and member with specified offsets.",
                                        "Class `TestBBoxList`: A class that extends TestLabelList and CRUDMixin to handle bounding box annotations for a specific project type with a method to create annotations.",
                                        "Function `make_annotation`: A method to create a BoundingBox annotation with specified parameters for a given document and user.",
                                        "Class `TestSegmentationList`: A class that represents a list of segmentation annotations with CRUD operations.",
                                        "Function `make_annotation`: A function that creates a Segmentation annotation with specified parameters.",
                                        "Class TestTextList: A model that represents a list of text labels with CRUD operations, associated with a specific project type and view name.",
                                        "Class `TestSharedLabelList`: A test class for shared label lists allowing project members to fetch and delete annotations.",
                                        "Function `setUpTestData`: Sets up test data for a project with collaborative annotation, creates annotations for project members, and generates a URL for the project item.",
                                        "Function `make_annotation`: A function that creates an annotation for a specific task and user.",
                                        "Function `test_allows_project_member_to_fetch_all_annotation`: Tests whether project members can fetch all annotations and asserts that the response contains 3 annotations.",
                                        "Function `test_allows_project_member_to_bulk_delete_annotation`: Tests if a project member can bulk delete annotations, asserting a successful deletion and verifying the count of annotations.",
                                        "Class TestSharedCategoryList: A class that extends TestSharedLabelList and CRUDMixin, representing a shared category list for document classification projects.",
                                        "Class `TestSharedSpanList`: A class that extends TestSharedLabelList and CRUDMixin to handle Span annotations in a sequence labeling project.",
                                        "Function `make_annotation`: A method that creates annotations for a document with specified offsets and increments the start offset.",
                                        "Class TestSharedTextList: A class that extends TestSharedLabelList and CRUDMixin, representing a shared text list with a specified model, task, and view name.",
                                        "Class `TestDataLabeling`: A test class for testing annotation permissions for project members and non-members.",
                                        "Function `setUp`: Initializes necessary objects and data for testing a specific view in a project.",
                                        "Function `create_data`: A function that creates data by generating a label ID based on a project item.",
                                        "Function `test_allows_project_member_to_annotate`: Tests if project members are able to create annotations with status code 201.",
                                        "Function `test_denies_non_project_member_to_annotate`: Tests that non-project members are denied access to annotate.",
                                        "Function test_denies_unauthenticated_user_to_annotate: Tests that an unauthenticated user is denied permission to annotate.",
                                        "Class TestCategoryCreation: A class that combines TestDataLabeling and CRUDMixin functionalities for creating test categories.",
                                        "Class TestSpanCreation: A test class for creating span annotations with specific label, start offset, and end offset values.",
                                        "Function `create_data`: A function that generates data with label ID, start offset, and end offset.",
                                        "Class `TestRelationCreation`: A test class for creating relations between spans in a sequence labeling project.",
                                        "Function `create_data`: Generates and returns a dictionary containing IDs and types for relation data.",
                                        "Class TestTextLabelCreation: A class that represents text label creation with specific task and view name attributes.",
                                        "Function `create_data`: A function that returns a dictionary with a key \"text\" and value \"example\".",
                                        "Class `TestBoundingBoxCreation`: A test class for creating bounding box annotations in a project with project members being able to annotate.",
                                        "Function `create_data`: Generates a dictionary containing coordinates and label ID for a bounding box annotation.",
                                        "Function `test_allows_project_member_to_annotate`: Tests if project members can annotate by creating annotations with unique UUIDs for each member.",
                                        "Class `TestSegmentationCreation`: A test class for creating segmentation data that allows project members to annotate with specified points and label.",
                                        "Function `create_data`: Generates data for a new object with specified points and a label ID.",
                                        "Function `test_allows_project_member_to_annotate`: Tests if project members can successfully create annotations with a unique UUID.",
                                        "Class `TestLabelDetail`: Contains test cases to check permissions for accessing, updating, and deleting annotations based on user roles within a project.",
                                        "Function `setUp`: Sets up necessary objects and data for testing a specific view in a project.",
                                        "Function `create_annotation_data`: A function that generates annotation data for a document based on specified parameters.",
                                        "Function test_allows_owner_to_get_annotation: Tests that the project admin can successfully fetch annotations with a status code of 200.",
                                        "Function `test_denies_non_owner_to_get_annotation`: Tests that non-owners are denied access to get annotations for project staff members.",
                                        "Function `test_denies_non_project_member_to_get_annotation`: Tests that a non-project member is denied access to get annotations.",
                                        "Function `test_denies_unauthenticated_user_to_get_annotation`: Tests that unauthenticated users are denied access to get annotations.",
                                        "Function `test_allows_owner_to_update_annotation`: Tests that the owner of a project can update annotations with a successful HTTP status code of 200.",
                                        "Function `test_denies_non_owner_to_update_annotation`: Tests that non-owners are denied permission to update annotations for staff members in the project.",
                                        "Function `test_denies_non_project_member_to_update_annotation`: Tests that non-project members are denied permission to update annotations.",
                                        "Function `test_allows_owner_to_delete_annotation`: Tests if the owner of a project can delete an annotation and expects a 204 status code.",
                                        "Function `test_denies_non_owner_to_delete_annotation`: Tests that non-owners are denied permission to delete annotations for project staff members.",
                                        "Function `test_denies_non_project_member_to_delete_annotation`: Tests whether a non-project member is denied permission to delete an annotation.",
                                        "Class TestCategoryDetail: A subclass of TestLabelDetail and CRUDMixin that handles category details for document classification tasks.",
                                        "Function `create_annotation_data`: A function that generates annotation data based on the task, document, and user provided.",
                                        "Class TestSpanDetail: A class that extends TestLabelDetail and CRUDMixin, representing details for sequence labeling tasks with a specific view name.",
                                        "Class TestTextDetail: A model for text annotations with specific attributes and methods related to CRUD operations.",
                                        "Function `setUp`: Initializes the test case by setting up the test environment and initializing data for testing.",
                                        "Function `create_annotation_data`: A function that creates annotation data for a document based on task, document, and user information.",
                                        "Class TestBBoxDetail: A class that extends TestLabelDetail and CRUDMixin, representing bounding box annotations with specific attributes and methods.",
                                        "Function `create_annotation_data`: A function that generates BoundingBox annotations with specific parameters for a given document.",
                                        "Class `TestSegmentationDetail`: A class that extends TestLabelDetail and CRUDMixin to handle segmentation annotations with a specific view name and annotation creation method.",
                                        "Function create_annotation_data: A function that creates annotation data for a Segmentation model using provided document, user, and points.",
                                        "Class `TestSharedLabelDetail`: Contains test cases to ensure that any member can get, update, and delete annotations in a collaborative document classification project.",
                                        "Function `setUp`: Sets up necessary data for testing collaborative annotation by preparing a project, creating a document, annotation, label, and defining URL.",
                                        "Function `make_annotation`: A function that creates annotations for a specific document and user member.",
                                        "Function `test_allows_any_member_to_get_annotation`: Tests that any member of a project can fetch annotations with a status code of 200 OK.",
                                        "Function `test_allows_any_member_to_update_annotation`: Tests if any member of a project can update annotations with a status of 200 OK.",
                                        "Function `test_allows_any_member_to_delete_annotation`: Tests that any member is able to delete an annotation with a successful status code of 204.",
                                        "Class TestSharedCategoryDetail: Inherits from TestSharedLabelDetail and CRUDMixin to represent shared category details with a specified view name.",
                                        "Class `TestSharedSpanDetail`: A model that extends TestSharedLabelDetail and CRUDMixin to handle span annotations for sequence labeling projects.",
                                        "Function `make_annotation`: A function that creates an annotation for a specific document and user with specified offsets.",
                                        "Class TestSharedTextDetail: A test class for shared text details with a specific task type and view name, inheriting from TestSharedLabelDetail and CRUDMixin.",
                                        "Function `setUp`: Sets up the test environment by initializing the data dictionary with a \"text\" key set to \"changed\"."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `make_annotation`\nCode:\ndef make_annotation(task, doc, user, **kwargs):\n    annotation_model = {\n        ProjectType.DOCUMENT_CLASSIFICATION: \"Category\",\n        ProjectType.SEQUENCE_LABELING: \"Span\",\n        ProjectType.SEQ2SEQ: \"TextLabel\",\n        ProjectType.SPEECH2TEXT: \"TextLabel\",\n    }.get(task)\n    return mommy.make(annotation_model, example=doc, user=user, **kwargs)"
                                    ],
                                    "code": "from model_mommy import mommy\n\nfrom projects.models import ProjectType\n\n\ndef make_annotation(task, doc, user, **kwargs):\n    annotation_model = {\n        ProjectType.DOCUMENT_CLASSIFICATION: \"Category\",\n        ProjectType.SEQUENCE_LABELING: \"Span\",\n        ProjectType.SEQ2SEQ: \"TextLabel\",\n        ProjectType.SPEECH2TEXT: \"TextLabel\",\n    }.get(task)\n    return mommy.make(annotation_model, example=doc, user=user, **kwargs)\n",
                                    "summary": "Function `make_annotation`: A versatile function that generates annotations tailored to specific project types depending on the given task.",
                                    "code_element_summaries": [
                                        "Function `make_annotation`: A function that creates annotations for different project types based on the task provided."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that allows for representation of bounding box annotations in dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import (\n    BoundingBoxDetailAPI,\n    BoundingBoxListAPI,\n    CategoryDetailAPI,\n    CategoryListAPI,\n    RelationDetail,\n    RelationList,\n    SegmentationDetailAPI,\n    SegmentationListAPI,\n    SpanDetailAPI,\n    SpanListAPI,\n    TextLabelDetailAPI,\n    TextLabelListAPI,\n)\n\nurlpatterns = [\n    path(route=\"examples/<int:example_id>/relations\", view=RelationList.as_view(), name=\"relation_list\"),\n    path(\n        route=\"examples/<int:example_id>/relations/<int:annotation_id>\",\n        view=RelationDetail.as_view(),\n        name=\"relation_detail\",\n    ),\n    path(route=\"examples/<int:example_id>/categories\", view=CategoryListAPI.as_view(), name=\"category_list\"),\n    path(\n        route=\"examples/<int:example_id>/categories/<int:annotation_id>\",\n        view=CategoryDetailAPI.as_view(),\n        name=\"category_detail\",\n    ),\n    path(route=\"examples/<int:example_id>/spans\", view=SpanListAPI.as_view(), name=\"span_list\"),\n    path(route=\"examples/<int:example_id>/spans/<int:annotation_id>\", view=SpanDetailAPI.as_view(), name=\"span_detail\"),\n    path(route=\"examples/<int:example_id>/texts\", view=TextLabelListAPI.as_view(), name=\"text_list\"),\n    path(\n        route=\"examples/<int:example_id>/texts/<int:annotation_id>\",\n        view=TextLabelDetailAPI.as_view(),\n        name=\"text_detail\",\n    ),\n    path(route=\"examples/<int:example_id>/bboxes\", view=BoundingBoxListAPI.as_view(), name=\"bbox_list\"),\n    path(\n        route=\"examples/<int:example_id>/bboxes/<int:annotation_id>\",\n        view=BoundingBoxDetailAPI.as_view(),\n        name=\"bbox_detail\",\n    ),\n    path(route=\"examples/<int:example_id>/segments\", view=SegmentationListAPI.as_view(), name=\"segmentation_list\"),\n    path(\n        route=\"examples/<int:example_id>/segments/<int:annotation_id>\",\n        view=SegmentationDetailAPI.as_view(),\n        name=\"segmentation_detail\",\n    ),\n]\n",
                            "summary": "URL patterns for different API views related to annotations and segments in examples.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `BaseListAPI`\nCode:\nclass BaseListAPI(generics.ListCreateAPIView):\n    label_class: Type[Label]\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    swagger_schema = None\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        queryset = self.label_class.objects.filter(example=self.kwargs[\"example_id\"])\n        if not self.project.collaborative_annotation:\n            queryset = queryset.filter(user=self.request.user)\n        return queryset\n\n    def create(self, request, *args, **kwargs):\n        request.data[\"example\"] = self.kwargs[\"example_id\"]\n        try:\n            response = super().create(request, args, kwargs)\n        except ValidationError as err:\n            response = Response({\"detail\": err.messages}, status=status.HTTP_400_BAD_REQUEST)\n        return response\n\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.kwargs[\"example_id\"], user=self.request.user)\n\n    def delete(self, request, *args, **kwargs):\n        queryset = self.get_queryset()\n        queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        queryset = self.label_class.objects.filter(example=self.kwargs[\"example_id\"])\n        if not self.project.collaborative_annotation:\n            queryset = queryset.filter(user=self.request.user)\n        return queryset",
                                "Function `create`\nCode:\n    def create(self, request, *args, **kwargs):\n        request.data[\"example\"] = self.kwargs[\"example_id\"]\n        try:\n            response = super().create(request, args, kwargs)\n        except ValidationError as err:\n            response = Response({\"detail\": err.messages}, status=status.HTTP_400_BAD_REQUEST)\n        return response",
                                "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.kwargs[\"example_id\"], user=self.request.user)",
                                "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        queryset = self.get_queryset()\n        queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                "Class `BaseDetailAPI`\nCode:\nclass BaseDetailAPI(generics.RetrieveUpdateDestroyAPIView):\n    lookup_url_kwarg = \"annotation_id\"\n    swagger_schema = None\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_permissions(self):\n        if self.project.collaborative_annotation:\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & IsProjectMember & partial(CanEditLabel, self.queryset)]\n        return super().get_permissions()",
                                "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                "Function `get_permissions`\nCode:\n    def get_permissions(self):\n        if self.project.collaborative_annotation:\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & IsProjectMember & partial(CanEditLabel, self.queryset)]\n        return super().get_permissions()",
                                "Class `CategoryListAPI`\nCode:\nclass CategoryListAPI(BaseListAPI):\n    label_class = Category\n    serializer_class = CategorySerializer\n\n    def create(self, request, *args, **kwargs):\n        if self.project.single_class_classification:\n            self.get_queryset().delete()\n        return super().create(request, args, kwargs)",
                                "Function `create`\nCode:\n    def create(self, request, *args, **kwargs):\n        if self.project.single_class_classification:\n            self.get_queryset().delete()\n        return super().create(request, args, kwargs)",
                                "Class `CategoryDetailAPI`\nCode:\nclass CategoryDetailAPI(BaseDetailAPI):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer",
                                "Class `SpanListAPI`\nCode:\nclass SpanListAPI(BaseListAPI):\n    label_class = Span\n    serializer_class = SpanSerializer",
                                "Class `SpanDetailAPI`\nCode:\nclass SpanDetailAPI(BaseDetailAPI):\n    queryset = Span.objects.all()\n    serializer_class = SpanSerializer",
                                "Class `TextLabelListAPI`\nCode:\nclass TextLabelListAPI(BaseListAPI):\n    label_class = TextLabel\n    serializer_class = TextLabelSerializer",
                                "Class `TextLabelDetailAPI`\nCode:\nclass TextLabelDetailAPI(BaseDetailAPI):\n    queryset = TextLabel.objects.all()\n    serializer_class = TextLabelSerializer",
                                "Class `RelationList`\nCode:\nclass RelationList(BaseListAPI):\n    label_class = Relation\n    serializer_class = RelationSerializer",
                                "Class `RelationDetail`\nCode:\nclass RelationDetail(BaseDetailAPI):\n    queryset = Relation.objects.all()\n    serializer_class = RelationSerializer",
                                "Class `BoundingBoxListAPI`\nCode:\nclass BoundingBoxListAPI(BaseListAPI):\n    label_class = BoundingBox\n    serializer_class = BoundingBoxSerializer",
                                "Class `BoundingBoxDetailAPI`\nCode:\nclass BoundingBoxDetailAPI(BaseDetailAPI):\n    queryset = BoundingBox.objects.all()\n    serializer_class = BoundingBoxSerializer",
                                "Class `SegmentationListAPI`\nCode:\nclass SegmentationListAPI(BaseListAPI):\n    label_class = Segmentation\n    serializer_class = SegmentationSerializer",
                                "Class `SegmentationDetailAPI`\nCode:\nclass SegmentationDetailAPI(BaseDetailAPI):\n    queryset = Segmentation.objects.all()\n    serializer_class = SegmentationSerializer"
                            ],
                            "code": "from functools import partial\nfrom typing import Type\n\nfrom django.core.exceptions import ValidationError\nfrom django.shortcuts import get_object_or_404\nfrom rest_framework import generics, status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom .permissions import CanEditLabel\nfrom .serializers import (\n    BoundingBoxSerializer,\n    CategorySerializer,\n    RelationSerializer,\n    SegmentationSerializer,\n    SpanSerializer,\n    TextLabelSerializer,\n)\nfrom labels.models import (\n    BoundingBox,\n    Category,\n    Label,\n    Relation,\n    Segmentation,\n    Span,\n    TextLabel,\n)\nfrom projects.models import Project\nfrom projects.permissions import IsProjectMember\n\n\nclass BaseListAPI(generics.ListCreateAPIView):\n    label_class: Type[Label]\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    swagger_schema = None\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        queryset = self.label_class.objects.filter(example=self.kwargs[\"example_id\"])\n        if not self.project.collaborative_annotation:\n            queryset = queryset.filter(user=self.request.user)\n        return queryset\n\n    def create(self, request, *args, **kwargs):\n        request.data[\"example\"] = self.kwargs[\"example_id\"]\n        try:\n            response = super().create(request, args, kwargs)\n        except ValidationError as err:\n            response = Response({\"detail\": err.messages}, status=status.HTTP_400_BAD_REQUEST)\n        return response\n\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.kwargs[\"example_id\"], user=self.request.user)\n\n    def delete(self, request, *args, **kwargs):\n        queryset = self.get_queryset()\n        queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass BaseDetailAPI(generics.RetrieveUpdateDestroyAPIView):\n    lookup_url_kwarg = \"annotation_id\"\n    swagger_schema = None\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_permissions(self):\n        if self.project.collaborative_annotation:\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & IsProjectMember & partial(CanEditLabel, self.queryset)]\n        return super().get_permissions()\n\n\nclass CategoryListAPI(BaseListAPI):\n    label_class = Category\n    serializer_class = CategorySerializer\n\n    def create(self, request, *args, **kwargs):\n        if self.project.single_class_classification:\n            self.get_queryset().delete()\n        return super().create(request, args, kwargs)\n\n\nclass CategoryDetailAPI(BaseDetailAPI):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer\n\n\nclass SpanListAPI(BaseListAPI):\n    label_class = Span\n    serializer_class = SpanSerializer\n\n\nclass SpanDetailAPI(BaseDetailAPI):\n    queryset = Span.objects.all()\n    serializer_class = SpanSerializer\n\n\nclass TextLabelListAPI(BaseListAPI):\n    label_class = TextLabel\n    serializer_class = TextLabelSerializer\n\n\nclass TextLabelDetailAPI(BaseDetailAPI):\n    queryset = TextLabel.objects.all()\n    serializer_class = TextLabelSerializer\n\n\nclass RelationList(BaseListAPI):\n    label_class = Relation\n    serializer_class = RelationSerializer\n\n\nclass RelationDetail(BaseDetailAPI):\n    queryset = Relation.objects.all()\n    serializer_class = RelationSerializer\n\n\nclass BoundingBoxListAPI(BaseListAPI):\n    label_class = BoundingBox\n    serializer_class = BoundingBoxSerializer\n\n\nclass BoundingBoxDetailAPI(BaseDetailAPI):\n    queryset = BoundingBox.objects.all()\n    serializer_class = BoundingBoxSerializer\n\n\nclass SegmentationListAPI(BaseListAPI):\n    label_class = Segmentation\n    serializer_class = SegmentationSerializer\n\n\nclass SegmentationDetailAPI(BaseDetailAPI):\n    queryset = Segmentation.objects.all()\n    serializer_class = SegmentationSerializer\n",
                            "summary": "A set of classes and functions that handle various API operations for specific label classes, including list, create, retrieve, update, and delete functions with permission checks and error handling.",
                            "code_element_summaries": [
                                "Class `BaseListAPI`: A class that handles list and create operations for a specific label class, with permission checks and error handling.",
                                "Function `project`: Returns the Project object with the specified ID or raises a 404 error if not found.",
                                "Function `get_queryset`: Retrieves a queryset of label_class objects filtered by example_id and user based on project settings.",
                                "Function `create`: Modifies the request data and handles validation errors when creating a resource.",
                                "Function `perform_create`: Saves the serializer data with additional parameters like example_id and user extracted from the request.",
                                "Function `delete`: Deletes all objects in the queryset and returns a 204 No Content response.",
                                "Class BaseDetailAPI: A generic API view for retrieving, updating, and deleting details with permissions based on project collaboration settings.",
                                "Function `project`: Retrieves a Project object based on the provided project_id parameter.",
                                "Function `get_permissions`: Determines the permission classes based on project settings for collaborative annotation.",
                                "Class CategoryListAPI: A class that handles the creation of category objects, with special handling for single class classification projects.",
                                "Function `create`: Deletes existing queryset if project has single class classification before creating new instance.",
                                "Class `CategoryDetailAPI`: A class that handles API requests for retrieving detailed information about categories using CategorySerializer.",
                                "Class SpanListAPI: A class that defines the API for handling lists of Span objects with specified label and serializer classes.",
                                "Class SpanDetailAPI: A class that defines API endpoints for retrieving details of Span objects using a serializer.",
                                "Class TextLabelListAPI: A class that represents a list of text labels with specified label class and serializer class.",
                                "Class TextLabelDetailAPI: A detail API class for TextLabel objects with specified queryset and serializer class.",
                                "Class RelationList: A list API class that handles relations with a specified label class and serializer class.",
                                "Class RelationDetail: A detail API class for handling Relation objects with specified queryset and serializer class.",
                                "Class BoundingBoxListAPI: A class that handles API requests for a list of bounding box annotations using BoundingBox and BoundingBoxSerializer.",
                                "Class BoundingBoxDetailAPI: A detail API class for handling BoundingBox objects with specified queryset and serializer.",
                                "Class SegmentationListAPI: A list API class for managing segmentation annotations with specified label class and serializer.",
                                "Class SegmentationDetailAPI: A detail API class for retrieving segmentation data using SegmentationSerializer."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that provides methods to convert bounding box annotations into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "label_types",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content includes classes and functions for managing label types, categories, spans, and relations in a Django project, with features such as serialization, validation, CRUD operations, URL patterns, and data conversion.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelAdmin`\nCode:\nclass LabelAdmin(admin.ModelAdmin):\n    list_display = (\"text\", \"project\", \"text_color\", \"background_color\")\n    ordering = (\"project\",)\n    search_fields = (\"text\",)",
                                "Class `CategoryTypeAdmin`\nCode:\nclass CategoryTypeAdmin(LabelAdmin):\n    pass",
                                "Class `SpanTypeAdmin`\nCode:\nclass SpanTypeAdmin(LabelAdmin):\n    pass"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import CategoryType, SpanType\n\n\nclass LabelAdmin(admin.ModelAdmin):\n    list_display = (\"text\", \"project\", \"text_color\", \"background_color\")\n    ordering = (\"project\",)\n    search_fields = (\"text\",)\n\n\nclass CategoryTypeAdmin(LabelAdmin):\n    pass\n\n\nclass SpanTypeAdmin(LabelAdmin):\n    pass\n\n\nadmin.site.register(CategoryType, CategoryTypeAdmin)\nadmin.site.register(SpanType, SpanTypeAdmin)\n",
                            "summary": "Classes LabelAdmin, CategoryTypeAdmin, and SpanTypeAdmin represent admin interface settings for managing label objects with specific fields for text, project, text color, and background color.",
                            "code_element_summaries": [
                                "Class LabelAdmin: Represents the admin interface settings for managing label objects with fields for text, project, text color, and background color.",
                                "Class CategoryTypeAdmin: A subclass of LabelAdmin that represents the admin interface for category type annotations.",
                                "Class SpanTypeAdmin: A subclass of LabelAdmin for managing SpanType models."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelTypesConfig`\nCode:\nclass LabelTypesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"label_types\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass LabelTypesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"label_types\"\n",
                            "summary": "Class LabelTypesConfig: A configuration class for defining label types in a Django application with a default auto field and name \"label_types\".",
                            "code_element_summaries": [
                                "Class LabelTypesConfig: Configures label types for the Django application with a default auto field and name \"label_types\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "exceptions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\exceptions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelValidationError`\nCode:\nclass LabelValidationError(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"You cannot create a label with same name or shortcut key.\""
                            ],
                            "code": "from rest_framework import status\nfrom rest_framework.exceptions import APIException\n\n\nclass LabelValidationError(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"You cannot create a label with same name or shortcut key.\"\n",
                            "summary": "Class LabelValidationError: Represents an API exception for duplicate label names or shortcut keys.",
                            "code_element_summaries": [
                                "Class LabelValidationError: Represents an API exception for when a label with the same name or shortcut key already exists."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A migration class that handles database schema changes for renaming and creating models in a Django project.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"api\", \"0032_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"SpanType\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.CharField(db_index=True, max_length=100)),\n                        (\n                            \"prefix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                                max_length=10,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"suffix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[\n                                    (\"0\", \"0\"),\n                                    (\"1\", \"1\"),\n                                    (\"2\", \"2\"),\n                                    (\"3\", \"3\"),\n                                    (\"4\", \"4\"),\n                                    (\"5\", \"5\"),\n                                    (\"6\", \"6\"),\n                                    (\"7\", \"7\"),\n                                    (\"8\", \"8\"),\n                                    (\"9\", \"9\"),\n                                    (\"a\", \"a\"),\n                                    (\"b\", \"b\"),\n                                    (\"c\", \"c\"),\n                                    (\"d\", \"d\"),\n                                    (\"e\", \"e\"),\n                                    (\"f\", \"f\"),\n                                    (\"g\", \"g\"),\n                                    (\"h\", \"h\"),\n                                    (\"i\", \"i\"),\n                                    (\"j\", \"j\"),\n                                    (\"k\", \"k\"),\n                                    (\"l\", \"l\"),\n                                    (\"m\", \"m\"),\n                                    (\"n\", \"n\"),\n                                    (\"o\", \"o\"),\n                                    (\"p\", \"p\"),\n                                    (\"q\", \"q\"),\n                                    (\"r\", \"r\"),\n                                    (\"s\", \"s\"),\n                                    (\"t\", \"t\"),\n                                    (\"u\", \"u\"),\n                                    (\"v\", \"v\"),\n                                    (\"w\", \"w\"),\n                                    (\"x\", \"x\"),\n                                    (\"y\", \"y\"),\n                                    (\"z\", \"z\"),\n                                ],\n                                max_length=1,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"background_color\",\n                            models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                        ),\n                        (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\")),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                        \"abstract\": False,\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"RelationTypes\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"color\", models.TextField()),\n                        (\"name\", models.TextField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"relation_types\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"CategoryType\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.CharField(db_index=True, max_length=100)),\n                        (\n                            \"prefix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                                max_length=10,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"suffix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[\n                                    (\"0\", \"0\"),\n                                    (\"1\", \"1\"),\n                                    (\"2\", \"2\"),\n                                    (\"3\", \"3\"),\n                                    (\"4\", \"4\"),\n                                    (\"5\", \"5\"),\n                                    (\"6\", \"6\"),\n                                    (\"7\", \"7\"),\n                                    (\"8\", \"8\"),\n                                    (\"9\", \"9\"),\n                                    (\"a\", \"a\"),\n                                    (\"b\", \"b\"),\n                                    (\"c\", \"c\"),\n                                    (\"d\", \"d\"),\n                                    (\"e\", \"e\"),\n                                    (\"f\", \"f\"),\n                                    (\"g\", \"g\"),\n                                    (\"h\", \"h\"),\n                                    (\"i\", \"i\"),\n                                    (\"j\", \"j\"),\n                                    (\"k\", \"k\"),\n                                    (\"l\", \"l\"),\n                                    (\"m\", \"m\"),\n                                    (\"n\", \"n\"),\n                                    (\"o\", \"o\"),\n                                    (\"p\", \"p\"),\n                                    (\"q\", \"q\"),\n                                    (\"r\", \"r\"),\n                                    (\"s\", \"s\"),\n                                    (\"t\", \"t\"),\n                                    (\"u\", \"u\"),\n                                    (\"v\", \"v\"),\n                                    (\"w\", \"w\"),\n                                    (\"x\", \"x\"),\n                                    (\"y\", \"y\"),\n                                    (\"z\", \"z\"),\n                                ],\n                                max_length=1,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"background_color\",\n                            models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                        ),\n                        (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\")),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                        \"abstract\": False,\n                    },\n                ),\n                migrations.AddConstraint(\n                    model_name=\"spantype\",\n                    constraint=models.UniqueConstraint(\n                        fields=(\"project\", \"text\"), name=\"label_types_spantype_is_unique\"\n                    ),\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"relationtypes\",\n                    unique_together={(\"color\", \"name\")},\n                ),\n                migrations.AddConstraint(\n                    model_name=\"categorytype\",\n                    constraint=models.UniqueConstraint(\n                        fields=(\"project\", \"text\"), name=\"label_types_categorytype_is_unique\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 06:54\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport label_types.models\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"api\", \"0032_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"SpanType\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.CharField(db_index=True, max_length=100)),\n                        (\n                            \"prefix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                                max_length=10,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"suffix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[\n                                    (\"0\", \"0\"),\n                                    (\"1\", \"1\"),\n                                    (\"2\", \"2\"),\n                                    (\"3\", \"3\"),\n                                    (\"4\", \"4\"),\n                                    (\"5\", \"5\"),\n                                    (\"6\", \"6\"),\n                                    (\"7\", \"7\"),\n                                    (\"8\", \"8\"),\n                                    (\"9\", \"9\"),\n                                    (\"a\", \"a\"),\n                                    (\"b\", \"b\"),\n                                    (\"c\", \"c\"),\n                                    (\"d\", \"d\"),\n                                    (\"e\", \"e\"),\n                                    (\"f\", \"f\"),\n                                    (\"g\", \"g\"),\n                                    (\"h\", \"h\"),\n                                    (\"i\", \"i\"),\n                                    (\"j\", \"j\"),\n                                    (\"k\", \"k\"),\n                                    (\"l\", \"l\"),\n                                    (\"m\", \"m\"),\n                                    (\"n\", \"n\"),\n                                    (\"o\", \"o\"),\n                                    (\"p\", \"p\"),\n                                    (\"q\", \"q\"),\n                                    (\"r\", \"r\"),\n                                    (\"s\", \"s\"),\n                                    (\"t\", \"t\"),\n                                    (\"u\", \"u\"),\n                                    (\"v\", \"v\"),\n                                    (\"w\", \"w\"),\n                                    (\"x\", \"x\"),\n                                    (\"y\", \"y\"),\n                                    (\"z\", \"z\"),\n                                ],\n                                max_length=1,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"background_color\",\n                            models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                        ),\n                        (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\")),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                        \"abstract\": False,\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"RelationTypes\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"color\", models.TextField()),\n                        (\"name\", models.TextField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"relation_types\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"CategoryType\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.CharField(db_index=True, max_length=100)),\n                        (\n                            \"prefix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                                max_length=10,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"suffix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[\n                                    (\"0\", \"0\"),\n                                    (\"1\", \"1\"),\n                                    (\"2\", \"2\"),\n                                    (\"3\", \"3\"),\n                                    (\"4\", \"4\"),\n                                    (\"5\", \"5\"),\n                                    (\"6\", \"6\"),\n                                    (\"7\", \"7\"),\n                                    (\"8\", \"8\"),\n                                    (\"9\", \"9\"),\n                                    (\"a\", \"a\"),\n                                    (\"b\", \"b\"),\n                                    (\"c\", \"c\"),\n                                    (\"d\", \"d\"),\n                                    (\"e\", \"e\"),\n                                    (\"f\", \"f\"),\n                                    (\"g\", \"g\"),\n                                    (\"h\", \"h\"),\n                                    (\"i\", \"i\"),\n                                    (\"j\", \"j\"),\n                                    (\"k\", \"k\"),\n                                    (\"l\", \"l\"),\n                                    (\"m\", \"m\"),\n                                    (\"n\", \"n\"),\n                                    (\"o\", \"o\"),\n                                    (\"p\", \"p\"),\n                                    (\"q\", \"q\"),\n                                    (\"r\", \"r\"),\n                                    (\"s\", \"s\"),\n                                    (\"t\", \"t\"),\n                                    (\"u\", \"u\"),\n                                    (\"v\", \"v\"),\n                                    (\"w\", \"w\"),\n                                    (\"x\", \"x\"),\n                                    (\"y\", \"y\"),\n                                    (\"z\", \"z\"),\n                                ],\n                                max_length=1,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"background_color\",\n                            models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                        ),\n                        (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\")),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                        \"abstract\": False,\n                    },\n                ),\n                migrations.AddConstraint(\n                    model_name=\"spantype\",\n                    constraint=models.UniqueConstraint(\n                        fields=(\"project\", \"text\"), name=\"label_types_spantype_is_unique\"\n                    ),\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"relationtypes\",\n                    unique_together={(\"color\", \"name\")},\n                ),\n                migrations.AddConstraint(\n                    model_name=\"categorytype\",\n                    constraint=models.UniqueConstraint(\n                        fields=(\"project\", \"text\"), name=\"label_types_categorytype_is_unique\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A migration class that sets up models for SpanType, RelationTypes, and CategoryType with specified fields and constraints.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates models for SpanType, RelationTypes, and CategoryType with various fields and constraints."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_rename_relationtypes_relationtype.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0002_rename_relationtypes_relationtype.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0003_auto_20220127_0654\"),\n        (\"api\", \"0033_auto_20220127_0654\"),\n        (\"label_types\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationTypes\",\n            new_name=\"RelationType\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 07:27\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0003_auto_20220127_0654\"),\n        (\"api\", \"0033_auto_20220127_0654\"),\n        (\"label_types\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationTypes\",\n            new_name=\"RelationType\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class responsible for handling the migration process of renaming a model from \"RelationTypes\" to \"RelationType\" in a Django project.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that handles renaming a model from \"RelationTypes\" to \"RelationType\" in a Django project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_auto_20220204_0201.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0003_auto_20220204_0201.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"label_types\", \"0002_rename_relationtypes_relationtype\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"categorytype\",\n                    name=\"project\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\"),\n                ),\n                migrations.AlterField(\n                    model_name=\"relationtype\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"relation_types\",\n                        to=\"projects.project\",\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"spantype\",\n                    name=\"project\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\"),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"label_types\", \"0002_rename_relationtypes_relationtype\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"categorytype\",\n                    name=\"project\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\"),\n                ),\n                migrations.AlterField(\n                    model_name=\"relationtype\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"relation_types\",\n                        to=\"projects.project\",\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"spantype\",\n                    name=\"project\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\"),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class designed to handle database and state operations for altering field models associated with project categories, relations, and spans.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that separates database and state operations for altering field models related to project categories, relations, and spans."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_rename_relationtype_relationtypeold.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0004_rename_relationtype_relationtypeold.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        (\"labels\", \"0005_alter_relation_project\"),\n        (\"label_types\", \"0003_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationType\",\n            new_name=\"RelationTypeOld\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 05:05\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        (\"labels\", \"0005_alter_relation_project\"),\n        (\"label_types\", \"0003_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationType\",\n            new_name=\"RelationTypeOld\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class for renaming the model \"RelationType\" to \"RelationTypeOld\" in a Django project.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that handles renaming a model from \"RelationType\" to \"RelationTypeOld\" in a Django project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_relationtype_and_more.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0005_relationtype_and_more.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        (\"label_types\", \"0004_rename_relationtype_relationtypeold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"RelationType\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"background_color\",\n                    models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                ),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\")),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.AddConstraint(\n            model_name=\"relationtype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"label_types_relationtype_is_unique\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 05:11\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport label_types.models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        (\"label_types\", \"0004_rename_relationtype_relationtypeold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"RelationType\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"background_color\",\n                    models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                ),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\")),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.AddConstraint(\n            model_name=\"relationtype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"label_types_relationtype_is_unique\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class for creating a new model RelationType with defined fields and constraints.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a new model `RelationType` with specified fields and constraints."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0006_auto_20220222_0512.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0006_auto_20220222_0512.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `copy_relation_type`\nCode:\ndef copy_relation_type(apps, schema_editor):\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    RelationType = apps.get_model(\"label_types\", \"RelationType\")\n    for relation_type in RelationTypeOld.objects.all():\n        RelationType(\n            background_color=relation_type.color, text=relation_type.name, project=relation_type.project\n        ).save()\n        relation_type.delete()",
                                        "Function `delete_new_relation_type`\nCode:\ndef delete_new_relation_type(apps, schema_editor):\n    RelationTypeNew = apps.get_model(\"label_types\", \"RelationType\")\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    for relation_type in RelationTypeNew.objects.all():\n        RelationTypeOld.objects.get_or_create(\n            color=relation_type.background_color, name=relation_type.text, project=relation_type.project\n        )\n        relation_type.delete()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0005_relationtype_and_more\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_relation_type, reverse_code=delete_new_relation_type),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 05:12\n\nfrom django.db import migrations\n\n\ndef copy_relation_type(apps, schema_editor):\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    RelationType = apps.get_model(\"label_types\", \"RelationType\")\n    for relation_type in RelationTypeOld.objects.all():\n        RelationType(\n            background_color=relation_type.color, text=relation_type.name, project=relation_type.project\n        ).save()\n        relation_type.delete()\n\n\ndef delete_new_relation_type(apps, schema_editor):\n    RelationTypeNew = apps.get_model(\"label_types\", \"RelationType\")\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    for relation_type in RelationTypeNew.objects.all():\n        RelationTypeOld.objects.get_or_create(\n            color=relation_type.background_color, name=relation_type.text, project=relation_type.project\n        )\n        relation_type.delete()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0005_relationtype_and_more\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_relation_type, reverse_code=delete_new_relation_type),\n    ]\n",
                                    "summary": "Content:\nFunction `copy_relation_type` copies relation types from an old model to a new model, while `delete_new_relation_type` deletes new relation types and creates corresponding old relation types in the database, all managed by the Migration class.",
                                    "code_element_summaries": [
                                        "Function `copy_relation_type`: Copies relation types from an old model to a new model in a database.",
                                        "Function `delete_new_relation_type`: Deletes new relation types and creates corresponding old relation types in the database.",
                                        "Class Migration: A migration class that handles dependencies and operations for database schema changes."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0007_delete_relationtypeold.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0007_delete_relationtypeold.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0009_delete_relationold\"),\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"RelationTypeOld\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 06:46\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0009_delete_relationold\"),\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"RelationTypeOld\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class that defines dependencies and operations for database schema changes during migrations.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that specifies dependencies and operations for database schema changes."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a class ExportedBoundingBox which acts as a proxy model of BoundingBox, offering methods to convert bounding box annotations into dictionary and tuple representations.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Function `generate_random_hex_color`\nCode:\ndef generate_random_hex_color():\n    return f\"#{random.randint(0, 0xFFFFFF):06x}\"",
                                "Class `LabelType`\nCode:\nclass LabelType(models.Model):\n    text = models.CharField(max_length=100, db_index=True)\n    prefix_key = models.CharField(\n        max_length=10,\n        blank=True,\n        null=True,\n        choices=((\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")),\n    )\n    suffix_key = models.CharField(\n        max_length=1, blank=True, null=True, choices=tuple((c, c) for c in string.digits + string.ascii_lowercase)\n    )\n    project = models.ForeignKey(\n        to=Project,\n        on_delete=models.CASCADE,\n        # related_name='labels'\n    )\n    background_color = models.CharField(max_length=7, default=generate_random_hex_color)\n    text_color = models.CharField(max_length=7, default=\"#ffffff\")\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.text\n\n    @property\n    def labels(self):\n        raise NotImplementedError()\n\n    def clean(self):\n        # Don't allow shortcut key not to have a suffix key.\n        if self.prefix_key and not self.suffix_key:\n            message = \"Shortcut key may not have a suffix key.\"\n            raise ValidationError(message)\n\n        # each shortcut (prefix key + suffix key) can only be assigned to one label\n        if self.suffix_key or self.prefix_key:\n            other_labels = self.labels.exclude(id=self.id)\n            if other_labels.filter(suffix_key=self.suffix_key, prefix_key=self.prefix_key).exists():\n                message = \"A label with the shortcut already exists in the project.\"\n                raise ValidationError(message)\n\n        super().clean()\n\n    class Meta:\n        abstract = True\n        constraints = [models.UniqueConstraint(fields=[\"project\", \"text\"], name=\"%(app_label)s_%(class)s_is_unique\")]\n        ordering = [\"created_at\"]",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        return self.text",
                                "Function `labels`\nCode:\n    def labels(self):\n        raise NotImplementedError()",
                                "Function `clean`\nCode:\n    def clean(self):\n        # Don't allow shortcut key not to have a suffix key.\n        if self.prefix_key and not self.suffix_key:\n            message = \"Shortcut key may not have a suffix key.\"\n            raise ValidationError(message)\n\n        # each shortcut (prefix key + suffix key) can only be assigned to one label\n        if self.suffix_key or self.prefix_key:\n            other_labels = self.labels.exclude(id=self.id)\n            if other_labels.filter(suffix_key=self.suffix_key, prefix_key=self.prefix_key).exists():\n                message = \"A label with the shortcut already exists in the project.\"\n                raise ValidationError(message)\n\n        super().clean()",
                                "Class `Meta`\nCode:\n    class Meta:\n        abstract = True\n        constraints = [models.UniqueConstraint(fields=[\"project\", \"text\"], name=\"%(app_label)s_%(class)s_is_unique\")]\n        ordering = [\"created_at\"]",
                                "Class `CategoryType`\nCode:\nclass CategoryType(LabelType):\n    @property\n    def labels(self):\n        return CategoryType.objects.filter(project=self.project)",
                                "Function `labels`\nCode:\n    def labels(self):\n        return CategoryType.objects.filter(project=self.project)",
                                "Class `SpanType`\nCode:\nclass SpanType(LabelType):\n    @property\n    def labels(self):\n        return SpanType.objects.filter(project=self.project)",
                                "Function `labels`\nCode:\n    def labels(self):\n        return SpanType.objects.filter(project=self.project)",
                                "Class `RelationType`\nCode:\nclass RelationType(LabelType):\n    @property\n    def labels(self):\n        return RelationType.objects.filter(project=self.project)",
                                "Function `labels`\nCode:\n    def labels(self):\n        return RelationType.objects.filter(project=self.project)"
                            ],
                            "code": "import random\nimport string\n\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\n\nfrom projects.models import Project\n\n\ndef generate_random_hex_color():\n    return f\"#{random.randint(0, 0xFFFFFF):06x}\"\n\n\nclass LabelType(models.Model):\n    text = models.CharField(max_length=100, db_index=True)\n    prefix_key = models.CharField(\n        max_length=10,\n        blank=True,\n        null=True,\n        choices=((\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")),\n    )\n    suffix_key = models.CharField(\n        max_length=1, blank=True, null=True, choices=tuple((c, c) for c in string.digits + string.ascii_lowercase)\n    )\n    project = models.ForeignKey(\n        to=Project,\n        on_delete=models.CASCADE,\n        # related_name='labels'\n    )\n    background_color = models.CharField(max_length=7, default=generate_random_hex_color)\n    text_color = models.CharField(max_length=7, default=\"#ffffff\")\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.text\n\n    @property\n    def labels(self):\n        raise NotImplementedError()\n\n    def clean(self):\n        # Don't allow shortcut key not to have a suffix key.\n        if self.prefix_key and not self.suffix_key:\n            message = \"Shortcut key may not have a suffix key.\"\n            raise ValidationError(message)\n\n        # each shortcut (prefix key + suffix key) can only be assigned to one label\n        if self.suffix_key or self.prefix_key:\n            other_labels = self.labels.exclude(id=self.id)\n            if other_labels.filter(suffix_key=self.suffix_key, prefix_key=self.prefix_key).exists():\n                message = \"A label with the shortcut already exists in the project.\"\n                raise ValidationError(message)\n\n        super().clean()\n\n    class Meta:\n        abstract = True\n        constraints = [models.UniqueConstraint(fields=[\"project\", \"text\"], name=\"%(app_label)s_%(class)s_is_unique\")]\n        ordering = [\"created_at\"]\n\n\nclass CategoryType(LabelType):\n    @property\n    def labels(self):\n        return CategoryType.objects.filter(project=self.project)\n\n\nclass SpanType(LabelType):\n    @property\n    def labels(self):\n        return SpanType.objects.filter(project=self.project)\n\n\nclass RelationType(LabelType):\n    @property\n    def labels(self):\n        return RelationType.objects.filter(project=self.project)\n",
                            "summary": "Content:\nA collection of functions and classes related to label types, categories, spans, and relations, with functionalities such as generating random colors, object representation, label retrieval, and validation.",
                            "code_element_summaries": [
                                "Function `generate_random_hex_color`: Generates a random hexadecimal color code.",
                                "Class `LabelType`: An abstract model representing label types with text, prefix and suffix keys, project association, colors, and validation for shortcut keys.",
                                "Function `__str__`: Returns the text representation of an object.",
                                "Function `labels`: A placeholder function that raises a NotImplementedError when called.",
                                "Function `clean`: Validates and ensures that shortcut keys have suffix keys and are unique within the project's labels.",
                                "Class Meta: Defines metadata options for a model, including abstract status, constraints, and default ordering.",
                                "Class `CategoryType`: A model representing different categories with a property to retrieve labels associated with the category type.",
                                "Function `labels`: Returns a list of category types associated with the project.",
                                "Class SpanType: A model that represents different types of spans with a property to access labels associated with the span type.",
                                "Function `labels`: Retrieves SpanType objects that are associated with a specific project.",
                                "Class `RelationType`: Inherits from LabelType and provides a property to retrieve labels associated with a specific project.",
                                "Function `labels`: Retrieves all relation types associated with a specific project."
                            ],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelSerializer`\nCode:\nclass LabelSerializer(serializers.ModelSerializer):\n    def validate(self, attrs):\n        prefix_key = attrs.get(\"prefix_key\")\n        suffix_key = attrs.get(\"suffix_key\")\n\n        # In the case of user don't set any shortcut key.\n        if prefix_key is None and suffix_key is None:\n            return super().validate(attrs)\n\n        # Don't allow shortcut key not to have a suffix key.\n        if prefix_key and not suffix_key:\n            raise ValidationError(\"Shortcut key may not have a suffix key.\")\n\n        # Don't allow to save same shortcut key when prefix_key is null.\n        try:\n            context = self.context[\"request\"].parser_context\n            project_id = context[\"kwargs\"][\"project_id\"]\n            label_id = context[\"kwargs\"].get(\"label_id\")\n        except (AttributeError, KeyError):\n            pass  # unit tests don't always have the correct context set up\n        else:\n            conflicting_labels = self.Meta.model.objects.filter(\n                suffix_key=suffix_key,\n                prefix_key=prefix_key,\n                project=project_id,\n            )\n\n            if label_id is not None:\n                conflicting_labels = conflicting_labels.exclude(id=label_id)\n\n            if conflicting_labels.exists():\n                raise ValidationError(\"Duplicate shortcut key.\")\n\n        return super().validate(attrs)\n\n    class Meta:\n        model = LabelType\n        fields = (\n            \"id\",\n            \"text\",\n            \"prefix_key\",\n            \"suffix_key\",\n            \"background_color\",\n            \"text_color\",\n        )",
                                "Function `validate`\nCode:\n    def validate(self, attrs):\n        prefix_key = attrs.get(\"prefix_key\")\n        suffix_key = attrs.get(\"suffix_key\")\n\n        # In the case of user don't set any shortcut key.\n        if prefix_key is None and suffix_key is None:\n            return super().validate(attrs)\n\n        # Don't allow shortcut key not to have a suffix key.\n        if prefix_key and not suffix_key:\n            raise ValidationError(\"Shortcut key may not have a suffix key.\")\n\n        # Don't allow to save same shortcut key when prefix_key is null.\n        try:\n            context = self.context[\"request\"].parser_context\n            project_id = context[\"kwargs\"][\"project_id\"]\n            label_id = context[\"kwargs\"].get(\"label_id\")\n        except (AttributeError, KeyError):\n            pass  # unit tests don't always have the correct context set up\n        else:\n            conflicting_labels = self.Meta.model.objects.filter(\n                suffix_key=suffix_key,\n                prefix_key=prefix_key,\n                project=project_id,\n            )\n\n            if label_id is not None:\n                conflicting_labels = conflicting_labels.exclude(id=label_id)\n\n            if conflicting_labels.exists():\n                raise ValidationError(\"Duplicate shortcut key.\")\n\n        return super().validate(attrs)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = LabelType\n        fields = (\n            \"id\",\n            \"text\",\n            \"prefix_key\",\n            \"suffix_key\",\n            \"background_color\",\n            \"text_color\",\n        )",
                                "Class `CategoryTypeSerializer`\nCode:\nclass CategoryTypeSerializer(LabelSerializer):\n    class Meta:\n        model = CategoryType\n        fields = LabelSerializer.Meta.fields",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = CategoryType\n        fields = LabelSerializer.Meta.fields",
                                "Class `SpanTypeSerializer`\nCode:\nclass SpanTypeSerializer(LabelSerializer):\n    class Meta:\n        model = SpanType\n        fields = LabelSerializer.Meta.fields",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = SpanType\n        fields = LabelSerializer.Meta.fields",
                                "Class `RelationTypeSerializer`\nCode:\nclass RelationTypeSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = RelationType\n        fields = LabelSerializer.Meta.fields",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = RelationType\n        fields = LabelSerializer.Meta.fields"
                            ],
                            "code": "from rest_framework import serializers\nfrom rest_framework.exceptions import ValidationError\n\nfrom .models import CategoryType, LabelType, RelationType, SpanType\n\n\nclass LabelSerializer(serializers.ModelSerializer):\n    def validate(self, attrs):\n        prefix_key = attrs.get(\"prefix_key\")\n        suffix_key = attrs.get(\"suffix_key\")\n\n        # In the case of user don't set any shortcut key.\n        if prefix_key is None and suffix_key is None:\n            return super().validate(attrs)\n\n        # Don't allow shortcut key not to have a suffix key.\n        if prefix_key and not suffix_key:\n            raise ValidationError(\"Shortcut key may not have a suffix key.\")\n\n        # Don't allow to save same shortcut key when prefix_key is null.\n        try:\n            context = self.context[\"request\"].parser_context\n            project_id = context[\"kwargs\"][\"project_id\"]\n            label_id = context[\"kwargs\"].get(\"label_id\")\n        except (AttributeError, KeyError):\n            pass  # unit tests don't always have the correct context set up\n        else:\n            conflicting_labels = self.Meta.model.objects.filter(\n                suffix_key=suffix_key,\n                prefix_key=prefix_key,\n                project=project_id,\n            )\n\n            if label_id is not None:\n                conflicting_labels = conflicting_labels.exclude(id=label_id)\n\n            if conflicting_labels.exists():\n                raise ValidationError(\"Duplicate shortcut key.\")\n\n        return super().validate(attrs)\n\n    class Meta:\n        model = LabelType\n        fields = (\n            \"id\",\n            \"text\",\n            \"prefix_key\",\n            \"suffix_key\",\n            \"background_color\",\n            \"text_color\",\n        )\n\n\nclass CategoryTypeSerializer(LabelSerializer):\n    class Meta:\n        model = CategoryType\n        fields = LabelSerializer.Meta.fields\n\n\nclass SpanTypeSerializer(LabelSerializer):\n    class Meta:\n        model = SpanType\n        fields = LabelSerializer.Meta.fields\n\n\nclass RelationTypeSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = RelationType\n        fields = LabelSerializer.Meta.fields\n",
                            "summary": "Class `LabelSerializer`: A serializer class for validating and saving label data with constraints on shortcut keys, used by CategoryType, SpanType, and RelationType serializers.",
                            "code_element_summaries": [
                                "Class `LabelSerializer`: A serializer class for validating and saving label data with specific constraints on shortcut keys.",
                                "Function `validate`: Validates the attributes of a model instance, checking for duplicate shortcut keys and ensuring proper key combinations.",
                                "Class Meta: Defines the model and fields for LabelType in the context of metadata configuration.",
                                "Class CategoryTypeSerializer: A serializer class for CategoryType models that inherits from LabelSerializer.",
                                "Class Meta: Defines metadata options for the CategoryType model and specifies the fields to be used from the LabelSerializer.",
                                "Class SpanTypeSerializer: A serializer for SpanType models that inherits from LabelSerializer and specifies the model and fields to include.",
                                "Class Meta: Defines metadata for the SpanType model with specific fields from LabelSerializer.",
                                "Class RelationTypeSerializer: A serializer for the RelationType model that includes fields specified in the LabelSerializer.",
                                "Class Meta: Defines metadata options for the RelationType model and specifies fields to be included from the LabelSerializer."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content includes test cases for ensuring uniqueness and validation of label attributes, CRUD operations on label lists in a project, and a function to generate labels based on project type.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_models.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\tests\\test_models.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestLabel`\nCode:\nclass TestLabel(TestCase):\n    def test_deny_creating_same_text(self):\n        label = mommy.make(\"CategoryType\")\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"CategoryType\", project=label.project, text=label.text)\n\n    def test_keys_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()\n\n    def test_suffix_key_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=None, suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()\n\n    def test_cannot_add_label_only_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\")\n        with self.assertRaises(ValidationError):\n            label.clean()\n\n    def test_can_add_label_only_suffix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)\n\n    def test_can_add_label_suffix_key_with_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)",
                                        "Function `test_deny_creating_same_text`\nCode:\n    def test_deny_creating_same_text(self):\n        label = mommy.make(\"CategoryType\")\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"CategoryType\", project=label.project, text=label.text)",
                                        "Function `test_keys_uniqueness`\nCode:\n    def test_keys_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()",
                                        "Function `test_suffix_key_uniqueness`\nCode:\n    def test_suffix_key_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=None, suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()",
                                        "Function `test_cannot_add_label_only_prefix_key`\nCode:\n    def test_cannot_add_label_only_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\")\n        with self.assertRaises(ValidationError):\n            label.clean()",
                                        "Function `test_can_add_label_only_suffix_key`\nCode:\n    def test_can_add_label_only_suffix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)",
                                        "Function `test_can_add_label_suffix_key_with_prefix_key`\nCode:\n    def test_can_add_label_suffix_key_with_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)",
                                        "Class `TestGeneratedColor`\nCode:\nclass TestGeneratedColor(TestCase):\n    def test_length(self):\n        for _ in range(100):\n            color = generate_random_hex_color()\n            self.assertEqual(len(color), 7)",
                                        "Function `test_length`\nCode:\n    def test_length(self):\n        for _ in range(100):\n            color = generate_random_hex_color()\n            self.assertEqual(len(color), 7)"
                                    ],
                                    "code": "from django.core.exceptions import ValidationError\nfrom django.db import IntegrityError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom label_types.models import CategoryType, generate_random_hex_color\n\n\nclass TestLabel(TestCase):\n    def test_deny_creating_same_text(self):\n        label = mommy.make(\"CategoryType\")\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"CategoryType\", project=label.project, text=label.text)\n\n    def test_keys_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()\n\n    def test_suffix_key_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=None, suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()\n\n    def test_cannot_add_label_only_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\")\n        with self.assertRaises(ValidationError):\n            label.clean()\n\n    def test_can_add_label_only_suffix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)\n\n    def test_can_add_label_suffix_key_with_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)\n\n\nclass TestGeneratedColor(TestCase):\n    def test_length(self):\n        for _ in range(100):\n            color = generate_random_hex_color()\n            self.assertEqual(len(color), 7)\n",
                                    "summary": "Class `TestLabel`: Contains test cases to ensure uniqueness and validation of label attributes in the CategoryType model, including checking for duplicate texts and key combinations.",
                                    "code_element_summaries": [
                                        "Class `TestLabel`: Contains test cases to ensure uniqueness and validation of label attributes in the CategoryType model.",
                                        "Function test_deny_creating_same_text: Tests that creating a CategoryType with the same project and text as an existing CategoryType raises an IntegrityError.",
                                        "Function `test_keys_uniqueness`: Tests the uniqueness of keys in a CategoryType object.",
                                        "Function `test_suffix_key_uniqueness`: Tests the uniqueness of suffix keys in CategoryType instances.",
                                        "Function test_cannot_add_label_only_prefix_key: Tests that a label with only a prefix key cannot be added to a project.",
                                        "Function `test_can_add_label_only_suffix_key`: Tests the ability to add a label with only a suffix key to a project.",
                                        "Function `test_can_add_label_suffix_key_with_prefix_key`: Tests the ability to add a label suffix key with a prefix key to a project category type.",
                                        "Class TestGeneratedColor: Contains a test case to verify that randomly generated hex colors have a length of 7 characters.",
                                        "Function `test_length`: A unit test function that checks the length of randomly generated hex colors."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestLabelList`\nCode:\nclass TestLabelList(CRUDMixin):\n    def setUp(self):\n        self.non_member = make_user()\n        self.project_a = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.label = make_label(self.project_a.item)\n        self.url = reverse(viewname=\"category_types\", args=[self.project_a.item.id])\n\n        # Ensure that the API does not return the labels of the other project.\n        self.project_b = make_project(task=\"Any\", users=[\"admin\"], roles=[settings.ROLE_PROJECT_ADMIN])\n        make_label(self.project_b.item)\n\n        # for label creation\n        self.data = {\"text\": \"example\"}\n\n    def test_returns_labels_to_project_member(self):\n        for member in self.project_a.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)\n            self.assertEqual(response.data[0][\"id\"], self.label.id)\n\n    def test_does_not_return_labels_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_labels_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_create_label(self):\n        self.assert_create(self.project_a.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_create_label(self):\n        for member in self.project_a.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_create_label(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_label(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_bulk_delete_label(self):\n        self.assert_delete(self.project_a.admin, status.HTTP_204_NO_CONTENT, data={\"ids\": [self.label.id]})\n\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project_a.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.non_member = make_user()\n        self.project_a = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.label = make_label(self.project_a.item)\n        self.url = reverse(viewname=\"category_types\", args=[self.project_a.item.id])\n\n        # Ensure that the API does not return the labels of the other project.\n        self.project_b = make_project(task=\"Any\", users=[\"admin\"], roles=[settings.ROLE_PROJECT_ADMIN])\n        make_label(self.project_b.item)\n\n        # for label creation\n        self.data = {\"text\": \"example\"}",
                                        "Function `test_returns_labels_to_project_member`\nCode:\n    def test_returns_labels_to_project_member(self):\n        for member in self.project_a.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)\n            self.assertEqual(response.data[0][\"id\"], self.label.id)",
                                        "Function `test_does_not_return_labels_to_non_project_member`\nCode:\n    def test_does_not_return_labels_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_does_not_return_labels_to_unauthenticated_user`\nCode:\n    def test_does_not_return_labels_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_create_label`\nCode:\n    def test_allows_admin_to_create_label(self):\n        self.assert_create(self.project_a.admin, status.HTTP_201_CREATED)",
                                        "Function `test_denies_project_staff_to_create_label`\nCode:\n    def test_denies_project_staff_to_create_label(self):\n        for member in self.project_a.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_create_label`\nCode:\n    def test_denies_non_project_member_to_create_label(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_create_label`\nCode:\n    def test_denies_unauthenticated_user_to_create_label(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_bulk_delete_label`\nCode:\n    def test_allows_admin_to_bulk_delete_label(self):\n        self.assert_delete(self.project_a.admin, status.HTTP_204_NO_CONTENT, data={\"ids\": [self.label.id]})",
                                        "Function `test_denies_project_staff_to_bulk_delete_label`\nCode:\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project_a.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})",
                                        "Class `TestAllowMemberToCreateLabelType`\nCode:\nclass TestAllowMemberToCreateLabelType(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, allow_member_to_create_label_type=True)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_types\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_allows_member_to_create_label_type(self):\n        for member in self.project.members:\n            self.data[\"text\"] = member.username\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, allow_member_to_create_label_type=True)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_types\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}",
                                        "Function `test_allows_member_to_create_label_type`\nCode:\n    def test_allows_member_to_create_label_type(self):\n        for member in self.project.members:\n            self.data[\"text\"] = member.username\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Function `test_denies_project_staff_to_bulk_delete_label`\nCode:\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})",
                                        "Class `TestLabelDetailAPI`\nCode:\nclass TestLabelDetailAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_type\", args=[cls.project.item.id, cls.label.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_returns_label_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.label.id)\n\n    def test_does_not_return_label_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_label_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_update_label(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_project_staff_to_update_label(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_label(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_update_label(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_delete_label(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_label(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_label(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_label(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_type\", args=[cls.project.item.id, cls.label.id])\n        cls.data = {\"text\": \"example\"}",
                                        "Function `test_returns_label_to_project_member`\nCode:\n    def test_returns_label_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.label.id)",
                                        "Function `test_does_not_return_label_to_non_project_member`\nCode:\n    def test_does_not_return_label_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_does_not_return_label_to_unauthenticated_user`\nCode:\n    def test_does_not_return_label_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_update_label`\nCode:\n    def test_allows_admin_to_update_label(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])",
                                        "Function `test_denies_project_staff_to_update_label`\nCode:\n    def test_denies_project_staff_to_update_label(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_update_label`\nCode:\n    def test_denies_non_project_member_to_update_label(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_update_label`\nCode:\n    def test_denies_unauthenticated_user_to_update_label(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_delete_label`\nCode:\n    def test_allows_admin_to_delete_label(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_project_staff_to_delete_label`\nCode:\n    def test_denies_project_staff_to_delete_label(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_delete_label`\nCode:\n    def test_denies_non_project_member_to_delete_label(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_delete_label`\nCode:\n    def test_denies_unauthenticated_user_to_delete_label(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestLabelUploadAPI`\nCode:\nclass TestLabelUploadAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.url = reverse(viewname=\"category_type_upload\", args=[cls.project.item.id])\n\n    def assert_upload_file(self, filename, user=None, expected_status=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        with open(os.path.join(DATA_DIR, filename), \"rb\") as f:\n            response = self.client.post(self.url, data={\"file\": f})\n        self.assertEqual(response.status_code, expected_status)\n\n    def test_allows_project_admin_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.project.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_member_to_upload_label(self):\n        for member in self.project.staffs:\n            self.assert_upload_file(\"valid_labels.json\", member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", expected_status=status.HTTP_403_FORBIDDEN)\n\n    def test_try_to_upload_invalid_file(self):\n        self.assert_upload_file(\"invalid_labels.json\", self.project.admin, status.HTTP_400_BAD_REQUEST)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.url = reverse(viewname=\"category_type_upload\", args=[cls.project.item.id])",
                                        "Function `assert_upload_file`\nCode:\n    def assert_upload_file(self, filename, user=None, expected_status=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        with open(os.path.join(DATA_DIR, filename), \"rb\") as f:\n            response = self.client.post(self.url, data={\"file\": f})\n        self.assertEqual(response.status_code, expected_status)",
                                        "Function `test_allows_project_admin_to_upload_label`\nCode:\n    def test_allows_project_admin_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.project.admin, status.HTTP_201_CREATED)",
                                        "Function `test_denies_project_member_to_upload_label`\nCode:\n    def test_denies_project_member_to_upload_label(self):\n        for member in self.project.staffs:\n            self.assert_upload_file(\"valid_labels.json\", member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_upload_label`\nCode:\n    def test_denies_non_project_member_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_upload_label`\nCode:\n    def test_denies_unauthenticated_user_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", expected_status=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_try_to_upload_invalid_file`\nCode:\n    def test_try_to_upload_invalid_file(self):\n        self.assert_upload_file(\"invalid_labels.json\", self.project.admin, status.HTTP_400_BAD_REQUEST)"
                                    ],
                                    "code": "import os\n\nfrom django.conf import settings\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\nfrom rest_framework.test import APITestCase\n\nfrom .utils import make_label\nfrom api.tests.utils import CRUDMixin\nfrom projects.models import ProjectType\nfrom projects.tests.utils import make_project, prepare_project\nfrom users.tests.utils import make_user\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"data\")\n\n\nclass TestLabelList(CRUDMixin):\n    def setUp(self):\n        self.non_member = make_user()\n        self.project_a = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.label = make_label(self.project_a.item)\n        self.url = reverse(viewname=\"category_types\", args=[self.project_a.item.id])\n\n        # Ensure that the API does not return the labels of the other project.\n        self.project_b = make_project(task=\"Any\", users=[\"admin\"], roles=[settings.ROLE_PROJECT_ADMIN])\n        make_label(self.project_b.item)\n\n        # for label creation\n        self.data = {\"text\": \"example\"}\n\n    def test_returns_labels_to_project_member(self):\n        for member in self.project_a.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)\n            self.assertEqual(response.data[0][\"id\"], self.label.id)\n\n    def test_does_not_return_labels_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_labels_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_create_label(self):\n        self.assert_create(self.project_a.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_create_label(self):\n        for member in self.project_a.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_create_label(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_label(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_bulk_delete_label(self):\n        self.assert_delete(self.project_a.admin, status.HTTP_204_NO_CONTENT, data={\"ids\": [self.label.id]})\n\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project_a.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})\n\n\nclass TestAllowMemberToCreateLabelType(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, allow_member_to_create_label_type=True)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_types\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_allows_member_to_create_label_type(self):\n        for member in self.project.members:\n            self.data[\"text\"] = member.username\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})\n\n\nclass TestLabelDetailAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_type\", args=[cls.project.item.id, cls.label.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_returns_label_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.label.id)\n\n    def test_does_not_return_label_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_label_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_update_label(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_project_staff_to_update_label(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_label(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_update_label(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_delete_label(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_label(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_label(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_label(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestLabelUploadAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.url = reverse(viewname=\"category_type_upload\", args=[cls.project.item.id])\n\n    def assert_upload_file(self, filename, user=None, expected_status=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        with open(os.path.join(DATA_DIR, filename), \"rb\") as f:\n            response = self.client.post(self.url, data={\"file\": f})\n        self.assertEqual(response.status_code, expected_status)\n\n    def test_allows_project_admin_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.project.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_member_to_upload_label(self):\n        for member in self.project.staffs:\n            self.assert_upload_file(\"valid_labels.json\", member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", expected_status=status.HTTP_403_FORBIDDEN)\n\n    def test_try_to_upload_invalid_file(self):\n        self.assert_upload_file(\"invalid_labels.json\", self.project.admin, status.HTTP_400_BAD_REQUEST)\n",
                                    "summary": "Class `TestLabelList`: A test class for CRUD operations on label lists in a project, with functions testing label retrieval, creation, and deletion based on user roles, including admins, project members, and non-project members.",
                                    "code_element_summaries": [
                                        "Class `TestLabelList`: A test class for CRUD operations on label lists in a project, including fetching, creating, and deleting labels with different user roles.",
                                        "Function `setUp`: Initializes test data including users, projects, labels, and URLs for API testing.",
                                        "Function `test_returns_labels_to_project_member`: Tests the functionality of returning labels to project members.",
                                        "Function `test_does_not_return_labels_to_non_project_member`: Asserts that non-project members cannot access labels.",
                                        "Function `test_does_not_return_labels_to_unauthenticated_user`: Asserts that labels are not returned to unauthenticated users with a HTTP 403 Forbidden status.",
                                        "Function test_allows_admin_to_create_label: Asserts that the admin user of project A can create a label with a status of HTTP 201 CREATED.",
                                        "Function `test_denies_project_staff_to_create_label`: Tests that project staff members are denied permission to create labels.",
                                        "Function `test_denies_non_project_member_to_create_label`: Tests that a non-project member is denied permission to create a label.",
                                        "Function `test_denies_unauthenticated_user_to_create_label`: Tests that an unauthenticated user is denied access to create a label.",
                                        "Function `test_allows_admin_to_bulk_delete_label`: Tests whether the admin user can successfully delete labels in bulk.",
                                        "Function `test_denies_project_staff_to_bulk_delete_label`: Tests that project staff members are denied permission to bulk delete labels.",
                                        "Class `TestAllowMemberToCreateLabelType`: A test class that checks if members can create label types and if project staff are denied bulk deletion of labels.",
                                        "Function `setUpTestData`: Sets up test data for a project with a document classification type, allowing members to create label types, and prepares label, URL, and data for testing.",
                                        "Function `test_allows_member_to_create_label_type`: Tests if a member is allowed to create a label type for a project.",
                                        "Function `test_denies_project_staff_to_bulk_delete_label`: Tests that project staff members are denied permission to bulk delete a label.",
                                        "Class `TestLabelDetailAPI`: Contains test cases to verify permissions for retrieving, updating, and deleting labels in a project based on user roles.",
                                        "Function `setUpTestData`: Sets up test data including a non-member user, a project, a label, a URL, and data for testing purposes.",
                                        "Function `test_returns_label_to_project_member`: Verifies that the label ID is returned to a project member when fetching data.",
                                        "Function `test_does_not_return_label_to_non_project_member`: A test function that checks if a non-project member is denied access to label information.",
                                        "Function `test_does_not_return_label_to_unauthenticated_user`: Asserts that the label is not returned to unauthenticated users with a 403 Forbidden status.",
                                        "Function `test_allows_admin_to_update_label`: Verifies that an admin user can update the label of a project successfully.",
                                        "Function `test_denies_project_staff_to_update_label`: Tests that project staff members are denied permission to update labels.",
                                        "Function `test_denies_non_project_member_to_update_label`: Tests that a non-project member is denied access to update the label.",
                                        "Function `test_denies_unauthenticated_user_to_update_label`: Tests that unauthenticated users are denied permission to update a label, expecting a 403 Forbidden status.",
                                        "Function `test_allows_admin_to_delete_label`: Tests if the admin user is allowed to delete a label with a successful response status code.",
                                        "Function `test_denies_project_staff_to_delete_label`: Tests that project staff members are denied permission to delete a label.",
                                        "Function `test_denies_non_project_member_to_delete_label`: Tests that a non-project member is denied permission to delete a label.",
                                        "Function `test_denies_unauthenticated_user_to_delete_label`: Tests that an unauthenticated user is denied access to delete a label with an expected status code of 403 Forbidden.",
                                        "Class `TestLabelUploadAPI`: A test case class for testing label upload API functionality with different user roles and file types.",
                                        "Function `setUpTestData`: Sets up test data including a non-member user, a project of document classification type, and a URL for category type upload.",
                                        "Function `assert_upload_file`: A function that asserts uploading a file with specified filename, user, and expected status code.",
                                        "Function `test_allows_project_admin_to_upload_label`: Tests whether project admins can upload labels successfully using a valid JSON file.",
                                        "Function `test_denies_project_member_to_upload_label`: Tests that project members are denied access to upload label files with a HTTP 403 Forbidden status code.",
                                        "Function `test_denies_non_project_member_to_upload_label`: Tests if a non-project member is denied permission to upload label files.",
                                        "Function `test_denies_unauthenticated_user_to_upload_label`: Tests that an unauthenticated user is denied access to upload a label file, expecting a 403 Forbidden status.",
                                        "Function test_try_to_upload_invalid_file: Tests the functionality of uploading an invalid file for label annotations and expects a 400 Bad Request status."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `make_label`\nCode:\ndef make_label(project, **kwargs):\n    if project.project_type.endswith(\"Classification\") or project.project_type in {\n        ProjectType.BOUNDING_BOX,\n        ProjectType.SEGMENTATION,\n    }:\n        return mommy.make(\"CategoryType\", project=project, **kwargs)\n    else:\n        return mommy.make(\"SpanType\", project=project, **kwargs)"
                                    ],
                                    "code": "from model_mommy import mommy\n\nfrom projects.models import ProjectType\n\n\ndef make_label(project, **kwargs):\n    if project.project_type.endswith(\"Classification\") or project.project_type in {\n        ProjectType.BOUNDING_BOX,\n        ProjectType.SEGMENTATION,\n    }:\n        return mommy.make(\"CategoryType\", project=project, **kwargs)\n    else:\n        return mommy.make(\"SpanType\", project=project, **kwargs)\n",
                                    "summary": "Function `make_label`: A function that generates labels based on the project type, either as a CategoryType or SpanType.",
                                    "code_element_summaries": [
                                        "Function `make_label`: A function that creates a label based on the project type, either as a CategoryType or SpanType."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a proxy model ExportedBoundingBox with methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import (\n    CategoryTypeDetail,\n    CategoryTypeList,\n    CategoryTypeUploadAPI,\n    RelationTypeDetail,\n    RelationTypeList,\n    RelationTypeUploadAPI,\n    SpanTypeDetail,\n    SpanTypeList,\n    SpanTypeUploadAPI,\n)\n\nurlpatterns = [\n    path(route=\"category-types\", view=CategoryTypeList.as_view(), name=\"category_types\"),\n    path(route=\"category-types/<int:label_id>\", view=CategoryTypeDetail.as_view(), name=\"category_type\"),\n    path(route=\"span-types\", view=SpanTypeList.as_view(), name=\"span_types\"),\n    path(route=\"span-types/<int:label_id>\", view=SpanTypeDetail.as_view(), name=\"span_type\"),\n    path(route=\"category-type-upload\", view=CategoryTypeUploadAPI.as_view(), name=\"category_type_upload\"),\n    path(route=\"span-type-upload\", view=SpanTypeUploadAPI.as_view(), name=\"span_type_upload\"),\n    path(route=\"relation-type-upload\", view=RelationTypeUploadAPI.as_view(), name=\"relation_type-upload\"),\n    path(route=\"relation-types\", view=RelationTypeList.as_view(), name=\"relation_types_list\"),\n    path(route=\"relation-types/<int:label_id>\", view=RelationTypeDetail.as_view(), name=\"relation_type_detail\"),\n]\n",
                            "summary": "URL patterns for different types of categories, spans, and relations, along with upload APIs, are defined using Django's path function in urlpatterns.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Function `camel_to_snake`\nCode:\ndef camel_to_snake(name):\n    name = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", name).lower()",
                                "Function `camel_to_snake_dict`\nCode:\ndef camel_to_snake_dict(d):\n    return {camel_to_snake(k): v for k, v in d.items()}",
                                "Class `LabelList`\nCode:\nclass LabelList(generics.ListCreateAPIView):\n    model = LabelType\n    filter_backends = [DjangoFilterBackend]\n    serializer_class = LabelSerializer\n    pagination_class = None\n\n    def get_permissions(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.allow_member_to_create_label_type and self.request.method == \"POST\":\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n        return super().get_permissions()\n\n    def get_queryset(self):\n        return self.model.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        self.model.objects.filter(pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                "Function `get_permissions`\nCode:\n    def get_permissions(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.allow_member_to_create_label_type and self.request.method == \"POST\":\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n        return super().get_permissions()",
                                "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        return self.model.objects.filter(project=self.kwargs[\"project_id\"])",
                                "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])",
                                "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        self.model.objects.filter(pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                "Class `CategoryTypeList`\nCode:\nclass CategoryTypeList(LabelList):\n    model = CategoryType\n    serializer_class = CategoryTypeSerializer",
                                "Class `CategoryTypeDetail`\nCode:\nclass CategoryTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = CategoryType.objects.all()\n    serializer_class = CategoryTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]",
                                "Class `SpanTypeList`\nCode:\nclass SpanTypeList(LabelList):\n    model = SpanType\n    serializer_class = SpanTypeSerializer",
                                "Class `SpanTypeDetail`\nCode:\nclass SpanTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = SpanType.objects.all()\n    serializer_class = SpanTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]",
                                "Class `RelationTypeList`\nCode:\nclass RelationTypeList(LabelList):\n    model = RelationType\n    serializer_class = RelationTypeSerializer",
                                "Class `RelationTypeDetail`\nCode:\nclass RelationTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = RelationType.objects.all()\n    serializer_class = RelationTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]",
                                "Class `LabelUploadAPI`\nCode:\nclass LabelUploadAPI(APIView):\n    parser_classes = (MultiPartParser,)\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n    serializer_class = LabelSerializer\n\n    @transaction.atomic\n    def post(self, request, *args, **kwargs):\n        if \"file\" not in request.data:\n            raise ParseError(\"Empty content\")\n        try:\n            labels = json.load(request.data[\"file\"])\n            labels = list(map(camel_to_snake_dict, labels))\n            serializer = self.serializer_class(data=labels, many=True)\n            serializer.is_valid(raise_exception=True)\n            serializer.save(project_id=kwargs[\"project_id\"])\n            return Response(status=status.HTTP_201_CREATED)\n        except json.decoder.JSONDecodeError:\n            raise ParseError(\"The file format is invalid.\")\n        except IntegrityError:\n            raise LabelValidationError",
                                "Function `post`\nCode:\n    def post(self, request, *args, **kwargs):\n        if \"file\" not in request.data:\n            raise ParseError(\"Empty content\")\n        try:\n            labels = json.load(request.data[\"file\"])\n            labels = list(map(camel_to_snake_dict, labels))\n            serializer = self.serializer_class(data=labels, many=True)\n            serializer.is_valid(raise_exception=True)\n            serializer.save(project_id=kwargs[\"project_id\"])\n            return Response(status=status.HTTP_201_CREATED)\n        except json.decoder.JSONDecodeError:\n            raise ParseError(\"The file format is invalid.\")\n        except IntegrityError:\n            raise LabelValidationError",
                                "Class `CategoryTypeUploadAPI`\nCode:\nclass CategoryTypeUploadAPI(LabelUploadAPI):\n    serializer_class = CategoryTypeSerializer",
                                "Class `SpanTypeUploadAPI`\nCode:\nclass SpanTypeUploadAPI(LabelUploadAPI):\n    serializer_class = SpanTypeSerializer",
                                "Class `RelationTypeUploadAPI`\nCode:\nclass RelationTypeUploadAPI(LabelUploadAPI):\n    serializer_class = RelationTypeSerializer"
                            ],
                            "code": "import json\nimport re\n\nfrom django.db import IntegrityError, transaction\nfrom django.shortcuts import get_object_or_404\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import generics, status\nfrom rest_framework.exceptions import ParseError\nfrom rest_framework.parsers import MultiPartParser\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom .exceptions import LabelValidationError\nfrom .models import CategoryType, LabelType, RelationType, SpanType\nfrom .serializers import (\n    CategoryTypeSerializer,\n    LabelSerializer,\n    RelationTypeSerializer,\n    SpanTypeSerializer,\n)\nfrom projects.models import Project\nfrom projects.permissions import (\n    IsProjectAdmin,\n    IsProjectMember,\n    IsProjectStaffAndReadOnly,\n)\n\n\ndef camel_to_snake(name):\n    name = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", name).lower()\n\n\ndef camel_to_snake_dict(d):\n    return {camel_to_snake(k): v for k, v in d.items()}\n\n\nclass LabelList(generics.ListCreateAPIView):\n    model = LabelType\n    filter_backends = [DjangoFilterBackend]\n    serializer_class = LabelSerializer\n    pagination_class = None\n\n    def get_permissions(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.allow_member_to_create_label_type and self.request.method == \"POST\":\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n        return super().get_permissions()\n\n    def get_queryset(self):\n        return self.model.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        self.model.objects.filter(pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass CategoryTypeList(LabelList):\n    model = CategoryType\n    serializer_class = CategoryTypeSerializer\n\n\nclass CategoryTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = CategoryType.objects.all()\n    serializer_class = CategoryTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n\nclass SpanTypeList(LabelList):\n    model = SpanType\n    serializer_class = SpanTypeSerializer\n\n\nclass SpanTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = SpanType.objects.all()\n    serializer_class = SpanTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n\nclass RelationTypeList(LabelList):\n    model = RelationType\n    serializer_class = RelationTypeSerializer\n\n\nclass RelationTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = RelationType.objects.all()\n    serializer_class = RelationTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n\nclass LabelUploadAPI(APIView):\n    parser_classes = (MultiPartParser,)\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n    serializer_class = LabelSerializer\n\n    @transaction.atomic\n    def post(self, request, *args, **kwargs):\n        if \"file\" not in request.data:\n            raise ParseError(\"Empty content\")\n        try:\n            labels = json.load(request.data[\"file\"])\n            labels = list(map(camel_to_snake_dict, labels))\n            serializer = self.serializer_class(data=labels, many=True)\n            serializer.is_valid(raise_exception=True)\n            serializer.save(project_id=kwargs[\"project_id\"])\n            return Response(status=status.HTTP_201_CREATED)\n        except json.decoder.JSONDecodeError:\n            raise ParseError(\"The file format is invalid.\")\n        except IntegrityError:\n            raise LabelValidationError\n\n\nclass CategoryTypeUploadAPI(LabelUploadAPI):\n    serializer_class = CategoryTypeSerializer\n\n\nclass SpanTypeUploadAPI(LabelUploadAPI):\n    serializer_class = SpanTypeSerializer\n\n\nclass RelationTypeUploadAPI(LabelUploadAPI):\n    serializer_class = RelationTypeSerializer\n",
                            "summary": "A set of functions and classes for managing label types, uploading label data, and converting keys from camelCase to snake_case in a Django API project.",
                            "code_element_summaries": [
                                "Function `camel_to_snake`: Converts a camelCase string to snake_case.",
                                "Function `camel_to_snake_dict`: Converts keys in a dictionary from camel case to snake case.",
                                "Class `LabelList`: A Django API view for managing label types within a project, including creation, deletion, and permission handling based on project membership.",
                                "Function `get_permissions`: Determines the permission classes based on project settings and request method for a specific project.",
                                "Function `get_queryset`: Returns a queryset filtered by project ID.",
                                "Function `perform_create`: Saves the serializer data with the project_id extracted from the request's kwargs.",
                                "Function `delete`: Deletes objects based on the provided IDs from the request data.",
                                "Class CategoryTypeList: A LabelList subclass representing a list of CategoryType instances with a specified serializer class.",
                                "Class CategoryTypeDetail: A view for retrieving, updating, and deleting CategoryType instances with specified permissions and serializer.",
                                "Class SpanTypeList: Represents a list of SpanType objects with associated serializer class.",
                                "Class SpanTypeDetail: API view for retrieving, updating, and deleting a specific SpanType instance with specified permissions and serializer.",
                                "Class RelationTypeList: A LabelList subclass that defines the model and serializer class for relation types.",
                                "Class `RelationTypeDetail`: An API view for retrieving, updating, and deleting a specific relation type with specified permissions.",
                                "Class `LabelUploadAPI`: An API view for uploading label data in JSON format, converting keys from camelCase to snake_case, and saving the data to the database with project_id association.",
                                "Function `post`: Handles POST requests by parsing and saving label data, converting camel case keys to snake case, and handling errors related to file content and data integrity.",
                                "Class CategoryTypeUploadAPI: A subclass of LabelUploadAPI that uses CategoryTypeSerializer for uploading category type annotations.",
                                "Class SpanTypeUploadAPI: A subclass of LabelUploadAPI that handles uploading span type annotations using the SpanTypeSerializer.",
                                "Class RelationTypeUploadAPI: An API endpoint for uploading relation type annotations using the RelationTypeSerializer."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content provides a proxy model ExportedBoundingBox that extends BoundingBox and includes methods to convert bounding box annotations into dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "manage.py",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\manage.py",
                    "is_dir": false,
                    "code_elements": [],
                    "code": "#!/usr/bin/env python\nimport os\nimport sys\n\nif __name__ == \"__main__\":\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings.development\")\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)\n",
                    "summary": "A Python script that sets the Django settings module and executes management commands from the command line.",
                    "code_element_summaries": [],
                    "children": []
                },
                {
                    "name": "metrics",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content introduces a proxy model called ExportedBoundingBox that allows for the conversion of bounding box annotations into dictionary and tuple formats.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\admin.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content provides a class ExportedBoundingBox that includes methods to convert bounding box annotations into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `MetricsConfig`\nCode:\nclass MetricsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"metrics\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass MetricsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"metrics\"\n",
                            "summary": "Class MetricsConfig: AppConfig class for the \"metrics\" app with a default auto field of \"django.db.models.BigAutoField\".",
                            "code_element_summaries": [
                                "Class MetricsConfig: An AppConfig class for the \"metrics\" app with a default auto field of \"django.db.models.BigAutoField\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The class ExportedBoundingBox serves as a proxy model of BoundingBox, offering functionality to convert bounding box annotations into dictionary and tuple representations.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content defines a class ExportedBoundingBox that acts as a proxy model of BoundingBox, providing methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\models.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content provides methods for converting bounding box annotations into dictionary and tuple formats within a proxy model called ExportedBoundingBox.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "tests.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\tests.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `TestMemberProgress`\nCode:\nclass TestMemberProgress(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"member_progress\", args=[self.project.item.id])\n\n    def test_fetch_initial_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})\n\n    def test_fetch_progress(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})",
                                "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"member_progress\", args=[self.project.item.id])",
                                "Function `test_fetch_initial_progress`\nCode:\n    def test_fetch_initial_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})",
                                "Function `test_fetch_progress`\nCode:\n    def test_fetch_progress(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})",
                                "Class `TestProgressHelper`\nCode:\nclass TestProgressHelper(CRUDMixin):\n    collaborative_annotation = False\n\n    def setUp(self):\n        self.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=self.collaborative_annotation\n        )\n        self.example = make_doc(self.project.item)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        self.url = reverse(viewname=\"progress\", args=[self.project.item.id])",
                                "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=self.collaborative_annotation\n        )\n        self.example = make_doc(self.project.item)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        self.url = reverse(viewname=\"progress\", args=[self.project.item.id])",
                                "Class `TestProgress`\nCode:\nclass TestProgress(TestProgressHelper):\n    collaborative_annotation = False\n\n    def test_fetch_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n        self.assertEqual(response.data, expected)\n\n    def test_cannot_affect_others_progress(self):\n        for member in self.project.staffs:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 1, \"complete\": 0}\n            self.assertEqual(response.data, expected)",
                                "Function `test_fetch_progress`\nCode:\n    def test_fetch_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n        self.assertEqual(response.data, expected)",
                                "Function `test_cannot_affect_others_progress`\nCode:\n    def test_cannot_affect_others_progress(self):\n        for member in self.project.staffs:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 1, \"complete\": 0}\n            self.assertEqual(response.data, expected)",
                                "Class `TestProgressOnCollaborativeAnnotation`\nCode:\nclass TestProgressOnCollaborativeAnnotation(TestProgressHelper):\n    collaborative_annotation = True\n\n    def test_fetch_progress(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n            self.assertEqual(response.data, expected)",
                                "Function `test_fetch_progress`\nCode:\n    def test_fetch_progress(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n            self.assertEqual(response.data, expected)",
                                "Class `TestCategoryDistribution`\nCode:\nclass TestCategoryDistribution(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.label = make_label(self.project.item, text=\"label\")\n        mommy.make(\"Category\", example=self.example, label=self.label, user=self.project.admin)\n        self.url = reverse(viewname=\"category_distribution\", args=[self.project.item.id])\n\n    def test_fetch_distribution(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {member.username: {self.label.text: 0} for member in self.project.members}\n        expected[self.project.admin.username][self.label.text] = 1\n        self.assertEqual(response.data, expected)",
                                "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.label = make_label(self.project.item, text=\"label\")\n        mommy.make(\"Category\", example=self.example, label=self.label, user=self.project.admin)\n        self.url = reverse(viewname=\"category_distribution\", args=[self.project.item.id])",
                                "Function `test_fetch_distribution`\nCode:\n    def test_fetch_distribution(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {member.username: {self.label.text: 0} for member in self.project.members}\n        expected[self.project.admin.username][self.label.text] = 1\n        self.assertEqual(response.data, expected)"
                            ],
                            "code": "from model_mommy import mommy\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom examples.tests.utils import make_doc\nfrom label_types.tests.utils import make_label\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestMemberProgress(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"member_progress\", args=[self.project.item.id])\n\n    def test_fetch_initial_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})\n\n    def test_fetch_progress(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})\n\n\nclass TestProgressHelper(CRUDMixin):\n    collaborative_annotation = False\n\n    def setUp(self):\n        self.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=self.collaborative_annotation\n        )\n        self.example = make_doc(self.project.item)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        self.url = reverse(viewname=\"progress\", args=[self.project.item.id])\n\n\nclass TestProgress(TestProgressHelper):\n    collaborative_annotation = False\n\n    def test_fetch_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n        self.assertEqual(response.data, expected)\n\n    def test_cannot_affect_others_progress(self):\n        for member in self.project.staffs:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 1, \"complete\": 0}\n            self.assertEqual(response.data, expected)\n\n\nclass TestProgressOnCollaborativeAnnotation(TestProgressHelper):\n    collaborative_annotation = True\n\n    def test_fetch_progress(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n            self.assertEqual(response.data, expected)\n\n\nclass TestCategoryDistribution(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.label = make_label(self.project.item, text=\"label\")\n        mommy.make(\"Category\", example=self.example, label=self.label, user=self.project.admin)\n        self.url = reverse(viewname=\"category_distribution\", args=[self.project.item.id])\n\n    def test_fetch_distribution(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {member.username: {self.label.text: 0} for member in self.project.members}\n        expected[self.project.admin.username][self.label.text] = 1\n        self.assertEqual(response.data, expected)\n",
                            "summary": "A series of test classes and functions that verify the functionality of fetching and managing progress, category distribution, and collaborative annotations in a document classification project.",
                            "code_element_summaries": [
                                "Class `TestMemberProgress`: A class that tests fetching initial and updated progress of members in a project.",
                                "Function `setUp`: Initializes project, example document, and URL for document classification.",
                                "Function `test_fetch_initial_progress`: Tests fetching initial progress data for a project and asserts the response data matches the expected progress information.",
                                "Function `test_fetch_progress`: Tests fetching progress data for a project and verifies the expected progress values.",
                                "Class TestProgressHelper: A helper class for managing test progress in a project with document classification annotations.",
                                "Function `setUp`: Sets up the necessary data and objects for testing document classification projects with collaborative annotation.",
                                "Class `TestProgress`: A model representing test progress with methods to fetch progress and ensure progress is not affected by others.",
                                "Function `test_fetch_progress`: Tests the progress of fetching data and compares the response data with expected values.",
                                "Function `test_cannot_affect_others_progress`: Tests that a staff member's progress does not affect other staff members' progress in a project.",
                                "Class `TestProgressOnCollaborativeAnnotation`: A test class for checking progress on collaborative annotations within a project.",
                                "Function `test_fetch_progress`: Tests the progress fetch functionality for project members with expected total, remaining, and complete values.",
                                "Class `TestCategoryDistribution`: A test class for fetching category distribution data in a project.",
                                "Function `setUp`: Sets up necessary data for testing document classification project by creating a project, an example document, a label, a category, and a URL.",
                                "Function `test_fetch_distribution`: A test function that checks if the distribution of annotations is fetched correctly for project members."
                            ],
                            "children": []
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import (\n    CategoryTypeDistribution,\n    MemberProgressAPI,\n    ProgressAPI,\n    RelationTypeDistribution,\n    SpanTypeDistribution,\n)\n\nurlpatterns = [\n    path(route=\"progress\", view=ProgressAPI.as_view(), name=\"progress\"),\n    path(route=\"member-progress\", view=MemberProgressAPI.as_view(), name=\"member_progress\"),\n    path(route=\"category-distribution\", view=CategoryTypeDistribution.as_view(), name=\"category_distribution\"),\n    path(route=\"relation-distribution\", view=RelationTypeDistribution.as_view(), name=\"relation_distribution\"),\n    path(route=\"span-distribution\", view=SpanTypeDistribution.as_view(), name=\"span_distribution\"),\n]\n",
                            "summary": "URL patterns for various API views related to progress, member progress, category distribution, relation distribution, and span distribution are defined using Django's path function.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ProgressAPI`\nCode:\nclass ProgressAPI(APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        total = examples.count()\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.collaborative_annotation:\n            complete = ExampleState.objects.count_done(examples)\n        else:\n            complete = ExampleState.objects.count_done(examples, user=self.request.user)\n        data = {\"total\": total, \"remaining\": total - complete, \"complete\": complete}\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        total = examples.count()\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.collaborative_annotation:\n            complete = ExampleState.objects.count_done(examples)\n        else:\n            complete = ExampleState.objects.count_done(examples, user=self.request.user)\n        data = {\"total\": total, \"remaining\": total - complete, \"complete\": complete}\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Class `MemberProgressAPI`\nCode:\nclass MemberProgressAPI(APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = ExampleState.objects.measure_member_progress(examples, members)\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = ExampleState.objects.measure_member_progress(examples, members)\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Class `LabelDistribution`\nCode:\nclass LabelDistribution(abc.ABC, APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    model = Label\n    label_type = LabelType\n\n    def get(self, request, *args, **kwargs):\n        labels = self.label_type.objects.filter(project=self.kwargs[\"project_id\"])\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = self.model.objects.calc_label_distribution(examples, members, labels)\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        labels = self.label_type.objects.filter(project=self.kwargs[\"project_id\"])\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = self.model.objects.calc_label_distribution(examples, members, labels)\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Class `CategoryTypeDistribution`\nCode:\nclass CategoryTypeDistribution(LabelDistribution):\n    model = Category\n    label_type = CategoryType",
                                "Class `SpanTypeDistribution`\nCode:\nclass SpanTypeDistribution(LabelDistribution):\n    model = Span\n    label_type = SpanType",
                                "Class `RelationTypeDistribution`\nCode:\nclass RelationTypeDistribution(LabelDistribution):\n    model = Relation\n    label_type = RelationType"
                            ],
                            "code": "import abc\n\nfrom django.shortcuts import get_object_or_404\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom examples.models import Example, ExampleState\nfrom label_types.models import CategoryType, LabelType, RelationType, SpanType\nfrom labels.models import Category, Label, Relation, Span\nfrom projects.models import Member, Project\nfrom projects.permissions import IsProjectAdmin, IsProjectStaffAndReadOnly\n\n\nclass ProgressAPI(APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        total = examples.count()\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.collaborative_annotation:\n            complete = ExampleState.objects.count_done(examples)\n        else:\n            complete = ExampleState.objects.count_done(examples, user=self.request.user)\n        data = {\"total\": total, \"remaining\": total - complete, \"complete\": complete}\n        return Response(data=data, status=status.HTTP_200_OK)\n\n\nclass MemberProgressAPI(APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = ExampleState.objects.measure_member_progress(examples, members)\n        return Response(data=data, status=status.HTTP_200_OK)\n\n\nclass LabelDistribution(abc.ABC, APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    model = Label\n    label_type = LabelType\n\n    def get(self, request, *args, **kwargs):\n        labels = self.label_type.objects.filter(project=self.kwargs[\"project_id\"])\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = self.model.objects.calc_label_distribution(examples, members, labels)\n        return Response(data=data, status=status.HTTP_200_OK)\n\n\nclass CategoryTypeDistribution(LabelDistribution):\n    model = Category\n    label_type = CategoryType\n\n\nclass SpanTypeDistribution(LabelDistribution):\n    model = Span\n    label_type = SpanType\n\n\nclass RelationTypeDistribution(LabelDistribution):\n    model = Relation\n    label_type = RelationType\n",
                            "summary": "Classes `ProgressAPI`, `MemberProgressAPI`, `LabelDistribution`, `CategoryTypeDistribution`, `SpanTypeDistribution`, and `RelationTypeDistribution` provide API views and models for retrieving and analyzing progress, member progress, label distribution, category type distribution, span type distribution, and relation type distribution data in a project.",
                            "code_element_summaries": [
                                "Class `ProgressAPI`: An API view that retrieves progress information for examples in a project, including total, remaining, and completed annotations.",
                                "Function `get`: Retrieves data related to examples in a project, including total count, remaining count, and completed count based on collaborative annotation settings.",
                                "Class `MemberProgressAPI`: An API view that retrieves and calculates member progress data for a specific project.",
                                "Function `get`: Retrieves and returns data related to member progress within a specific project based on examples and members.",
                                "Class `LabelDistribution`: An API view class that calculates label distribution based on examples, members, and labels associated with a project.",
                                "Function `get`: Retrieves label distribution data for a specific project by filtering labels, examples, and members.",
                                "Class CategoryTypeDistribution: A subclass of LabelDistribution representing the distribution of category labels.",
                                "Class SpanTypeDistribution: A model that represents the distribution of span types in a labeling task.",
                                "Class RelationTypeDistribution: A model that represents the distribution of relation types in a dataset."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content defines a class ExportedBoundingBox which acts as a proxy model for BoundingBox, providing methods to convert bounding box annotations into dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "projects",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "Classes MemberAdmin, ProjectAdmin, and TagAdmin provide model admin functionality for managing member roles, projects, and tags, while ProjectsConfig handles the configuration for the \"projects\" app, and custom exceptions RoleConstraintException and RoleAlreadyAssignedException handle role errors in projects.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `MemberAdmin`\nCode:\nclass MemberAdmin(admin.ModelAdmin):\n    list_display = (\n        \"user\",\n        \"role\",\n        \"project\",\n    )\n    ordering = (\"user\",)\n    search_fields = (\"user__username\",)",
                                "Class `ProjectAdmin`\nCode:\nclass ProjectAdmin(admin.ModelAdmin):\n    list_display = (\"name\", \"description\", \"project_type\", \"random_order\", \"collaborative_annotation\")\n    ordering = (\"project_type\",)\n    search_fields = (\"name\",)",
                                "Class `TagAdmin`\nCode:\nclass TagAdmin(admin.ModelAdmin):\n    list_display = (\n        \"project\",\n        \"text\",\n    )\n    ordering = (\n        \"project\",\n        \"text\",\n    )\n    search_fields = (\"text\",)"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import (\n    BoundingBoxProject,\n    ImageCaptioningProject,\n    ImageClassificationProject,\n    Member,\n    Project,\n    SegmentationProject,\n    Seq2seqProject,\n    SequenceLabelingProject,\n    Tag,\n    TextClassificationProject,\n)\n\n\nclass MemberAdmin(admin.ModelAdmin):\n    list_display = (\n        \"user\",\n        \"role\",\n        \"project\",\n    )\n    ordering = (\"user\",)\n    search_fields = (\"user__username\",)\n\n\nclass ProjectAdmin(admin.ModelAdmin):\n    list_display = (\"name\", \"description\", \"project_type\", \"random_order\", \"collaborative_annotation\")\n    ordering = (\"project_type\",)\n    search_fields = (\"name\",)\n\n\nclass TagAdmin(admin.ModelAdmin):\n    list_display = (\n        \"project\",\n        \"text\",\n    )\n    ordering = (\n        \"project\",\n        \"text\",\n    )\n    search_fields = (\"text\",)\n\n\nadmin.site.register(Member, MemberAdmin)\nadmin.site.register(Project, ProjectAdmin)\nadmin.site.register(TextClassificationProject, ProjectAdmin)\nadmin.site.register(SequenceLabelingProject, ProjectAdmin)\nadmin.site.register(Seq2seqProject, ProjectAdmin)\nadmin.site.register(BoundingBoxProject, ProjectAdmin)\nadmin.site.register(SegmentationProject, ProjectAdmin)\nadmin.site.register(ImageCaptioningProject, ProjectAdmin)\nadmin.site.register(ImageClassificationProject, ProjectAdmin)\nadmin.site.register(Tag, TagAdmin)\n",
                            "summary": "Classes MemberAdmin, ProjectAdmin, and TagAdmin: Model admin classes with specified display, ordering, and search functionality for managing member roles, projects, and tags, respectively.",
                            "code_element_summaries": [
                                "Class MemberAdmin: A model admin class for managing member roles and projects with specified display, ordering, and search functionality.",
                                "Class ProjectAdmin: A model admin class for managing projects with specified display fields, ordering, and search functionality.",
                                "Class TagAdmin: A model admin class for managing tags with specified list display, ordering, and search fields."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ProjectsConfig`\nCode:\nclass ProjectsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"projects\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass ProjectsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"projects\"\n",
                            "summary": "Class ProjectsConfig: A Django application configuration class for the \"projects\" app with a specified default auto field.",
                            "code_element_summaries": [
                                "Class ProjectsConfig: A Django application configuration class for the \"projects\" app with a specified default auto field."
                            ],
                            "children": []
                        },
                        {
                            "name": "exceptions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\exceptions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RoleConstraintException`\nCode:\nclass RoleConstraintException(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"The project needs at least one administrator.\"",
                                "Class `RoleAlreadyAssignedException`\nCode:\nclass RoleAlreadyAssignedException(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"This user is already assigned to a role in this project.\""
                            ],
                            "code": "from rest_framework import status\nfrom rest_framework.exceptions import APIException\n\n\nclass RoleConstraintException(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"The project needs at least one administrator.\"\n\n\nclass RoleAlreadyAssignedException(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"This user is already assigned to a role in this project.\"\n",
                            "summary": "Class RoleConstraintException: Custom API exception for role constraint errors in projects requiring at least one administrator. \n\nClass RoleAlreadyAssignedException: Exception for users already assigned to roles in projects.",
                            "code_element_summaries": [
                                "Class RoleConstraintException: A custom API exception representing a role constraint error in a project that requires at least one administrator.",
                                "Class RoleAlreadyAssignedException: Represents an exception for when a user is already assigned to a role in a project."
                            ],
                            "children": []
                        },
                        {
                            "name": "management",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\management",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Command: A management command for creating a member with specified role, user, and project names non-interactively.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "commands",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\management\\commands",
                                    "is_dir": true,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "Class Command: A management command for creating a member with specified role, user, and project names non-interactively.",
                                    "code_element_summaries": [],
                                    "children": [
                                        {
                                            "name": "create_member.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\management\\commands\\create_member.py",
                                            "is_dir": false,
                                            "code_elements": [
                                                "Class `Command`\nCode:\nclass Command(BaseCommand):\n    help = \"Non-interactively create a member\"\n\n    @classmethod\n    def add_arguments(self, parser):\n        parser.add_argument(\"--rolename\", default=None, help=\"The name of the role.\")\n        parser.add_argument(\"--username\", default=None, help=\"The name of the user.\")\n        parser.add_argument(\"--projectname\", default=None, help=\"The name of the project.\")\n\n    def handle(self, *args, **options):\n        rolename = options.get(\"rolename\")\n        username = options.get(\"username\")\n        projectname = options.get(\"projectname\")\n\n        if not rolename or not username or not projectname:\n            raise CommandError(\"--rolename  --projectname  --username are required for the member\")\n\n        if rolename and projectname and username:\n            try:\n                role = Role.objects.get(name=rolename)\n                user = User.objects.get(username=username)\n                project = Project.objects.get(name=projectname)\n                member = Member.objects.create(role_id=role.id, user_id=user.id, project_id=project.id)\n            except Exception as ex:\n                self.stderr.write(self.style.ERROR('Error occurred while creating member \"%s\"' % ex))\n            else:\n                self.stdout.write(self.style.SUCCESS('Member created successfully \"%s\"' % member.id))",
                                                "Function `add_arguments`\nCode:\n    def add_arguments(self, parser):\n        parser.add_argument(\"--rolename\", default=None, help=\"The name of the role.\")\n        parser.add_argument(\"--username\", default=None, help=\"The name of the user.\")\n        parser.add_argument(\"--projectname\", default=None, help=\"The name of the project.\")",
                                                "Function `handle`\nCode:\n    def handle(self, *args, **options):\n        rolename = options.get(\"rolename\")\n        username = options.get(\"username\")\n        projectname = options.get(\"projectname\")\n\n        if not rolename or not username or not projectname:\n            raise CommandError(\"--rolename  --projectname  --username are required for the member\")\n\n        if rolename and projectname and username:\n            try:\n                role = Role.objects.get(name=rolename)\n                user = User.objects.get(username=username)\n                project = Project.objects.get(name=projectname)\n                member = Member.objects.create(role_id=role.id, user_id=user.id, project_id=project.id)\n            except Exception as ex:\n                self.stderr.write(self.style.ERROR('Error occurred while creating member \"%s\"' % ex))\n            else:\n                self.stdout.write(self.style.SUCCESS('Member created successfully \"%s\"' % member.id))"
                                            ],
                                            "code": "from django.contrib.auth.models import User\nfrom django.core.management.base import BaseCommand, CommandError\nfrom models import Project\n\nfrom ...models import Member\nfrom roles.models import Role\n\n\nclass Command(BaseCommand):\n    help = \"Non-interactively create a member\"\n\n    @classmethod\n    def add_arguments(self, parser):\n        parser.add_argument(\"--rolename\", default=None, help=\"The name of the role.\")\n        parser.add_argument(\"--username\", default=None, help=\"The name of the user.\")\n        parser.add_argument(\"--projectname\", default=None, help=\"The name of the project.\")\n\n    def handle(self, *args, **options):\n        rolename = options.get(\"rolename\")\n        username = options.get(\"username\")\n        projectname = options.get(\"projectname\")\n\n        if not rolename or not username or not projectname:\n            raise CommandError(\"--rolename  --projectname  --username are required for the member\")\n\n        if rolename and projectname and username:\n            try:\n                role = Role.objects.get(name=rolename)\n                user = User.objects.get(username=username)\n                project = Project.objects.get(name=projectname)\n                member = Member.objects.create(role_id=role.id, user_id=user.id, project_id=project.id)\n            except Exception as ex:\n                self.stderr.write(self.style.ERROR('Error occurred while creating member \"%s\"' % ex))\n            else:\n                self.stdout.write(self.style.SUCCESS('Member created successfully \"%s\"' % member.id))\n",
                                            "summary": "Class Command: A management command for creating a member with specified role, user, and project names non-interactively.",
                                            "code_element_summaries": [
                                                "Class `Command`: A management command to non-interactively create a member with specified role, user, and project names.",
                                                "Function `add_arguments`: Adds command line arguments for role name, user name, and project name with default values and help descriptions.",
                                                "Function `handle`: A function that creates a member with a specified role, username, and project name, handling error cases."
                                            ],
                                            "children": []
                                        },
                                        {
                                            "name": "__init__.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\management\\commands\\__init__.py",
                                            "is_dir": false,
                                            "code_elements": [],
                                            "code": "",
                                            "summary": "The content provides a proxy model ExportedBoundingBox that includes methods to convert bounding box annotations into dictionary and tuple forms.",
                                            "code_element_summaries": [],
                                            "children": []
                                        }
                                    ]
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\management\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content defines a class ExportedBoundingBox that extends BoundingBox and provides methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A class responsible for managing database schema changes and data migrations within the application, including altering foreign key relationships and adding new fields to existing models.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"roles\", \"0003_delete_member\"),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Member\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\"role\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"roles.role\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"user\", \"project\")},\n                    },\n                ),\n            ],\n            database_operations=[],\n        ),\n        migrations.RunSQL(\n            sql=\"ALTER TABLE members_member RENAME TO projects_member\",\n            reverse_sql=\"ALTER TABLE projects_member RENAME TO members_member\",\n        ),\n        migrations.RunSQL(\n            sql=\"UPDATE django_content_type SET app_label='projects' WHERE app_label='members'\",\n            reverse_sql=\"UPDATE django_content_type SET app_label='members' WHERE app_label='projects'\",\n        ),\n        migrations.RunSQL(\n            sql=\"UPDATE django_migrations SET app='projects' WHERE app='members'\",\n            reverse_sql=\"UPDATE django_migrations SET app='members' WHERE app='projects'\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-13 01:54\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"roles\", \"0003_delete_member\"),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Member\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\"role\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"roles.role\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"user\", \"project\")},\n                    },\n                ),\n            ],\n            database_operations=[],\n        ),\n        migrations.RunSQL(\n            sql=\"ALTER TABLE members_member RENAME TO projects_member\",\n            reverse_sql=\"ALTER TABLE projects_member RENAME TO members_member\",\n        ),\n        migrations.RunSQL(\n            sql=\"UPDATE django_content_type SET app_label='projects' WHERE app_label='members'\",\n            reverse_sql=\"UPDATE django_content_type SET app_label='members' WHERE app_label='projects'\",\n        ),\n        migrations.RunSQL(\n            sql=\"UPDATE django_migrations SET app='projects' WHERE app='members'\",\n            reverse_sql=\"UPDATE django_migrations SET app='members' WHERE app='projects'\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class responsible for managing database schema changes associated with project member roles and their mappings.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that handles database schema changes related to project member roles and their mappings."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_auto_20220204_0201.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0002_auto_20220204_0201.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n        (\"projects\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Project\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"name\", models.CharField(max_length=100)),\n                        (\"description\", models.TextField(default=\"\")),\n                        (\"guideline\", models.TextField(blank=True, default=\"\")),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project_type\",\n                            models.CharField(\n                                choices=[\n                                    (\"DocumentClassification\", \"document classification\"),\n                                    (\"SequenceLabeling\", \"sequence labeling\"),\n                                    (\"Seq2seq\", \"sequence to sequence\"),\n                                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                                    (\"Speech2text\", \"speech to text\"),\n                                    (\"ImageClassification\", \"image classification\"),\n                                ],\n                                max_length=30,\n                            ),\n                        ),\n                        (\"random_order\", models.BooleanField(default=False)),\n                        (\"collaborative_annotation\", models.BooleanField(default=False)),\n                        (\"single_class_classification\", models.BooleanField(default=False)),\n                        (\n                            \"created_by\",\n                            models.ForeignKey(\n                                null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                            ),\n                        ),\n                        (\n                            \"polymorphic_ctype\",\n                            models.ForeignKey(\n                                editable=False,\n                                null=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"polymorphic_projects.project_set+\",\n                                to=\"contenttypes.contenttype\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"ImageClassificationProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"IntentDetectionAndSlotFillingProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Seq2seqProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"SequenceLabelingProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                        (\"allow_overlapping\", models.BooleanField(default=False)),\n                        (\"grapheme_mode\", models.BooleanField(default=False)),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Speech2textProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"TextClassificationProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Tag\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.TextField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"tags\", to=\"projects.project\"\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.AlterField(\n                    model_name=\"member\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            database_operations=[\n                migrations.RunSQL(\n                    sql=\"\"\"\n                    UPDATE django_content_type\n                    SET app_label = 'projects'\n                    WHERE app_label = 'api' AND model LIKE '%project'\n                    \"\"\",\n                    reverse_sql=\"\"\"\n                    UPDATE django_content_type\n                    SET app_label = 'api'\n                    WHERE app_label = 'projects' AND model LIKE '%project'\n                    \"\"\",\n                )\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n        (\"projects\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Project\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"name\", models.CharField(max_length=100)),\n                        (\"description\", models.TextField(default=\"\")),\n                        (\"guideline\", models.TextField(blank=True, default=\"\")),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project_type\",\n                            models.CharField(\n                                choices=[\n                                    (\"DocumentClassification\", \"document classification\"),\n                                    (\"SequenceLabeling\", \"sequence labeling\"),\n                                    (\"Seq2seq\", \"sequence to sequence\"),\n                                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                                    (\"Speech2text\", \"speech to text\"),\n                                    (\"ImageClassification\", \"image classification\"),\n                                ],\n                                max_length=30,\n                            ),\n                        ),\n                        (\"random_order\", models.BooleanField(default=False)),\n                        (\"collaborative_annotation\", models.BooleanField(default=False)),\n                        (\"single_class_classification\", models.BooleanField(default=False)),\n                        (\n                            \"created_by\",\n                            models.ForeignKey(\n                                null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                            ),\n                        ),\n                        (\n                            \"polymorphic_ctype\",\n                            models.ForeignKey(\n                                editable=False,\n                                null=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"polymorphic_projects.project_set+\",\n                                to=\"contenttypes.contenttype\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"ImageClassificationProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"IntentDetectionAndSlotFillingProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Seq2seqProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"SequenceLabelingProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                        (\"allow_overlapping\", models.BooleanField(default=False)),\n                        (\"grapheme_mode\", models.BooleanField(default=False)),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Speech2textProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"TextClassificationProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Tag\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.TextField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"tags\", to=\"projects.project\"\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.AlterField(\n                    model_name=\"member\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            database_operations=[\n                migrations.RunSQL(\n                    sql=\"\"\"\n                    UPDATE django_content_type\n                    SET app_label = 'projects'\n                    WHERE app_label = 'api' AND model LIKE '%project'\n                    \"\"\",\n                    reverse_sql=\"\"\"\n                    UPDATE django_content_type\n                    SET app_label = 'api'\n                    WHERE app_label = 'projects' AND model LIKE '%project'\n                    \"\"\",\n                )\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class responsible for managing database schema changes and data migrations across different project types within the application.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that handles database schema changes and data migrations for various project types in the application."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_alter_project_polymorphic_ctype.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0003_alter_project_polymorphic_ctype.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n        (\"projects\", \"0002_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"polymorphic_ctype\",\n            field=models.ForeignKey(\n                editable=False,\n                null=True,\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"polymorphic_%(app_label)s.%(class)s_set+\",\n                to=\"contenttypes.contenttype\",\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-21 00:01\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n        (\"projects\", \"0002_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"polymorphic_ctype\",\n            field=models.ForeignKey(\n                editable=False,\n                null=True,\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"polymorphic_%(app_label)s.%(class)s_set+\",\n                to=\"contenttypes.contenttype\",\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that modifies the foreign key relationship between the `Project` model and `ContentType`.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that alters a field in the `Project` model by changing the foreign key relationship with `ContentType`."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_sequencelabelingproject_use_relation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0004_sequencelabelingproject_use_relation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"use_relation\",\n            field=models.BooleanField(default=False),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-23 22:59\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"use_relation\",\n            field=models.BooleanField(default=False),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that adds a boolean field \"use_relation\" to the model \"sequencelabelingproject\".",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that adds a boolean field \"use_relation\" to the model \"sequencelabelingproject\"."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_boundingboxproject_alter_project_project_type.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0005_boundingboxproject_alter_project_project_type.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0004_sequencelabelingproject_use_relation\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"BoundingBoxProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 00:20\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0004_sequencelabelingproject_use_relation\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"BoundingBoxProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a new model and alters a field in an existing model.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a BoundingBoxProject model and alters the project_type field in the Project model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0006_segmentationproject_alter_project_project_type.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0006_segmentationproject_alter_project_project_type.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0005_boundingboxproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"SegmentationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                    (\"Segmentation\", \"segmentation\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 04:43\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0005_boundingboxproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"SegmentationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                    (\"Segmentation\", \"segmentation\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that creates a SegmentationProject model and alters the project_type field in the Project model.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that creates a SegmentationProject model and alters the project_type field in the Project model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0007_imagecaptioningproject_alter_project_project_type.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0007_imagecaptioningproject_alter_project_project_type.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0006_segmentationproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ImageCaptioningProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                    (\"Segmentation\", \"segmentation\"),\n                    (\"ImageCaptioning\", \"image captioning\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 23:07\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0006_segmentationproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ImageCaptioningProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                    (\"Segmentation\", \"segmentation\"),\n                    (\"ImageCaptioning\", \"image captioning\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: Represents a migration operation for creating a new model ImageCaptioningProject and altering field choices in the Project model.",
                                    "code_element_summaries": [
                                        "Class `Migration`: Represents a migration operation for creating a new model `ImageCaptioningProject` and altering the field choices in the `Project` model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0008_project_allow_member_to_create_label_type_and_more.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0008_project_allow_member_to_create_label_type_and_more.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0007_imagecaptioningproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"allow_member_to_create_label_type\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"Document Classification\"),\n                    (\"SequenceLabeling\", \"Sequence Labeling\"),\n                    (\"Seq2seq\", \"Seq2Seq\"),\n                    (\"IntentDetectionAndSlotFilling\", \"Intent Detection And Slot Filling\"),\n                    (\"Speech2text\", \"Speech2Text\"),\n                    (\"ImageClassification\", \"Image Classification\"),\n                    (\"BoundingBox\", \"Bounding Box\"),\n                    (\"Segmentation\", \"Segmentation\"),\n                    (\"ImageCaptioning\", \"Image Captioning\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.1.7 on 2023-06-07 04:57\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0007_imagecaptioningproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"allow_member_to_create_label_type\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"Document Classification\"),\n                    (\"SequenceLabeling\", \"Sequence Labeling\"),\n                    (\"Seq2seq\", \"Seq2Seq\"),\n                    (\"IntentDetectionAndSlotFilling\", \"Intent Detection And Slot Filling\"),\n                    (\"Speech2text\", \"Speech2Text\"),\n                    (\"ImageClassification\", \"Image Classification\"),\n                    (\"BoundingBox\", \"Bounding Box\"),\n                    (\"Segmentation\", \"Segmentation\"),\n                    (\"ImageCaptioning\", \"Image Captioning\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration class that modifies fields in the Project model by adding a boolean field and altering a char field.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that adds a boolean field and alters a char field in the `Project` model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content defines a class ExportedBoundingBox that acts as a proxy model of BoundingBox, providing methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ProjectType`\nCode:\nclass ProjectType(models.TextChoices):\n    DOCUMENT_CLASSIFICATION = \"DocumentClassification\"\n    SEQUENCE_LABELING = \"SequenceLabeling\"\n    SEQ2SEQ = \"Seq2seq\"\n    INTENT_DETECTION_AND_SLOT_FILLING = \"IntentDetectionAndSlotFilling\"\n    SPEECH2TEXT = \"Speech2text\"\n    IMAGE_CLASSIFICATION = \"ImageClassification\"\n    BOUNDING_BOX = \"BoundingBox\"\n    SEGMENTATION = \"Segmentation\"\n    IMAGE_CAPTIONING = \"ImageCaptioning\"",
                                "Class `Project`\nCode:\nclass Project(PolymorphicModel):\n    name = models.CharField(max_length=100)\n    description = models.TextField(default=\"\")\n    guideline = models.TextField(default=\"\", blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    created_by = models.ForeignKey(\n        User,\n        on_delete=models.SET_NULL,\n        null=True,\n    )\n    project_type = models.CharField(max_length=30, choices=ProjectType.choices)\n    random_order = models.BooleanField(default=False)\n    collaborative_annotation = models.BooleanField(default=False)\n    single_class_classification = models.BooleanField(default=False)\n    allow_member_to_create_label_type = models.BooleanField(default=False)\n\n    def add_admin(self):\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        Member.objects.create(\n            project=self,\n            user=self.created_by,\n            role=admin_role,\n        )\n\n    @property\n    @abc.abstractmethod\n    def is_text_project(self) -> bool:\n        return False\n\n    def clone(self) -> \"Project\":\n        \"\"\"Clone the project.\n        See https://docs.djangoproject.com/en/4.2/topics/db/queries/#copying-model-instances\n\n        Returns:\n            The cloned project.\n        \"\"\"\n        project = Project.objects.get(pk=self.pk)\n        project.pk = None\n        project.id = None\n        project._state.adding = True\n        project.save()\n\n        def bulk_clone(queryset: models.QuerySet, field_initializers: Optional[Dict[Any, Any]] = None):\n            \"\"\"Clone the queryset.\n\n            Args:\n                queryset: The queryset to clone.\n                field_initializers: The field initializers.\n            \"\"\"\n            if field_initializers is None:\n                field_initializers = {}\n            items = []\n            for item in queryset:\n                item.id = None\n                item.pk = None\n                for field, value_or_callable in field_initializers.items():\n                    if callable(value_or_callable):\n                        value_or_callable = value_or_callable()\n                    setattr(item, field, value_or_callable)\n                item.project = project\n                item._state.adding = True\n                items.append(item)\n            queryset.model.objects.bulk_create(items)\n\n        bulk_clone(self.role_mappings.all())\n        bulk_clone(self.tags.all())\n\n        # clone examples\n        bulk_clone(self.examples.all(), field_initializers={\"uuid\": uuid.uuid4})\n\n        # clone label types\n        bulk_clone(self.categorytype_set.all())\n        bulk_clone(self.spantype_set.all())\n        bulk_clone(self.relationtype_set.all())\n\n        return project\n\n    def __str__(self):\n        return self.name",
                                "Function `add_admin`\nCode:\n    def add_admin(self):\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        Member.objects.create(\n            project=self,\n            user=self.created_by,\n            role=admin_role,\n        )",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `clone`: Clone the project.\nCode:\n    def clone(self) -> \"Project\":\n        \"\"\"Clone the project.\n        See https://docs.djangoproject.com/en/4.2/topics/db/queries/#copying-model-instances\n\n        Returns:\n            The cloned project.\n        \"\"\"\n        project = Project.objects.get(pk=self.pk)\n        project.pk = None\n        project.id = None\n        project._state.adding = True\n        project.save()\n\n        def bulk_clone(queryset: models.QuerySet, field_initializers: Optional[Dict[Any, Any]] = None):\n            \"\"\"Clone the queryset.\n\n            Args:\n                queryset: The queryset to clone.\n                field_initializers: The field initializers.\n            \"\"\"\n            if field_initializers is None:\n                field_initializers = {}\n            items = []\n            for item in queryset:\n                item.id = None\n                item.pk = None\n                for field, value_or_callable in field_initializers.items():\n                    if callable(value_or_callable):\n                        value_or_callable = value_or_callable()\n                    setattr(item, field, value_or_callable)\n                item.project = project\n                item._state.adding = True\n                items.append(item)\n            queryset.model.objects.bulk_create(items)\n\n        bulk_clone(self.role_mappings.all())\n        bulk_clone(self.tags.all())\n\n        # clone examples\n        bulk_clone(self.examples.all(), field_initializers={\"uuid\": uuid.uuid4})\n\n        # clone label types\n        bulk_clone(self.categorytype_set.all())\n        bulk_clone(self.spantype_set.all())\n        bulk_clone(self.relationtype_set.all())\n\n        return project",
                                "Function `bulk_clone`: Clone the queryset.\nCode:\n        def bulk_clone(queryset: models.QuerySet, field_initializers: Optional[Dict[Any, Any]] = None):\n            \"\"\"Clone the queryset.\n\n            Args:\n                queryset: The queryset to clone.\n                field_initializers: The field initializers.\n            \"\"\"\n            if field_initializers is None:\n                field_initializers = {}\n            items = []\n            for item in queryset:\n                item.id = None\n                item.pk = None\n                for field, value_or_callable in field_initializers.items():\n                    if callable(value_or_callable):\n                        value_or_callable = value_or_callable()\n                    setattr(item, field, value_or_callable)\n                item.project = project\n                item._state.adding = True\n                items.append(item)\n            queryset.model.objects.bulk_create(items)",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        return self.name",
                                "Class `TextClassificationProject`\nCode:\nclass TextClassificationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return True",
                                "Class `SequenceLabelingProject`\nCode:\nclass SequenceLabelingProject(Project):\n    allow_overlapping = models.BooleanField(default=False)\n    grapheme_mode = models.BooleanField(default=False)\n    use_relation = models.BooleanField(default=False)\n\n    @property\n    def is_text_project(self) -> bool:\n        return True",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return True",
                                "Class `Seq2seqProject`\nCode:\nclass Seq2seqProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return True",
                                "Class `IntentDetectionAndSlotFillingProject`\nCode:\nclass IntentDetectionAndSlotFillingProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return True",
                                "Class `Speech2textProject`\nCode:\nclass Speech2textProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Class `ImageClassificationProject`\nCode:\nclass ImageClassificationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Class `BoundingBoxProject`\nCode:\nclass BoundingBoxProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Class `SegmentationProject`\nCode:\nclass SegmentationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Class `ImageCaptioningProject`\nCode:\nclass ImageCaptioningProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Class `Tag`\nCode:\nclass Tag(models.Model):\n    text = models.TextField()\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"tags\")\n\n    def __str__(self):\n        return self.text",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        return self.text",
                                "Class `MemberManager`\nCode:\nclass MemberManager(Manager):\n    def can_update(self, project: int, member_id: int, new_role: str) -> bool:\n        \"\"\"The project needs at least 1 admin.\n\n        Args:\n            project: The project id.\n            member_id: The member id.\n            new_role: The new role name.\n\n        Returns:\n            Whether the mapping can be updated or not.\n        \"\"\"\n        queryset = self.filter(project=project, role__name=settings.ROLE_PROJECT_ADMIN)\n        if queryset.count() > 1:\n            return True\n        else:\n            admin = queryset.first()\n            # we can change the role except for the only admin.\n            return admin.id != member_id or new_role == settings.ROLE_PROJECT_ADMIN\n\n    def has_role(self, project_id: int, user: User, role_name: str):\n        return self.filter(project=project_id, user=user, role__name=role_name).exists()",
                                "Function `can_update`: The project needs at least 1 admin.\nCode:\n    def can_update(self, project: int, member_id: int, new_role: str) -> bool:\n        \"\"\"The project needs at least 1 admin.\n\n        Args:\n            project: The project id.\n            member_id: The member id.\n            new_role: The new role name.\n\n        Returns:\n            Whether the mapping can be updated or not.\n        \"\"\"\n        queryset = self.filter(project=project, role__name=settings.ROLE_PROJECT_ADMIN)\n        if queryset.count() > 1:\n            return True\n        else:\n            admin = queryset.first()\n            # we can change the role except for the only admin.\n            return admin.id != member_id or new_role == settings.ROLE_PROJECT_ADMIN",
                                "Function `has_role`\nCode:\n    def has_role(self, project_id: int, user: User, role_name: str):\n        return self.filter(project=project_id, user=user, role__name=role_name).exists()",
                                "Class `Member`\nCode:\nclass Member(models.Model):\n    user = models.ForeignKey(to=User, on_delete=models.CASCADE, related_name=\"role_mappings\")\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"role_mappings\")\n    role = models.ForeignKey(to=Role, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    objects = MemberManager()\n\n    def clean(self):\n        members = self.__class__.objects.exclude(id=self.id)\n        if members.filter(user=self.user, project=self.project).exists():\n            message = \"This user is already assigned to a role in this project.\"\n            raise ValidationError(message)\n\n    def is_admin(self):\n        return self.role.name == settings.ROLE_PROJECT_ADMIN\n\n    @property\n    def username(self):\n        return self.user.username\n\n    class Meta:\n        unique_together = (\"user\", \"project\")",
                                "Function `clean`\nCode:\n    def clean(self):\n        members = self.__class__.objects.exclude(id=self.id)\n        if members.filter(user=self.user, project=self.project).exists():\n            message = \"This user is already assigned to a role in this project.\"\n            raise ValidationError(message)",
                                "Function `is_admin`\nCode:\n    def is_admin(self):\n        return self.role.name == settings.ROLE_PROJECT_ADMIN",
                                "Function `username`\nCode:\n    def username(self):\n        return self.user.username",
                                "Class `Meta`\nCode:\n    class Meta:\n        unique_together = (\"user\", \"project\")"
                            ],
                            "code": "import abc\nimport uuid\nfrom typing import Any, Dict, Optional\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import User\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.db.models import Manager\nfrom polymorphic.models import PolymorphicModel\n\nfrom roles.models import Role\n\n\nclass ProjectType(models.TextChoices):\n    DOCUMENT_CLASSIFICATION = \"DocumentClassification\"\n    SEQUENCE_LABELING = \"SequenceLabeling\"\n    SEQ2SEQ = \"Seq2seq\"\n    INTENT_DETECTION_AND_SLOT_FILLING = \"IntentDetectionAndSlotFilling\"\n    SPEECH2TEXT = \"Speech2text\"\n    IMAGE_CLASSIFICATION = \"ImageClassification\"\n    BOUNDING_BOX = \"BoundingBox\"\n    SEGMENTATION = \"Segmentation\"\n    IMAGE_CAPTIONING = \"ImageCaptioning\"\n\n\nclass Project(PolymorphicModel):\n    name = models.CharField(max_length=100)\n    description = models.TextField(default=\"\")\n    guideline = models.TextField(default=\"\", blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    created_by = models.ForeignKey(\n        User,\n        on_delete=models.SET_NULL,\n        null=True,\n    )\n    project_type = models.CharField(max_length=30, choices=ProjectType.choices)\n    random_order = models.BooleanField(default=False)\n    collaborative_annotation = models.BooleanField(default=False)\n    single_class_classification = models.BooleanField(default=False)\n    allow_member_to_create_label_type = models.BooleanField(default=False)\n\n    def add_admin(self):\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        Member.objects.create(\n            project=self,\n            user=self.created_by,\n            role=admin_role,\n        )\n\n    @property\n    @abc.abstractmethod\n    def is_text_project(self) -> bool:\n        return False\n\n    def clone(self) -> \"Project\":\n        \"\"\"Clone the project.\n        See https://docs.djangoproject.com/en/4.2/topics/db/queries/#copying-model-instances\n\n        Returns:\n            The cloned project.\n        \"\"\"\n        project = Project.objects.get(pk=self.pk)\n        project.pk = None\n        project.id = None\n        project._state.adding = True\n        project.save()\n\n        def bulk_clone(queryset: models.QuerySet, field_initializers: Optional[Dict[Any, Any]] = None):\n            \"\"\"Clone the queryset.\n\n            Args:\n                queryset: The queryset to clone.\n                field_initializers: The field initializers.\n            \"\"\"\n            if field_initializers is None:\n                field_initializers = {}\n            items = []\n            for item in queryset:\n                item.id = None\n                item.pk = None\n                for field, value_or_callable in field_initializers.items():\n                    if callable(value_or_callable):\n                        value_or_callable = value_or_callable()\n                    setattr(item, field, value_or_callable)\n                item.project = project\n                item._state.adding = True\n                items.append(item)\n            queryset.model.objects.bulk_create(items)\n\n        bulk_clone(self.role_mappings.all())\n        bulk_clone(self.tags.all())\n\n        # clone examples\n        bulk_clone(self.examples.all(), field_initializers={\"uuid\": uuid.uuid4})\n\n        # clone label types\n        bulk_clone(self.categorytype_set.all())\n        bulk_clone(self.spantype_set.all())\n        bulk_clone(self.relationtype_set.all())\n\n        return project\n\n    def __str__(self):\n        return self.name\n\n\nclass TextClassificationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True\n\n\nclass SequenceLabelingProject(Project):\n    allow_overlapping = models.BooleanField(default=False)\n    grapheme_mode = models.BooleanField(default=False)\n    use_relation = models.BooleanField(default=False)\n\n    @property\n    def is_text_project(self) -> bool:\n        return True\n\n\nclass Seq2seqProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True\n\n\nclass IntentDetectionAndSlotFillingProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True\n\n\nclass Speech2textProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False\n\n\nclass ImageClassificationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False\n\n\nclass BoundingBoxProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False\n\n\nclass SegmentationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False\n\n\nclass ImageCaptioningProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False\n\n\nclass Tag(models.Model):\n    text = models.TextField()\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"tags\")\n\n    def __str__(self):\n        return self.text\n\n\nclass MemberManager(Manager):\n    def can_update(self, project: int, member_id: int, new_role: str) -> bool:\n        \"\"\"The project needs at least 1 admin.\n\n        Args:\n            project: The project id.\n            member_id: The member id.\n            new_role: The new role name.\n\n        Returns:\n            Whether the mapping can be updated or not.\n        \"\"\"\n        queryset = self.filter(project=project, role__name=settings.ROLE_PROJECT_ADMIN)\n        if queryset.count() > 1:\n            return True\n        else:\n            admin = queryset.first()\n            # we can change the role except for the only admin.\n            return admin.id != member_id or new_role == settings.ROLE_PROJECT_ADMIN\n\n    def has_role(self, project_id: int, user: User, role_name: str):\n        return self.filter(project=project_id, user=user, role__name=role_name).exists()\n\n\nclass Member(models.Model):\n    user = models.ForeignKey(to=User, on_delete=models.CASCADE, related_name=\"role_mappings\")\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"role_mappings\")\n    role = models.ForeignKey(to=Role, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    objects = MemberManager()\n\n    def clean(self):\n        members = self.__class__.objects.exclude(id=self.id)\n        if members.filter(user=self.user, project=self.project).exists():\n            message = \"This user is already assigned to a role in this project.\"\n            raise ValidationError(message)\n\n    def is_admin(self):\n        return self.role.name == settings.ROLE_PROJECT_ADMIN\n\n    @property\n    def username(self):\n        return self.user.username\n\n    class Meta:\n        unique_together = (\"user\", \"project\")\n",
                            "summary": "Classes and functions related to project management, including defining project types, cloning projects, handling project members and roles, and determining if a project involves text annotations.",
                            "code_element_summaries": [
                                "Class `ProjectType`: A model that defines choices for different types of projects, such as document classification, sequence labeling, image classification, etc.",
                                "Class `Project`: A model representing a project with various attributes and methods for cloning and adding administrators.",
                                "Function `add_admin`: Adds the project creator as an admin role member to the project.",
                                "Function `is_text_project`: Returns a boolean value indicating whether the project is a text project or not.",
                                "Function `clone`: Clones the project by creating a new instance with updated field values.",
                                "Function `bulk_clone`: A function that clones a given queryset with the option to initialize fields with specific values or callables.",
                                "Function `__str__`: Returns the name of the object when converted to a string.",
                                "Class TextClassificationProject: A subclass of Project with a property to determine if it is a text classification project.",
                                "Function `is_text_project`: Returns a boolean value indicating whether the project involves text annotations.",
                                "Class SequenceLabelingProject: A model that represents a project for sequence labeling with specific project settings.",
                                "Function `is_text_project`: Returns a boolean value indicating if the project involves text annotations.",
                                "Class Seq2seqProject: A subclass of Project that determines if the project involves text data.",
                                "Function is_text_project: Returns a boolean value indicating if the project involves text annotations.",
                                "Class IntentDetectionAndSlotFillingProject: A subclass of Project that indicates it is a text project.",
                                "Function is_text_project: Returns a boolean value True.",
                                "Class Speech2textProject: A subclass of Project that defines a property indicating if the project involves text.",
                                "Function `is_text_project`: Returns False indicating that the project is not a text project.",
                                "Class ImageClassificationProject: A subclass of Project that defines a property for determining if the project involves text annotations.",
                                "Function is_text_project: Returns False, indicating that the project does not involve text annotations.",
                                "Class BoundingBoxProject: A subclass of Project with a property indicating it is not a text project.",
                                "Function `is_text_project`: Returns False indicating that the project does not involve text annotations.",
                                "Class SegmentationProject: An extension of the Project class with a property that determines if it is a text project.",
                                "Function `is_text_project`: Returns False indicating that the project does not involve text annotations.",
                                "Class ImageCaptioningProject: A subclass of Project with a property that indicates whether it is a text project or not.",
                                "Function `is_text_project`: Returns False, indicating that the project is not a text project.",
                                "Class Tag: Represents a tag with text content associated with a project in a Django model.",
                                "Function `__str__`: Returns the text representation of an object.",
                                "Class `MemberManager`: Manages project members and their roles, providing methods to check if a project has at least one admin and if a user has a specific role within a project.",
                                "Function `can_update`: Checks if a project has at least one admin before allowing role updates.",
                                "Function `has_role`: Checks if a user has a specific role in a project.",
                                "Class Member: Represents the membership of a user in a project with a specific role, including methods to check if the user is an admin and retrieve the username.",
                                "Function `clean`: Validates that a user is not already assigned to a role in a project before saving the object.",
                                "Function `is_admin`: Checks if the user has the role of project administrator based on the role name stored in settings.",
                                "Function `username`: Returns the username of the user associated with the object.",
                                "Class Meta: Specifies that the combination of \"user\" and \"project\" fields should be unique in the model."
                            ],
                            "children": []
                        },
                        {
                            "name": "permissions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\permissions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RolePermission`\nCode:\nclass RolePermission(BasePermission):\n    UNSAFE_METHODS = (\"POST\", \"PATCH\", \"DELETE\")\n    unsafe_methods_check = True\n    role_name = \"\"\n\n    @classmethod\n    def get_project_id(cls, request, view):\n        return view.kwargs.get(\"project_id\") or request.query_params.get(\"project_id\")\n\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        if self.unsafe_methods_check and request.method in self.UNSAFE_METHODS:\n            return request.user.is_superuser\n\n        project_id = self.get_project_id(request, view)\n        if not project_id and request.method in SAFE_METHODS:\n            return True\n\n        return Member.objects.has_role(project_id, request.user, self.role_name)",
                                "Function `get_project_id`\nCode:\n    def get_project_id(cls, request, view):\n        return view.kwargs.get(\"project_id\") or request.query_params.get(\"project_id\")",
                                "Function `has_permission`\nCode:\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        if self.unsafe_methods_check and request.method in self.UNSAFE_METHODS:\n            return request.user.is_superuser\n\n        project_id = self.get_project_id(request, view)\n        if not project_id and request.method in SAFE_METHODS:\n            return True\n\n        return Member.objects.has_role(project_id, request.user, self.role_name)",
                                "Class `IsProjectAdmin`\nCode:\nclass IsProjectAdmin(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_PROJECT_ADMIN",
                                "Class `IsAnnotatorAndReadOnly`\nCode:\nclass IsAnnotatorAndReadOnly(RolePermission):\n    role_name = settings.ROLE_ANNOTATOR",
                                "Class `IsAnnotator`\nCode:\nclass IsAnnotator(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_ANNOTATOR",
                                "Class `IsAnnotationApproverAndReadOnly`\nCode:\nclass IsAnnotationApproverAndReadOnly(RolePermission):\n    role_name = settings.ROLE_ANNOTATION_APPROVER",
                                "Class `IsAnnotationApprover`\nCode:\nclass IsAnnotationApprover(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_ANNOTATION_APPROVER"
                            ],
                            "code": "from django.conf import settings\nfrom rest_framework.permissions import SAFE_METHODS, BasePermission\n\nfrom .models import Member\n\n\nclass RolePermission(BasePermission):\n    UNSAFE_METHODS = (\"POST\", \"PATCH\", \"DELETE\")\n    unsafe_methods_check = True\n    role_name = \"\"\n\n    @classmethod\n    def get_project_id(cls, request, view):\n        return view.kwargs.get(\"project_id\") or request.query_params.get(\"project_id\")\n\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        if self.unsafe_methods_check and request.method in self.UNSAFE_METHODS:\n            return request.user.is_superuser\n\n        project_id = self.get_project_id(request, view)\n        if not project_id and request.method in SAFE_METHODS:\n            return True\n\n        return Member.objects.has_role(project_id, request.user, self.role_name)\n\n\nclass IsProjectAdmin(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_PROJECT_ADMIN\n\n\nclass IsAnnotatorAndReadOnly(RolePermission):\n    role_name = settings.ROLE_ANNOTATOR\n\n\nclass IsAnnotator(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_ANNOTATOR\n\n\nclass IsAnnotationApproverAndReadOnly(RolePermission):\n    role_name = settings.ROLE_ANNOTATION_APPROVER\n\n\nclass IsAnnotationApprover(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_ANNOTATION_APPROVER\n\n\nIsProjectMember = IsAnnotator | IsAnnotationApprover | IsProjectAdmin  # type: ignore\nIsProjectStaffAndReadOnly = IsAnnotatorAndReadOnly | IsAnnotationApproverAndReadOnly  # type: ignore\n",
                            "summary": "Class `RolePermission`: Handles role-based permissions for different HTTP methods and project-specific actions, with subclasses defining specific roles and permissions.",
                            "code_element_summaries": [
                                "Class `RolePermission`: A model that handles role-based permissions for different HTTP methods and project-specific actions.",
                                "Function `get_project_id`: Returns the project ID from the view's kwargs or request query parameters.",
                                "Function `has_permission`: Determines if a user has the necessary permissions based on their role and the requested method.",
                                "Class IsProjectAdmin: A RolePermission class that checks if the user has project admin role permissions.",
                                "Class IsAnnotatorAndReadOnly: A RolePermission subclass representing annotators with read-only permissions.",
                                "Class IsAnnotator: A subclass of RolePermission that represents annotators with specific role settings.",
                                "Class IsAnnotationApproverAndReadOnly: A RolePermission class that represents users with the role of annotation approver and read-only access.",
                                "Class IsAnnotationApprover: A role permission class representing annotation approvers with specific settings."
                            ],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `MemberSerializer`\nCode:\nclass MemberSerializer(serializers.ModelSerializer):\n    username = serializers.SerializerMethodField()\n    rolename = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_username(cls, instance):\n        user = instance.user\n        return user.username if user else None\n\n    @classmethod\n    def get_rolename(cls, instance):\n        role = instance.role\n        return role.name if role else None\n\n    class Meta:\n        model = Member\n        fields = (\"id\", \"user\", \"role\", \"username\", \"rolename\")",
                                "Function `get_username`\nCode:\n    def get_username(cls, instance):\n        user = instance.user\n        return user.username if user else None",
                                "Function `get_rolename`\nCode:\n    def get_rolename(cls, instance):\n        role = instance.role\n        return role.name if role else None",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Member\n        fields = (\"id\", \"user\", \"role\", \"username\", \"rolename\")",
                                "Class `TagSerializer`\nCode:\nclass TagSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Tag\n        fields = (\n            \"id\",\n            \"project\",\n            \"text\",\n        )\n        read_only_fields = (\"id\", \"project\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Tag\n        fields = (\n            \"id\",\n            \"project\",\n            \"text\",\n        )\n        read_only_fields = (\"id\", \"project\")",
                                "Class `ProjectSerializer`\nCode:\nclass ProjectSerializer(serializers.ModelSerializer):\n    tags = TagSerializer(many=True, required=False)\n    author = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_author(cls, instance):\n        if instance.created_by:\n            return instance.created_by.username\n        return \"\"\n\n    class Meta:\n        model = Project\n        fields = [\n            \"id\",\n            \"name\",\n            \"description\",\n            \"guideline\",\n            \"project_type\",\n            \"created_at\",\n            \"updated_at\",\n            \"random_order\",\n            \"author\",\n            \"collaborative_annotation\",\n            \"single_class_classification\",\n            \"allow_member_to_create_label_type\",\n            \"is_text_project\",\n            \"tags\",\n        ]\n        read_only_fields = (\n            \"created_at\",\n            \"updated_at\",\n            \"author\",\n            \"is_text_project\",\n        )\n\n    def create(self, validated_data):\n        tags = TagSerializer(data=validated_data.pop(\"tags\", []), many=True)\n        project = self.Meta.model.objects.create(**validated_data)\n        tags.is_valid()\n        tags.save(project=project)\n        return project\n\n    def update(self, instance, validated_data):\n        # Don't update tags. Please use TagAPI.\n        validated_data.pop(\"tags\", None)\n        return super().update(instance, validated_data)",
                                "Function `get_author`\nCode:\n    def get_author(cls, instance):\n        if instance.created_by:\n            return instance.created_by.username\n        return \"\"",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Project\n        fields = [\n            \"id\",\n            \"name\",\n            \"description\",\n            \"guideline\",\n            \"project_type\",\n            \"created_at\",\n            \"updated_at\",\n            \"random_order\",\n            \"author\",\n            \"collaborative_annotation\",\n            \"single_class_classification\",\n            \"allow_member_to_create_label_type\",\n            \"is_text_project\",\n            \"tags\",\n        ]\n        read_only_fields = (\n            \"created_at\",\n            \"updated_at\",\n            \"author\",\n            \"is_text_project\",\n        )",
                                "Function `create`\nCode:\n    def create(self, validated_data):\n        tags = TagSerializer(data=validated_data.pop(\"tags\", []), many=True)\n        project = self.Meta.model.objects.create(**validated_data)\n        tags.is_valid()\n        tags.save(project=project)\n        return project",
                                "Function `update`\nCode:\n    def update(self, instance, validated_data):\n        # Don't update tags. Please use TagAPI.\n        validated_data.pop(\"tags\", None)\n        return super().update(instance, validated_data)",
                                "Class `TextClassificationProjectSerializer`\nCode:\nclass TextClassificationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = TextClassificationProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = TextClassificationProject",
                                "Class `SequenceLabelingProjectSerializer`\nCode:\nclass SequenceLabelingProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = SequenceLabelingProject\n        fields = ProjectSerializer.Meta.fields + [\"allow_overlapping\", \"grapheme_mode\", \"use_relation\"]",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = SequenceLabelingProject\n        fields = ProjectSerializer.Meta.fields + [\"allow_overlapping\", \"grapheme_mode\", \"use_relation\"]",
                                "Class `Seq2seqProjectSerializer`\nCode:\nclass Seq2seqProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = Seq2seqProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = Seq2seqProject",
                                "Class `IntentDetectionAndSlotFillingProjectSerializer`\nCode:\nclass IntentDetectionAndSlotFillingProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = IntentDetectionAndSlotFillingProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = IntentDetectionAndSlotFillingProject",
                                "Class `Speech2textProjectSerializer`\nCode:\nclass Speech2textProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = Speech2textProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = Speech2textProject",
                                "Class `ImageClassificationProjectSerializer`\nCode:\nclass ImageClassificationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = ImageClassificationProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = ImageClassificationProject",
                                "Class `BoundingBoxProjectSerializer`\nCode:\nclass BoundingBoxProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = BoundingBoxProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = BoundingBoxProject",
                                "Class `SegmentationProjectSerializer`\nCode:\nclass SegmentationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = SegmentationProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = SegmentationProject",
                                "Class `ImageCaptioningProjectSerializer`\nCode:\nclass ImageCaptioningProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = ImageCaptioningProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = ImageCaptioningProject",
                                "Class `ProjectPolymorphicSerializer`\nCode:\nclass ProjectPolymorphicSerializer(PolymorphicSerializer):\n    model_serializer_mapping = {\n        Project: ProjectSerializer,\n        **{cls.Meta.model: cls for cls in ProjectSerializer.__subclasses__()},\n    }"
                            ],
                            "code": "from rest_framework import serializers\nfrom rest_polymorphic.serializers import PolymorphicSerializer\n\nfrom .models import (\n    BoundingBoxProject,\n    ImageCaptioningProject,\n    ImageClassificationProject,\n    IntentDetectionAndSlotFillingProject,\n    Member,\n    Project,\n    SegmentationProject,\n    Seq2seqProject,\n    SequenceLabelingProject,\n    Speech2textProject,\n    Tag,\n    TextClassificationProject,\n)\n\n\nclass MemberSerializer(serializers.ModelSerializer):\n    username = serializers.SerializerMethodField()\n    rolename = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_username(cls, instance):\n        user = instance.user\n        return user.username if user else None\n\n    @classmethod\n    def get_rolename(cls, instance):\n        role = instance.role\n        return role.name if role else None\n\n    class Meta:\n        model = Member\n        fields = (\"id\", \"user\", \"role\", \"username\", \"rolename\")\n\n\nclass TagSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Tag\n        fields = (\n            \"id\",\n            \"project\",\n            \"text\",\n        )\n        read_only_fields = (\"id\", \"project\")\n\n\nclass ProjectSerializer(serializers.ModelSerializer):\n    tags = TagSerializer(many=True, required=False)\n    author = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_author(cls, instance):\n        if instance.created_by:\n            return instance.created_by.username\n        return \"\"\n\n    class Meta:\n        model = Project\n        fields = [\n            \"id\",\n            \"name\",\n            \"description\",\n            \"guideline\",\n            \"project_type\",\n            \"created_at\",\n            \"updated_at\",\n            \"random_order\",\n            \"author\",\n            \"collaborative_annotation\",\n            \"single_class_classification\",\n            \"allow_member_to_create_label_type\",\n            \"is_text_project\",\n            \"tags\",\n        ]\n        read_only_fields = (\n            \"created_at\",\n            \"updated_at\",\n            \"author\",\n            \"is_text_project\",\n        )\n\n    def create(self, validated_data):\n        tags = TagSerializer(data=validated_data.pop(\"tags\", []), many=True)\n        project = self.Meta.model.objects.create(**validated_data)\n        tags.is_valid()\n        tags.save(project=project)\n        return project\n\n    def update(self, instance, validated_data):\n        # Don't update tags. Please use TagAPI.\n        validated_data.pop(\"tags\", None)\n        return super().update(instance, validated_data)\n\n\nclass TextClassificationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = TextClassificationProject\n\n\nclass SequenceLabelingProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = SequenceLabelingProject\n        fields = ProjectSerializer.Meta.fields + [\"allow_overlapping\", \"grapheme_mode\", \"use_relation\"]\n\n\nclass Seq2seqProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = Seq2seqProject\n\n\nclass IntentDetectionAndSlotFillingProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = IntentDetectionAndSlotFillingProject\n\n\nclass Speech2textProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = Speech2textProject\n\n\nclass ImageClassificationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = ImageClassificationProject\n\n\nclass BoundingBoxProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = BoundingBoxProject\n\n\nclass SegmentationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = SegmentationProject\n\n\nclass ImageCaptioningProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = ImageCaptioningProject\n\n\nclass ProjectPolymorphicSerializer(PolymorphicSerializer):\n    model_serializer_mapping = {\n        Project: ProjectSerializer,\n        **{cls.Meta.model: cls for cls in ProjectSerializer.__subclasses__()},\n    }\n",
                            "summary": "Class MemberSerializer: A serializer for the Member model with functions to retrieve username and rolename, along with metadata specifying fields for serialization.",
                            "code_element_summaries": [
                                "Class MemberSerializer: A serializer class for the Member model that includes username and rolename fields derived from user and role instances.",
                                "Function `get_username`: Returns the username of a user associated with an instance, or None if no user is found.",
                                "Function `get_rolename`: A function that retrieves the name of a role associated with a given instance, or returns None if no role is found.",
                                "Class Meta: Defines metadata for the Member model specifying fields to include in serialization.",
                                "Class TagSerializer: A serializer class for the Tag model that specifies fields and read-only fields.",
                                "Class Meta: A configuration class for defining metadata related to the Tag model, specifying fields and read-only fields.",
                                "Class `ProjectSerializer`: A serializer class for the Project model that includes fields for tags, author, and various project details, with methods for creating and updating project instances.",
                                "Function `get_author`: Returns the username of the author of a given instance, or an empty string if no author is found.",
                                "Class Meta: Defines the model and fields for a Project along with read-only fields.",
                                "Function `create`: Creates a new project instance with associated tags based on validated data.",
                                "Function `update`: Updates an instance by removing the \"tags\" field from the validated data before calling the superclass update method.",
                                "Class TextClassificationProjectSerializer: A serializer for TextClassificationProject models that extends ProjectSerializer.",
                                "Class Meta: A subclass of ProjectSerializer.Meta that specifies the model as TextClassificationProject.",
                                "Class SequenceLabelingProjectSerializer: A serializer for SequenceLabelingProject models that includes additional fields for overlapping, grapheme mode, and relation usage.",
                                "Class Meta: Extends ProjectSerializer.Meta to include additional fields specific to SequenceLabelingProject.",
                                "Class Seq2seqProjectSerializer: A serializer class for Seq2seqProject models that extends ProjectSerializer.",
                                "Class Meta: Inherits Meta attributes from ProjectSerializer and specifies the model as Seq2seqProject.",
                                "Class IntentDetectionAndSlotFillingProjectSerializer: Serializer for Intent Detection and Slot Filling projects that extends ProjectSerializer.",
                                "Class `Meta`: Extends the Meta class from ProjectSerializer to specify the model as IntentDetectionAndSlotFillingProject.",
                                "Class Speech2textProjectSerializer: A serializer class for Speech2textProject models that extends ProjectSerializer.",
                                "Class Meta: Extends the Meta class of ProjectSerializer to specify the model as Speech2textProject.",
                                "Class ImageClassificationProjectSerializer: A serializer class for ImageClassificationProject models that inherits from ProjectSerializer.",
                                "Class Meta: Extends ProjectSerializer.Meta and specifies the model as ImageClassificationProject.",
                                "Class BoundingBoxProjectSerializer: A serializer for BoundingBoxProject models that inherits from ProjectSerializer.",
                                "Class Meta: Inherits Meta attributes from the ProjectSerializer class and specifies the model as BoundingBoxProject.",
                                "Class SegmentationProjectSerializer: A serializer class for SegmentationProject models that inherits from ProjectSerializer.",
                                "Class Meta: A subclass that specifies metadata for the SegmentationProject model in the ProjectSerializer.",
                                "Class ImageCaptioningProjectSerializer: A serializer class for ImageCaptioningProject models that extends ProjectSerializer.",
                                "Class Meta: Inherits the Meta attributes from ProjectSerializer.Meta and specifies the model as ImageCaptioningProject.",
                                "Class ProjectPolymorphicSerializer: A serializer that maps different models to their respective serializers using a polymorphic approach."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The TestMemberListAPI, TestProjectList, TestProjectCreate, TestSequenceLabelingProjectCreation, TestProjectDetailAPI, TestProjectModel, TestTagList, and ProjectData classes are designed for testing CRUD operations, project management, tag handling, and data representation in a project setting.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_member.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests\\test_member.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestMemberListAPI`\nCode:\nclass TestMemberListAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        self.data = {\"user\": self.non_member.id, \"role\": admin_role.id, \"project\": self.project.item.id}\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_know_members(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_know_members(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_know_members(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_known_members(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_add_member(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_add_member(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_add_member(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_add_member(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        ids = [item.id for item in self.project.item.role_mappings.all()]\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n\n    def test_allows_project_admin_to_remove_members(self):\n        self.assert_bulk_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        response = self.client.get(self.url)\n        self.assertEqual(len(response.data), 1)\n\n    def test_denies_project_staff_to_remove_members(self):\n        for member in self.project.staffs:\n            self.assert_bulk_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_remove_members(self):\n        self.assert_bulk_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_remove_members(self):\n        self.assert_bulk_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        self.data = {\"user\": self.non_member.id, \"role\": admin_role.id, \"project\": self.project.item.id}\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])",
                                        "Function `test_allows_project_admin_to_know_members`\nCode:\n    def test_allows_project_admin_to_know_members(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_project_staff_to_know_members`\nCode:\n    def test_denies_project_staff_to_know_members(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_know_members`\nCode:\n    def test_denies_non_project_member_to_know_members(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_known_members`\nCode:\n    def test_denies_unauthenticated_user_to_known_members(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_add_member`\nCode:\n    def test_allows_project_admin_to_add_member(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)",
                                        "Function `test_denies_project_staff_to_add_member`\nCode:\n    def test_denies_project_staff_to_add_member(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_add_member`\nCode:\n    def test_denies_non_project_member_to_add_member(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_add_member`\nCode:\n    def test_denies_unauthenticated_user_to_add_member(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `assert_bulk_delete`\nCode:\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        ids = [item.id for item in self.project.item.role_mappings.all()]\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)",
                                        "Function `test_allows_project_admin_to_remove_members`\nCode:\n    def test_allows_project_admin_to_remove_members(self):\n        self.assert_bulk_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        response = self.client.get(self.url)\n        self.assertEqual(len(response.data), 1)",
                                        "Function `test_denies_project_staff_to_remove_members`\nCode:\n    def test_denies_project_staff_to_remove_members(self):\n        for member in self.project.staffs:\n            self.assert_bulk_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_remove_members`\nCode:\n    def test_denies_non_project_member_to_remove_members(self):\n        self.assert_bulk_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_remove_members`\nCode:\n    def test_denies_unauthenticated_user_to_remove_members(self):\n        self.assert_bulk_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestMemberRoleDetailAPI`\nCode:\nclass TestMemberRoleDetailAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        member = Member.objects.get(user=self.project.approver)\n        self.url = reverse(viewname=\"member_detail\", args=[self.project.item.id, member.id])\n        self.data = {\"role\": admin_role.id}\n\n    def test_allows_project_admin_to_known_member(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_know_member(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_know_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_know_member(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_change_member_role(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_change_member_role(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_change_member_role(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_change_member_role(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        member = Member.objects.get(user=self.project.approver)\n        self.url = reverse(viewname=\"member_detail\", args=[self.project.item.id, member.id])\n        self.data = {\"role\": admin_role.id}",
                                        "Function `test_allows_project_admin_to_known_member`\nCode:\n    def test_allows_project_admin_to_known_member(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_project_staff_to_know_member`\nCode:\n    def test_denies_project_staff_to_know_member(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_know_member`\nCode:\n    def test_denies_non_project_member_to_know_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_know_member`\nCode:\n    def test_denies_unauthenticated_user_to_know_member(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_change_member_role`\nCode:\n    def test_allows_project_admin_to_change_member_role(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_project_staff_to_change_member_role`\nCode:\n    def test_denies_project_staff_to_change_member_role(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_change_member_role`\nCode:\n    def test_denies_non_project_member_to_change_member_role(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_change_member_role`\nCode:\n    def test_denies_unauthenticated_user_to_change_member_role(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestMemberFilter`\nCode:\nclass TestMemberFilter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])\n        self.url += f\"?user={self.project.admin.id}\"\n\n    def test_filter_role_by_user_id(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])\n        self.url += f\"?user={self.project.admin.id}\"",
                                        "Function `test_filter_role_by_user_id`\nCode:\n    def test_filter_role_by_user_id(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)",
                                        "Class `TestMyRole`\nCode:\nclass TestMyRole(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"my_role\", args=[self.project.item.id])\n\n    def test_admin(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_PROJECT_ADMIN)\n\n    def test_approver(self):\n        response = self.assert_fetch(self.project.approver, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATION_APPROVER)\n\n    def test_annotator(self):\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATOR)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"my_role\", args=[self.project.item.id])",
                                        "Function `test_admin`\nCode:\n    def test_admin(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_PROJECT_ADMIN)",
                                        "Function `test_approver`\nCode:\n    def test_approver(self):\n        response = self.assert_fetch(self.project.approver, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATION_APPROVER)",
                                        "Function `test_annotator`\nCode:\n    def test_annotator(self):\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATOR)",
                                        "Class `TestMemberManager`\nCode:\nclass TestMemberManager(CRUDMixin):\n    def test_has_role(self):\n        project = prepare_project()\n        admin = project.admin\n        expected = [\n            (settings.ROLE_PROJECT_ADMIN, True),\n            (settings.ROLE_ANNOTATION_APPROVER, False),\n            (settings.ROLE_ANNOTATOR, False),\n        ]\n        for role, expect in expected:\n            self.assertEqual(Member.objects.has_role(project.item, admin, role), expect)",
                                        "Function `test_has_role`\nCode:\n    def test_has_role(self):\n        project = prepare_project()\n        admin = project.admin\n        expected = [\n            (settings.ROLE_PROJECT_ADMIN, True),\n            (settings.ROLE_ANNOTATION_APPROVER, False),\n            (settings.ROLE_ANNOTATOR, False),\n        ]\n        for role, expect in expected:\n            self.assertEqual(Member.objects.has_role(project.item, admin, role), expect)",
                                        "Class `TestMember`\nCode:\nclass TestMember(TestCase):\n    def test_clean(self):\n        member = mommy.make(\"Member\")\n        same_user = Member(project=member.project, user=member.user, role=member.role)\n        with self.assertRaises(ValidationError):\n            same_user.clean()",
                                        "Function `test_clean`\nCode:\n    def test_clean(self):\n        member = mommy.make(\"Member\")\n        same_user = Member(project=member.project, user=member.user, role=member.role)\n        with self.assertRaises(ValidationError):\n            same_user.clean()"
                                    ],
                                    "code": "from django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.test import TestCase\nfrom model_mommy import mommy\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom projects.models import Member\nfrom projects.tests.utils import prepare_project\nfrom roles.models import Role\nfrom users.tests.utils import make_user\n\n\nclass TestMemberListAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        self.data = {\"user\": self.non_member.id, \"role\": admin_role.id, \"project\": self.project.item.id}\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_know_members(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_know_members(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_know_members(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_known_members(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_add_member(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_add_member(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_add_member(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_add_member(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        ids = [item.id for item in self.project.item.role_mappings.all()]\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n\n    def test_allows_project_admin_to_remove_members(self):\n        self.assert_bulk_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        response = self.client.get(self.url)\n        self.assertEqual(len(response.data), 1)\n\n    def test_denies_project_staff_to_remove_members(self):\n        for member in self.project.staffs:\n            self.assert_bulk_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_remove_members(self):\n        self.assert_bulk_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_remove_members(self):\n        self.assert_bulk_delete(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestMemberRoleDetailAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        member = Member.objects.get(user=self.project.approver)\n        self.url = reverse(viewname=\"member_detail\", args=[self.project.item.id, member.id])\n        self.data = {\"role\": admin_role.id}\n\n    def test_allows_project_admin_to_known_member(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_know_member(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_know_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_know_member(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_change_member_role(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_change_member_role(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_change_member_role(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_change_member_role(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestMemberFilter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])\n        self.url += f\"?user={self.project.admin.id}\"\n\n    def test_filter_role_by_user_id(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n\n\nclass TestMyRole(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"my_role\", args=[self.project.item.id])\n\n    def test_admin(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_PROJECT_ADMIN)\n\n    def test_approver(self):\n        response = self.assert_fetch(self.project.approver, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATION_APPROVER)\n\n    def test_annotator(self):\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATOR)\n\n\nclass TestMemberManager(CRUDMixin):\n    def test_has_role(self):\n        project = prepare_project()\n        admin = project.admin\n        expected = [\n            (settings.ROLE_PROJECT_ADMIN, True),\n            (settings.ROLE_ANNOTATION_APPROVER, False),\n            (settings.ROLE_ANNOTATOR, False),\n        ]\n        for role, expect in expected:\n            self.assertEqual(Member.objects.has_role(project.item, admin, role), expect)\n\n\nclass TestMember(TestCase):\n    def test_clean(self):\n        member = mommy.make(\"Member\")\n        same_user = Member(project=member.project, user=member.user, role=member.role)\n        with self.assertRaises(ValidationError):\n            same_user.clean()\n",
                                    "summary": "Class `TestMemberListAPI`: A test class for CRUD operations related to project members, including fetching, adding, and removing members with different user roles, along with permission checks.",
                                    "code_element_summaries": [
                                        "Class `TestMemberListAPI`: A test class for CRUD operations related to project members, including fetching, adding, and removing members with different user roles.",
                                        "Function `setUp`: Prepares the necessary data and environment for testing membership-related functionalities in a project.",
                                        "Function `test_allows_project_admin_to_know_members`: Tests whether a project admin can retrieve information about project members successfully.",
                                        "Function `test_denies_project_staff_to_know_members`: Tests that project staff are denied access to view members with a status code of 403 Forbidden.",
                                        "Function `test_denies_non_project_member_to_know_members`: Tests that non-project members are denied access to view project members.",
                                        "Function `test_denies_unauthenticated_user_to_known_members`: Tests that unauthenticated users are denied access to known members with an expected HTTP 403 Forbidden status.",
                                        "Function `test_allows_project_admin_to_add_member`: Verifies that project admins can successfully add a member to the project.",
                                        "Function `test_denies_project_staff_to_add_member`: Tests that project staff are denied permission to add members to the project.",
                                        "Function `test_denies_non_project_member_to_add_member`: Tests that a non-project member is denied permission to add a member to the project.",
                                        "Function `test_denies_unauthenticated_user_to_add_member`: Tests whether an unauthenticated user is denied access to add a member.",
                                        "Function `assert_bulk_delete`: A method to assert bulk deletion of items in a project with the specified user and expected status code.",
                                        "Function `test_allows_project_admin_to_remove_members`: Tests if a project admin can successfully remove members and verifies the response data length.",
                                        "Function `test_denies_project_staff_to_remove_members`: Tests that project staff are denied permission to remove members with a 403 Forbidden status.",
                                        "Function `test_denies_non_project_member_to_remove_members`: A test function that checks if a non-project member is denied permission to remove members from a project.",
                                        "Function `test_denies_unauthenticated_user_to_remove_members`: Tests that unauthenticated users are denied access to remove members with an expected status code of 403 Forbidden.",
                                        "Class `TestMemberRoleDetailAPI`: Tests for API endpoints that allow project admins to view and change member roles, with permission checks for staff, non-project members, and unauthenticated users.",
                                        "Function `setUp`: Sets up the necessary data and objects for testing member details in a project.",
                                        "Function `test_allows_project_admin_to_known_member`: Asserts that a project admin can fetch a known member with a status code of 200 OK.",
                                        "Function `test_denies_project_staff_to_know_member`: Tests that project staff members are denied access to view other project staff members' information.",
                                        "Function `test_denies_non_project_member_to_know_member`: A test function that checks if a non-project member is denied access to view project members.",
                                        "Function `test_denies_unauthenticated_user_to_know_member`: Tests that unauthenticated users are denied access to view member information with an expected status code of 403 Forbidden.",
                                        "Function `test_allows_project_admin_to_change_member_role`: Checks if a project admin can successfully change a member's role with a status code of 200 OK.",
                                        "Function `test_denies_project_staff_to_change_member_role`: Tests that project staff members are denied permission to change member roles.",
                                        "Function `test_denies_non_project_member_to_change_member_role`: Tests that non-project members are denied permission to change a member's role.",
                                        "Function `test_denies_unauthenticated_user_to_change_member_role`: Tests that unauthenticated users are denied permission to change a member's role.",
                                        "Class `TestMemberFilter`: A test class for filtering members by user ID in a project.",
                                        "Function `setUp`: Sets up necessary data and URLs for testing member list view with specific project and user.",
                                        "Function `test_filter_role_by_user_id`: Tests the filtering of roles by user ID and asserts that only one role is returned in the response data.",
                                        "Class TestMyRole: Contains test methods to verify roles (admin, approver, annotator) in a project.",
                                        "Function `setUp`: Sets up the test environment by preparing a project and generating a URL for a specific role.",
                                        "Function `test_admin`: Tests the fetching of project admin role name with expected data.",
                                        "Function `test_approver`: Tests if the project's approver role is set correctly to ROLE_ANNOTATION_APPROVER.",
                                        "Function `test_annotator`: Tests the annotator role by fetching the annotator and checking if it matches the specified role in the settings.",
                                        "Class TestMemberManager: Contains a method to test if a member has a specific role within a project.",
                                        "Function `test_has_role`: Tests whether a project admin has the specified roles in the project.",
                                        "Class TestMember: A test case for the clean method of the Member model that checks for validation errors when creating a new member with the same project, user, and role.",
                                        "Function `test_clean`: Tests the clean method of the Member model by creating a duplicate Member instance and expecting a ValidationError."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_project.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests\\test_project.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestProjectList`\nCode:\nclass TestProjectList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n\n    def test_return_projects_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            project = response.data[\"results\"][0]\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertEqual(project[\"id\"], self.project.item.id)\n\n    def test_does_not_return_project_to_non_member(self):\n        response = self.assert_fetch(self.non_member, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], 0)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_list\")",
                                        "Function `test_return_projects_to_member`\nCode:\n    def test_return_projects_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            project = response.data[\"results\"][0]\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertEqual(project[\"id\"], self.project.item.id)",
                                        "Function `test_does_not_return_project_to_non_member`\nCode:\n    def test_does_not_return_project_to_non_member(self):\n        response = self.assert_fetch(self.non_member, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], 0)",
                                        "Class `TestProjectCreate`\nCode:\nclass TestProjectCreate(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"DocumentClassification\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"resourcetype\": \"TextClassificationProject\",\n        }\n\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"name\"], self.data[\"name\"])\n\n    def test_exists_project_administrator(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        members = Member.objects.filter(project=response.data[\"id\"])\n        self.assertEqual(members.count(), 1)\n        member = members.first()\n        self.assertEqual(member.role.name, settings.ROLE_PROJECT_ADMIN)\n\n    def test_denies_non_staff_user_to_create_project(self):\n        self.assert_create(self.user, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_project(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"DocumentClassification\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"resourcetype\": \"TextClassificationProject\",\n        }",
                                        "Function `test_allows_staff_user_to_create_project`\nCode:\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"name\"], self.data[\"name\"])",
                                        "Function `test_exists_project_administrator`\nCode:\n    def test_exists_project_administrator(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        members = Member.objects.filter(project=response.data[\"id\"])\n        self.assertEqual(members.count(), 1)\n        member = members.first()\n        self.assertEqual(member.role.name, settings.ROLE_PROJECT_ADMIN)",
                                        "Function `test_denies_non_staff_user_to_create_project`\nCode:\n    def test_denies_non_staff_user_to_create_project(self):\n        self.assert_create(self.user, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_create_project`\nCode:\n    def test_denies_unauthenticated_user_to_create_project(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestSequenceLabelingProjectCreation`\nCode:\nclass TestSequenceLabelingProjectCreation(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"SequenceLabeling\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"allow_overlapping\": True,\n            \"grapheme_mode\": True,\n            \"resourcetype\": \"SequenceLabelingProject\",\n        }\n\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"allow_overlapping\"], self.data[\"allow_overlapping\"])\n        self.assertEqual(response.data[\"grapheme_mode\"], self.data[\"grapheme_mode\"])",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"SequenceLabeling\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"allow_overlapping\": True,\n            \"grapheme_mode\": True,\n            \"resourcetype\": \"SequenceLabelingProject\",\n        }",
                                        "Function `test_allows_staff_user_to_create_project`\nCode:\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"allow_overlapping\"], self.data[\"allow_overlapping\"])\n        self.assertEqual(response.data[\"grapheme_mode\"], self.data[\"grapheme_mode\"])",
                                        "Class `TestProjectDetailAPI`\nCode:\nclass TestProjectDetailAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\"SequenceLabeling\")\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_detail\", args=[cls.project.item.id])\n        cls.data = {\"description\": \"lorem\", \"resourcetype\": \"SequenceLabelingProject\"}\n\n    def test_return_project_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.project.item.id)\n\n    def test_does_not_return_project_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_update_project(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"description\"], self.data[\"description\"])\n\n    def test_denies_project_staff_to_update_project(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_member_to_update_project(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_delete_project(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_project(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_member_to_delete_project(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(\"SequenceLabeling\")\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_detail\", args=[cls.project.item.id])\n        cls.data = {\"description\": \"lorem\", \"resourcetype\": \"SequenceLabelingProject\"}",
                                        "Function `test_return_project_to_member`\nCode:\n    def test_return_project_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.project.item.id)",
                                        "Function `test_does_not_return_project_to_non_member`\nCode:\n    def test_does_not_return_project_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_update_project`\nCode:\n    def test_allows_admin_to_update_project(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"description\"], self.data[\"description\"])",
                                        "Function `test_denies_project_staff_to_update_project`\nCode:\n    def test_denies_project_staff_to_update_project(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_member_to_update_project`\nCode:\n    def test_denies_non_member_to_update_project(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_delete_project`\nCode:\n    def test_allows_admin_to_delete_project(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_project_staff_to_delete_project`\nCode:\n    def test_denies_project_staff_to_delete_project(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_member_to_delete_project`\nCode:\n    def test_denies_non_member_to_delete_project(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Class `TestProjectModel`\nCode:\nclass TestProjectModel(TestCase):\n    def setUp(self):\n        self.project = prepare_project().item\n\n    def test_clone_project(self):\n        project = self.project.clone()\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n        self.assertEqual(project.role_mappings.count(), self.project.role_mappings.count())",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project().item",
                                        "Function `test_clone_project`\nCode:\n    def test_clone_project(self):\n        project = self.project.clone()\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n        self.assertEqual(project.role_mappings.count(), self.project.role_mappings.count())",
                                        "Class `TestCloneProject`\nCode:\nclass TestCloneProject(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.project = project.item\n        cls.user = project.admin\n        make_doc(cls.project)\n        cls.category_type = make_label(cls.project)\n        cls.url = reverse(viewname=\"clone_project\", args=[cls.project.id])\n\n    def test_clone_project(self):\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n\n        project = Project.objects.get(id=response.data[\"id\"])\n\n        # assert project\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n\n        # assert category type\n        category_type = project.categorytype_set.first()\n        self.assertEqual(category_type.text, self.category_type.text)\n\n        # assert example\n        example = self.project.examples.first()\n        cloned_example = project.examples.first()\n        self.assertEqual(example.text, cloned_example.text)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.project = project.item\n        cls.user = project.admin\n        make_doc(cls.project)\n        cls.category_type = make_label(cls.project)\n        cls.url = reverse(viewname=\"clone_project\", args=[cls.project.id])",
                                        "Function `test_clone_project`\nCode:\n    def test_clone_project(self):\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n\n        project = Project.objects.get(id=response.data[\"id\"])\n\n        # assert project\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n\n        # assert category type\n        category_type = project.categorytype_set.first()\n        self.assertEqual(category_type.text, self.category_type.text)\n\n        # assert example\n        example = self.project.examples.first()\n        cloned_example = project.examples.first()\n        self.assertEqual(example.text, cloned_example.text)"
                                    ],
                                    "code": "from django.conf import settings\nfrom django.test import TestCase\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom examples.tests.utils import make_doc\nfrom label_types.tests.utils import make_label\nfrom projects.models import Member, Project, ProjectType\nfrom projects.tests.utils import prepare_project\nfrom roles.tests.utils import create_default_roles\nfrom users.tests.utils import make_user\n\n\nclass TestProjectList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n\n    def test_return_projects_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            project = response.data[\"results\"][0]\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertEqual(project[\"id\"], self.project.item.id)\n\n    def test_does_not_return_project_to_non_member(self):\n        response = self.assert_fetch(self.non_member, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], 0)\n\n\nclass TestProjectCreate(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"DocumentClassification\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"resourcetype\": \"TextClassificationProject\",\n        }\n\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"name\"], self.data[\"name\"])\n\n    def test_exists_project_administrator(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        members = Member.objects.filter(project=response.data[\"id\"])\n        self.assertEqual(members.count(), 1)\n        member = members.first()\n        self.assertEqual(member.role.name, settings.ROLE_PROJECT_ADMIN)\n\n    def test_denies_non_staff_user_to_create_project(self):\n        self.assert_create(self.user, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_project(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestSequenceLabelingProjectCreation(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"SequenceLabeling\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"allow_overlapping\": True,\n            \"grapheme_mode\": True,\n            \"resourcetype\": \"SequenceLabelingProject\",\n        }\n\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"allow_overlapping\"], self.data[\"allow_overlapping\"])\n        self.assertEqual(response.data[\"grapheme_mode\"], self.data[\"grapheme_mode\"])\n\n\nclass TestProjectDetailAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\"SequenceLabeling\")\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_detail\", args=[cls.project.item.id])\n        cls.data = {\"description\": \"lorem\", \"resourcetype\": \"SequenceLabelingProject\"}\n\n    def test_return_project_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.project.item.id)\n\n    def test_does_not_return_project_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_update_project(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"description\"], self.data[\"description\"])\n\n    def test_denies_project_staff_to_update_project(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_member_to_update_project(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_delete_project(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_project(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_member_to_delete_project(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n\nclass TestProjectModel(TestCase):\n    def setUp(self):\n        self.project = prepare_project().item\n\n    def test_clone_project(self):\n        project = self.project.clone()\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n        self.assertEqual(project.role_mappings.count(), self.project.role_mappings.count())\n\n\nclass TestCloneProject(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.project = project.item\n        cls.user = project.admin\n        make_doc(cls.project)\n        cls.category_type = make_label(cls.project)\n        cls.url = reverse(viewname=\"clone_project\", args=[cls.project.id])\n\n    def test_clone_project(self):\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n\n        project = Project.objects.get(id=response.data[\"id\"])\n\n        # assert project\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n\n        # assert category type\n        category_type = project.categorytype_set.first()\n        self.assertEqual(category_type.text, self.category_type.text)\n\n        # assert example\n        example = self.project.examples.first()\n        cloned_example = project.examples.first()\n        self.assertEqual(example.text, cloned_example.text)\n",
                                    "summary": "Class TestProjectList: Methods for testing project retrieval for members and non-members, including setup of test data and test functions.\nClass TestProjectCreate: Test cases for project creation by staff users, assignment of project administrators, and denial of creation for non-staff or unauthenticated users.\nClass TestSequenceLabelingProjectCreation: Tests if staff users can create Sequence Labeling projects with specific attributes.\nClass TestProjectDetailAPI: Test cases for accessing, updating, and deleting projects based on user roles, including setup of test data and assertion of responses.\nClass TestProjectModel: Test methods for cloning projects and verifying the equality of project attributes.",
                                    "code_element_summaries": [
                                        "Class TestProjectList: Contains methods to test the retrieval of projects for members and non-members.",
                                        "Function setUpTestData: Sets up test data including a project, a non-member user, and a URL for project listing.",
                                        "Function `test_return_projects_to_member`: A test function to verify that projects are correctly returned to a member in a project.",
                                        "Function `test_does_not_return_project_to_non_member`: A test function that checks if a non-member user cannot access a project.",
                                        "Class `TestProjectCreate`: Contains test cases to ensure that staff users can create projects, project administrators are correctly assigned, and non-staff or unauthenticated users are denied project creation.",
                                        "Function `setUpTestData`: Sets up test data including default roles, a user, URL, and data for a project creation test.",
                                        "Function `test_allows_staff_user_to_create_project`: A test function that checks if a staff user can successfully create a project.",
                                        "Function `test_exists_project_administrator`: A test function to check if a project administrator exists in the system.",
                                        "Function test_denies_non_staff_user_to_create_project: Tests that a non-staff user is denied permission to create a project.",
                                        "Function `test_denies_unauthenticated_user_to_create_project`: Tests that an unauthenticated user is denied permission to create a project.",
                                        "Class `TestSequenceLabelingProjectCreation`: A test class that checks if a staff user can create a Sequence Labeling project with specific attributes.",
                                        "Function `setUpTestData`: A method to set up test data including creating default roles, making a user, defining a URL, and initializing project data.",
                                        "Function `test_allows_staff_user_to_create_project`: Verifies that a staff user can create a project with specific attributes successfully.",
                                        "Class `TestProjectDetailAPI`: Contains test cases for accessing, updating, and deleting projects based on user roles.",
                                        "Function `setUpTestData`: Sets up test data for a SequenceLabeling project, including project details, user, URL, and project data.",
                                        "Function `test_return_project_to_member`: Tests the functionality of returning a project to a member by asserting the response data.",
                                        "Function test_does_not_return_project_to_non_member: Asserts that a non-member user cannot fetch a project, returning a 403 Forbidden status.",
                                        "Function `test_allows_admin_to_update_project`: Tests if an admin user is allowed to update a project and checks if the description is updated correctly.",
                                        "Function `test_denies_project_staff_to_update_project`: Tests that project staff members are denied permission to update the project.",
                                        "Function `test_denies_non_member_to_update_project`: Tests that non-members are denied access to update a project with a 403 Forbidden status.",
                                        "Function `test_allows_admin_to_delete_project`: Tests whether an admin user can successfully delete a project with a status code of 204.",
                                        "Function `test_denies_project_staff_to_delete_project`: Tests that project staff members are denied permission to delete the project.",
                                        "Function `test_denies_non_member_to_delete_project`: Tests that a non-member is denied permission to delete a project.",
                                        "Class TestProjectModel: Contains test methods for cloning projects and asserting the equality of project attributes.",
                                        "Function setUp: Sets up the project item for testing purposes.",
                                        "Function `test_clone_project`: Tests the cloning functionality of a project by ensuring that the cloned project has a different ID but the same name and role mappings as the original project.",
                                        "Class `TestCloneProject`: A test class for cloning projects that sets up test data and asserts the successful cloning of projects, category types, and examples.",
                                        "Function `setUpTestData`: Sets up test data for a document classification project, including project, user, document, category type, and URL for cloning the project.",
                                        "Function `test_clone_project`: Tests the cloning of a project by asserting the creation of a new project with the same name and category type, as well as the cloning of examples."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_tag.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests\\test_tag.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestTagList`\nCode:\nclass TestTagList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        make_tag(project=cls.project.item)\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])\n\n    def test_return_tags_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)\n\n    def test_does_not_return_tags_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_tags_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        make_tag(project=cls.project.item)\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])",
                                        "Function `test_return_tags_to_member`\nCode:\n    def test_return_tags_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)",
                                        "Function `test_does_not_return_tags_to_non_member`\nCode:\n    def test_does_not_return_tags_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_does_not_return_tags_to_unauthenticated_user`\nCode:\n    def test_does_not_return_tags_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestTagCreate`\nCode:\nclass TestTagCreate(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_allows_admin_to_create_tag(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_project_staff_to_create_tag(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_tag(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}",
                                        "Function `test_allows_admin_to_create_tag`\nCode:\n    def test_allows_admin_to_create_tag(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])",
                                        "Function `test_denies_project_staff_to_create_tag`\nCode:\n    def test_denies_project_staff_to_create_tag(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_create_tag`\nCode:\n    def test_denies_unauthenticated_user_to_create_tag(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestTagDelete`\nCode:\nclass TestTagDelete(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n\n    def setUp(self):\n        tag = make_tag(project=self.project.item)\n        self.url = reverse(viewname=\"tag_detail\", args=[self.project.item.id, tag.id])\n\n    def test_allows_admin_to_delete_tag(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_tag(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_tag(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        tag = make_tag(project=self.project.item)\n        self.url = reverse(viewname=\"tag_detail\", args=[self.project.item.id, tag.id])",
                                        "Function `test_allows_admin_to_delete_tag`\nCode:\n    def test_allows_admin_to_delete_tag(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_project_staff_to_delete_tag`\nCode:\n    def test_denies_project_staff_to_delete_tag(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_delete_tag`\nCode:\n    def test_denies_unauthenticated_user_to_delete_tag(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom projects.tests.utils import make_tag, prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestTagList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        make_tag(project=cls.project.item)\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])\n\n    def test_return_tags_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)\n\n    def test_does_not_return_tags_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_tags_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestTagCreate(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_allows_admin_to_create_tag(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_project_staff_to_create_tag(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_tag(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestTagDelete(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n\n    def setUp(self):\n        tag = make_tag(project=self.project.item)\n        self.url = reverse(viewname=\"tag_detail\", args=[self.project.item.id, tag.id])\n\n    def test_allows_admin_to_delete_tag(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_tag(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_tag(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Class `TestTagList`: A test class for CRUD operations on tag lists, including tests for returning tags to members, non-members, and unauthenticated users, with additional test classes for tag creation and deletion by different user roles.",
                                    "code_element_summaries": [
                                        "Class `TestTagList`: A test class for CRUD operations on tag lists, including tests for returning tags to members, non-members, and unauthenticated users.",
                                        "Function `setUpTestData`: A method that sets up test data including a project, a non-member user, and a tag list URL for testing purposes.",
                                        "Function `test_return_tags_to_member`: Tests that each member in the project has only one tag associated with them.",
                                        "Function test_does_not_return_tags_to_non_member: Asserts that non-members are forbidden from fetching tags.",
                                        "Function `test_does_not_return_tags_to_unauthenticated_user`: A test function that checks if tags are not returned to unauthenticated users.",
                                        "Class `TestTagCreate`: Contains test cases to verify the creation of tags by different user roles in a project.",
                                        "Function `setUpTestData`: Sets up test data including a project, user, URL, and data for testing tag list functionality.",
                                        "Function `test_allows_admin_to_create_tag`: Tests if the admin user is able to create a tag successfully.",
                                        "Function `test_denies_project_staff_to_create_tag`: Tests that project staff members are denied permission to create tags.",
                                        "Function `test_denies_unauthenticated_user_to_create_tag`: Tests that an unauthenticated user is denied access to create a tag with an expected HTTP 403 Forbidden status.",
                                        "Class `TestTagDelete`: Contains test cases to verify the deletion of tags by different user roles in a project.",
                                        "Function `setUpTestData`: A method for setting up test data including a project and a non-member user.",
                                        "Function `setUp`: Initializes test data and sets up the URL for tag detail view.",
                                        "Function test_allows_admin_to_delete_tag: Tests if the admin user is able to delete a tag and expects a HTTP 204 No Content response.",
                                        "Function `test_denies_project_staff_to_delete_tag`: Tests that project staff members are denied permission to delete a tag.",
                                        "Function test_denies_unauthenticated_user_to_delete_tag: Tests that an unauthenticated user is denied access to delete a tag with an expected HTTP 403 Forbidden response."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ProjectData`\nCode:\nclass ProjectData:\n    def __init__(self, item, members):\n        self.item = item\n        self.members = members\n\n    @property\n    def id(self):\n        return self.item.id\n\n    @property\n    def admin(self):\n        return self.members[0]\n\n    @property\n    def approver(self):\n        return self.members[1]\n\n    @property\n    def annotator(self):\n        return self.members[2]\n\n    @property\n    def staffs(self):\n        return [self.approver, self.annotator]",
                                        "Function `__init__`\nCode:\n    def __init__(self, item, members):\n        self.item = item\n        self.members = members",
                                        "Function `id`\nCode:\n    def id(self):\n        return self.item.id",
                                        "Function `admin`\nCode:\n    def admin(self):\n        return self.members[0]",
                                        "Function `approver`\nCode:\n    def approver(self):\n        return self.members[1]",
                                        "Function `annotator`\nCode:\n    def annotator(self):\n        return self.members[2]",
                                        "Function `staffs`\nCode:\n    def staffs(self):\n        return [self.approver, self.annotator]",
                                        "Function `assign_user_to_role`\nCode:\ndef assign_user_to_role(project_member, project, role_name):\n    role, _ = Role.objects.get_or_create(name=role_name)\n    if Member.objects.filter(user=project_member, project=project).exists():\n        mapping = Member.objects.get(user=project_member, project=project)\n        mapping.role = role\n        mapping.save()\n    else:\n        mapping = Member.objects.get_or_create(role_id=role.id, user_id=project_member.id, project_id=project.id)\n    return mapping",
                                        "Function `make_project`\nCode:\ndef make_project(task: str, users: List[str], roles: List[str], collaborative_annotation=False, **kwargs):\n    create_default_roles()\n\n    # create users.\n    users = [make_user(name) for name in users]\n\n    # create a project.\n    project_model = {\n        ProjectType.DOCUMENT_CLASSIFICATION: \"TextClassificationProject\",\n        ProjectType.SEQUENCE_LABELING: \"SequenceLabelingProject\",\n        ProjectType.SEQ2SEQ: \"Seq2seqProject\",\n        ProjectType.SPEECH2TEXT: \"Speech2TextProject\",\n        ProjectType.IMAGE_CLASSIFICATION: \"ImageClassificationProject\",\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: \"IntentDetectionAndSlotFillingProject\",\n        ProjectType.BOUNDING_BOX: \"BoundingBoxProject\",\n        ProjectType.SEGMENTATION: \"SegmentationProject\",\n        ProjectType.IMAGE_CAPTIONING: \"ImageCaptioningProject\",\n    }.get(task, \"Project\")\n    project = mommy.make(\n        _model=project_model,\n        project_type=task,\n        collaborative_annotation=collaborative_annotation,\n        created_by=users[0],\n        **kwargs,\n    )\n\n    # assign roles to the users.\n    for user, role in zip(users, roles):\n        assign_user_to_role(user, project, role)\n\n    return ProjectData(item=project, members=users)",
                                        "Function `make_tag`\nCode:\ndef make_tag(project):\n    return mommy.make(\"Tag\", project=project)",
                                        "Function `prepare_project`\nCode:\ndef prepare_project(task: str = \"Any\", collaborative_annotation=False, **kwargs):\n    return make_project(\n        task=task,\n        users=[\"admin\", \"approver\", \"annotator\"],\n        roles=[\n            settings.ROLE_PROJECT_ADMIN,\n            settings.ROLE_ANNOTATION_APPROVER,\n            settings.ROLE_ANNOTATOR,\n        ],\n        collaborative_annotation=collaborative_annotation,\n        **kwargs,\n    )"
                                    ],
                                    "code": "from typing import List\n\nfrom django.conf import settings\nfrom model_mommy import mommy\n\nfrom projects.models import Member, ProjectType, Role\nfrom roles.tests.utils import create_default_roles\nfrom users.tests.utils import make_user\n\n\nclass ProjectData:\n    def __init__(self, item, members):\n        self.item = item\n        self.members = members\n\n    @property\n    def id(self):\n        return self.item.id\n\n    @property\n    def admin(self):\n        return self.members[0]\n\n    @property\n    def approver(self):\n        return self.members[1]\n\n    @property\n    def annotator(self):\n        return self.members[2]\n\n    @property\n    def staffs(self):\n        return [self.approver, self.annotator]\n\n\ndef assign_user_to_role(project_member, project, role_name):\n    role, _ = Role.objects.get_or_create(name=role_name)\n    if Member.objects.filter(user=project_member, project=project).exists():\n        mapping = Member.objects.get(user=project_member, project=project)\n        mapping.role = role\n        mapping.save()\n    else:\n        mapping = Member.objects.get_or_create(role_id=role.id, user_id=project_member.id, project_id=project.id)\n    return mapping\n\n\ndef make_project(task: str, users: List[str], roles: List[str], collaborative_annotation=False, **kwargs):\n    create_default_roles()\n\n    # create users.\n    users = [make_user(name) for name in users]\n\n    # create a project.\n    project_model = {\n        ProjectType.DOCUMENT_CLASSIFICATION: \"TextClassificationProject\",\n        ProjectType.SEQUENCE_LABELING: \"SequenceLabelingProject\",\n        ProjectType.SEQ2SEQ: \"Seq2seqProject\",\n        ProjectType.SPEECH2TEXT: \"Speech2TextProject\",\n        ProjectType.IMAGE_CLASSIFICATION: \"ImageClassificationProject\",\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: \"IntentDetectionAndSlotFillingProject\",\n        ProjectType.BOUNDING_BOX: \"BoundingBoxProject\",\n        ProjectType.SEGMENTATION: \"SegmentationProject\",\n        ProjectType.IMAGE_CAPTIONING: \"ImageCaptioningProject\",\n    }.get(task, \"Project\")\n    project = mommy.make(\n        _model=project_model,\n        project_type=task,\n        collaborative_annotation=collaborative_annotation,\n        created_by=users[0],\n        **kwargs,\n    )\n\n    # assign roles to the users.\n    for user, role in zip(users, roles):\n        assign_user_to_role(user, project, role)\n\n    return ProjectData(item=project, members=users)\n\n\ndef make_tag(project):\n    return mommy.make(\"Tag\", project=project)\n\n\ndef prepare_project(task: str = \"Any\", collaborative_annotation=False, **kwargs):\n    return make_project(\n        task=task,\n        users=[\"admin\", \"approver\", \"annotator\"],\n        roles=[\n            settings.ROLE_PROJECT_ADMIN,\n            settings.ROLE_ANNOTATION_APPROVER,\n            settings.ROLE_ANNOTATOR,\n        ],\n        collaborative_annotation=collaborative_annotation,\n        **kwargs,\n    )\n",
                                    "summary": "Class ProjectData: Represents project data with item and members attributes, providing methods for accessing specific members and assigning users to roles in a project.",
                                    "code_element_summaries": [
                                        "Class ProjectData: Represents project data with item and members attributes, providing properties for id, admin, approver, annotator, and staffs.",
                                        "Function `__init__`: Initializes an object with the given item and members attributes.",
                                        "Function `id`: A method that returns the id of an item.",
                                        "Function `admin`: Returns the first member in a list of members.",
                                        "Function `approver`: Returns the second member in a list called 'members'.",
                                        "Function `annotator`: Returns the third element from the list of members.",
                                        "Function `staffs`: Returns a list containing the approver and annotator associated with the object.",
                                        "Function `assign_user_to_role`: Assign a user to a specific role in a project, creating a mapping if it does not already exist.",
                                        "Function `make_project`: Creates a project with specified task type, users, roles, and collaborative annotation option, assigning roles to users accordingly.",
                                        "Function `make_tag`: A function that creates a Tag instance associated with a specific project using the mommy library.",
                                        "Function `prepare_project`: Generates a project with specified task, users, roles, and collaborative annotation settings."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that provides methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views.member import MemberDetail, MemberList, MyRole\nfrom .views.project import CloneProject, ProjectDetail, ProjectList\nfrom .views.tag import TagDetail, TagList\n\nurlpatterns = [\n    path(route=\"projects\", view=ProjectList.as_view(), name=\"project_list\"),\n    path(route=\"projects/<int:project_id>\", view=ProjectDetail.as_view(), name=\"project_detail\"),\n    path(route=\"projects/<int:project_id>/my-role\", view=MyRole.as_view(), name=\"my_role\"),\n    path(route=\"projects/<int:project_id>/tags\", view=TagList.as_view(), name=\"tag_list\"),\n    path(route=\"projects/<int:project_id>/tags/<int:tag_id>\", view=TagDetail.as_view(), name=\"tag_detail\"),\n    path(route=\"projects/<int:project_id>/members\", view=MemberList.as_view(), name=\"member_list\"),\n    path(route=\"projects/<int:project_id>/clone\", view=CloneProject.as_view(), name=\"clone_project\"),\n    path(route=\"projects/<int:project_id>/members/<int:member_id>\", view=MemberDetail.as_view(), name=\"member_detail\"),\n]\n",
                            "summary": "URL patterns for various views related to projects, tags, and members in a Django application.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\views",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class `MemberList`: Handles CRUD operations for project members with filtering and permission settings, while `MemberDetail` manages individual member details and updates with role constraints and exception handling, supported by `MyRole` for retrieving member objects based on user and project ID. \nClass `ProjectList`: A view for handling project listing, creation, and deletion with permission management, role-based filtering, and constraints on bulk deletion. \nClass `TagList`: A view for managing tags within a project, with functions to retrieve and create tags, and a detail view for deleting tags with specific permissions.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "member.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\views\\member.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `MemberList`\nCode:\nclass MemberList(generics.ListCreateAPIView):\n    filter_backends = [DjangoFilterBackend]\n    filterset_fields = [\"user\"]\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def filter_queryset(self, queryset):\n        queryset = queryset.filter(project=self.kwargs[\"project_id\"])\n        return super().filter_queryset(queryset)\n\n    def perform_create(self, serializer):\n        try:\n            serializer.save(project_id=self.kwargs[\"project_id\"])\n        except IntegrityError:\n            raise RoleAlreadyAssignedException\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        project_id = self.kwargs[\"project_id\"]\n        Member.objects.filter(project=project_id, pk__in=delete_ids).exclude(user=self.request.user).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Function `filter_queryset`\nCode:\n    def filter_queryset(self, queryset):\n        queryset = queryset.filter(project=self.kwargs[\"project_id\"])\n        return super().filter_queryset(queryset)",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        try:\n            serializer.save(project_id=self.kwargs[\"project_id\"])\n        except IntegrityError:\n            raise RoleAlreadyAssignedException",
                                        "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        project_id = self.kwargs[\"project_id\"]\n        Member.objects.filter(project=project_id, pk__in=delete_ids).exclude(user=self.request.user).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Class `MemberDetail`\nCode:\nclass MemberDetail(generics.RetrieveUpdateAPIView):\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    lookup_url_kwarg = \"member_id\"\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def perform_update(self, serializer):\n        project_id = self.kwargs[\"project_id\"]\n        member_id = self.kwargs[\"member_id\"]\n        role = serializer.validated_data[\"role\"]\n        if not Member.objects.can_update(project_id, member_id, role.name):\n            raise RoleConstraintException\n        try:\n            super().perform_update(serializer)\n        except IntegrityError:\n            raise RoleAlreadyAssignedException",
                                        "Function `perform_update`\nCode:\n    def perform_update(self, serializer):\n        project_id = self.kwargs[\"project_id\"]\n        member_id = self.kwargs[\"member_id\"]\n        role = serializer.validated_data[\"role\"]\n        if not Member.objects.can_update(project_id, member_id, role.name):\n            raise RoleConstraintException\n        try:\n            super().perform_update(serializer)\n        except IntegrityError:\n            raise RoleAlreadyAssignedException",
                                        "Class `MyRole`\nCode:\nclass MyRole(generics.RetrieveAPIView):\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    permission_classes = [IsAuthenticated & IsProjectMember]\n\n    def get_object(self):\n        kwargs = {\"user\": self.request.user, \"project_id\": self.kwargs[\"project_id\"]}\n        return get_object_or_404(self.queryset, **kwargs)",
                                        "Function `get_object`\nCode:\n    def get_object(self):\n        kwargs = {\"user\": self.request.user, \"project_id\": self.kwargs[\"project_id\"]}\n        return get_object_or_404(self.queryset, **kwargs)"
                                    ],
                                    "code": "from django.db import IntegrityError\nfrom django.shortcuts import get_object_or_404\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import generics, status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom projects.exceptions import RoleAlreadyAssignedException, RoleConstraintException\nfrom projects.models import Member\nfrom projects.permissions import IsProjectAdmin, IsProjectMember\nfrom projects.serializers import MemberSerializer\n\n\nclass MemberList(generics.ListCreateAPIView):\n    filter_backends = [DjangoFilterBackend]\n    filterset_fields = [\"user\"]\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def filter_queryset(self, queryset):\n        queryset = queryset.filter(project=self.kwargs[\"project_id\"])\n        return super().filter_queryset(queryset)\n\n    def perform_create(self, serializer):\n        try:\n            serializer.save(project_id=self.kwargs[\"project_id\"])\n        except IntegrityError:\n            raise RoleAlreadyAssignedException\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        project_id = self.kwargs[\"project_id\"]\n        Member.objects.filter(project=project_id, pk__in=delete_ids).exclude(user=self.request.user).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass MemberDetail(generics.RetrieveUpdateAPIView):\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    lookup_url_kwarg = \"member_id\"\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def perform_update(self, serializer):\n        project_id = self.kwargs[\"project_id\"]\n        member_id = self.kwargs[\"member_id\"]\n        role = serializer.validated_data[\"role\"]\n        if not Member.objects.can_update(project_id, member_id, role.name):\n            raise RoleConstraintException\n        try:\n            super().perform_update(serializer)\n        except IntegrityError:\n            raise RoleAlreadyAssignedException\n\n\nclass MyRole(generics.RetrieveAPIView):\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    permission_classes = [IsAuthenticated & IsProjectMember]\n\n    def get_object(self):\n        kwargs = {\"user\": self.request.user, \"project_id\": self.kwargs[\"project_id\"]}\n        return get_object_or_404(self.queryset, **kwargs)\n",
                                    "summary": "Class `MemberList` handles CRUD operations for project members with filtering and permission settings, while `MemberDetail` manages individual member details and updates with role constraints and exception handling, supported by `MyRole` for retrieving member objects based on user and project ID.",
                                    "code_element_summaries": [
                                        "Class `MemberList`: A view that handles listing, creating, and deleting members in a project with specific filtering and permission settings.",
                                        "Function `filter_queryset`: Filters the queryset based on the project ID provided in the kwargs.",
                                        "Function `perform_create`: Saves the serializer data with a specified project_id and raises an exception if IntegrityError occurs.",
                                        "Function `delete`: Deletes multiple Member instances related to a specific project based on provided IDs.",
                                        "Class `MemberDetail`: A view for retrieving and updating member details with permission checks and exception handling.",
                                        "Function `perform_update`: Updates a member's role in a project while handling role constraints and integrity errors.",
                                        "Class MyRole: Retrieves a member object based on user and project ID with specified permission classes.",
                                        "Function `get_object`: Retrieves an object based on user and project ID parameters."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "project.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\views\\project.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ProjectList`\nCode:\nclass ProjectList(generics.ListCreateAPIView):\n    serializer_class = ProjectPolymorphicSerializer\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    search_fields = (\"name\", \"description\")\n    ordering_fields = [\"name\", \"created_at\", \"created_by\", \"project_type\"]\n    ordering = [\"-created_at\"]\n\n    def get_permissions(self):\n        if self.request.method == \"GET\":\n            self.permission_classes = [\n                IsAuthenticated,\n            ]\n        else:\n            self.permission_classes = [IsAuthenticated & IsAdminUser]\n        return super().get_permissions()\n\n    def get_queryset(self):\n        return Project.objects.filter(role_mappings__user=self.request.user)\n\n    def perform_create(self, serializer):\n        project = serializer.save(created_by=self.request.user)\n        project.add_admin()\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        projects = Project.objects.filter(\n            role_mappings__user=self.request.user,\n            role_mappings__role__name=settings.ROLE_PROJECT_ADMIN,\n            pk__in=delete_ids,\n        )\n        # Todo: I want to use bulk delete.\n        # But it causes the constraint error.\n        # See https://github.com/django-polymorphic/django-polymorphic/issues/229\n        for project in projects:\n            project.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Function `get_permissions`\nCode:\n    def get_permissions(self):\n        if self.request.method == \"GET\":\n            self.permission_classes = [\n                IsAuthenticated,\n            ]\n        else:\n            self.permission_classes = [IsAuthenticated & IsAdminUser]\n        return super().get_permissions()",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        return Project.objects.filter(role_mappings__user=self.request.user)",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        project = serializer.save(created_by=self.request.user)\n        project.add_admin()",
                                        "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        projects = Project.objects.filter(\n            role_mappings__user=self.request.user,\n            role_mappings__role__name=settings.ROLE_PROJECT_ADMIN,\n            pk__in=delete_ids,\n        )\n        # Todo: I want to use bulk delete.\n        # But it causes the constraint error.\n        # See https://github.com/django-polymorphic/django-polymorphic/issues/229\n        for project in projects:\n            project.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Class `ProjectDetail`\nCode:\nclass ProjectDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Project.objects.all()\n    serializer_class = ProjectPolymorphicSerializer\n    lookup_url_kwarg = \"project_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]",
                                        "Class `CloneProject`\nCode:\nclass CloneProject(views.APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @transaction.atomic\n    def post(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        cloned_project = project.clone()\n        serializer = ProjectPolymorphicSerializer(cloned_project)\n        return Response(serializer.data, status=status.HTTP_201_CREATED)",
                                        "Function `post`\nCode:\n    def post(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        cloned_project = project.clone()\n        serializer = ProjectPolymorphicSerializer(cloned_project)\n        return Response(serializer.data, status=status.HTTP_201_CREATED)"
                                    ],
                                    "code": "from django.conf import settings\nfrom django.db import transaction\nfrom django.shortcuts import get_object_or_404\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import filters, generics, status, views\nfrom rest_framework.permissions import IsAdminUser, IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom projects.models import Project\nfrom projects.permissions import IsProjectAdmin, IsProjectStaffAndReadOnly\nfrom projects.serializers import ProjectPolymorphicSerializer\n\n\nclass ProjectList(generics.ListCreateAPIView):\n    serializer_class = ProjectPolymorphicSerializer\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    search_fields = (\"name\", \"description\")\n    ordering_fields = [\"name\", \"created_at\", \"created_by\", \"project_type\"]\n    ordering = [\"-created_at\"]\n\n    def get_permissions(self):\n        if self.request.method == \"GET\":\n            self.permission_classes = [\n                IsAuthenticated,\n            ]\n        else:\n            self.permission_classes = [IsAuthenticated & IsAdminUser]\n        return super().get_permissions()\n\n    def get_queryset(self):\n        return Project.objects.filter(role_mappings__user=self.request.user)\n\n    def perform_create(self, serializer):\n        project = serializer.save(created_by=self.request.user)\n        project.add_admin()\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        projects = Project.objects.filter(\n            role_mappings__user=self.request.user,\n            role_mappings__role__name=settings.ROLE_PROJECT_ADMIN,\n            pk__in=delete_ids,\n        )\n        # Todo: I want to use bulk delete.\n        # But it causes the constraint error.\n        # See https://github.com/django-polymorphic/django-polymorphic/issues/229\n        for project in projects:\n            project.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass ProjectDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Project.objects.all()\n    serializer_class = ProjectPolymorphicSerializer\n    lookup_url_kwarg = \"project_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n\nclass CloneProject(views.APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @transaction.atomic\n    def post(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        cloned_project = project.clone()\n        serializer = ProjectPolymorphicSerializer(cloned_project)\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n",
                                    "summary": "Class `ProjectList`: A view for handling project listing, creation, and deletion with permission management, role-based filtering, and constraints on bulk deletion.",
                                    "code_element_summaries": [
                                        "Class `ProjectList`: A view that handles listing and creating projects, setting permissions based on request method, filtering projects based on user role, and deleting projects with constraints preventing bulk delete.",
                                        "Function `get_permissions`: A method that dynamically sets permission classes based on the request method, allowing different access levels for GET and other methods.",
                                        "Function get_queryset: Retrieves project objects filtered by user role mappings in the request.",
                                        "Function `perform_create`: A method that creates a project instance using a serializer and assigns the current user as the creator, then adds them as an admin.",
                                        "Function `delete`: Deletes projects with specific IDs after checking user permissions, with a note on potential constraint error when using bulk delete.",
                                        "Class ProjectDetail: An API view for retrieving, updating, and deleting project details with specified permissions and serializer.",
                                        "Class `CloneProject`: An API view that allows authenticated project administrators to clone a project and return the serialized data of the cloned project.",
                                        "Function `post`: Clones a project and returns its serialized data with a status of 201 Created."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "tag.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\views\\tag.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TagList`\nCode:\nclass TagList(generics.ListCreateAPIView):\n    serializer_class = TagSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get_queryset(self):\n        return Tag.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        return Tag.objects.filter(project=self.kwargs[\"project_id\"])",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])",
                                        "Class `TagDetail`\nCode:\nclass TagDetail(generics.DestroyAPIView):\n    queryset = Tag.objects.all()\n    serializer_class = TagSerializer\n    lookup_url_kwarg = \"tag_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]"
                                    ],
                                    "code": "from rest_framework import generics\nfrom rest_framework.permissions import IsAuthenticated\n\nfrom projects.models import Tag\nfrom projects.permissions import IsProjectAdmin, IsProjectStaffAndReadOnly\nfrom projects.serializers import TagSerializer\n\n\nclass TagList(generics.ListCreateAPIView):\n    serializer_class = TagSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get_queryset(self):\n        return Tag.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])\n\n\nclass TagDetail(generics.DestroyAPIView):\n    queryset = Tag.objects.all()\n    serializer_class = TagSerializer\n    lookup_url_kwarg = \"tag_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n",
                                    "summary": "Class `TagList`: A view for managing tags within a project, with functions to retrieve and create tags, and a detail view for deleting tags with specific permissions.",
                                    "code_element_summaries": [
                                        "Class `TagList`: A view that handles the creation and listing of tags for a specific project, with authentication and permission checks in place.",
                                        "Function `get_queryset`: Retrieves all tags associated with a specific project ID.",
                                        "Function `perform_create`: Saves the serializer with the project_id extracted from the URL kwargs.",
                                        "Class TagDetail: An API view for handling the deletion of Tag instances with specific permissions and serializer."
                                    ],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content provides a proxy model, ExportedBoundingBox, that represents bounding box annotations in dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "roles",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that allows for bounding box annotations to be converted into dictionary and tuple forms.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RoleAdmin`\nCode:\nclass RoleAdmin(admin.ModelAdmin):\n    list_display = (\"name\", \"description\")\n    ordering = (\"name\",)\n    search_fields = (\"name\",)"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import Role\n\n\nclass RoleAdmin(admin.ModelAdmin):\n    list_display = (\"name\", \"description\")\n    ordering = (\"name\",)\n    search_fields = (\"name\",)\n\n\nadmin.site.register(Role, RoleAdmin)\n",
                            "summary": "Class RoleAdmin: A model admin class for managing roles with specified list display, ordering, and search fields.",
                            "code_element_summaries": [
                                "Class RoleAdmin: A model admin class for managing roles with specified list display, ordering, and search fields."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RolesConfig`\nCode:\nclass RolesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"roles\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass RolesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"roles\"\n",
                            "summary": "Class RolesConfig: A configuration class for the 'roles' app in Django with a default auto field set to \"django.db.models.BigAutoField\".",
                            "code_element_summaries": [
                                "Class RolesConfig: A configuration class for the 'roles' app in Django with a default auto field set to \"django.db.models.BigAutoField\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "management",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\management",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Command: A management command for creating default roles in the database with error handling and database operations.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "commands",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\management\\commands",
                                    "is_dir": true,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "Class Command: A management command for creating default roles in the database with error handling and database operations.",
                                    "code_element_summaries": [],
                                    "children": [
                                        {
                                            "name": "create_roles.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\management\\commands\\create_roles.py",
                                            "is_dir": false,
                                            "code_elements": [
                                                "Class `Command`\nCode:\nclass Command(BaseCommand):\n    help = \"Non-interactively create default roles\"\n\n    def handle(self, *args, **options):\n        try:\n            role_names = [settings.ROLE_PROJECT_ADMIN, settings.ROLE_ANNOTATOR, settings.ROLE_ANNOTATION_APPROVER]\n        except KeyError as key_error:\n            self.stderr.write(self.style.ERROR(f'Missing Key: \"{key_error}\"'))\n        for role_name in role_names:\n            if Role.objects.filter(name=role_name).exists():\n                continue\n            role = Role()\n            role.name = role_name\n            try:\n                role.save()\n            except DatabaseError as db_error:\n                self.stderr.write(self.style.ERROR(f'Database Error: \"{db_error}\"'))\n            else:\n                self.stdout.write(self.style.SUCCESS(f'Role created successfully \"{role_name}\"'))",
                                                "Function `handle`\nCode:\n    def handle(self, *args, **options):\n        try:\n            role_names = [settings.ROLE_PROJECT_ADMIN, settings.ROLE_ANNOTATOR, settings.ROLE_ANNOTATION_APPROVER]\n        except KeyError as key_error:\n            self.stderr.write(self.style.ERROR(f'Missing Key: \"{key_error}\"'))\n        for role_name in role_names:\n            if Role.objects.filter(name=role_name).exists():\n                continue\n            role = Role()\n            role.name = role_name\n            try:\n                role.save()\n            except DatabaseError as db_error:\n                self.stderr.write(self.style.ERROR(f'Database Error: \"{db_error}\"'))\n            else:\n                self.stdout.write(self.style.SUCCESS(f'Role created successfully \"{role_name}\"'))"
                                            ],
                                            "code": "from django.conf import settings\nfrom django.core.management.base import BaseCommand\nfrom django.db import DatabaseError\n\nfrom ...models import Role\n\n\nclass Command(BaseCommand):\n    help = \"Non-interactively create default roles\"\n\n    def handle(self, *args, **options):\n        try:\n            role_names = [settings.ROLE_PROJECT_ADMIN, settings.ROLE_ANNOTATOR, settings.ROLE_ANNOTATION_APPROVER]\n        except KeyError as key_error:\n            self.stderr.write(self.style.ERROR(f'Missing Key: \"{key_error}\"'))\n        for role_name in role_names:\n            if Role.objects.filter(name=role_name).exists():\n                continue\n            role = Role()\n            role.name = role_name\n            try:\n                role.save()\n            except DatabaseError as db_error:\n                self.stderr.write(self.style.ERROR(f'Database Error: \"{db_error}\"'))\n            else:\n                self.stdout.write(self.style.SUCCESS(f'Role created successfully \"{role_name}\"'))\n",
                                            "summary": "Class Command: A management command for creating default roles in the database, including roles for project admin, annotator, and annotation approver, with error handling for missing keys and database operations.",
                                            "code_element_summaries": [
                                                "Class Command: A management command to non-interactively create default roles in the database.",
                                                "Function `handle`: Creates roles for project admin, annotator, and annotation approver, handling errors related to missing keys and database operations."
                                            ],
                                            "children": []
                                        },
                                        {
                                            "name": "__init__.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\management\\commands\\__init__.py",
                                            "is_dir": false,
                                            "code_elements": [],
                                            "code": "",
                                            "summary": "The content defines a class ExportedBoundingBox that acts as a proxy model for BoundingBox, providing methods to convert bounding box annotations into dictionary and tuple formats.",
                                            "code_element_summaries": [],
                                            "children": []
                                        }
                                    ]
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\management\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a class ExportedBoundingBox that acts as a proxy model of BoundingBox, offering methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A class that manages database schema changes for creating, renaming, and handling operations for Role, RoleMapping, and Member models.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Role\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"name\", models.CharField(max_length=100, unique=True)),\n                        (\"description\", models.TextField(default=\"\")),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"RoleMapping\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\"role\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"roles.role\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"user\", \"project\")},\n                    },\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-11 06:55\n\nfrom django.conf import settings\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Role\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"name\", models.CharField(max_length=100, unique=True)),\n                        (\"description\", models.TextField(default=\"\")),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"RoleMapping\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\"role\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"roles.role\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"user\", \"project\")},\n                    },\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: Defines the database schema changes needed for creating Role and RoleMapping models.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that defines the database schema changes required to create the Role and RoleMapping models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_rename_rolemapping_member.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\migrations\\0002_rename_rolemapping_member.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n        (\"roles\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RoleMapping\",\n            new_name=\"Member\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-12 23:06\n\nfrom django.conf import settings\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n        (\"roles\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RoleMapping\",\n            new_name=\"Member\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A class responsible for managing database schema changes, including renaming a model from RoleMapping to Member.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A migration class that handles dependencies and operations for database schema changes, including renaming a model from RoleMapping to Member."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_delete_member.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\migrations\\0003_delete_member.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"roles\", \"0002_rename_rolemapping_member\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Member\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(\n                    name=\"Member\",\n                    table=\"members_member\",\n                ),\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-13 01:54\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"roles\", \"0002_rename_rolemapping_member\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Member\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(\n                    name=\"Member\",\n                    table=\"members_member\",\n                ),\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A class designed to handle database and state operations separately for the Member model during migrations.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration class that separates database and state operations for the Member model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content defines a class ExportedBoundingBox that serves as a proxy model for BoundingBox, providing methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Role`\nCode:\nclass Role(models.Model):\n    name = models.CharField(max_length=100, unique=True)\n    description = models.TextField(default=\"\")\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.name",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        return self.name"
                            ],
                            "code": "from django.db import models\n\n\nclass Role(models.Model):\n    name = models.CharField(max_length=100, unique=True)\n    description = models.TextField(default=\"\")\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.name\n",
                            "summary": "Class Role: A model representing roles with fields for name, description, and timestamps, with a function to return the name as a string.",
                            "code_element_summaries": [
                                "Class Role: Represents a model with fields for name, description, creation and update timestamps.",
                                "Function `__str__`: Returns the name of the object as a string representation."
                            ],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RoleSerializer`\nCode:\nclass RoleSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Role\n        fields = (\"id\", \"name\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Role\n        fields = (\"id\", \"name\")"
                            ],
                            "code": "from rest_framework import serializers\n\nfrom .models import Role\n\n\nclass RoleSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Role\n        fields = (\"id\", \"name\")\n",
                            "summary": "Class RoleSerializer: A serializer class for the Role model with id and name fields, with defined metadata for the Role model.",
                            "code_element_summaries": [
                                "Class RoleSerializer: A serializer class for the Role model with fields id and name.",
                                "Class Meta: Defines metadata for the Role model with specified fields."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class TestRoleAPI: A test class for CRUD operations on roles and permissions for authenticated and unauthenticated users, with a function to create default roles for project administrators, annotators, and annotation approvers.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestRoleAPI`\nCode:\nclass TestRoleAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"roles\")\n\n    def test_allows_authenticated_user_to_get_roles(self):\n        self.assert_fetch(self.user, status.HTTP_200_OK)\n\n    def test_denies_unauthenticated_user_to_get_roles(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"roles\")",
                                        "Function `test_allows_authenticated_user_to_get_roles`\nCode:\n    def test_allows_authenticated_user_to_get_roles(self):\n        self.assert_fetch(self.user, status.HTTP_200_OK)",
                                        "Function `test_denies_unauthenticated_user_to_get_roles`\nCode:\n    def test_denies_unauthenticated_user_to_get_roles(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import create_default_roles\nfrom api.tests.utils import CRUDMixin\nfrom users.tests.utils import make_user\n\n\nclass TestRoleAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"roles\")\n\n    def test_allows_authenticated_user_to_get_roles(self):\n        self.assert_fetch(self.user, status.HTTP_200_OK)\n\n    def test_denies_unauthenticated_user_to_get_roles(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Class TestRoleAPI: A test class for testing CRUD operations on roles and checking permissions for authenticated and unauthenticated users.",
                                    "code_element_summaries": [
                                        "Class TestRoleAPI: A test class for CRUD operations on roles, including methods to check permissions for authenticated and unauthenticated users.",
                                        "Function setUpTestData: Initializes test data by creating default roles, making a user, and setting a URL for roles view.",
                                        "Function `test_allows_authenticated_user_to_get_roles`: Tests that an authenticated user can retrieve roles successfully.",
                                        "Function `test_denies_unauthenticated_user_to_get_roles`: Tests that deny unauthenticated users from accessing roles and returns a 403 Forbidden status."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `create_default_roles`\nCode:\ndef create_default_roles():\n    Role.objects.get_or_create(name=settings.ROLE_PROJECT_ADMIN)\n    Role.objects.get_or_create(name=settings.ROLE_ANNOTATOR)\n    Role.objects.get_or_create(name=settings.ROLE_ANNOTATION_APPROVER)"
                                    ],
                                    "code": "from django.conf import settings\n\nfrom roles.models import Role\n\n\ndef create_default_roles():\n    Role.objects.get_or_create(name=settings.ROLE_PROJECT_ADMIN)\n    Role.objects.get_or_create(name=settings.ROLE_ANNOTATOR)\n    Role.objects.get_or_create(name=settings.ROLE_ANNOTATION_APPROVER)\n",
                                    "summary": "Function `create_default_roles`: A function that generates default roles for project administrators, annotators, and annotation approvers.",
                                    "code_element_summaries": [
                                        "Function `create_default_roles`: A function that creates default roles for project administrators, annotators, and annotation approvers."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that provides methods to represent bounding box annotations in dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import Roles\n\nurlpatterns = [path(route=\"roles\", view=Roles.as_view(), name=\"roles\")]\n",
                            "summary": "URL patterns for accessing the Roles view in Django.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Roles`\nCode:\nclass Roles(generics.ListAPIView):\n    serializer_class = RoleSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated]\n    queryset = Role.objects.all()"
                            ],
                            "code": "from rest_framework import generics\nfrom rest_framework.permissions import IsAuthenticated\n\nfrom .models import Role\nfrom .serializers import RoleSerializer\n\n\nclass Roles(generics.ListAPIView):\n    serializer_class = RoleSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated]\n    queryset = Role.objects.all()\n",
                            "summary": "Class Roles: A ListAPIView for retrieving all Role objects using RoleSerializer, without pagination, and requiring authentication.",
                            "code_element_summaries": [
                                "Class Roles: A ListAPIView that retrieves all Role objects with RoleSerializer, no pagination, and requires authentication."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The ExportedBoundingBox class is a proxy model of BoundingBox that provides methods to convert bounding box annotations into dictionary and tuple representations.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "social",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content introduces a proxy model ExportedBoundingBox that extends BoundingBox and includes methods to convert bounding box annotations into dictionary and tuple forms.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\admin.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The ExportedBoundingBox class is a proxy model that provides methods to represent bounding box annotations in dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `SocialConfig`\nCode:\nclass SocialConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"social\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass SocialConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"social\"\n",
                            "summary": "Class SocialConfig: AppConfig class for the \"social\" app with default auto field setting.",
                            "code_element_summaries": [
                                "Class SocialConfig: An AppConfig class for the \"social\" app with a default auto field setting."
                            ],
                            "children": []
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\models.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The ExportedBoundingBox class extends BoundingBox to represent bounding box annotations as dictionaries and tuples.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "okta.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\okta.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `OktaLogin`\nCode:\nclass OktaLogin(SocialLoginView):\n    adapter_class = OktaOAuth2Adapter\n    callback_url = \"/projects\"\n    client_class = OAuth2Client"
                            ],
                            "code": "from allauth.socialaccount.providers.oauth2.client import OAuth2Client\nfrom allauth.socialaccount.providers.okta.views import OktaOAuth2Adapter\nfrom dj_rest_auth.registration.views import SocialLoginView\n\n\nclass OktaLogin(SocialLoginView):\n    adapter_class = OktaOAuth2Adapter\n    callback_url = \"/projects\"\n    client_class = OAuth2Client\n",
                            "summary": "Class OktaLogin: A specialized subclass of SocialLoginView tailored for Okta OAuth2 authentication in a project.",
                            "code_element_summaries": [
                                "Class OktaLogin: A subclass of SocialLoginView that specifies Okta OAuth2 adapter, callback URL, and client class for project authentication."
                            ],
                            "children": []
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .okta import OktaLogin\n\nurlpatterns = [\n    path(\"complete/okta-oauth2/\", OktaLogin.as_view(), name=\"okta_login\"),\n]\n",
                            "summary": "Defining a URL path for Okta OAuth2 login using the OktaLogin view.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "v1_urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\v1_urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import Social\n\nurlpatterns = [\n    path(\"links/\", Social.as_view()),\n]\n",
                            "summary": "URL patterns for accessing the Social view are defined in the urlpatterns list.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Social`\nCode:\nclass Social(APIView):\n    permission_classes = ()\n\n    def get(self, request, *args, **kwargs):\n        return Response(\n            {\n                \"okta\": {\n                    \"type\": \"oauth2\",\n                    \"base_url\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\"),\n                    \"client_id\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\"),\n                    \"redirect_path\": \"/social/complete/okta-oauth2\",\n                    \"authorize_url\": \"https://\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                    + \"/oauth2/v1/authorize?response_type=code&client_id=\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\")\n                    + \"&scope=openid&state=unknown&response_mode=form_post\",\n                }\n                if settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                else {},\n            }\n        )",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        return Response(\n            {\n                \"okta\": {\n                    \"type\": \"oauth2\",\n                    \"base_url\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\"),\n                    \"client_id\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\"),\n                    \"redirect_path\": \"/social/complete/okta-oauth2\",\n                    \"authorize_url\": \"https://\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                    + \"/oauth2/v1/authorize?response_type=code&client_id=\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\")\n                    + \"&scope=openid&state=unknown&response_mode=form_post\",\n                }\n                if settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                else {},\n            }\n        )"
                            ],
                            "code": "from django.conf import settings\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\n\nclass Social(APIView):\n    permission_classes = ()\n\n    def get(self, request, *args, **kwargs):\n        return Response(\n            {\n                \"okta\": {\n                    \"type\": \"oauth2\",\n                    \"base_url\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\"),\n                    \"client_id\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\"),\n                    \"redirect_path\": \"/social/complete/okta-oauth2\",\n                    \"authorize_url\": \"https://\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                    + \"/oauth2/v1/authorize?response_type=code&client_id=\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\")\n                    + \"&scope=openid&state=unknown&response_mode=form_post\",\n                }\n                if settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                else {},\n            }\n        )\n",
                            "summary": "Class Social: An API view class that retrieves and returns Okta OAuth2 configuration details in a response object.",
                            "code_element_summaries": [
                                "Class `Social`: An API view class that returns Okta OAuth2 configuration details in a response.",
                                "Function `get`: Returns Okta OAuth2 configuration details in a response object."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content provides a proxy model ExportedBoundingBox that extends BoundingBox and includes methods to convert bounding box annotations into dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "users",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content introduces a proxy model ExportedBoundingBox that facilitates the conversion of bounding box annotations into dictionary and tuple representations.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\admin.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content provides a proxy model ExportedBoundingBox that converts bounding box annotations into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `UsersConfig`\nCode:\nclass UsersConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"users\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass UsersConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"users\"\n",
                            "summary": "Class UsersConfig: An AppConfig class for the \"users\" app in Django with a default auto field of \"BigAutoField\".",
                            "code_element_summaries": [
                                "Class UsersConfig: An AppConfig class for the \"users\" app in Django with a default auto field of \"BigAutoField\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The ExportedBoundingBox class serves as a proxy model for converting bounding box annotations into dictionary and tuple representations.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a proxy model ExportedBoundingBox with methods to convert bounding box annotations into dictionary and tuple forms.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\models.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content provides a class ExportedBoundingBox that acts as a proxy model for BoundingBox, allowing for representation of bounding box annotations in dictionary and tuple forms.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `UserSerializer`\nCode:\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = get_user_model()\n        fields = (\"id\", \"username\", \"is_superuser\", \"is_staff\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = get_user_model()\n        fields = (\"id\", \"username\", \"is_superuser\", \"is_staff\")"
                            ],
                            "code": "from django.contrib.auth import get_user_model\nfrom rest_framework import serializers\n\n\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = get_user_model()\n        fields = (\"id\", \"username\", \"is_superuser\", \"is_staff\")\n",
                            "summary": "Class UserSerializer: A model serializer for user objects with specified fields and metadata options for user-related data.",
                            "code_element_summaries": [
                                "Class UserSerializer: A model serializer for user objects that includes specific fields like id, username, is_superuser, and is_staff.",
                                "Class Meta: Defines metadata options for a model, specifying the model and fields to include in user-related data."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "A set of test cases and functions for testing user API endpoints, authentication, authorization, and user creation, including a function to create users with specific staff status using Django User model.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestUserAPI`\nCode:\nclass TestUserAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"user_list\")\n\n    def test_allows_authenticated_user_to_get_users(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertEqual(response.data[0][\"username\"], self.user.username)\n\n    def test_denies_unauthenticated_user_to_get_users(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"user_list\")",
                                        "Function `test_allows_authenticated_user_to_get_users`\nCode:\n    def test_allows_authenticated_user_to_get_users(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertEqual(response.data[0][\"username\"], self.user.username)",
                                        "Function `test_denies_unauthenticated_user_to_get_users`\nCode:\n    def test_denies_unauthenticated_user_to_get_users(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)",
                                        "Class `TestMeAPI`\nCode:\nclass TestMeAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"me\")\n\n    def test_return_own_information(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.data[\"id\"], self.user.id)\n        self.assertEqual(response.data[\"username\"], self.user.username)\n\n    def test_does_not_return_information_to_unauthenticated_user(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"me\")",
                                        "Function `test_return_own_information`\nCode:\n    def test_return_own_information(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.data[\"id\"], self.user.id)\n        self.assertEqual(response.data[\"username\"], self.user.username)",
                                        "Function `test_does_not_return_information_to_unauthenticated_user`\nCode:\n    def test_does_not_return_information_to_unauthenticated_user(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)",
                                        "Class `TestUserCreationAPI`\nCode:\nclass TestUserCreationAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.staff = make_user(username=\"bob\", is_staff=True)\n        cls.non_staff = make_user(username=\"tom\", is_staff=False)\n        cls.url = reverse(viewname=\"user_create\")\n        cls.payload = {\"username\": \"hironsan\", \"password1\": \"foobarbaz\", \"password2\": \"foobarbaz\"}\n\n    def test_staff_can_create_user(self):\n        self.client.force_login(self.staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.data[\"username\"], \"hironsan\")\n\n    def test_non_staff_cannot_create_user(self):\n        self.client.force_login(self.non_staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.staff = make_user(username=\"bob\", is_staff=True)\n        cls.non_staff = make_user(username=\"tom\", is_staff=False)\n        cls.url = reverse(viewname=\"user_create\")\n        cls.payload = {\"username\": \"hironsan\", \"password1\": \"foobarbaz\", \"password2\": \"foobarbaz\"}",
                                        "Function `test_staff_can_create_user`\nCode:\n    def test_staff_can_create_user(self):\n        self.client.force_login(self.staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.data[\"username\"], \"hironsan\")",
                                        "Function `test_non_staff_cannot_create_user`\nCode:\n    def test_non_staff_cannot_create_user(self):\n        self.client.force_login(self.non_staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\nfrom rest_framework.test import APITestCase\n\nfrom .utils import make_user\n\n\nclass TestUserAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"user_list\")\n\n    def test_allows_authenticated_user_to_get_users(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertEqual(response.data[0][\"username\"], self.user.username)\n\n    def test_denies_unauthenticated_user_to_get_users(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\n\n\nclass TestMeAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"me\")\n\n    def test_return_own_information(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.data[\"id\"], self.user.id)\n        self.assertEqual(response.data[\"username\"], self.user.username)\n\n    def test_does_not_return_information_to_unauthenticated_user(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\n\n\nclass TestUserCreationAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.staff = make_user(username=\"bob\", is_staff=True)\n        cls.non_staff = make_user(username=\"tom\", is_staff=False)\n        cls.url = reverse(viewname=\"user_create\")\n        cls.payload = {\"username\": \"hironsan\", \"password1\": \"foobarbaz\", \"password2\": \"foobarbaz\"}\n\n    def test_staff_can_create_user(self):\n        self.client.force_login(self.staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.data[\"username\"], \"hironsan\")\n\n    def test_non_staff_cannot_create_user(self):\n        self.client.force_login(self.non_staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "A series of test case classes and functions designed to test user API endpoints, authentication, authorization, and user creation with both staff and non-staff users.",
                                    "code_element_summaries": [
                                        "Class `TestUserAPI`: A test case class for testing user API endpoints, including methods to check authentication and authorization.",
                                        "Function `setUpTestData`: Sets up test data including a user with the username \"bob\" and a URL for the user list view.",
                                        "Function `test_allows_authenticated_user_to_get_users`: Verifies that an authenticated user can successfully retrieve user information.",
                                        "Function test_denies_unauthenticated_user_to_get_users: Tests that unauthenticated users are denied access to get user data.",
                                        "Class TestMeAPI: A test case class for testing API endpoints related to user information retrieval and authentication.",
                                        "Function `setUpTestData`: A method used to set up test data including a user with username \"bob\" and a URL for the \"me\" view.",
                                        "Function `test_return_own_information`: A test function that checks if the API returns the correct user information.",
                                        "Function `test_does_not_return_information_to_unauthenticated_user`: Tests that an unauthenticated user does not have access to specific information.",
                                        "Class `TestUserCreationAPI`: A test case class for testing user creation API endpoints with staff and non-staff users.",
                                        "Function `setUpTestData`: A method to set up test data including staff and non-staff users, URL, and payload for user creation.",
                                        "Function `test_staff_can_create_user`: Verifies that staff users can successfully create a new user with the username \"hironsan\".",
                                        "Function `test_non_staff_cannot_create_user`: Tests that non-staff users are forbidden from creating new users."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `make_user`\nCode:\ndef make_user(username: str = \"bob\", is_staff: bool = False):\n    user_model = get_user_model()\n    user, _ = user_model.objects.get_or_create(username=username, password=\"pass\", is_staff=is_staff)\n    return user"
                                    ],
                                    "code": "from django.contrib.auth import get_user_model\n\n\ndef make_user(username: str = \"bob\", is_staff: bool = False):\n    user_model = get_user_model()\n    user, _ = user_model.objects.get_or_create(username=username, password=\"pass\", is_staff=is_staff)\n    return user\n",
                                    "summary": "Function `make_user`: Creates a user with specified username and staff status using Django User model.",
                                    "code_element_summaries": [
                                        "Function `make_user`: A function that creates a user with specified username and staff status using the Django User model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "The content provides a class ExportedBoundingBox that acts as a proxy model for BoundingBox, offering methods to convert bounding box annotations into dictionary and tuple formats.",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import include, path\n\nfrom .views import Me, UserCreation, Users\n\nurlpatterns = [\n    path(route=\"me\", view=Me.as_view(), name=\"me\"),\n    path(route=\"users\", view=Users.as_view(), name=\"user_list\"),\n    path(route=\"users/create\", view=UserCreation.as_view(), name=\"user_create\"),\n    path(\"auth/\", include(\"dj_rest_auth.urls\")),\n]\n",
                            "summary": "URL patterns for user-related views such as retrieving user information, listing users, creating users, and authentication endpoints are defined in Django urlpatterns.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Me`\nCode:\nclass Me(APIView):\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, *args, **kwargs):\n        serializer = UserSerializer(request.user, context={\"request\": request})\n        return Response(serializer.data)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        serializer = UserSerializer(request.user, context={\"request\": request})\n        return Response(serializer.data)",
                                "Class `Users`\nCode:\nclass Users(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n    pagination_class = None\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter)\n    search_fields = (\"username\",)",
                                "Class `UserCreation`\nCode:\nclass UserCreation(generics.CreateAPIView):\n    serializer_class = RegisterSerializer\n    permission_classes = [IsAuthenticated & IsAdminUser]\n\n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        user = self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        return Response(UserSerializer(user).data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def perform_create(self, serializer):\n        user = serializer.save(self.request)\n        return user",
                                "Function `create`\nCode:\n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        user = self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        return Response(UserSerializer(user).data, status=status.HTTP_201_CREATED, headers=headers)",
                                "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        user = serializer.save(self.request)\n        return user"
                            ],
                            "code": "from dj_rest_auth.registration.serializers import RegisterSerializer\nfrom django.contrib.auth.models import User\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import filters, generics, status\nfrom rest_framework.permissions import IsAdminUser, IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom .serializers import UserSerializer\nfrom projects.permissions import IsProjectAdmin\n\n\nclass Me(APIView):\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, *args, **kwargs):\n        serializer = UserSerializer(request.user, context={\"request\": request})\n        return Response(serializer.data)\n\n\nclass Users(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n    pagination_class = None\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter)\n    search_fields = (\"username\",)\n\n\nclass UserCreation(generics.CreateAPIView):\n    serializer_class = RegisterSerializer\n    permission_classes = [IsAuthenticated & IsAdminUser]\n\n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        user = self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        return Response(UserSerializer(user).data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def perform_create(self, serializer):\n        user = serializer.save(self.request)\n        return user\n",
                            "summary": "Classes Me, Users, and UserCreation with functions to retrieve, list, and create user instances along with their serialized data.",
                            "code_element_summaries": [
                                "Class Me: An API view class that returns serialized data of the authenticated user.",
                                "Function `get`: Returns serialized data of the current user using the UserSerializer.",
                                "Class `Users`: A view that lists all users with specified permissions, serializer, and search functionality enabled.",
                                "Class `UserCreation`: A view for creating user instances with authentication and admin permissions.",
                                "Function `create`: Creates a new user instance based on request data and returns a response with the user's serialized data.",
                                "Function `perform_create`: Saves the user data from the serializer and returns the saved user."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content provides a proxy model ExportedBoundingBox with methods to convert bounding box annotations into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "__init__.py",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\__init__.py",
                    "is_dir": false,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content provides a class ExportedBoundingBox that acts as a proxy model of BoundingBox and allows for representation of bounding box annotations in dictionary and tuple forms.",
                    "code_element_summaries": [],
                    "children": []
                }
            ]
        }
    ]
}