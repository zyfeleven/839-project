{
    "name": "doccano-master",
    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master",
    "is_dir": true,
    "code_elements": [],
    "code": "",
    "summary": "Django application framework: A comprehensive system that includes proxy models, user management, authentication views, URL routing, and testing suites to efficiently manage user data and improve API functionality.",
    "code_element_summaries": [],
    "children": [
        {
            "name": "backend",
            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend",
            "is_dir": true,
            "code_elements": [],
            "code": "",
            "summary": "The content outlines a Django application framework that encompasses various components such as proxy models for bounding boxes, application configurations, user management, authentication views, URL routing, and testing suites, all aimed at efficiently handling user data and enhancing API functionality.",
            "code_element_summaries": [],
            "children": [
                {
                    "name": "api",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "Summary: The content describes various components of a Django application, including configuration classes, custom management commands for admin user creation, middleware for handling HTTP requests and user authentication, migration classes for managing models in a document annotation system, test suites for validating functionality, URL configurations for task status views, and an API view for retrieving asynchronous task statuses.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ApiConfig`\nCode:\nclass ApiConfig(AppConfig):\n    name = \"api\"\n    verbose_name = \"Api\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass ApiConfig(AppConfig):\n    name = \"api\"\n    verbose_name = \"Api\"\n",
                            "summary": "Class ApiConfig: A configuration class for the \"api\" application that specifies its name and verbose name.",
                            "code_element_summaries": [
                                "Class ApiConfig: A configuration class for the \"api\" application, defining its name and verbose name."
                            ],
                            "children": []
                        },
                        {
                            "name": "management",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Command: A custom management command that facilitates the non-interactive creation of an admin user while ensuring database availability through configurable polling intervals and robust error handling.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "commands",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management\\commands",
                                    "is_dir": true,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "Class Command: A custom management command for creating an admin user non-interactively and ensuring database availability with configurable polling intervals and comprehensive error handling.",
                                    "code_element_summaries": [],
                                    "children": [
                                        {
                                            "name": "create_admin.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management\\commands\\create_admin.py",
                                            "is_dir": false,
                                            "code_elements": [
                                                "Class `Command`\nCode:\nclass Command(createsuperuser.Command):\n    help = \"Non-interactively create an admin user\"\n\n    def add_arguments(self, parser):\n        super().add_arguments(parser)\n        parser.add_argument(\"--password\", default=None, help=\"The password for the admin.\")\n\n    def handle(self, *args, **options):\n        password = options.get(\"password\")\n        username = options.get(\"username\")\n\n        if not username:\n            self.stderr.write(\"Error: Blank username isn't allowed.\")\n            raise CommandError(\"--username is required if specifying --password\")\n\n        if not password:\n            self.stderr.write(\"Error: Blank password isn't allowed.\")\n            raise CommandError(\"--password is required\")\n\n        if password == \"password\":\n            self.stdout.write(self.style.WARNING(\"Warning: You should change the default password.\"))\n\n        try:\n            super().handle(*args, **options)\n        except Exception as err:\n            if \"is already taken\" in str(err):\n                self.stderr.write(f\"User {username} already exists.\")\n            else:\n                raise\n\n        database = options.get(\"database\")\n        db = self.UserModel._default_manager.db_manager(database)\n        user = db.get(username=username)\n        user.set_password(password)\n        message = f\"Setting password for User {username}.\"\n        self.stdout.write(self.style.SUCCESS(message))\n        user.save()",
                                                "Function `add_arguments`\nCode:\n    def add_arguments(self, parser):\n        super().add_arguments(parser)\n        parser.add_argument(\"--password\", default=None, help=\"The password for the admin.\")",
                                                "Function `handle`\nCode:\n    def handle(self, *args, **options):\n        password = options.get(\"password\")\n        username = options.get(\"username\")\n\n        if not username:\n            self.stderr.write(\"Error: Blank username isn't allowed.\")\n            raise CommandError(\"--username is required if specifying --password\")\n\n        if not password:\n            self.stderr.write(\"Error: Blank password isn't allowed.\")\n            raise CommandError(\"--password is required\")\n\n        if password == \"password\":\n            self.stdout.write(self.style.WARNING(\"Warning: You should change the default password.\"))\n\n        try:\n            super().handle(*args, **options)\n        except Exception as err:\n            if \"is already taken\" in str(err):\n                self.stderr.write(f\"User {username} already exists.\")\n            else:\n                raise\n\n        database = options.get(\"database\")\n        db = self.UserModel._default_manager.db_manager(database)\n        user = db.get(username=username)\n        user.set_password(password)\n        message = f\"Setting password for User {username}.\"\n        self.stdout.write(self.style.SUCCESS(message))\n        user.save()"
                                            ],
                                            "code": "from django.contrib.auth.management.commands import createsuperuser\nfrom django.core.management import CommandError\n\n\nclass Command(createsuperuser.Command):\n    help = \"Non-interactively create an admin user\"\n\n    def add_arguments(self, parser):\n        super().add_arguments(parser)\n        parser.add_argument(\"--password\", default=None, help=\"The password for the admin.\")\n\n    def handle(self, *args, **options):\n        password = options.get(\"password\")\n        username = options.get(\"username\")\n\n        if not username:\n            self.stderr.write(\"Error: Blank username isn't allowed.\")\n            raise CommandError(\"--username is required if specifying --password\")\n\n        if not password:\n            self.stderr.write(\"Error: Blank password isn't allowed.\")\n            raise CommandError(\"--password is required\")\n\n        if password == \"password\":\n            self.stdout.write(self.style.WARNING(\"Warning: You should change the default password.\"))\n\n        try:\n            super().handle(*args, **options)\n        except Exception as err:\n            if \"is already taken\" in str(err):\n                self.stderr.write(f\"User {username} already exists.\")\n            else:\n                raise\n\n        database = options.get(\"database\")\n        db = self.UserModel._default_manager.db_manager(database)\n        user = db.get(username=username)\n        user.set_password(password)\n        message = f\"Setting password for User {username}.\"\n        self.stdout.write(self.style.SUCCESS(message))\n        user.save()\n",
                                            "summary": "Class Command: A custom management command for creating an admin user non-interactively, with an extended argument parser for optional password input and comprehensive error handling during user creation.",
                                            "code_element_summaries": [
                                                "Class `Command`: A custom management command for non-interactively creating an admin user, requiring a username and password, and providing error handling for user creation.",
                                                "Function `add_arguments`: Extends the argument parser to include an optional password argument for the admin.",
                                                "Function `handle`: A method that processes user input for setting a password, ensuring required fields are provided, warning about default passwords, and handling potential errors related to user creation and password setting."
                                            ],
                                            "children": []
                                        },
                                        {
                                            "name": "wait_for_db.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management\\commands\\wait_for_db.py",
                                            "is_dir": false,
                                            "code_elements": [
                                                "Class `Command`\nCode:\nclass Command(BaseCommand):\n    help = \"Blocks until the database is available\"\n\n    def add_arguments(self, parser):\n        parser.add_argument(\"--poll_seconds\", type=float, default=3)\n        parser.add_argument(\"--max_retries\", type=int, default=60)\n\n    def handle(self, *args, **options):\n        max_retries = options[\"max_retries\"]\n        poll_seconds = options[\"poll_seconds\"]\n\n        for retry in range(max_retries):\n            try:\n                connection.ensure_connection()\n            except OperationalError as ex:\n                self.stdout.write(\n                    \"Database unavailable on attempt {attempt}/{max_retries}:\"\n                    \" {error}\".format(attempt=retry + 1, max_retries=max_retries, error=ex)\n                )\n                time.sleep(poll_seconds)\n            else:\n                break\n        else:\n            self.stdout.write(self.style.ERROR(\"Database unavailable\"))\n            sys.exit(1)",
                                                "Function `add_arguments`\nCode:\n    def add_arguments(self, parser):\n        parser.add_argument(\"--poll_seconds\", type=float, default=3)\n        parser.add_argument(\"--max_retries\", type=int, default=60)",
                                                "Function `handle`\nCode:\n    def handle(self, *args, **options):\n        max_retries = options[\"max_retries\"]\n        poll_seconds = options[\"poll_seconds\"]\n\n        for retry in range(max_retries):\n            try:\n                connection.ensure_connection()\n            except OperationalError as ex:\n                self.stdout.write(\n                    \"Database unavailable on attempt {attempt}/{max_retries}:\"\n                    \" {error}\".format(attempt=retry + 1, max_retries=max_retries, error=ex)\n                )\n                time.sleep(poll_seconds)\n            else:\n                break\n        else:\n            self.stdout.write(self.style.ERROR(\"Database unavailable\"))\n            sys.exit(1)"
                                            ],
                                            "code": "import sys\nimport time\n\nfrom django.core.management.base import BaseCommand\nfrom django.db import connection\nfrom django.db.utils import OperationalError\n\n\nclass Command(BaseCommand):\n    help = \"Blocks until the database is available\"\n\n    def add_arguments(self, parser):\n        parser.add_argument(\"--poll_seconds\", type=float, default=3)\n        parser.add_argument(\"--max_retries\", type=int, default=60)\n\n    def handle(self, *args, **options):\n        max_retries = options[\"max_retries\"]\n        poll_seconds = options[\"poll_seconds\"]\n\n        for retry in range(max_retries):\n            try:\n                connection.ensure_connection()\n            except OperationalError as ex:\n                self.stdout.write(\n                    \"Database unavailable on attempt {attempt}/{max_retries}:\"\n                    \" {error}\".format(attempt=retry + 1, max_retries=max_retries, error=ex)\n                )\n                time.sleep(poll_seconds)\n            else:\n                break\n        else:\n            self.stdout.write(self.style.ERROR(\"Database unavailable\"))\n            sys.exit(1)\n",
                                            "summary": "Class Command: A management command that ensures database availability through configurable polling intervals and maximum retries, with methods for argument configuration and connection handling.",
                                            "code_element_summaries": [
                                                "Class Command: A management command that blocks execution until the database becomes available, allowing for configurable polling intervals and maximum retry attempts.",
                                                "Function `add_arguments`: A method that configures command-line argument options for polling duration and maximum retries using a parser.",
                                                "Function `handle`: A method that attempts to establish a database connection with retry logic, providing error messages and exiting if the connection cannot be established after a specified number of attempts."
                                            ],
                                            "children": []
                                        },
                                        {
                                            "name": "__init__.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management\\commands\\__init__.py",
                                            "is_dir": false,
                                            "code_elements": [],
                                            "code": "",
                                            "summary": "",
                                            "code_element_summaries": [],
                                            "children": []
                                        }
                                    ]
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\management\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "middleware.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\middleware.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RangesMiddleware`: Quick solution. See:\nCode:\nclass RangesMiddleware(MiddlewareMixin):\n    \"\"\"Quick solution. See:\n    https://stackoverflow.com/questions/14324250/byte-ranges-in-django/35928017#35928017\n    \"\"\"\n\n    def process_response(self, request, response):\n        if response.status_code != 200 or not hasattr(response, \"file_to_stream\"):\n            return response\n        http_range = request.META.get(\"HTTP_RANGE\")\n        if not (http_range and http_range.startswith(\"bytes=\") and http_range.count(\"-\") == 1):\n            return response\n        if_range = request.META.get(\"HTTP_IF_RANGE\")\n        if if_range and if_range != response.get(\"Last-Modified\") and if_range != response.get(\"ETag\"):\n            return response\n        f = response.file_to_stream\n        statobj = os.fstat(f.fileno())\n        start, end = http_range.split(\"=\")[1].split(\"-\")\n        if not start:  # requesting the last N bytes\n            start = max(0, statobj.st_size - int(end))\n            end = \"\"\n        start, end = int(start or 0), int(end or statobj.st_size - 1)\n        assert 0 <= start < statobj.st_size, (start, statobj.st_size)\n        end = min(end, statobj.st_size - 1)\n        f.seek(start)\n        old_read = f.read\n        f.read = lambda n: old_read(min(n, end + 1 - f.tell()))\n        response.status_code = 206\n        response[\"Content-Length\"] = end + 1 - start\n        response[\"Content-Range\"] = \"bytes %d-%d/%d\" % (start, end, statobj.st_size)\n        return response",
                                "Function `process_response`\nCode:\n    def process_response(self, request, response):\n        if response.status_code != 200 or not hasattr(response, \"file_to_stream\"):\n            return response\n        http_range = request.META.get(\"HTTP_RANGE\")\n        if not (http_range and http_range.startswith(\"bytes=\") and http_range.count(\"-\") == 1):\n            return response\n        if_range = request.META.get(\"HTTP_IF_RANGE\")\n        if if_range and if_range != response.get(\"Last-Modified\") and if_range != response.get(\"ETag\"):\n            return response\n        f = response.file_to_stream\n        statobj = os.fstat(f.fileno())\n        start, end = http_range.split(\"=\")[1].split(\"-\")\n        if not start:  # requesting the last N bytes\n            start = max(0, statobj.st_size - int(end))\n            end = \"\"\n        start, end = int(start or 0), int(end or statobj.st_size - 1)\n        assert 0 <= start < statobj.st_size, (start, statobj.st_size)\n        end = min(end, statobj.st_size - 1)\n        f.seek(start)\n        old_read = f.read\n        f.read = lambda n: old_read(min(n, end + 1 - f.tell()))\n        response.status_code = 206\n        response[\"Content-Length\"] = end + 1 - start\n        response[\"Content-Range\"] = \"bytes %d-%d/%d\" % (start, end, statobj.st_size)\n        return response",
                                "Function `to_django_header`\nCode:\ndef to_django_header(header):\n    return f\"HTTP_{header.replace('-', '_').upper()}\"",
                                "Class `HeaderAuthMiddleware`\nCode:\nclass HeaderAuthMiddleware(RemoteUserMiddleware):\n    header = to_django_header(settings.HEADER_AUTH_USER_NAME)\n\n    def process_request(self, request):\n        if request.user.is_authenticated:\n            return\n\n        username = request.META.get(self.header)\n        if not username:\n            return\n\n        super().process_request(request)\n        self.process_user_groups(request.user, request.META)\n\n    @classmethod\n    def process_user_groups(cls, user, headers):\n        if not user.is_authenticated:\n            return\n\n        groups = cls.parse_user_groups_from_header(headers)\n\n        is_superuser = settings.HEADER_AUTH_ADMIN_GROUP_NAME in groups\n        if user.is_superuser != is_superuser:\n            user.is_superuser = is_superuser\n            user.save()\n\n    @classmethod\n    def parse_user_groups_from_header(cls, headers):\n        try:\n            groups_header = headers[to_django_header(settings.HEADER_AUTH_USER_GROUPS)]\n        except KeyError:\n            return []\n        else:\n            return groups_header.split(settings.HEADER_AUTH_GROUPS_SEPERATOR)",
                                "Function `process_request`\nCode:\n    def process_request(self, request):\n        if request.user.is_authenticated:\n            return\n\n        username = request.META.get(self.header)\n        if not username:\n            return\n\n        super().process_request(request)\n        self.process_user_groups(request.user, request.META)",
                                "Function `process_user_groups`\nCode:\n    def process_user_groups(cls, user, headers):\n        if not user.is_authenticated:\n            return\n\n        groups = cls.parse_user_groups_from_header(headers)\n\n        is_superuser = settings.HEADER_AUTH_ADMIN_GROUP_NAME in groups\n        if user.is_superuser != is_superuser:\n            user.is_superuser = is_superuser\n            user.save()",
                                "Function `parse_user_groups_from_header`\nCode:\n    def parse_user_groups_from_header(cls, headers):\n        try:\n            groups_header = headers[to_django_header(settings.HEADER_AUTH_USER_GROUPS)]\n        except KeyError:\n            return []\n        else:\n            return groups_header.split(settings.HEADER_AUTH_GROUPS_SEPERATOR)"
                            ],
                            "code": "import os\n\nfrom django.conf import settings\nfrom django.contrib.auth.middleware import RemoteUserMiddleware\nfrom django.utils.deprecation import MiddlewareMixin\n\n\nclass RangesMiddleware(MiddlewareMixin):\n    \"\"\"Quick solution. See:\n    https://stackoverflow.com/questions/14324250/byte-ranges-in-django/35928017#35928017\n    \"\"\"\n\n    def process_response(self, request, response):\n        if response.status_code != 200 or not hasattr(response, \"file_to_stream\"):\n            return response\n        http_range = request.META.get(\"HTTP_RANGE\")\n        if not (http_range and http_range.startswith(\"bytes=\") and http_range.count(\"-\") == 1):\n            return response\n        if_range = request.META.get(\"HTTP_IF_RANGE\")\n        if if_range and if_range != response.get(\"Last-Modified\") and if_range != response.get(\"ETag\"):\n            return response\n        f = response.file_to_stream\n        statobj = os.fstat(f.fileno())\n        start, end = http_range.split(\"=\")[1].split(\"-\")\n        if not start:  # requesting the last N bytes\n            start = max(0, statobj.st_size - int(end))\n            end = \"\"\n        start, end = int(start or 0), int(end or statobj.st_size - 1)\n        assert 0 <= start < statobj.st_size, (start, statobj.st_size)\n        end = min(end, statobj.st_size - 1)\n        f.seek(start)\n        old_read = f.read\n        f.read = lambda n: old_read(min(n, end + 1 - f.tell()))\n        response.status_code = 206\n        response[\"Content-Length\"] = end + 1 - start\n        response[\"Content-Range\"] = \"bytes %d-%d/%d\" % (start, end, statobj.st_size)\n        return response\n\n\ndef to_django_header(header):\n    return f\"HTTP_{header.replace('-', '_').upper()}\"\n\n\nclass HeaderAuthMiddleware(RemoteUserMiddleware):\n    header = to_django_header(settings.HEADER_AUTH_USER_NAME)\n\n    def process_request(self, request):\n        if request.user.is_authenticated:\n            return\n\n        username = request.META.get(self.header)\n        if not username:\n            return\n\n        super().process_request(request)\n        self.process_user_groups(request.user, request.META)\n\n    @classmethod\n    def process_user_groups(cls, user, headers):\n        if not user.is_authenticated:\n            return\n\n        groups = cls.parse_user_groups_from_header(headers)\n\n        is_superuser = settings.HEADER_AUTH_ADMIN_GROUP_NAME in groups\n        if user.is_superuser != is_superuser:\n            user.is_superuser = is_superuser\n            user.save()\n\n    @classmethod\n    def parse_user_groups_from_header(cls, headers):\n        try:\n            groups_header = headers[to_django_header(settings.HEADER_AUTH_USER_GROUPS)]\n        except KeyError:\n            return []\n        else:\n            return groups_header.split(settings.HEADER_AUTH_GROUPS_SEPERATOR)\n",
                            "summary": "Classes and functions for Django middleware that handle HTTP byte range requests, user authentication via headers, and user group management, enabling partial content delivery and user permissions processing.",
                            "code_element_summaries": [
                                "Class `RangesMiddleware`: A Django middleware that handles HTTP byte range requests to enable partial content delivery for file responses.",
                                "Function `process_response`: A function that handles HTTP range requests by validating the request and adjusting the response to stream a specific byte range from a file, returning a 206 Partial Content status when applicable.",
                                "Function `to_django_header`: Converts a given HTTP header string into a format suitable for Django by replacing hyphens with underscores and converting it to uppercase.",
                                "Class `HeaderAuthMiddleware`: A middleware that authenticates users based on headers and manages user group permissions in a Django application.",
                                "Function `process_request`: Handles user authentication and processes user groups based on request metadata if the user is not authenticated.",
                                "Function `process_user_groups`: A class method that updates a user's superuser status based on their authentication and the groups parsed from the provided headers.",
                                "Function `parse_user_groups_from_header`: A class method that extracts user groups from the provided headers, returning them as a list or an empty list if the header is not present."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A series of Django migrations that establish, modify, and manage various models and relationships within a document annotation system, including the introduction of new fields, constraints, and the deletion or alteration of existing models to enhance functionality and maintain data integrity.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Document\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\"meta\", models.TextField(default=\"{}\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"annotations_approved_by\",\n                    models.ForeignKey(\n                        null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"DocumentAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"doc_annotations\", to=\"api.Document\"\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Label\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=\"#209cee\", max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Project\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.CharField(max_length=100)),\n                (\"description\", models.TextField(default=\"\")),\n                (\"guideline\", models.TextField(default=\"\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"project_type\",\n                    models.CharField(\n                        choices=[\n                            (\"DocumentClassification\", \"document classification\"),\n                            (\"SequenceLabeling\", \"sequence labeling\"),\n                            (\"Seq2seq\", \"sequence to sequence\"),\n                        ],\n                        max_length=30,\n                    ),\n                ),\n                (\"randomize_document_order\", models.BooleanField(default=False)),\n                (\"collaborative_annotation\", models.BooleanField(default=False)),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n        ),\n        migrations.CreateModel(\n            name=\"Role\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.CharField(max_length=100, unique=True)),\n                (\"description\", models.TextField(default=\"\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"RoleMapping\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Seq2seqAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.CharField(max_length=500)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"seq2seq_annotations\",\n                        to=\"api.Document\",\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"SequenceAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"start_offset\", models.IntegerField()),\n                (\"end_offset\", models.IntegerField()),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"seq_annotations\", to=\"api.Document\"\n                    ),\n                ),\n                (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Label\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Seq2seqProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"SequenceLabelingProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"TextClassificationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"role\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Role\"),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"user\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=settings.AUTH_USER_MODEL\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"polymorphic_ctype\",\n            field=models.ForeignKey(\n                editable=False,\n                null=True,\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"polymorphic_api.project_set+\",\n                to=\"contenttypes.ContentType\",\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"users\",\n            field=models.ManyToManyField(related_name=\"projects\", to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"label\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"labels\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"documentannotation\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Label\"),\n        ),\n        migrations.AddField(\n            model_name=\"documentannotation\",\n            name=\"user\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"document\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"documents\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"sequenceannotation\",\n            unique_together={(\"document\", \"user\", \"label\", \"start_offset\", \"end_offset\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"seq2seqannotation\",\n            unique_together={(\"document\", \"user\", \"text\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"rolemapping\",\n            unique_together={(\"user\", \"project\", \"role\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"label\",\n            unique_together={(\"project\", \"text\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"documentannotation\",\n            unique_together={(\"document\", \"user\", \"label\")},\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 2.1.7 on 2019-10-25 16:26\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Document\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\"meta\", models.TextField(default=\"{}\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"annotations_approved_by\",\n                    models.ForeignKey(\n                        null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"DocumentAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"doc_annotations\", to=\"api.Document\"\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Label\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=\"#209cee\", max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Project\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.CharField(max_length=100)),\n                (\"description\", models.TextField(default=\"\")),\n                (\"guideline\", models.TextField(default=\"\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"project_type\",\n                    models.CharField(\n                        choices=[\n                            (\"DocumentClassification\", \"document classification\"),\n                            (\"SequenceLabeling\", \"sequence labeling\"),\n                            (\"Seq2seq\", \"sequence to sequence\"),\n                        ],\n                        max_length=30,\n                    ),\n                ),\n                (\"randomize_document_order\", models.BooleanField(default=False)),\n                (\"collaborative_annotation\", models.BooleanField(default=False)),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n        ),\n        migrations.CreateModel(\n            name=\"Role\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.CharField(max_length=100, unique=True)),\n                (\"description\", models.TextField(default=\"\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"RoleMapping\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Seq2seqAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.CharField(max_length=500)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"seq2seq_annotations\",\n                        to=\"api.Document\",\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"SequenceAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"start_offset\", models.IntegerField()),\n                (\"end_offset\", models.IntegerField()),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"seq_annotations\", to=\"api.Document\"\n                    ),\n                ),\n                (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Label\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Seq2seqProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"SequenceLabelingProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"TextClassificationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"role\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Role\"),\n        ),\n        migrations.AddField(\n            model_name=\"rolemapping\",\n            name=\"user\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=settings.AUTH_USER_MODEL\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"polymorphic_ctype\",\n            field=models.ForeignKey(\n                editable=False,\n                null=True,\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"polymorphic_api.project_set+\",\n                to=\"contenttypes.ContentType\",\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"users\",\n            field=models.ManyToManyField(related_name=\"projects\", to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"label\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"labels\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"documentannotation\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.Label\"),\n        ),\n        migrations.AddField(\n            model_name=\"documentannotation\",\n            name=\"user\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"document\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"documents\", to=\"api.Project\"\n            ),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"sequenceannotation\",\n            unique_together={(\"document\", \"user\", \"label\", \"start_offset\", \"end_offset\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"seq2seqannotation\",\n            unique_together={(\"document\", \"user\", \"text\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"rolemapping\",\n            unique_together={(\"user\", \"project\", \"role\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"label\",\n            unique_together={(\"project\", \"text\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"documentannotation\",\n            unique_together={(\"document\", \"user\", \"label\")},\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that sets up the models and relationships for a document annotation system, including Document, DocumentAnnotation, Label, Project, Role, and various annotation types.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A Django migration that creates models for Document, DocumentAnnotation, Label, Project, Role, and various annotation types, establishing relationships and constraints between them for a document annotation system."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_comment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0002_comment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Comment\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"comments\", to=\"api.Document\"\n                    ),\n                ),\n                (\n                    \"user\",\n                    models.ForeignKey(\n                        null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 2.1.11 on 2019-12-12 19:11\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Comment\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"comments\", to=\"api.Document\"\n                    ),\n                ),\n                (\n                    \"user\",\n                    models.ForeignKey(\n                        null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes a Comment model containing fields for text, timestamps, and foreign key associations with Document and User models.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates a Comment model with fields for text, timestamps, and foreign key relationships to Document and User models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_project_single_class_classification.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0002_project_single_class_classification.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"single_class_classification\",\n            field=models.BooleanField(default=False),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 2.1.11 on 2019-12-06 08:36\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"single_class_classification\",\n            field=models.BooleanField(default=False),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that introduces a BooleanField called \"single_class_classification\" to the \"project\" model, defaulting to False.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that adds a BooleanField named \"single_class_classification\" to the \"project\" model, with a default value of False."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_speech2text.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0002_speech2text.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Speech2textAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.TextField()),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"speech2text_annotations\",\n                        to=\"api.Document\",\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Speech2textProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"Speech2text\", \"speech to text\"),\n                ],\n                max_length=30,\n            ),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"speech2textannotation\",\n            unique_together={(\"document\", \"user\")},\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 2.1.11 on 2019-12-11 22:11\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Speech2textAnnotation\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.TextField()),\n                (\n                    \"document\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"speech2text_annotations\",\n                        to=\"api.Document\",\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Speech2textProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"Speech2text\", \"speech to text\"),\n                ],\n                max_length=30,\n            ),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"speech2textannotation\",\n            unique_together={(\"document\", \"user\")},\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that sets up the Speech2textAnnotation and Speech2textProject models, updates the project type field, and enforces unique constraints for speech-to-text annotations.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates the Speech2textAnnotation and Speech2textProject models, modifies the project type field, and establishes unique constraints for speech-to-text annotations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_merge_20200612_0205.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0003_merge_20200612_0205.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0002_speech2text\"),\n        (\"api\", \"0002_project_single_class_classification\"),\n    ]\n\n    operations = []"
                                    ],
                                    "code": "# Generated by Django 2.1.7 on 2020-06-12 02:05\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0002_speech2text\"),\n        (\"api\", \"0002_project_single_class_classification\"),\n    ]\n\n    operations = []\n",
                                    "summary": "Class Migration: A Django migration class that specifies dependencies on earlier migrations without executing any operations.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration class that defines dependencies on previous migrations without any operations to perform."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_merge_20210114_1117.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0004_merge_20210114_1117.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0002_comment\"),\n        (\"api\", \"0003_merge_20200612_0205\"),\n    ]\n\n    operations = []"
                                    ],
                                    "code": "# Generated by Django 3.1.5 on 2021-01-14 11:17\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0002_comment\"),\n        (\"api\", \"0003_merge_20200612_0205\"),\n    ]\n\n    operations = []\n",
                                    "summary": "Class Migration: A Django migration class that establishes database schema change dependencies without performing any specific operations.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration class that defines dependencies for database schema changes without any operations specified."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_auto_20210120_1730.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0005_auto_20210120_1730.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0004_merge_20210114_1117\"),\n    ]\n\n    operations = [\n        migrations.AlterModelOptions(\n            name=\"comment\",\n            options={\"ordering\": (\"-created_at\",)},\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"suffix_key\",\n            field=models.CharField(\n                blank=True,\n                choices=[\n                    (\"0\", \"0\"),\n                    (\"1\", \"1\"),\n                    (\"2\", \"2\"),\n                    (\"3\", \"3\"),\n                    (\"4\", \"4\"),\n                    (\"5\", \"5\"),\n                    (\"6\", \"6\"),\n                    (\"7\", \"7\"),\n                    (\"8\", \"8\"),\n                    (\"9\", \"9\"),\n                    (\"a\", \"a\"),\n                    (\"b\", \"b\"),\n                    (\"c\", \"c\"),\n                    (\"d\", \"d\"),\n                    (\"e\", \"e\"),\n                    (\"f\", \"f\"),\n                    (\"g\", \"g\"),\n                    (\"h\", \"h\"),\n                    (\"i\", \"i\"),\n                    (\"j\", \"j\"),\n                    (\"k\", \"k\"),\n                    (\"l\", \"l\"),\n                    (\"m\", \"m\"),\n                    (\"n\", \"n\"),\n                    (\"o\", \"o\"),\n                    (\"p\", \"p\"),\n                    (\"q\", \"q\"),\n                    (\"r\", \"r\"),\n                    (\"s\", \"s\"),\n                    (\"t\", \"t\"),\n                    (\"u\", \"u\"),\n                    (\"v\", \"v\"),\n                    (\"w\", \"w\"),\n                    (\"x\", \"x\"),\n                    (\"y\", \"y\"),\n                    (\"z\", \"z\"),\n                ],\n                max_length=1,\n                null=True,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 2.2.13 on 2021-01-20 17:30\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0004_merge_20210114_1117\"),\n    ]\n\n    operations = [\n        migrations.AlterModelOptions(\n            name=\"comment\",\n            options={\"ordering\": (\"-created_at\",)},\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"suffix_key\",\n            field=models.CharField(\n                blank=True,\n                choices=[\n                    (\"0\", \"0\"),\n                    (\"1\", \"1\"),\n                    (\"2\", \"2\"),\n                    (\"3\", \"3\"),\n                    (\"4\", \"4\"),\n                    (\"5\", \"5\"),\n                    (\"6\", \"6\"),\n                    (\"7\", \"7\"),\n                    (\"8\", \"8\"),\n                    (\"9\", \"9\"),\n                    (\"a\", \"a\"),\n                    (\"b\", \"b\"),\n                    (\"c\", \"c\"),\n                    (\"d\", \"d\"),\n                    (\"e\", \"e\"),\n                    (\"f\", \"f\"),\n                    (\"g\", \"g\"),\n                    (\"h\", \"h\"),\n                    (\"i\", \"i\"),\n                    (\"j\", \"j\"),\n                    (\"k\", \"k\"),\n                    (\"l\", \"l\"),\n                    (\"m\", \"m\"),\n                    (\"n\", \"n\"),\n                    (\"o\", \"o\"),\n                    (\"p\", \"p\"),\n                    (\"q\", \"q\"),\n                    (\"r\", \"r\"),\n                    (\"s\", \"s\"),\n                    (\"t\", \"t\"),\n                    (\"u\", \"u\"),\n                    (\"v\", \"v\"),\n                    (\"w\", \"w\"),\n                    (\"x\", \"x\"),\n                    (\"y\", \"y\"),\n                    (\"z\", \"z\"),\n                ],\n                max_length=1,\n                null=True,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that changes the order of comments and updates the suffix_key field of the label model to permit specific character selections.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the ordering of comments and modifies the suffix_key field of the label model to allow for specific character choices."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_auto_20210201_0603.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0005_auto_20210201_0603.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0004_merge_20210114_1117\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"suffix_key\",\n            field=models.CharField(\n                blank=True,\n                choices=[\n                    (\"0\", \"0\"),\n                    (\"1\", \"1\"),\n                    (\"2\", \"2\"),\n                    (\"3\", \"3\"),\n                    (\"4\", \"4\"),\n                    (\"5\", \"5\"),\n                    (\"6\", \"6\"),\n                    (\"7\", \"7\"),\n                    (\"8\", \"8\"),\n                    (\"9\", \"9\"),\n                    (\"a\", \"a\"),\n                    (\"b\", \"b\"),\n                    (\"c\", \"c\"),\n                    (\"d\", \"d\"),\n                    (\"e\", \"e\"),\n                    (\"f\", \"f\"),\n                    (\"g\", \"g\"),\n                    (\"h\", \"h\"),\n                    (\"i\", \"i\"),\n                    (\"j\", \"j\"),\n                    (\"k\", \"k\"),\n                    (\"l\", \"l\"),\n                    (\"m\", \"m\"),\n                    (\"n\", \"n\"),\n                    (\"o\", \"o\"),\n                    (\"p\", \"p\"),\n                    (\"q\", \"q\"),\n                    (\"r\", \"r\"),\n                    (\"s\", \"s\"),\n                    (\"t\", \"t\"),\n                    (\"u\", \"u\"),\n                    (\"v\", \"v\"),\n                    (\"w\", \"w\"),\n                    (\"x\", \"x\"),\n                    (\"y\", \"y\"),\n                    (\"z\", \"z\"),\n                ],\n                max_length=1,\n                null=True,\n            ),\n        ),\n        migrations.CreateModel(\n            name=\"AutoLabelingConfig\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"model_name\", models.CharField(max_length=100)),\n                (\"model_attrs\", models.JSONField(default=dict)),\n                (\"template\", models.TextField(default=\"\")),\n                (\"label_mapping\", models.JSONField(default=dict)),\n                (\"default\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"auto_labeling_config\",\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.5 on 2021-02-01 06:03\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0004_merge_20210114_1117\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"suffix_key\",\n            field=models.CharField(\n                blank=True,\n                choices=[\n                    (\"0\", \"0\"),\n                    (\"1\", \"1\"),\n                    (\"2\", \"2\"),\n                    (\"3\", \"3\"),\n                    (\"4\", \"4\"),\n                    (\"5\", \"5\"),\n                    (\"6\", \"6\"),\n                    (\"7\", \"7\"),\n                    (\"8\", \"8\"),\n                    (\"9\", \"9\"),\n                    (\"a\", \"a\"),\n                    (\"b\", \"b\"),\n                    (\"c\", \"c\"),\n                    (\"d\", \"d\"),\n                    (\"e\", \"e\"),\n                    (\"f\", \"f\"),\n                    (\"g\", \"g\"),\n                    (\"h\", \"h\"),\n                    (\"i\", \"i\"),\n                    (\"j\", \"j\"),\n                    (\"k\", \"k\"),\n                    (\"l\", \"l\"),\n                    (\"m\", \"m\"),\n                    (\"n\", \"n\"),\n                    (\"o\", \"o\"),\n                    (\"p\", \"p\"),\n                    (\"q\", \"q\"),\n                    (\"r\", \"r\"),\n                    (\"s\", \"s\"),\n                    (\"t\", \"t\"),\n                    (\"u\", \"u\"),\n                    (\"v\", \"v\"),\n                    (\"w\", \"w\"),\n                    (\"x\", \"x\"),\n                    (\"y\", \"y\"),\n                    (\"z\", \"z\"),\n                ],\n                max_length=1,\n                null=True,\n            ),\n        ),\n        migrations.CreateModel(\n            name=\"AutoLabelingConfig\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"model_name\", models.CharField(max_length=100)),\n                (\"model_attrs\", models.JSONField(default=dict)),\n                (\"template\", models.TextField(default=\"\")),\n                (\"label_mapping\", models.JSONField(default=dict)),\n                (\"default\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"auto_labeling_config\",\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the \"suffix_key\" field in the \"label\" model and introduces a new model called \"AutoLabelingConfig\" with multiple fields and relationships.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the \"suffix_key\" field of the \"label\" model and creates a new model called \"AutoLabelingConfig\" with various fields and relationships."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0006_merge_20210221_1258.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0006_merge_20210221_1258.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0005_auto_20210201_0603\"),\n        (\"api\", \"0005_auto_20210120_1730\"),\n    ]\n\n    operations = []"
                                    ],
                                    "code": "# Generated by Django 3.1.6 on 2021-02-21 12:58\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0005_auto_20210201_0603\"),\n        (\"api\", \"0005_auto_20210120_1730\"),\n    ]\n\n    operations = []\n",
                                    "summary": "Class Migration: A Django migration class that outlines dependencies for database schema modifications without performing any operations.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration class that specifies dependencies for database schema changes without any operations defined."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0007_auto_20210301_0302.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0007_auto_20210301_0302.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0006_merge_20210221_1258\"),\n    ]\n\n    operations = [\n        migrations.AlterUniqueTogether(\n            name=\"rolemapping\",\n            unique_together={(\"user\", \"project\")},\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.6 on 2021-03-01 03:02\n\nfrom django.conf import settings\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0006_merge_20210221_1258\"),\n    ]\n\n    operations = [\n        migrations.AlterUniqueTogether(\n            name=\"rolemapping\",\n            unique_together={(\"user\", \"project\")},\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies unique constraints on the RoleMapping model to enforce unique user-project combinations.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the unique constraints for the RoleMapping model to ensure unique combinations of user and project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0008_auto_20210302_1013.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0008_auto_20210302_1013.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0007_auto_20210301_0302\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"guideline\",\n            field=models.TextField(blank=True, default=\"\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.6 on 2021-03-02 10:13\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0007_auto_20210301_0302\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"guideline\",\n            field=models.TextField(blank=True, default=\"\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the 'guideline' field of the 'project' model to be a blankable TextField with a default value of an empty string.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the 'guideline' field of the 'project' model to be a blankable TextField with a default value of an empty string."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0009_annotations_relations_20210421_1445.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0009_annotations_relations_20210421_1445.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(  # id_autogen, annotation_id_1, annotation_id_2, type, author, timestamp\n            name=\"RelationTypes\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.TextField(max_length=50)),\n                (\"color\", models.TextField(max_length=20)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"relation_types\", to=\"api.Project\"\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(  # id_autogen, annotation_id_1, annotation_id_2, type, author, timestamp\n            name=\"AnnotationRelations\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"annotation_id_1\", models.IntegerField()),\n                (\"annotation_id_2\", models.IntegerField()),\n                (\"type\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.RelationTypes\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n                (\"timestamp\", models.DateTimeField(auto_now_add=True)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.6 on 2021-03-02 10:13\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(  # id_autogen, annotation_id_1, annotation_id_2, type, author, timestamp\n            name=\"RelationTypes\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"name\", models.TextField(max_length=50)),\n                (\"color\", models.TextField(max_length=20)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"relation_types\", to=\"api.Project\"\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(  # id_autogen, annotation_id_1, annotation_id_2, type, author, timestamp\n            name=\"AnnotationRelations\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"annotation_id_1\", models.IntegerField()),\n                (\"annotation_id_2\", models.IntegerField()),\n                (\"type\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.RelationTypes\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n                (\"timestamp\", models.DateTimeField(auto_now_add=True)),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"api.Project\",\n                    ),\n                ),\n            ],\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes two models, RelationTypes and AnnotationRelations, to effectively manage annotation relationships within a project.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates two models, RelationTypes and AnnotationRelations, with specified fields and relationships to manage annotation relations in a project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0009_auto_20210411_2330.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0009_auto_20210411_2330.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"document\",\n            name=\"meta\",\n            field=models.JSONField(default=dict),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.7 on 2021-04-11 23:30\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"document\",\n            name=\"meta\",\n            field=models.JSONField(default=dict),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the \"meta\" field of the \"document\" model to utilize a JSONField, setting its default value to an empty dictionary.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the \"meta\" field of the \"document\" model to use a JSONField with a default value of an empty dictionary."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0009_tag.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0009_tag.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Tag\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"tags\", to=\"api.project\"\n                    ),\n                ),\n            ],\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2 on 2021-04-13 16:50\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0008_auto_20210302_1013\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Tag\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.TextField()),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"tags\", to=\"api.project\"\n                    ),\n                ),\n            ],\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes a new Tag model featuring an auto-generated ID, text field, and a foreign key linking to the Project model.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates a new model called Tag with fields for an auto-generated ID, text, and a foreign key relationship to the Project model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0010_auto_20210413_0249.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0010_auto_20210413_0249.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0009_auto_20210411_2330\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"document\",\n            name=\"filename\",\n            field=models.FilePathField(default=\"\"),\n        ),\n        migrations.AlterField(\n            model_name=\"document\",\n            name=\"annotations_approved_by\",\n            field=models.ForeignKey(\n                blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.1.7 on 2021-04-13 02:49\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0009_auto_20210411_2330\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"document\",\n            name=\"filename\",\n            field=models.FilePathField(default=\"\"),\n        ),\n        migrations.AlterField(\n            model_name=\"document\",\n            name=\"annotations_approved_by\",\n            field=models.ForeignKey(\n                blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the 'document' model by adding a 'filename' field and updating the 'annotations_approved_by' field to permit null values while establishing a foreign key relationship with the user model.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that adds a 'filename' field to the 'document' model and alters the 'annotations_approved_by' field to allow null values and set the foreign key relationship to the user model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0011_merge_0009_tag_0010_auto_20210413_0249.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0011_merge_0009_tag_0010_auto_20210413_0249.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0009_tag\"),\n        (\"api\", \"0010_auto_20210413_0249\"),\n    ]\n\n    operations = []"
                                    ],
                                    "code": "# Generated by Django 3.2 on 2021-04-20 22:33\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0009_tag\"),\n        (\"api\", \"0010_auto_20210413_0249\"),\n    ]\n\n    operations = []\n",
                                    "summary": "Class Migration: A Django migration class that establishes dependencies on earlier migrations while omitting any operational changes.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration class that defines dependencies on previous migrations without specifying any operations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0012_auto_20210514_0654.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0012_auto_20210514_0654.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0011_merge_0009_tag_0010_auto_20210413_0249\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Category\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Example\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"meta\", models.JSONField(default=dict)),\n                (\"filename\", models.FileField(default=\".\", upload_to=\"\")),\n                (\"text\", models.TextField(blank=True, null=True)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"annotations_approved_by\",\n                    models.ForeignKey(\n                        blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"ImageClassificationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"Span\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"start_offset\", models.IntegerField()),\n                (\"end_offset\", models.IntegerField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"api.example\"\n                    ),\n                ),\n                (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.label\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"user\", \"label\", \"start_offset\", \"end_offset\")},\n            },\n        ),\n        migrations.CreateModel(\n            name=\"TextLabel\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.TextField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"api.example\"\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"user\", \"text\")},\n            },\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"documentannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"seq2seqannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"seq2seqannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"seq2seqannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"sequenceannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"speech2textannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"speech2textannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"speech2textannotation\",\n            name=\"user\",\n        ),\n        migrations.RenameField(\n            model_name=\"project\",\n            old_name=\"randomize_document_order\",\n            new_name=\"random_order\",\n        ),\n        migrations.RemoveField(\n            model_name=\"comment\",\n            name=\"document\",\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                ],\n                max_length=30,\n            ),\n        ),\n        migrations.DeleteModel(\n            name=\"Document\",\n        ),\n        migrations.DeleteModel(\n            name=\"DocumentAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"Seq2seqAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"SequenceAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"Speech2textAnnotation\",\n        ),\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"api.project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"example\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"api.example\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.label\"),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"user\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"comment\",\n            name=\"example\",\n            field=models.ForeignKey(\n                default=1, on_delete=django.db.models.deletion.CASCADE, related_name=\"comments\", to=\"api.example\"\n            ),\n            preserve_default=False,\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"category\",\n            unique_together={(\"example\", \"user\", \"label\")},\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2 on 2021-05-14 06:54\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0011_merge_0009_tag_0010_auto_20210413_0249\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Category\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Example\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"meta\", models.JSONField(default=dict)),\n                (\"filename\", models.FileField(default=\".\", upload_to=\"\")),\n                (\"text\", models.TextField(blank=True, null=True)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"annotations_approved_by\",\n                    models.ForeignKey(\n                        blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                    ),\n                ),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"ImageClassificationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.CreateModel(\n            name=\"Span\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"start_offset\", models.IntegerField()),\n                (\"end_offset\", models.IntegerField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"api.example\"\n                    ),\n                ),\n                (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.label\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"user\", \"label\", \"start_offset\", \"end_offset\")},\n            },\n        ),\n        migrations.CreateModel(\n            name=\"TextLabel\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"text\", models.TextField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"api.example\"\n                    ),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"user\", \"text\")},\n            },\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"documentannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"documentannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"seq2seqannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"seq2seqannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"seq2seqannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"sequenceannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"sequenceannotation\",\n            name=\"user\",\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"speech2textannotation\",\n            unique_together=None,\n        ),\n        migrations.RemoveField(\n            model_name=\"speech2textannotation\",\n            name=\"document\",\n        ),\n        migrations.RemoveField(\n            model_name=\"speech2textannotation\",\n            name=\"user\",\n        ),\n        migrations.RenameField(\n            model_name=\"project\",\n            old_name=\"randomize_document_order\",\n            new_name=\"random_order\",\n        ),\n        migrations.RemoveField(\n            model_name=\"comment\",\n            name=\"document\",\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                ],\n                max_length=30,\n            ),\n        ),\n        migrations.DeleteModel(\n            name=\"Document\",\n        ),\n        migrations.DeleteModel(\n            name=\"DocumentAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"Seq2seqAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"SequenceAnnotation\",\n        ),\n        migrations.DeleteModel(\n            name=\"Speech2textAnnotation\",\n        ),\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"project\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"api.project\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"example\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"api.example\"\n            ),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.label\"),\n        ),\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"user\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n        ),\n        migrations.AddField(\n            model_name=\"comment\",\n            name=\"example\",\n            field=models.ForeignKey(\n                default=1, on_delete=django.db.models.deletion.CASCADE, related_name=\"comments\", to=\"api.example\"\n            ),\n            preserve_default=False,\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"category\",\n            unique_together={(\"example\", \"user\", \"label\")},\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes new models for Category, Example, ImageClassificationProject, Span, and TextLabel, while also altering existing fields and relationships and eliminating outdated models associated with document annotations.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates new models for Category, Example, ImageClassificationProject, Span, and TextLabel, modifies existing fields and relationships, and removes obsolete models related to document annotations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0013_merge_20210528_1016.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0013_merge_20210528_1016.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0009_annotations_relations_20210421_1445\"),\n        (\"api\", \"0012_auto_20210514_0654\"),\n    ]\n\n    operations = []"
                                    ],
                                    "code": "# Generated by Django 3.2.3 on 2021-05-28 10:16\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0009_annotations_relations_20210421_1445\"),\n        (\"api\", \"0012_auto_20210514_0654\"),\n    ]\n\n    operations = []\n",
                                    "summary": "Class Migration: A Django migration class that specifies dependencies on earlier migrations without executing any operations.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration class that defines dependencies on previous migrations without any operations to perform."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0014_auto_20210603_0438.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0014_auto_20210603_0438.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0013_merge_20210528_1016\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"timestamp\",\n            field=models.DateTimeField(),\n        ),\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"type\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"annotation_relations\", to=\"api.relationtypes\"\n            ),\n        ),\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"user\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"annotation_relations\",\n                to=settings.AUTH_USER_MODEL,\n            ),\n        ),\n        migrations.AlterField(\n            model_name=\"relationtypes\",\n            name=\"color\",\n            field=models.TextField(),\n        ),\n        migrations.AlterField(\n            model_name=\"relationtypes\",\n            name=\"name\",\n            field=models.TextField(),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"annotationrelations\",\n            unique_together={(\"annotation_id_1\", \"annotation_id_2\", \"type\", \"project\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"relationtypes\",\n            unique_together={(\"color\", \"name\")},\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.3 on 2021-06-03 04:38\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0013_merge_20210528_1016\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"timestamp\",\n            field=models.DateTimeField(),\n        ),\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"type\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE, related_name=\"annotation_relations\", to=\"api.relationtypes\"\n            ),\n        ),\n        migrations.AlterField(\n            model_name=\"annotationrelations\",\n            name=\"user\",\n            field=models.ForeignKey(\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"annotation_relations\",\n                to=settings.AUTH_USER_MODEL,\n            ),\n        ),\n        migrations.AlterField(\n            model_name=\"relationtypes\",\n            name=\"color\",\n            field=models.TextField(),\n        ),\n        migrations.AlterField(\n            model_name=\"relationtypes\",\n            name=\"name\",\n            field=models.TextField(),\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"annotationrelations\",\n            unique_together={(\"annotation_id_1\", \"annotation_id_2\", \"type\", \"project\")},\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"relationtypes\",\n            unique_together={(\"color\", \"name\")},\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies fields and establishes unique constraints for the `annotationrelations` and `relationtypes` models in the application.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters fields and sets unique constraints for the `annotationrelations` and `relationtypes` models within the application."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0015_examplestate.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0015_examplestate.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0014_auto_20210603_0438\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExampleState\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"confirmed_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"confirmed_by\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"states\", to=\"api.example\"\n                    ),\n                ),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"confirmed_by\")},\n            },\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.3 on 2021-06-07 01:48\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0014_auto_20210603_0438\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExampleState\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"confirmed_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"confirmed_by\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"states\", to=\"api.example\"\n                    ),\n                ),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"confirmed_by\")},\n            },\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes the ExampleState model with fields for confirmation timestamp and user, while enforcing a unique constraint on the combination of example and confirmed_by.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates the ExampleState model with fields for confirmation timestamp and user, enforcing a unique constraint on the combination of example and confirmed_by."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0016_auto_20211018_0556.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0016_auto_20211018_0556.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0015_examplestate\"),\n    ]\n\n    operations = [\n        migrations.AlterModelOptions(\n            name=\"comment\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AlterModelOptions(\n            name=\"example\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AlterModelOptions(\n            name=\"label\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"allow_overlapping\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"grapheme_mode\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AlterField(\n            model_name=\"autolabelingconfig\",\n            name=\"label_mapping\",\n            field=models.JSONField(blank=True, default=dict),\n        ),\n        migrations.AlterField(\n            model_name=\"comment\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"filename\",\n            field=models.FileField(default=\".\", max_length=1024, upload_to=\"\"),\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"text\",\n            field=models.CharField(db_index=True, max_length=100),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.4 on 2021-10-18 05:56\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0015_examplestate\"),\n    ]\n\n    operations = [\n        migrations.AlterModelOptions(\n            name=\"comment\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AlterModelOptions(\n            name=\"example\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AlterModelOptions(\n            name=\"label\",\n            options={\"ordering\": [\"created_at\"]},\n        ),\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"allow_overlapping\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"grapheme_mode\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AlterField(\n            model_name=\"autolabelingconfig\",\n            name=\"label_mapping\",\n            field=models.JSONField(blank=True, default=dict),\n        ),\n        migrations.AlterField(\n            model_name=\"comment\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"filename\",\n            field=models.FileField(default=\".\", max_length=1024, upload_to=\"\"),\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"created_at\",\n            field=models.DateTimeField(auto_now_add=True, db_index=True),\n        ),\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"text\",\n            field=models.CharField(db_index=True, max_length=100),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that alters model options and fields for Comment, Example, Label, and SequenceLabelingProject models, focusing on ordering by creation date and introducing new fields.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that modifies model options and fields for the Comment, Example, Label, and SequenceLabelingProject models, including setting ordering by creation date and adding new fields."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0017_example_uuid.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0017_example_uuid.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `create_uuid`\nCode:\ndef create_uuid(apps, schema_editor):\n    Example = apps.get_model(\"api\", \"example\")\n    for example in Example.objects.all():\n        example.uuid = uuid.uuid4()\n        example.save(update_fields=[\"uuid\"])",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0016_auto_20211018_0556\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"uuid\",\n            field=models.UUIDField(editable=False, blank=True, null=True),\n        ),\n        migrations.RunPython(create_uuid, reverse_code=migrations.RunPython.noop),\n        migrations.AlterField(\n            model_name=\"example\", name=\"uuid\", field=models.UUIDField(default=uuid.uuid4, db_index=True, unique=True)\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-11-08 06:06\n\nimport uuid\n\nfrom django.db import migrations, models\n\n\ndef create_uuid(apps, schema_editor):\n    Example = apps.get_model(\"api\", \"example\")\n    for example in Example.objects.all():\n        example.uuid = uuid.uuid4()\n        example.save(update_fields=[\"uuid\"])\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0016_auto_20211018_0556\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"uuid\",\n            field=models.UUIDField(editable=False, blank=True, null=True),\n        ),\n        migrations.RunPython(create_uuid, reverse_code=migrations.RunPython.noop),\n        migrations.AlterField(\n            model_name=\"example\", name=\"uuid\", field=models.UUIDField(default=uuid.uuid4, db_index=True, unique=True)\n        ),\n    ]\n",
                                    "summary": "Function `create_uuid` and Class Migration: A function that generates unique UUIDs for instances of the Example model, accompanied by a Django migration that adds a UUID field with default values, uniqueness, and indexing to the model.",
                                    "code_element_summaries": [
                                        "Function `create_uuid`: A function that generates and assigns a unique UUID to each instance of the Example model in the database.",
                                        "Class Migration: A Django migration that adds a UUID field to the \"example\" model, sets a default value, and ensures uniqueness and indexing."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0018_alter_label_background_color.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0018_alter_label_background_color.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0017_example_uuid\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"background_color\",\n            field=models.CharField(default=generate_random_hex_color, max_length=7),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-11-17 05:56\n\nfrom django.db import migrations, models\nfrom label_types.models import generate_random_hex_color\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0017_example_uuid\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"label\",\n            name=\"background_color\",\n            field=models.CharField(default=generate_random_hex_color, max_length=7),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the `background_color` field of the `label` model to utilize a default value created by the `generate_random_hex_color` function.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A Django migration that alters the `background_color` field of the `label` model to use a default value generated by the `generate_random_hex_color` function."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0019_auto_20211124_0506.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0019_auto_20211124_0506.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0018_alter_label_background_color\"),\n    ]\n\n    operations = [\n        migrations.AlterUniqueTogether(\n            name=\"span\",\n            unique_together=set(),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(check=models.Q((\"start_offset__gte\", 0)), name=\"startOffset >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(check=models.Q((\"end_offset__gte\", 0)), name=\"endOffset >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(\n                check=models.Q((\"start_offset__lt\", django.db.models.expressions.F(\"end_offset\"))), name=\"start < end\"\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-11-24 05:06\n\nimport django.db.models.expressions\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0018_alter_label_background_color\"),\n    ]\n\n    operations = [\n        migrations.AlterUniqueTogether(\n            name=\"span\",\n            unique_together=set(),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(check=models.Q((\"start_offset__gte\", 0)), name=\"startOffset >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(check=models.Q((\"end_offset__gte\", 0)), name=\"endOffset >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"span\",\n            constraint=models.CheckConstraint(\n                check=models.Q((\"start_offset__lt\", django.db.models.expressions.F(\"end_offset\"))), name=\"start < end\"\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that alters the unique constraints of the `span` model and introduces multiple check constraints to validate offset values.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that modifies the `span` model's unique constraints and adds several check constraints to ensure valid offset values."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0020_auto_20211221_1415.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0020_auto_20211221_1415.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0019_auto_20211124_0506\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"CategoryType\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=generate_random_hex_color, max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.CreateModel(\n            name=\"SpanType\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=generate_random_hex_color, max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"label\",\n            unique_together=set(),\n        ),\n        migrations.AddConstraint(\n            model_name=\"label\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_label_is_unique\"),\n        ),\n        migrations.AddField(\n            model_name=\"spantype\",\n            name=\"project\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\"),\n        ),\n        migrations.AddField(\n            model_name=\"categorytype\",\n            name=\"project\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"spantype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_spantype_is_unique\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"categorytype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_categorytype_is_unique\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-12-21 14:15\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\nfrom label_types.models import generate_random_hex_color\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0019_auto_20211124_0506\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"CategoryType\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=generate_random_hex_color, max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.CreateModel(\n            name=\"SpanType\",\n            fields=[\n                (\"id\", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\"background_color\", models.CharField(default=generate_random_hex_color, max_length=7)),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.AlterUniqueTogether(\n            name=\"label\",\n            unique_together=set(),\n        ),\n        migrations.AddConstraint(\n            model_name=\"label\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_label_is_unique\"),\n        ),\n        migrations.AddField(\n            model_name=\"spantype\",\n            name=\"project\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\"),\n        ),\n        migrations.AddField(\n            model_name=\"categorytype\",\n            name=\"project\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"spantype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_spantype_is_unique\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"categorytype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"api_categorytype_is_unique\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that introduces the CategoryType and SpanType models, defining their fields, constraints, and interdependencies with existing API models.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates two new models, CategoryType and SpanType, with various fields and constraints, and establishes dependencies between them and existing models in the API."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0021_auto_20211221_1416.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0021_auto_20211221_1416.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `copy_label_to_subclass`\nCode:\ndef copy_label_to_subclass(apps, schema_editor):\n    Label = apps.get_model(\"api\", \"Label\")\n    for label in Label.objects.all():\n        project_type = label.project.project_type\n        if project_type.endswith(\"Classification\"):\n            model = apps.get_model(\"api\", \"CategoryType\")\n        else:\n            model = apps.get_model(\"api\", \"SpanType\")\n        model.objects.create(\n            id=label.id,\n            text=label.text,\n            prefix_key=label.prefix_key,\n            suffix_key=label.suffix_key,\n            project=label.project,\n            background_color=label.background_color,\n            text_color=label.text_color,\n            created_at=label.created_at,\n            updated_at=label.updated_at,\n        )",
                                        "Function `delete_subclass_object`\nCode:\ndef delete_subclass_object(apps, schema_editor):\n    CategoryType = apps.get_model(\"api\", \"CategoryType\")\n    SpanType = apps.get_model(\"api\", \"SpanType\")\n    Label = apps.get_model(\"api\", \"Label\")\n    for model in [CategoryType, SpanType]:\n        for label in model.objects.all():\n            old_label = Label(\n                id=label.id,\n                text=label.text,\n                prefix_key=label.prefix_key,\n                suffix_key=label.suffix_key,\n                project=label.project,\n                background_color=label.background_color,\n                text_color=label.text_color,\n                created_at=label.created_at,\n                updated_at=label.updated_at,\n            )\n            label.delete()\n            old_label.save()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0020_auto_20211221_1415\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_label_to_subclass, reverse_code=delete_subclass_object),\n    ]"
                                    ],
                                    "code": "from django.db import migrations\n\n\ndef copy_label_to_subclass(apps, schema_editor):\n    Label = apps.get_model(\"api\", \"Label\")\n    for label in Label.objects.all():\n        project_type = label.project.project_type\n        if project_type.endswith(\"Classification\"):\n            model = apps.get_model(\"api\", \"CategoryType\")\n        else:\n            model = apps.get_model(\"api\", \"SpanType\")\n        model.objects.create(\n            id=label.id,\n            text=label.text,\n            prefix_key=label.prefix_key,\n            suffix_key=label.suffix_key,\n            project=label.project,\n            background_color=label.background_color,\n            text_color=label.text_color,\n            created_at=label.created_at,\n            updated_at=label.updated_at,\n        )\n\n\ndef delete_subclass_object(apps, schema_editor):\n    CategoryType = apps.get_model(\"api\", \"CategoryType\")\n    SpanType = apps.get_model(\"api\", \"SpanType\")\n    Label = apps.get_model(\"api\", \"Label\")\n    for model in [CategoryType, SpanType]:\n        for label in model.objects.all():\n            old_label = Label(\n                id=label.id,\n                text=label.text,\n                prefix_key=label.prefix_key,\n                suffix_key=label.suffix_key,\n                project=label.project,\n                background_color=label.background_color,\n                text_color=label.text_color,\n                created_at=label.created_at,\n                updated_at=label.updated_at,\n            )\n            label.delete()\n            old_label.save()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0020_auto_20211221_1415\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_label_to_subclass, reverse_code=delete_subclass_object),\n    ]\n",
                                    "summary": "Functions `copy_label_to_subclass` and `delete_subclass_object`, along with the class Migration, collectively facilitate the migration of Label objects to specific subclasses and manage the deletion of subclass instances while preserving their labels in a Django database context.",
                                    "code_element_summaries": [
                                        "Function `copy_label_to_subclass`: A database migration function that copies Label objects to either CategoryType or SpanType subclasses based on the project type associated with each label.",
                                        "Function `delete_subclass_object`: A function that deletes instances of CategoryType and SpanType models and saves their corresponding labels as new Label instances.",
                                        "Class Migration: A Django migration that establishes dependencies and defines operations to run Python code for copying and deleting subclass objects."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0022_auto_20211221_1430.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0022_auto_20211221_1430.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0021_auto_20211221_1416\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"new_label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.categorytype\"),\n        ),\n        migrations.AddField(\n            model_name=\"span\",\n            name=\"new_label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.spantype\"),\n        ),\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.label\"),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.label\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-12-21 14:30\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0021_auto_20211221_1416\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"new_label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.categorytype\"),\n        ),\n        migrations.AddField(\n            model_name=\"span\",\n            name=\"new_label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.spantype\"),\n        ),\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.label\"),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"label\",\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to=\"api.label\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the Category and Span models by adding and altering fields, while updating their foreign key relationships.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that adds and alters fields in the Category and Span models, updating their relationships with foreign key references."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0023_auto_20211221_1430.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0023_auto_20211221_1430.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `copy_annotation`\nCode:\ndef copy_annotation(apps, schema_editor):\n    Category = apps.get_model(\"api\", \"Category\")\n    Span = apps.get_model(\"api\", \"Span\")\n    for model in [Category, Span]:\n        for annotation in model.objects.all():\n            if model == Category:\n                LabelModel = apps.get_model(\"api\", \"CategoryType\")\n            else:\n                LabelModel = apps.get_model(\"api\", \"SpanType\")\n            label = LabelModel.objects.get(pk=annotation.label.id)\n            annotation.new_label = label\n            annotation.save()",
                                        "Function `delete_annotation`\nCode:\ndef delete_annotation(apps, schema_editor):\n    Category = apps.get_model(\"api\", \"Category\")\n    Span = apps.get_model(\"api\", \"Span\")\n    for model in [Category, Span]:\n        for annotation in model.objects.all():\n            annotation.new_label = None\n            annotation.save()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0022_auto_20211221_1430\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_annotation, reverse_code=delete_annotation),\n    ]"
                                    ],
                                    "code": "from django.db import migrations\n\n\ndef copy_annotation(apps, schema_editor):\n    Category = apps.get_model(\"api\", \"Category\")\n    Span = apps.get_model(\"api\", \"Span\")\n    for model in [Category, Span]:\n        for annotation in model.objects.all():\n            if model == Category:\n                LabelModel = apps.get_model(\"api\", \"CategoryType\")\n            else:\n                LabelModel = apps.get_model(\"api\", \"SpanType\")\n            label = LabelModel.objects.get(pk=annotation.label.id)\n            annotation.new_label = label\n            annotation.save()\n\n\ndef delete_annotation(apps, schema_editor):\n    Category = apps.get_model(\"api\", \"Category\")\n    Span = apps.get_model(\"api\", \"Span\")\n    for model in [Category, Span]:\n        for annotation in model.objects.all():\n            annotation.new_label = None\n            annotation.save()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0022_auto_20211221_1430\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_annotation, reverse_code=delete_annotation),\n    ]\n",
                                    "summary": "Functions `copy_annotation` and `delete_annotation`, along with the class `Migration`, collectively manage the migration of annotation data in the database by copying existing annotations with updated labels and removing label associations from specified models.",
                                    "code_element_summaries": [
                                        "Function `copy_annotation`: A database migration function that copies annotations from existing models (Category and Span) and updates their labels to new corresponding label types.",
                                        "Function `delete_annotation`: A migration function that sets the `new_label` attribute of all `Category` and `Span` annotations to `None`.",
                                        "Class Migration: A Django migration that defines dependencies and operations to copy and delete annotations in the database."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0024_auto_20211221_1444.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0024_auto_20211221_1444.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0023_auto_20211221_1430\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"category\",\n            name=\"new_label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"span\",\n            name=\"new_label\",\n        ),\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.categorytype\"),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.spantype\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-12-21 14:44\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0023_auto_20211221_1430\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"category\",\n            name=\"new_label\",\n        ),\n        migrations.RemoveField(\n            model_name=\"span\",\n            name=\"new_label\",\n        ),\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.categorytype\"),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"label\",\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.spantype\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that updates the database schema by removing fields from the 'category' and 'span' models and modifying the 'label' fields to create foreign key relationships.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that modifies the database schema by removing fields from the 'category' and 'span' models and altering the 'label' fields to establish foreign key relationships."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0025_auto_20220107_0158.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0025_auto_20220107_0158.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `recover_label`\nCode:\ndef recover_label(apps, schema_editor):\n    CategoryType = apps.get_model(\"api\", \"CategoryType\")\n    SpanType = apps.get_model(\"api\", \"SpanType\")\n    Label = apps.get_model(\"api\", \"Label\")\n    for model in [CategoryType, SpanType]:\n        for label in model.objects.all():\n            old_label = Label(\n                id=label.id,\n                text=label.text,\n                prefix_key=label.prefix_key,\n                suffix_key=label.suffix_key,\n                project=label.project,\n                background_color=label.background_color,\n                text_color=label.text_color,\n                created_at=label.created_at,\n                updated_at=label.updated_at,\n            )\n            old_label.save()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0024_auto_20211221_1444\"),\n    ]\n\n    operations = [migrations.RunPython(code=migrations.RunPython.noop, reverse_code=recover_label)]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-07 01:58\n\nfrom django.db import migrations\n\n\ndef recover_label(apps, schema_editor):\n    CategoryType = apps.get_model(\"api\", \"CategoryType\")\n    SpanType = apps.get_model(\"api\", \"SpanType\")\n    Label = apps.get_model(\"api\", \"Label\")\n    for model in [CategoryType, SpanType]:\n        for label in model.objects.all():\n            old_label = Label(\n                id=label.id,\n                text=label.text,\n                prefix_key=label.prefix_key,\n                suffix_key=label.suffix_key,\n                project=label.project,\n                background_color=label.background_color,\n                text_color=label.text_color,\n                created_at=label.created_at,\n                updated_at=label.updated_at,\n            )\n            old_label.save()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0024_auto_20211221_1444\"),\n    ]\n\n    operations = [migrations.RunPython(code=migrations.RunPython.noop, reverse_code=recover_label)]\n",
                                    "summary": "Function `recover_label` and Class Migration: A database migration function that retrieves and saves labels from existing models, encapsulated within a Django migration class that manages schema changes.",
                                    "code_element_summaries": [
                                        "Function `recover_label`: A database migration function that retrieves existing labels from CategoryType and SpanType models and saves them as instances of the Label model.",
                                        "Class Migration: A Django migration class that defines dependencies and operations for database schema changes."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0026_auto_20220107_0200.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0026_auto_20220107_0200.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0025_auto_20220107_0158\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"Label\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-07 02:00\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0025_auto_20220107_0158\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"Label\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes a dependency on an earlier migration and outlines the operation to remove the \"Label\" model.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that defines a dependency on a previous migration and specifies the operation to delete the \"Label\" model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0027_auto_20211222_0454.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0027_auto_20211222_0454.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0026_auto_20220107_0200\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"IntentDetectionAndSlotFillingProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2021-12-22 04:54\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0026_auto_20220107_0200\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"IntentDetectionAndSlotFillingProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"api.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"api.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes the IntentDetectionAndSlotFillingProject model and modifies the project_type field in the Project model to support multiple classification options.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates the IntentDetectionAndSlotFillingProject model and alters the project_type field in the Project model to include various classification options."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0028_auto_20220111_0655.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0028_auto_20220111_0655.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0027_auto_20211222_0454\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterUniqueTogether(\n                    name=\"rolemapping\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"role\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"user\",\n                ),\n            ],\n            database_operations=[],\n        ),\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Role\",\n                ),\n                migrations.DeleteModel(\n                    name=\"RoleMapping\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Role\", table=\"roles_role\"),\n                migrations.AlterModelTable(name=\"RoleMapping\", table=\"roles_rolemapping\"),\n            ],\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-11 06:55\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0027_auto_20211222_0454\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterUniqueTogether(\n                    name=\"rolemapping\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"role\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"rolemapping\",\n                    name=\"user\",\n                ),\n            ],\n            database_operations=[],\n        ),\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Role\",\n                ),\n                migrations.DeleteModel(\n                    name=\"RoleMapping\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Role\", table=\"roles_role\"),\n                migrations.AlterModelTable(name=\"RoleMapping\", table=\"roles_rolemapping\"),\n            ],\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that updates the database schema by removing role management fields and models while renaming the remaining model tables.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A Django migration that alters the database schema by removing fields and models related to role management and modifies the table names for the remaining models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0029_auto_20220119_2333.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0029_auto_20220119_2333.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"project\",\n            name=\"users\",\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"created_by\",\n            field=models.ForeignKey(\n                null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-19 23:33\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"project\",\n            name=\"users\",\n        ),\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"created_by\",\n            field=models.ForeignKey(\n                null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that alters the 'project' model by removing the 'users' field and introducing a 'created_by' foreign key field that references the user model.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that removes the 'users' field from the 'project' model and adds a 'created_by' foreign key field referencing the user model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0030_delete_autolabelingconfig.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0030_delete_autolabelingconfig.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0029_auto_20220119_2333\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"AutoLabelingConfig\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"AutoLabelingConfig\", table=\"auto_labeling_autolabelingconfig\")\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-20 04:17\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0029_auto_20220119_2333\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"AutoLabelingConfig\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"AutoLabelingConfig\", table=\"auto_labeling_autolabelingconfig\")\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that removes the AutoLabelingConfig model from the state and modifies its associated database table name.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that deletes the AutoLabelingConfig model from the state and alters its database table name."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0031_auto_20220127_0032.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0031_auto_20220127_0032.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0030_delete_autolabelingconfig\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterUniqueTogether(\n                    name=\"category\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"label\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"user\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"label\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"user\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"textlabel\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"textlabel\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"textlabel\",\n                    name=\"user\",\n                ),\n                migrations.DeleteModel(\n                    name=\"AnnotationRelations\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Category\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Span\",\n                ),\n                migrations.DeleteModel(\n                    name=\"TextLabel\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Span\", table=\"labels_span\"),\n                migrations.AlterModelTable(name=\"Category\", table=\"labels_category\"),\n                migrations.AlterModelTable(name=\"TextLabel\", table=\"labels_textlabel\"),\n                migrations.AlterModelTable(name=\"AnnotationRelations\", table=\"labels_annotationrelations\"),\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 00:32\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0030_delete_autolabelingconfig\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterUniqueTogether(\n                    name=\"category\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"label\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"category\",\n                    name=\"user\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"label\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"span\",\n                    name=\"user\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"textlabel\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"textlabel\",\n                    name=\"example\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"textlabel\",\n                    name=\"user\",\n                ),\n                migrations.DeleteModel(\n                    name=\"AnnotationRelations\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Category\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Span\",\n                ),\n                migrations.DeleteModel(\n                    name=\"TextLabel\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Span\", table=\"labels_span\"),\n                migrations.AlterModelTable(name=\"Category\", table=\"labels_category\"),\n                migrations.AlterModelTable(name=\"TextLabel\", table=\"labels_textlabel\"),\n                migrations.AlterModelTable(name=\"AnnotationRelations\", table=\"labels_annotationrelations\"),\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the database schema by altering and removing fields and models associated with categories, spans, and text labels, along with changing their respective table names.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters and removes specific fields and models related to categories, spans, and text labels, while also modifying their database table names."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0032_auto_20220127_0654.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0032_auto_20220127_0654.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0031_auto_20220127_0032\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"categorytype\",\n                    name=\"project\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"relationtypes\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"relationtypes\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"spantype\",\n                    name=\"project\",\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 06:54\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0031_auto_20220127_0032\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"categorytype\",\n                    name=\"project\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"relationtypes\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"relationtypes\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"spantype\",\n                    name=\"project\",\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that updates the database schema by removing fields and changing unique constraints for certain models within the 'api' app.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that modifies the database schema by removing fields and altering unique constraints for specific models in the 'api' app."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0033_auto_20220127_0654.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0033_auto_20220127_0654.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0003_auto_20220127_0654\"),\n        (\"api\", \"0032_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"CategoryType\",\n                ),\n                migrations.DeleteModel(\n                    name=\"RelationTypes\",\n                ),\n                migrations.DeleteModel(\n                    name=\"SpanType\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"CategoryType\", table=\"label_types_categorytype\"),\n                migrations.AlterModelTable(name=\"RelationTypes\", table=\"label_types_relationtypes\"),\n                migrations.AlterModelTable(name=\"SpanType\", table=\"label_types_spantype\"),\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 06:54\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0003_auto_20220127_0654\"),\n        (\"api\", \"0032_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"CategoryType\",\n                ),\n                migrations.DeleteModel(\n                    name=\"RelationTypes\",\n                ),\n                migrations.DeleteModel(\n                    name=\"SpanType\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"CategoryType\", table=\"label_types_categorytype\"),\n                migrations.AlterModelTable(name=\"RelationTypes\", table=\"label_types_relationtypes\"),\n                migrations.AlterModelTable(name=\"SpanType\", table=\"label_types_spantype\"),\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that manages the deletion of certain models and modification of database table names based on defined dependencies.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that deletes specific models and alters the database table names for others within the specified dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0034_auto_20220128_0246.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0034_auto_20220128_0246.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0033_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"example\",\n                    name=\"annotations_approved_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"example\",\n                    name=\"project\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"examplestate\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"examplestate\",\n                    name=\"confirmed_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"examplestate\",\n                    name=\"example\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Comment\",\n                ),\n            ],\n            database_operations=[migrations.AlterModelTable(name=\"Comment\", table=\"examples_comment\")],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-28 02:46\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0033_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"example\",\n                    name=\"annotations_approved_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"example\",\n                    name=\"project\",\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"examplestate\",\n                    unique_together=None,\n                ),\n                migrations.RemoveField(\n                    model_name=\"examplestate\",\n                    name=\"confirmed_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"examplestate\",\n                    name=\"example\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Comment\",\n                ),\n            ],\n            database_operations=[migrations.AlterModelTable(name=\"Comment\", table=\"examples_comment\")],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that updates the database schema by removing certain fields and models while altering unique constraints for the Example and ExampleState models.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that modifies the database schema by removing specific fields and models, and altering the unique constraints for the Example and ExampleState models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0035_auto_20220128_0246.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0035_auto_20220128_0246.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0034_auto_20220128_0246\"),\n        (\"labels\", \"0004_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Example\",\n                ),\n                migrations.DeleteModel(\n                    name=\"ExampleState\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Example\", table=\"examples_example\"),\n                migrations.AlterModelTable(name=\"ExampleState\", table=\"examples_examplestate\"),\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-28 02:46\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0034_auto_20220128_0246\"),\n        (\"labels\", \"0004_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Example\",\n                ),\n                migrations.DeleteModel(\n                    name=\"ExampleState\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(name=\"Example\", table=\"examples_example\"),\n                migrations.AlterModelTable(name=\"ExampleState\", table=\"examples_examplestate\"),\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that removes the models \"Example\" and \"ExampleState\" and renames their corresponding database tables to \"examples_example\" and \"examples_examplestate.\"",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that deletes the models \"Example\" and \"ExampleState\" while altering their database table names to \"examples_example\" and \"examples_examplestate,\" respectively."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0036_auto_20220204_0201.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0036_auto_20220204_0201.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0035_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"imageclassificationproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"intentdetectionandslotfillingproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"project\",\n                    name=\"created_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"project\",\n                    name=\"polymorphic_ctype\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"seq2seqproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"sequencelabelingproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"speech2textproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"tag\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"textclassificationproject\",\n                    name=\"project_ptr\",\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0035_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.RemoveField(\n                    model_name=\"imageclassificationproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"intentdetectionandslotfillingproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"project\",\n                    name=\"created_by\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"project\",\n                    name=\"polymorphic_ctype\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"seq2seqproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"sequencelabelingproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"speech2textproject\",\n                    name=\"project_ptr\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"tag\",\n                    name=\"project\",\n                ),\n                migrations.RemoveField(\n                    model_name=\"textclassificationproject\",\n                    name=\"project_ptr\",\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that alters the database schema by removing designated fields from multiple project models while ensuring a clear distinction between database changes and state management.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that modifies the database schema by removing specific fields from various project models while maintaining separation between database and state operations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0037_auto_20220204_0201.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\0037_auto_20220204_0201.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0005_alter_relation_project\"),\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"auto_labeling\", \"0004_alter_autolabelingconfig_project\"),\n        (\"api\", \"0036_auto_20220204_0201\"),\n        (\"label_types\", \"0003_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"ImageClassificationProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"IntentDetectionAndSlotFillingProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Project\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Seq2seqProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"SequenceLabelingProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Speech2textProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Tag\",\n                ),\n                migrations.DeleteModel(\n                    name=\"TextClassificationProject\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(\n                    name=\"ImageClassificationProject\", table=\"projects_imageclassificationproject\"\n                ),\n                migrations.AlterModelTable(\n                    name=\"IntentDetectionAndSlotFillingProject\", table=\"projects_intentdetectionandslotfillingproject\"\n                ),\n                migrations.AlterModelTable(name=\"Project\", table=\"projects_project\"),\n                migrations.AlterModelTable(name=\"Seq2seqProject\", table=\"projects_seq2seqproject\"),\n                migrations.AlterModelTable(name=\"SequenceLabelingProject\", table=\"projects_sequencelabelingproject\"),\n                migrations.AlterModelTable(name=\"Speech2textProject\", table=\"projects_speech2textproject\"),\n                migrations.AlterModelTable(name=\"Tag\", table=\"projects_tag\"),\n                migrations.AlterModelTable(\n                    name=\"TextClassificationProject\", table=\"projects_textclassificationproject\"\n                ),\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0005_alter_relation_project\"),\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"auto_labeling\", \"0004_alter_autolabelingconfig_project\"),\n        (\"api\", \"0036_auto_20220204_0201\"),\n        (\"label_types\", \"0003_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"ImageClassificationProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"IntentDetectionAndSlotFillingProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Project\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Seq2seqProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"SequenceLabelingProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Speech2textProject\",\n                ),\n                migrations.DeleteModel(\n                    name=\"Tag\",\n                ),\n                migrations.DeleteModel(\n                    name=\"TextClassificationProject\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(\n                    name=\"ImageClassificationProject\", table=\"projects_imageclassificationproject\"\n                ),\n                migrations.AlterModelTable(\n                    name=\"IntentDetectionAndSlotFillingProject\", table=\"projects_intentdetectionandslotfillingproject\"\n                ),\n                migrations.AlterModelTable(name=\"Project\", table=\"projects_project\"),\n                migrations.AlterModelTable(name=\"Seq2seqProject\", table=\"projects_seq2seqproject\"),\n                migrations.AlterModelTable(name=\"SequenceLabelingProject\", table=\"projects_sequencelabelingproject\"),\n                migrations.AlterModelTable(name=\"Speech2textProject\", table=\"projects_speech2textproject\"),\n                migrations.AlterModelTable(name=\"Tag\", table=\"projects_tag\"),\n                migrations.AlterModelTable(\n                    name=\"TextClassificationProject\", table=\"projects_textclassificationproject\"\n                ),\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that handles dependencies and executes operations to delete and modify database models associated with different project types and tags.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that manages dependencies and performs operations to delete and alter database models related to various project types and tags."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class TestCreateAdminCommand, TestDatabaseUrl, HeaderAuthMiddlewareTest, and CRUDMixin: A collection of test suites and mixins designed to validate user creation commands, database URL configurations, header-based authentication, and CRUD operations in API test cases, ensuring proper error handling, logging, and behavior across various scenarios.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_commands.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests\\test_commands.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestCreateAdminCommand`\nCode:\nclass TestCreateAdminCommand(TestCase):\n    def test_can_create_user(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_out.write.assert_called_once_with(\"Setting password for User user.\\n\")\n\n    def test_raise_error_if_username_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                password=\"whoami\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank username isn't allowed.\\n\")\n\n    def test_raise_error_if_password_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                username=\"user\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank password isn't allowed.\\n\")\n\n    def test_warn_default_password(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"password\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        self.assertEqual(mock_out.write.call_count, 2)\n        mock_out.write.assert_any_call(\"Warning: You should change the default password.\\n\")\n        mock_out.write.assert_any_call(\"Setting password for User user.\\n\")\n\n    def test_warn_duplicate_username(self):\n        get_user_model().objects.create(username=\"admin\", password=\"pass\")\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        command.handle(\n            username=\"admin\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_err.write.assert_called_once_with(\"User admin already exists.\\n\")",
                                        "Function `test_can_create_user`\nCode:\n    def test_can_create_user(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_out.write.assert_called_once_with(\"Setting password for User user.\\n\")",
                                        "Function `test_raise_error_if_username_is_not_given`\nCode:\n    def test_raise_error_if_username_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                password=\"whoami\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank username isn't allowed.\\n\")",
                                        "Function `test_raise_error_if_password_is_not_given`\nCode:\n    def test_raise_error_if_password_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                username=\"user\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank password isn't allowed.\\n\")",
                                        "Function `test_warn_default_password`\nCode:\n    def test_warn_default_password(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"password\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        self.assertEqual(mock_out.write.call_count, 2)\n        mock_out.write.assert_any_call(\"Warning: You should change the default password.\\n\")\n        mock_out.write.assert_any_call(\"Setting password for User user.\\n\")",
                                        "Function `test_warn_duplicate_username`\nCode:\n    def test_warn_duplicate_username(self):\n        get_user_model().objects.create(username=\"admin\", password=\"pass\")\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        command.handle(\n            username=\"admin\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_err.write.assert_called_once_with(\"User admin already exists.\\n\")"
                                    ],
                                    "code": "from unittest.mock import MagicMock\n\nfrom django.contrib.auth import get_user_model\nfrom django.core.management import CommandError\nfrom django.test import TestCase\n\nfrom api.management.commands.create_admin import Command\n\n\nclass TestCreateAdminCommand(TestCase):\n    def test_can_create_user(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_out.write.assert_called_once_with(\"Setting password for User user.\\n\")\n\n    def test_raise_error_if_username_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                password=\"whoami\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank username isn't allowed.\\n\")\n\n    def test_raise_error_if_password_is_not_given(self):\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        with self.assertRaises(CommandError):\n            command.handle(\n                username=\"user\", email=\"example@doccano.com\", database=\"default\", interactive=False, verbosity=0\n            )\n            mock_err.write.assert_called_once_with(\"Error: Blank password isn't allowed.\\n\")\n\n    def test_warn_default_password(self):\n        mock_out = MagicMock()\n        command = Command(stdout=mock_out)\n        command.handle(\n            username=\"user\",\n            password=\"password\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        self.assertEqual(mock_out.write.call_count, 2)\n        mock_out.write.assert_any_call(\"Warning: You should change the default password.\\n\")\n        mock_out.write.assert_any_call(\"Setting password for User user.\\n\")\n\n    def test_warn_duplicate_username(self):\n        get_user_model().objects.create(username=\"admin\", password=\"pass\")\n        mock_err = MagicMock()\n        command = Command(stderr=mock_err)\n        command.handle(\n            username=\"admin\",\n            password=\"whoami\",\n            email=\"example@doccano.com\",\n            database=\"default\",\n            interactive=False,\n            verbosity=0,\n        )\n        self.assertEqual(get_user_model().objects.count(), 1)\n        mock_err.write.assert_called_once_with(\"User admin already exists.\\n\")\n",
                                    "summary": "Class TestCreateAdminCommand: A test suite that validates the functionality of user creation commands, ensuring proper error handling and logging for required fields, default passwords, and duplicate usernames.",
                                    "code_element_summaries": [
                                        "Class TestCreateAdminCommand: A test case that verifies the functionality of user creation commands, including checks for required fields, warnings for default passwords, and handling of duplicate usernames.",
                                        "Function `test_can_create_user`: A unit test that verifies the creation of a user and checks that the password setting is logged correctly.",
                                        "Function `test_raise_error_if_username_is_not_given`: A unit test that verifies a CommandError is raised when the username is not provided in the command handling process, and checks that the appropriate error message is written to stderr.",
                                        "Function `test_raise_error_if_password_is_not_given`: A unit test that verifies a `CommandError` is raised when a password is not provided, ensuring the error message is correctly written to stderr.",
                                        "Function `test_warn_default_password`: A unit test that verifies a warning message is displayed when a default password is used, and checks that a user is created with the specified credentials.",
                                        "Function `test_warn_duplicate_username`: A unit test that verifies the command correctly handles the creation of a user with a duplicate username by ensuring an error message is displayed and the user count remains unchanged."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_config.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests\\test_config.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestDatabaseUrl`\nCode:\nclass TestDatabaseUrl(TestCase):\n    def test_sslmode_defaults_to_required(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d\"):\n            self._assert_sslmode_is(\"require\")\n\n    def test_sslmode_not_set_for_sqlite(self):\n        with setenv(\"DATABASE_URL\", \"sqlite:///some/path\"):\n            self._assert_sslmode_is(None)\n\n    def test_sslmode_can_be_disabled_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=disable\"):\n            self._assert_sslmode_is(\"disable\")\n\n    def test_sslmode_can_be_required_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=require\"):\n            self._assert_sslmode_is(\"require\")\n\n    def test_database_url_with_complex_user(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://user%40host:p@h/d\"):\n            self._assert_user_is(\"user@host\")\n\n    def _assert_sslmode_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"OPTIONS\", {}).get(\"sslmode\")\n        self.assertEqual(actual, expected)\n\n    def _assert_user_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"USER\", \"\")\n        self.assertEqual(actual, expected)",
                                        "Function `test_sslmode_defaults_to_required`\nCode:\n    def test_sslmode_defaults_to_required(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d\"):\n            self._assert_sslmode_is(\"require\")",
                                        "Function `test_sslmode_not_set_for_sqlite`\nCode:\n    def test_sslmode_not_set_for_sqlite(self):\n        with setenv(\"DATABASE_URL\", \"sqlite:///some/path\"):\n            self._assert_sslmode_is(None)",
                                        "Function `test_sslmode_can_be_disabled_via_database_url`\nCode:\n    def test_sslmode_can_be_disabled_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=disable\"):\n            self._assert_sslmode_is(\"disable\")",
                                        "Function `test_sslmode_can_be_required_via_database_url`\nCode:\n    def test_sslmode_can_be_required_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=require\"):\n            self._assert_sslmode_is(\"require\")",
                                        "Function `test_database_url_with_complex_user`\nCode:\n    def test_database_url_with_complex_user(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://user%40host:p@h/d\"):\n            self._assert_user_is(\"user@host\")",
                                        "Function `_assert_sslmode_is`\nCode:\n    def _assert_sslmode_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"OPTIONS\", {}).get(\"sslmode\")\n        self.assertEqual(actual, expected)",
                                        "Function `_assert_user_is`\nCode:\n    def _assert_user_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"USER\", \"\")\n        self.assertEqual(actual, expected)",
                                        "Function `setenv`\nCode:\ndef setenv(key, value):\n    environ[key] = value\n    reload(settings)\n    yield\n    del environ[key]"
                                    ],
                                    "code": "from contextlib import contextmanager\nfrom importlib import reload\nfrom os import environ\n\nfrom django.test import TestCase\n\nfrom config.settings import base as settings\n\n\nclass TestDatabaseUrl(TestCase):\n    def test_sslmode_defaults_to_required(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d\"):\n            self._assert_sslmode_is(\"require\")\n\n    def test_sslmode_not_set_for_sqlite(self):\n        with setenv(\"DATABASE_URL\", \"sqlite:///some/path\"):\n            self._assert_sslmode_is(None)\n\n    def test_sslmode_can_be_disabled_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=disable\"):\n            self._assert_sslmode_is(\"disable\")\n\n    def test_sslmode_can_be_required_via_database_url(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://u:p@h/d?sslmode=require\"):\n            self._assert_sslmode_is(\"require\")\n\n    def test_database_url_with_complex_user(self):\n        with setenv(\"DATABASE_URL\", \"pgsql://user%40host:p@h/d\"):\n            self._assert_user_is(\"user@host\")\n\n    def _assert_sslmode_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"OPTIONS\", {}).get(\"sslmode\")\n        self.assertEqual(actual, expected)\n\n    def _assert_user_is(self, expected):\n        actual = settings.DATABASES[\"default\"].get(\"USER\", \"\")\n        self.assertEqual(actual, expected)\n\n\n@contextmanager\ndef setenv(key, value):\n    environ[key] = value\n    reload(settings)\n    yield\n    del environ[key]\n",
                                    "summary": "Class `TestDatabaseUrl`: A test suite that validates SSL mode settings and user configurations in database URLs for various database types, ensuring correct behavior through multiple test functions and a context manager for environment variable management.",
                                    "code_element_summaries": [
                                        "Class `TestDatabaseUrl`: A test case that verifies the behavior of SSL mode settings in database URLs across different database types and configurations.",
                                        "Function `test_sslmode_defaults_to_required`: A test function that verifies the default SSL mode for a PostgreSQL database connection is set to \"require\" when a specific environment variable is configured.",
                                        "Function `test_sslmode_not_set_for_sqlite`: A test function that verifies the SSL mode is not set when the database URL points to a SQLite database.",
                                        "Function `test_sslmode_can_be_disabled_via_database_url`: A test function that verifies the SSL mode can be disabled by setting a specific database URL environment variable.",
                                        "Function `test_sslmode_can_be_required_via_database_url`: A test function that verifies if the SSL mode can be set to 'require' through the DATABASE_URL environment variable.",
                                        "Function `test_database_url_with_complex_user`: A test function that verifies the correct user is set when a complex database URL is provided through an environment variable.",
                                        "Function `_assert_sslmode_is`: A test function that asserts whether the SSL mode of the default database configuration matches the expected value.",
                                        "Function `_assert_user_is`: A method that asserts whether the current database user matches the expected value.",
                                        "Function `setenv`: A context manager that sets an environment variable, reloads settings, and ensures the variable is removed after use."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_middleware.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests\\test_middleware.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `HeaderAuthMiddlewareTest`\nCode:\nclass HeaderAuthMiddlewareTest(TestCase):\n    def test_process_user_groups_is_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = False\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Admin;Reader\"})\n\n        self.assertTrue(user.is_superuser)\n\n    def test_process_user_groups_is_not_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = True\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Guest;Reader\"})\n\n        self.assertFalse(user.is_superuser)",
                                        "Function `test_process_user_groups_is_super`\nCode:\n    def test_process_user_groups_is_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = False\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Admin;Reader\"})\n\n        self.assertTrue(user.is_superuser)",
                                        "Function `test_process_user_groups_is_not_super`\nCode:\n    def test_process_user_groups_is_not_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = True\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Guest;Reader\"})\n\n        self.assertFalse(user.is_superuser)"
                                    ],
                                    "code": "from unittest import mock\n\nfrom django.contrib.auth.models import User\nfrom django.test import TestCase, override_settings\n\nfrom api.middleware import HeaderAuthMiddleware\n\n\n@override_settings(HEADER_AUTH_USER_GROUPS=\"X-AuthProxy-Groups\")\n@override_settings(HEADER_AUTH_ADMIN_GROUP_NAME=\"Admin\")\n@override_settings(HEADER_AUTH_GROUPS_SEPERATOR=\";\")\nclass HeaderAuthMiddlewareTest(TestCase):\n    def test_process_user_groups_is_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = False\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Admin;Reader\"})\n\n        self.assertTrue(user.is_superuser)\n\n    def test_process_user_groups_is_not_super(self):\n        user = User.objects.create_user(username=\"TestUser\")\n        user.is_superuser = True\n\n        get_response = mock.MagicMock()\n\n        middleware = HeaderAuthMiddleware(get_response)\n        middleware.process_user_groups(user, {\"HTTP_X_AUTHPROXY_GROUPS\": \"Guest;Reader\"})\n\n        self.assertFalse(user.is_superuser)\n",
                                    "summary": "Class `HeaderAuthMiddlewareTest`: A test suite for the `HeaderAuthMiddleware` that ensures the accurate assignment of superuser status based on user groups specified in HTTP headers through various test cases.",
                                    "code_element_summaries": [
                                        "Class `HeaderAuthMiddlewareTest`: A test case for the `HeaderAuthMiddleware` that verifies the correct assignment of superuser status based on user groups from HTTP headers.",
                                        "Function `test_process_user_groups_is_super`: A test case that verifies the `process_user_groups` method of the `HeaderAuthMiddleware` correctly sets a user's `is_superuser` status to True when provided with specific HTTP header groups.",
                                        "Function `test_process_user_groups_is_not_super`: A test case that verifies the `process_user_groups` method of `HeaderAuthMiddleware` correctly prevents a user from being marked as a superuser when processing user groups."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `CRUDMixin`\nCode:\nclass CRUDMixin(APITestCase):\n    url = \"\"\n    data: Dict[str, Any] = {}\n\n    def assert_fetch(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_create(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.post(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_update(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.patch(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN, data=None):\n        if user:\n            self.client.force_login(user)\n\n        if data is None:\n            data = {}\n        response = self.client.delete(self.url, data=data)\n        self.assertEqual(response.status_code, expected)",
                                        "Function `assert_fetch`\nCode:\n    def assert_fetch(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, expected)\n        return response",
                                        "Function `assert_create`\nCode:\n    def assert_create(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.post(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response",
                                        "Function `assert_update`\nCode:\n    def assert_update(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.patch(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response",
                                        "Function `assert_delete`\nCode:\n    def assert_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN, data=None):\n        if user:\n            self.client.force_login(user)\n\n        if data is None:\n            data = {}\n        response = self.client.delete(self.url, data=data)\n        self.assertEqual(response.status_code, expected)"
                                    ],
                                    "code": "from typing import Any, Dict\n\nfrom rest_framework import status\nfrom rest_framework.test import APITestCase\n\n\nclass CRUDMixin(APITestCase):\n    url = \"\"\n    data: Dict[str, Any] = {}\n\n    def assert_fetch(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_create(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.post(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_update(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        response = self.client.patch(self.url, data=self.data, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n        return response\n\n    def assert_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN, data=None):\n        if user:\n            self.client.force_login(user)\n\n        if data is None:\n            data = {}\n        response = self.client.delete(self.url, data=data)\n        self.assertEqual(response.status_code, expected)\n",
                                    "summary": "Class `CRUDMixin`: A mixin for API test cases that provides methods to assert the correct behavior and HTTP status codes for fetch, create, update, and delete operations, with optional user authentication.",
                                    "code_element_summaries": [
                                        "Class `CRUDMixin`: A mixin for API test cases that provides methods to assert the behavior of fetch, create, update, and delete operations with expected HTTP status codes.",
                                        "Function `assert_fetch`: A method that verifies the HTTP response status of a GET request, optionally logging in a user, and asserts that it matches the expected status code.",
                                        "Function `assert_create`: A method that tests the creation of a resource by posting data and asserting that the response status matches the expected status, with an optional user login.",
                                        "Function `assert_update`: A method that simulates a user login and sends a PATCH request to update data, asserting that the response status code matches the expected value.",
                                        "Function `assert_delete`: A method that verifies the HTTP DELETE request response status code against an expected value, optionally logging in a user and sending data with the request."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import TaskStatus\n\nurlpatterns = [\n    path(route=\"tasks/status/<task_id>\", view=TaskStatus.as_view(), name=\"task_status\"),\n]\n",
                            "summary": "URL Configuration: Defines a URL pattern for accessing the task status view using a task ID in a Django application.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `TaskStatus`\nCode:\nclass TaskStatus(APIView):\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, *args, **kwargs):\n        task = AsyncResult(kwargs[\"task_id\"])\n        ready = task.ready()\n        error = ready and not task.successful()\n\n        return Response(\n            {\n                \"ready\": ready,\n                \"result\": task.result if ready and not error else None,\n                \"error\": {\"text\": str(task.result)} if error else None,\n            }\n        )",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        task = AsyncResult(kwargs[\"task_id\"])\n        ready = task.ready()\n        error = ready and not task.successful()\n\n        return Response(\n            {\n                \"ready\": ready,\n                \"result\": task.result if ready and not error else None,\n                \"error\": {\"text\": str(task.result)} if error else None,\n            }\n        )"
                            ],
                            "code": "from celery.result import AsyncResult\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\n\nclass TaskStatus(APIView):\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, *args, **kwargs):\n        task = AsyncResult(kwargs[\"task_id\"])\n        ready = task.ready()\n        error = ready and not task.successful()\n\n        return Response(\n            {\n                \"ready\": ready,\n                \"result\": task.result if ready and not error else None,\n                \"error\": {\"text\": str(task.result)} if error else None,\n            }\n        )\n",
                            "summary": "Class TaskStatus: An API view that retrieves the status and result of an asynchronous task by its ID, indicating readiness and any potential errors.",
                            "code_element_summaries": [
                                "Class TaskStatus: An API view that checks the readiness and result of an asynchronous task, returning its status along with any potential errors.",
                                "Function `get`: Retrieves the status and result of an asynchronous task based on its ID, returning whether it is ready, the result if successful, and any associated error message."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\api\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "auto_labeling",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content outlines a Django application for automatic labeling, featuring admin configurations, custom exceptions, model migrations, serializers, and a comprehensive testing framework, alongside API views for managing project-related fields and enforcing permissions.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `AutoLabelingConfigAdmin`\nCode:\nclass AutoLabelingConfigAdmin(admin.ModelAdmin):\n    list_display = (\n        \"project\",\n        \"model_name\",\n        \"model_attrs\",\n    )\n    ordering = (\"project\",)\n\n    def get_readonly_fields(self, request, obj=None):\n        if obj:\n            return [\"model_name\"]\n        else:\n            return []",
                                "Function `get_readonly_fields`\nCode:\n    def get_readonly_fields(self, request, obj=None):\n        if obj:\n            return [\"model_name\"]\n        else:\n            return []"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import AutoLabelingConfig\n\n\nclass AutoLabelingConfigAdmin(admin.ModelAdmin):\n    list_display = (\n        \"project\",\n        \"model_name\",\n        \"model_attrs\",\n    )\n    ordering = (\"project\",)\n\n    def get_readonly_fields(self, request, obj=None):\n        if obj:\n            return [\"model_name\"]\n        else:\n            return []\n\n\nadmin.site.register(AutoLabelingConfig, AutoLabelingConfigAdmin)\n",
                            "summary": "Class AutoLabelingConfigAdmin: A Django admin configuration that manages project-related fields and dynamically sets the read-only status of the model name based on the object's existence.",
                            "code_element_summaries": [
                                "Class AutoLabelingConfigAdmin: A Django admin model configuration that displays project-related fields and controls the read-only status of the model name based on the object's existence.",
                                "Function `get_readonly_fields`: Returns a list of readonly fields for a model, specifically \"model_name\" if an object is provided, otherwise returns an empty list."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `AutoLabelingConfig`\nCode:\nclass AutoLabelingConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"auto_labeling\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass AutoLabelingConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"auto_labeling\"\n",
                            "summary": "Class AutoLabelingConfig: A Django application configuration class that defines the default auto field type and names the application \"auto_labeling\".",
                            "code_element_summaries": [
                                "Class AutoLabelingConfig: A Django application configuration class that sets the default auto field type and specifies the application name as \"auto_labeling\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "exceptions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\exceptions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `AutoLabelingPermissionDenied`\nCode:\nclass AutoLabelingPermissionDenied(PermissionDenied):\n    default_detail = (\n        \"You do not have permission to perform auto labeling.\" \"Please ask the project administrators to add you.\"\n    )",
                                "Class `URLConnectionError`\nCode:\nclass URLConnectionError(ValidationError):\n    default_detail = \"Failed to establish a connection. Please check the URL or network.\"",
                                "Class `AWSTokenError`\nCode:\nclass AWSTokenError(ValidationError):\n    default_detail = \"The security token included in the request is invalid.\"",
                                "Class `SampleDataException`\nCode:\nclass SampleDataException(ValidationError):\n    default_detail = (\n        \"The response is empty. Maybe the sample data is not appropriate.\"\n        \"Please specify another sample data which returns at least one label.\"\n    )",
                                "Class `TemplateMappingError`\nCode:\nclass TemplateMappingError(ValidationError):\n    default_detail = \"The response cannot be mapped. You might need to change the template.\"",
                                "Class `ResponseJSONDecodeError`\nCode:\nclass ResponseJSONDecodeError(ValidationError):\n    default_detail = \"The response cannot be decoded.\" \"Please try to return the response in dictionary or list format.\""
                            ],
                            "code": "from rest_framework.exceptions import PermissionDenied, ValidationError\n\n\nclass AutoLabelingPermissionDenied(PermissionDenied):\n    default_detail = (\n        \"You do not have permission to perform auto labeling.\" \"Please ask the project administrators to add you.\"\n    )\n\n\nclass URLConnectionError(ValidationError):\n    default_detail = \"Failed to establish a connection. Please check the URL or network.\"\n\n\nclass AWSTokenError(ValidationError):\n    default_detail = \"The security token included in the request is invalid.\"\n\n\nclass SampleDataException(ValidationError):\n    default_detail = (\n        \"The response is empty. Maybe the sample data is not appropriate.\"\n        \"Please specify another sample data which returns at least one label.\"\n    )\n\n\nclass TemplateMappingError(ValidationError):\n    default_detail = \"The response cannot be mapped. You might need to change the template.\"\n\n\nclass ResponseJSONDecodeError(ValidationError):\n    default_detail = \"The response cannot be decoded.\" \"Please try to return the response in dictionary or list format.\"\n",
                            "summary": "Classes AutoLabelingPermissionDenied, URLConnectionError, AWSTokenError, SampleDataException, TemplateMappingError, and ResponseJSONDecodeError: Custom exceptions and validation errors that provide specific messages related to permission issues, connection failures, invalid tokens, empty responses, template mapping failures, and JSON decoding problems, respectively.",
                            "code_element_summaries": [
                                "Class AutoLabelingPermissionDenied: A custom exception that indicates insufficient permissions for auto labeling, providing a specific error message for users.",
                                "Class URLConnectionError: A custom validation error that indicates a failure to establish a connection, providing a default message for users to check the URL or network.",
                                "Class AWSTokenError: A custom validation error that indicates an invalid security token in an AWS request.",
                                "Class SampleDataException: A custom exception that indicates an empty response due to inappropriate sample data, prompting the user to provide alternative data that returns at least one label.",
                                "Class TemplateMappingError: A specialized ValidationError that provides a default message indicating that the response cannot be mapped and suggests changing the template.",
                                "Class ResponseJSONDecodeError: A custom validation error indicating that a response cannot be decoded, with a default message suggesting a return in dictionary or list format."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A series of Django migrations that establish and modify the AutoLabelingConfig model by adding fields, linking it to the Project model, and updating existing records based on project types.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"api\", \"0030_delete_autolabelingconfig\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"AutoLabelingConfig\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"model_name\", models.CharField(max_length=100)),\n                        (\"model_attrs\", models.JSONField(default=dict)),\n                        (\"template\", models.TextField(default=\"\")),\n                        (\"label_mapping\", models.JSONField(blank=True, default=dict)),\n                        (\"default\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"auto_labeling_config\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                    ],\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-20 04:17\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"api\", \"0030_delete_autolabelingconfig\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"AutoLabelingConfig\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"model_name\", models.CharField(max_length=100)),\n                        (\"model_attrs\", models.JSONField(default=dict)),\n                        (\"template\", models.TextField(default=\"\")),\n                        (\"label_mapping\", models.JSONField(blank=True, default=dict)),\n                        (\"default\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"auto_labeling_config\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                    ],\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class `Migration`: A Django migration that sets up the `AutoLabelingConfig` model with multiple fields and links it to a prior migration.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A Django migration that creates the `AutoLabelingConfig` model with various fields and establishes a dependency on a previous migration."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_autolabelingconfig_task_type.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations\\0002_autolabelingconfig_task_type.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"auto_labeling\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"autolabelingconfig\",\n            name=\"task_type\",\n            field=models.CharField(\n                choices=[(\"Category\", \"category\"), (\"Span\", \"span\"), (\"Text\", \"text\"), (\"Relation\", \"relation\")],\n                default=\"Category\",\n                max_length=100,\n            ),\n            preserve_default=False,\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-25 00:23\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"auto_labeling\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"autolabelingconfig\",\n            name=\"task_type\",\n            field=models.CharField(\n                choices=[(\"Category\", \"category\"), (\"Span\", \"span\"), (\"Text\", \"text\"), (\"Relation\", \"relation\")],\n                default=\"Category\",\n                max_length=100,\n            ),\n            preserve_default=False,\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that introduces a new field \"task_type\" with defined choices to the \"autolabelingconfig\" model.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that adds a new field \"task_type\" with specified choices to the \"autolabelingconfig\" model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_fill_task_type.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations\\0003_fill_task_type.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `fill_task_type`\nCode:\ndef fill_task_type(apps, schema_editor):\n    AutoLabelingConfig = apps.get_model(\"auto_labeling\", \"AutoLabelingConfig\")\n    for config in AutoLabelingConfig.objects.all():\n        project = config.project\n        if project.project_type in [ProjectType.DOCUMENT_CLASSIFICATION, ProjectType.IMAGE_CLASSIFICATION]:\n            config.task_type = \"Category\"\n        elif project.project_type in [ProjectType.SEQ2SEQ, ProjectType.SPEECH2TEXT]:\n            config.task_type = \"Text\"\n        elif project.project_type in [ProjectType.SEQUENCE_LABELING]:\n            config.task_type = \"Span\"\n        else:\n            config.task_type = \"Category\"\n        config.save()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"auto_labeling\", \"0002_autolabelingconfig_task_type\"),\n    ]\n\n    operations = [migrations.RunPython(code=fill_task_type, reverse_code=migrations.RunPython.noop)]"
                                    ],
                                    "code": "from django.db import migrations\n\nfrom projects.models import ProjectType\n\n\ndef fill_task_type(apps, schema_editor):\n    AutoLabelingConfig = apps.get_model(\"auto_labeling\", \"AutoLabelingConfig\")\n    for config in AutoLabelingConfig.objects.all():\n        project = config.project\n        if project.project_type in [ProjectType.DOCUMENT_CLASSIFICATION, ProjectType.IMAGE_CLASSIFICATION]:\n            config.task_type = \"Category\"\n        elif project.project_type in [ProjectType.SEQ2SEQ, ProjectType.SPEECH2TEXT]:\n            config.task_type = \"Text\"\n        elif project.project_type in [ProjectType.SEQUENCE_LABELING]:\n            config.task_type = \"Span\"\n        else:\n            config.task_type = \"Category\"\n        config.save()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"auto_labeling\", \"0002_autolabelingconfig_task_type\"),\n    ]\n\n    operations = [migrations.RunPython(code=fill_task_type, reverse_code=migrations.RunPython.noop)]\n",
                                    "summary": "Function `fill_task_type` and class `Migration`: A database migration function and a Django migration class that collaboratively update the `task_type` field of `AutoLabelingConfig` instances based on the associated project's type.",
                                    "code_element_summaries": [
                                        "Function `fill_task_type`: A database migration function that updates the `task_type` field of `AutoLabelingConfig` instances based on the associated project's type.",
                                        "Class `Migration`: A Django migration that depends on a previous migration and executes a Python function to fill task types in the database."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_alter_autolabelingconfig_project.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations\\0004_alter_autolabelingconfig_project.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"auto_labeling\", \"0003_fill_task_type\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"autolabelingconfig\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"auto_labeling_config\",\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"auto_labeling\", \"0003_fill_task_type\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"autolabelingconfig\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"auto_labeling_config\",\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the ForeignKey field of the AutoLabelingConfig model to link it with the Project model, handling necessary database and state changes.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the ForeignKey field of the AutoLabelingConfig model to establish a relationship with the Project model while managing database and state operations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `AutoLabelingConfig`\nCode:\nclass AutoLabelingConfig(models.Model):\n    TASK_CHOICES = ((\"Category\", \"category\"), (\"Span\", \"span\"), (\"Text\", \"text\"), (\"Relation\", \"relation\"))\n    model_name = models.CharField(max_length=100)\n    model_attrs = models.JSONField(default=dict)\n    template = models.TextField(default=\"\")\n    label_mapping = models.JSONField(default=dict, blank=True)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"auto_labeling_config\")\n    task_type = models.CharField(max_length=100, choices=TASK_CHOICES)\n    default = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.model_name\n\n    def clean_fields(self, exclude=None):\n        super().clean_fields(exclude=exclude)\n        try:\n            RequestModelFactory.find(self.model_name)\n        except NameError:\n            message = f\"The specified model name {self.model_name} does not exist.\"\n            raise ValidationError(message)\n        except Exception:\n            message = \"The attributes does not match the model.\"\n            raise ValidationError(message)",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        return self.model_name",
                                "Function `clean_fields`\nCode:\n    def clean_fields(self, exclude=None):\n        super().clean_fields(exclude=exclude)\n        try:\n            RequestModelFactory.find(self.model_name)\n        except NameError:\n            message = f\"The specified model name {self.model_name} does not exist.\"\n            raise ValidationError(message)\n        except Exception:\n            message = \"The attributes does not match the model.\"\n            raise ValidationError(message)"
                            ],
                            "code": "from auto_labeling_pipeline.models import RequestModelFactory\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\n\nfrom projects.models import Project\n\n\nclass AutoLabelingConfig(models.Model):\n    TASK_CHOICES = ((\"Category\", \"category\"), (\"Span\", \"span\"), (\"Text\", \"text\"), (\"Relation\", \"relation\"))\n    model_name = models.CharField(max_length=100)\n    model_attrs = models.JSONField(default=dict)\n    template = models.TextField(default=\"\")\n    label_mapping = models.JSONField(default=dict, blank=True)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"auto_labeling_config\")\n    task_type = models.CharField(max_length=100, choices=TASK_CHOICES)\n    default = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.model_name\n\n    def clean_fields(self, exclude=None):\n        super().clean_fields(exclude=exclude)\n        try:\n            RequestModelFactory.find(self.model_name)\n        except NameError:\n            message = f\"The specified model name {self.model_name} does not exist.\"\n            raise ValidationError(message)\n        except Exception:\n            message = \"The attributes does not match the model.\"\n            raise ValidationError(message)\n",
                            "summary": "Class AutoLabelingConfig: A Django model that manages automatic labeling configurations with validation for model existence and provides a string representation of the model name.",
                            "code_element_summaries": [
                                "Class AutoLabelingConfig: A Django model that stores configuration settings for automatic labeling, including task type, model name, attributes, and project association, with validation for model existence.",
                                "Function `__str__`: Returns the string representation of the object, specifically its model name.",
                                "Function `clean_fields`: Validates the model name and attributes, raising a `ValidationError` if the model does not exist or if there is a mismatch in attributes."
                            ],
                            "children": []
                        },
                        {
                            "name": "pipeline",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\pipeline",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Functions `get_label_collection` and `execute_pipeline` handle label retrieval and data processing, respectively, while the abstract class LabelCollection and its derived classes Categories, Spans, and Texts manage the transformation and saving of specific label annotations within a project.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "execution.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\pipeline\\execution.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `get_label_collection`\nCode:\ndef get_label_collection(task_type: str) -> Type[Labels]:\n    return {\"Category\": ClassificationLabels, \"Span\": SequenceLabels, \"Text\": Seq2seqLabels}[task_type]",
                                        "Function `execute_pipeline`\nCode:\ndef execute_pipeline(data: str, config: AutoLabelingConfig):\n    label_collection = get_label_collection(config.task_type)\n    model = RequestModelFactory.create(model_name=config.model_name, attributes=config.model_attrs)\n    template = MappingTemplate(label_collection=label_collection, template=config.template)\n    post_processor = PostProcessor(config.label_mapping)\n    labels = pipeline(text=data, request_model=model, mapping_template=template, post_processing=post_processor)\n    labels = create_labels(config.task_type, labels)\n    return labels"
                                    ],
                                    "code": "from typing import Type\n\nfrom auto_labeling_pipeline.labels import (\n    ClassificationLabels,\n    Labels,\n    Seq2seqLabels,\n    SequenceLabels,\n)\nfrom auto_labeling_pipeline.mappings import MappingTemplate\nfrom auto_labeling_pipeline.models import RequestModelFactory\nfrom auto_labeling_pipeline.pipeline import pipeline\nfrom auto_labeling_pipeline.postprocessing import PostProcessor\n\nfrom .labels import create_labels\nfrom auto_labeling.models import AutoLabelingConfig\n\n\ndef get_label_collection(task_type: str) -> Type[Labels]:\n    return {\"Category\": ClassificationLabels, \"Span\": SequenceLabels, \"Text\": Seq2seqLabels}[task_type]\n\n\ndef execute_pipeline(data: str, config: AutoLabelingConfig):\n    label_collection = get_label_collection(config.task_type)\n    model = RequestModelFactory.create(model_name=config.model_name, attributes=config.model_attrs)\n    template = MappingTemplate(label_collection=label_collection, template=config.template)\n    post_processor = PostProcessor(config.label_mapping)\n    labels = pipeline(text=data, request_model=model, mapping_template=template, post_processing=post_processor)\n    labels = create_labels(config.task_type, labels)\n    return labels\n",
                                    "summary": "Functions `get_label_collection` and `execute_pipeline`: The former retrieves label classes based on task types, while the latter processes input data through a series of steps to generate labeled outputs according to a specified configuration.",
                                    "code_element_summaries": [
                                        "Function `get_label_collection`: Retrieves the appropriate label class based on the specified task type, returning a mapping of task types to their corresponding label classes.",
                                        "Function `execute_pipeline`: A function that processes input data through a series of steps involving model creation, mapping, and post-processing to generate labeled outputs based on the provided configuration."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "labels.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\pipeline\\labels.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `LabelCollection`\nCode:\nclass LabelCollection(abc.ABC):\n    label_type: Type[LabelType]\n    model: Type[Label]\n\n    def __init__(self, labels):\n        self.labels = labels\n\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        mapping = {c.text: c for c in self.label_type.objects.filter(project=project)}\n        annotations = []\n        for label in self.labels:\n            if label[\"label\"] not in mapping:\n                continue\n            label[\"example\"] = example\n            label[\"label\"] = mapping[label[\"label\"]]\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations\n\n    def save(self, project: Project, example: Example, user: User):\n        labels = self.transform(project, example, user)\n        labels = self.model.objects.filter_annotatable_labels(labels, project)\n        self.model.objects.bulk_create(labels)",
                                        "Function `__init__`\nCode:\n    def __init__(self, labels):\n        self.labels = labels",
                                        "Function `transform`\nCode:\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        mapping = {c.text: c for c in self.label_type.objects.filter(project=project)}\n        annotations = []\n        for label in self.labels:\n            if label[\"label\"] not in mapping:\n                continue\n            label[\"example\"] = example\n            label[\"label\"] = mapping[label[\"label\"]]\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations",
                                        "Function `save`\nCode:\n    def save(self, project: Project, example: Example, user: User):\n        labels = self.transform(project, example, user)\n        labels = self.model.objects.filter_annotatable_labels(labels, project)\n        self.model.objects.bulk_create(labels)",
                                        "Class `Categories`\nCode:\nclass Categories(LabelCollection):\n    label_type = CategoryType\n    model = Category",
                                        "Class `Spans`\nCode:\nclass Spans(LabelCollection):\n    label_type = SpanType\n    model = Span",
                                        "Class `Texts`\nCode:\nclass Texts(LabelCollection):\n    model = TextLabel\n\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        annotations = []\n        for label in self.labels:\n            label[\"example\"] = example\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations",
                                        "Function `transform`\nCode:\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        annotations = []\n        for label in self.labels:\n            label[\"example\"] = example\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations",
                                        "Function `create_labels`\nCode:\ndef create_labels(task_type: str, labels: Labels) -> LabelCollection:\n    return {\"Category\": Categories, \"Span\": Spans, \"Text\": Texts}[task_type](labels.dict())"
                                    ],
                                    "code": "import abc\nfrom typing import List, Type\n\nfrom auto_labeling_pipeline.labels import Labels\nfrom django.contrib.auth.models import User\n\nfrom examples.models import Example\nfrom label_types.models import CategoryType, LabelType, SpanType\nfrom labels.models import Category, Label, Span, TextLabel\nfrom projects.models import Project\n\n\nclass LabelCollection(abc.ABC):\n    label_type: Type[LabelType]\n    model: Type[Label]\n\n    def __init__(self, labels):\n        self.labels = labels\n\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        mapping = {c.text: c for c in self.label_type.objects.filter(project=project)}\n        annotations = []\n        for label in self.labels:\n            if label[\"label\"] not in mapping:\n                continue\n            label[\"example\"] = example\n            label[\"label\"] = mapping[label[\"label\"]]\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations\n\n    def save(self, project: Project, example: Example, user: User):\n        labels = self.transform(project, example, user)\n        labels = self.model.objects.filter_annotatable_labels(labels, project)\n        self.model.objects.bulk_create(labels)\n\n\nclass Categories(LabelCollection):\n    label_type = CategoryType\n    model = Category\n\n\nclass Spans(LabelCollection):\n    label_type = SpanType\n    model = Span\n\n\nclass Texts(LabelCollection):\n    model = TextLabel\n\n    def transform(self, project: Project, example: Example, user: User) -> List[Label]:\n        annotations = []\n        for label in self.labels:\n            label[\"example\"] = example\n            label[\"user\"] = user\n            annotations.append(self.model(**label))\n        return annotations\n\n\ndef create_labels(task_type: str, labels: Labels) -> LabelCollection:\n    return {\"Category\": Categories, \"Span\": Spans, \"Text\": Texts}[task_type](labels.dict())\n",
                                    "summary": "Class LabelCollection: An abstract base class that facilitates the transformation and saving of label annotations, while Classes Categories, Spans, and Texts manage specific types of labels and annotations within a project context.",
                                    "code_element_summaries": [
                                        "Class `LabelCollection`: An abstract base class that manages the transformation and saving of label annotations for a given project and example, utilizing specified label types and models.",
                                        "Function `__init__`: Initializes an instance with a list of labels.",
                                        "Function `transform`: A method that maps labels to their corresponding objects based on a project and user, creating a list of annotated labels for a given example.",
                                        "Function `save`: A method that transforms and filters labels for a project and example, then bulk creates the filtered labels in the database.",
                                        "Class Categories: A model for managing a collection of category labels, defined by the CategoryType and associated with the Category model.",
                                        "Class Spans: A collection model that manages spans of text annotations with a specified label type.",
                                        "Class Texts: A collection of labels that transforms label data into a list of TextLabel instances associated with a specific project, example, and user.",
                                        "Function `transform`: A method that creates and returns a list of Label instances associated with a given project, example, and user by populating label data with the provided example and user information.",
                                        "Function `create_labels`: A function that generates a LabelCollection based on the specified task type by mapping it to the corresponding label class and passing the labels as a dictionary."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\pipeline\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `AutoLabelingConfigSerializer`\nCode:\nclass AutoLabelingConfigSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = AutoLabelingConfig\n        fields = (\"id\", \"model_name\", \"model_attrs\", \"template\", \"label_mapping\", \"default\", \"task_type\")\n        read_only_fields = (\"created_at\", \"updated_at\")\n\n    def validate_model_name(self, value):\n        try:\n            RequestModelFactory.find(value)\n        except NameError:\n            raise serializers.ValidationError(f\"The specified model name {value} does not exist.\")\n        return value\n\n    def valid_label_mapping(self, value):\n        if isinstance(value, dict):\n            return value\n        else:\n            raise serializers.ValidationError(f\"The {value} is not a dictionary. Please specify it as a dictionary.\")\n\n    def validate(self, data):\n        try:\n            RequestModelFactory.create(data[\"model_name\"], data[\"model_attrs\"])\n        except Exception:\n            model = RequestModelFactory.find(data[\"model_name\"])\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise serializers.ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )\n        return data",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = AutoLabelingConfig\n        fields = (\"id\", \"model_name\", \"model_attrs\", \"template\", \"label_mapping\", \"default\", \"task_type\")\n        read_only_fields = (\"created_at\", \"updated_at\")",
                                "Function `validate_model_name`\nCode:\n    def validate_model_name(self, value):\n        try:\n            RequestModelFactory.find(value)\n        except NameError:\n            raise serializers.ValidationError(f\"The specified model name {value} does not exist.\")\n        return value",
                                "Function `valid_label_mapping`\nCode:\n    def valid_label_mapping(self, value):\n        if isinstance(value, dict):\n            return value\n        else:\n            raise serializers.ValidationError(f\"The {value} is not a dictionary. Please specify it as a dictionary.\")",
                                "Function `validate`\nCode:\n    def validate(self, data):\n        try:\n            RequestModelFactory.create(data[\"model_name\"], data[\"model_attrs\"])\n        except Exception:\n            model = RequestModelFactory.find(data[\"model_name\"])\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise serializers.ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )\n        return data"
                            ],
                            "code": "from auto_labeling_pipeline.models import RequestModelFactory\nfrom rest_framework import serializers\n\nfrom .models import AutoLabelingConfig\n\n\nclass AutoLabelingConfigSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = AutoLabelingConfig\n        fields = (\"id\", \"model_name\", \"model_attrs\", \"template\", \"label_mapping\", \"default\", \"task_type\")\n        read_only_fields = (\"created_at\", \"updated_at\")\n\n    def validate_model_name(self, value):\n        try:\n            RequestModelFactory.find(value)\n        except NameError:\n            raise serializers.ValidationError(f\"The specified model name {value} does not exist.\")\n        return value\n\n    def valid_label_mapping(self, value):\n        if isinstance(value, dict):\n            return value\n        else:\n            raise serializers.ValidationError(f\"The {value} is not a dictionary. Please specify it as a dictionary.\")\n\n    def validate(self, data):\n        try:\n            RequestModelFactory.create(data[\"model_name\"], data[\"model_attrs\"])\n        except Exception:\n            model = RequestModelFactory.find(data[\"model_name\"])\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise serializers.ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )\n        return data\n",
                            "summary": "Class AutoLabelingConfigSerializer: A serializer for the AutoLabelingConfig model that validates model names, label mappings, and input attributes while ensuring read-only specifications in its configuration class.",
                            "code_element_summaries": [
                                "Class AutoLabelingConfigSerializer: A serializer for the AutoLabelingConfig model that validates model names, label mappings, and ensures that provided attributes match the model's requirements.",
                                "Class Meta: A configuration class that defines the model and fields for AutoLabelingConfig, specifying which fields are read-only.",
                                "Function `validate_model_name`: Validates the existence of a specified model name by checking it against the RequestModelFactory, raising a validation error if the model does not exist.",
                                "Function `valid_label_mapping`: Validates that the input value is a dictionary, raising a validation error if it is not.",
                                "Function `validate`: Validates input data by attempting to create a model instance and raises a validation error if the attributes do not match the model's required fields."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class TestTemplateList and related test classes offer a thorough testing framework to ensure proper access control, response behavior, and validation of automated labeling functionalities in a document classification project.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestTemplateList`\nCode:\nclass TestTemplateList(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"auto_labeling_templates\", args=[self.project.item.id])\n\n    def test_allow_admin_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertIn(\"Custom REST Request\", response.data)\n        self.assertGreaterEqual(len(response.data), 1)\n\n    def test_deny_project_staff_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        for user in self.project.staffs:\n            self.assert_fetch(user, status.HTTP_403_FORBIDDEN)\n\n    def test_return_only_default_template_with_empty_task_name(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)\n\n    def test_return_only_default_template_with_wrong_task_name(self):\n        self.url += \"?task_name=foobar\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"auto_labeling_templates\", args=[self.project.item.id])",
                                        "Function `test_allow_admin_to_fetch_template_list`\nCode:\n    def test_allow_admin_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertIn(\"Custom REST Request\", response.data)\n        self.assertGreaterEqual(len(response.data), 1)",
                                        "Function `test_deny_project_staff_to_fetch_template_list`\nCode:\n    def test_deny_project_staff_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        for user in self.project.staffs:\n            self.assert_fetch(user, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_return_only_default_template_with_empty_task_name`\nCode:\n    def test_return_only_default_template_with_empty_task_name(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)",
                                        "Function `test_return_only_default_template_with_wrong_task_name`\nCode:\n    def test_return_only_default_template_with_wrong_task_name(self):\n        self.url += \"?task_name=foobar\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)",
                                        "Class `TestConfigParameter`\nCode:\nclass TestConfigParameter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"GCP Entity Analysis\",\n            \"model_attrs\": {\"key\": \"hoge\", \"type\": \"PLAIN_TEXT\", \"language\": \"en\"},\n            \"text\": \"example\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_parameter_testing\", args=[self.project.item.id])\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_proper_model(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        expected = RequestModelFactory.create(self.data[\"model_name\"], self.data[\"model_attrs\"])\n        self.assertEqual(kwargs[\"model\"], expected)\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_text(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_image(self, mock):\n        self.data[\"text\"] = str(data_dir / \"images/1500x500.jpeg\")\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"GCP Entity Analysis\",\n            \"model_attrs\": {\"key\": \"hoge\", \"type\": \"PLAIN_TEXT\", \"language\": \"en\"},\n            \"text\": \"example\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_parameter_testing\", args=[self.project.item.id])",
                                        "Function `test_called_with_proper_model`\nCode:\n    def test_called_with_proper_model(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        expected = RequestModelFactory.create(self.data[\"model_name\"], self.data[\"model_attrs\"])\n        self.assertEqual(kwargs[\"model\"], expected)",
                                        "Function `test_called_with_text`\nCode:\n    def test_called_with_text(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])",
                                        "Function `test_called_with_image`\nCode:\n    def test_called_with_image(self, mock):\n        self.data[\"text\"] = str(data_dir / \"images/1500x500.jpeg\")\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])",
                                        "Class `TestTemplateMapping`\nCode:\nclass TestTemplateMapping(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": {\n                \"Sentiment\": \"NEUTRAL\",\n                \"SentimentScore\": {\n                    \"Positive\": 0.004438233096152544,\n                    \"Negative\": 0.0005306027014739811,\n                    \"Neutral\": 0.9950305223464966,\n                    \"Mixed\": 5.80838445785048e-7,\n                },\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_template_test\", args=[self.project.item.id])\n\n    def test_template_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"NEUTRAL\"}]\n        self.assertEqual(response.json(), expected)\n\n    def test_json_decode_error(self):\n        self.data[\"template\"] = \"\"\n        self.assert_create(self.project.admin, status.HTTP_400_BAD_REQUEST)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": {\n                \"Sentiment\": \"NEUTRAL\",\n                \"SentimentScore\": {\n                    \"Positive\": 0.004438233096152544,\n                    \"Negative\": 0.0005306027014739811,\n                    \"Neutral\": 0.9950305223464966,\n                    \"Mixed\": 5.80838445785048e-7,\n                },\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_template_test\", args=[self.project.item.id])",
                                        "Function `test_template_mapping`\nCode:\n    def test_template_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"NEUTRAL\"}]\n        self.assertEqual(response.json(), expected)",
                                        "Function `test_json_decode_error`\nCode:\n    def test_json_decode_error(self):\n        self.data[\"template\"] = \"\"\n        self.assert_create(self.project.admin, status.HTTP_400_BAD_REQUEST)",
                                        "Class `TestLabelMapping`\nCode:\nclass TestLabelMapping(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": [{\"label\": \"NEGATIVE\"}],\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_mapping_test\", args=[self.project.item.id])\n\n    def test_label_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"Negative\"}]\n        self.assertEqual(response.json(), expected)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": [{\"label\": \"NEGATIVE\"}],\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_mapping_test\", args=[self.project.item.id])",
                                        "Function `test_label_mapping`\nCode:\n    def test_label_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"Negative\"}]\n        self.assertEqual(response.json(), expected)",
                                        "Class `TestConfigCreation`\nCode:\nclass TestConfigCreation(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"Amazon Comprehend Sentiment Analysis\",\n            \"model_attrs\": {\n                \"aws_access_key\": \"str\",\n                \"aws_secret_access_key\": \"str\",\n                \"region_name\": \"us-east-1\",\n                \"language_code\": \"en\",\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_configs\", args=[self.project.item.id])\n\n    def test_create_config(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"model_name\"], self.data[\"model_name\"])\n\n    def test_list_config(self):\n        mommy.make(\"AutoLabelingConfig\", project=self.project.item)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"Amazon Comprehend Sentiment Analysis\",\n            \"model_attrs\": {\n                \"aws_access_key\": \"str\",\n                \"aws_secret_access_key\": \"str\",\n                \"region_name\": \"us-east-1\",\n                \"language_code\": \"en\",\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_configs\", args=[self.project.item.id])",
                                        "Function `test_create_config`\nCode:\n    def test_create_config(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"model_name\"], self.data[\"model_name\"])",
                                        "Function `test_list_config`\nCode:\n    def test_list_config(self):\n        mommy.make(\"AutoLabelingConfig\", project=self.project.item)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)",
                                        "Class `TestAutomatedLabeling`\nCode:\nclass TestAutomatedLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, single_class_classification=False)\n        self.example = make_doc(self.project.item)\n        self.category_pos = mommy.make(\"CategoryType\", project=self.project.item, text=\"POS\")\n        self.category_neg = mommy.make(\"CategoryType\", project=self.project.item, text=\"NEG\")\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"POS\"}]))\n    def test_category_labeling(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Category.objects.first().label, self.category_pos)\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"NEUTRAL\"}]))\n    def test_nonexistent_category(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[Categories([{\"label\": \"POS\"}]), Categories([{\"label\": \"NEG\"}])],\n    )\n    def test_multiple_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 2)\n        self.assertEqual(Category.objects.first().label, self.category_pos)\n        self.assertEqual(Category.objects.last().label, self.category_neg)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[Categories([{\"label\": \"POS\"}]), Categories([{\"label\": \"POS\"}])],\n    )\n    def test_cannot_label_same_category_type(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[\n            Categories([{\"label\": \"POS\"}]),\n            Spans([{\"label\": \"LOC\", \"start_offset\": 0, \"end_offset\": 5}]),\n        ],\n    )\n    def test_allow_multi_type_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Span.objects.count(), 1)\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"POS\"}]))\n    def test_cannot_use_other_project_config(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\")\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, single_class_classification=False)\n        self.example = make_doc(self.project.item)\n        self.category_pos = mommy.make(\"CategoryType\", project=self.project.item, text=\"POS\")\n        self.category_neg = mommy.make(\"CategoryType\", project=self.project.item, text=\"NEG\")\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"",
                                        "Function `test_category_labeling`\nCode:\n    def test_category_labeling(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Category.objects.first().label, self.category_pos)",
                                        "Function `test_nonexistent_category`\nCode:\n    def test_nonexistent_category(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)",
                                        "Function `test_multiple_configs`\nCode:\n    def test_multiple_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 2)\n        self.assertEqual(Category.objects.first().label, self.category_pos)\n        self.assertEqual(Category.objects.last().label, self.category_neg)",
                                        "Function `test_cannot_label_same_category_type`\nCode:\n    def test_cannot_label_same_category_type(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)",
                                        "Function `test_allow_multi_type_configs`\nCode:\n    def test_allow_multi_type_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Span.objects.count(), 1)",
                                        "Function `test_cannot_use_other_project_config`\nCode:\n    def test_cannot_use_other_project_config(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\")\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)",
                                        "Class `TestAutomatedSpanLabeling`\nCode:\nclass TestAutomatedSpanLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQUENCE_LABELING)\n        self.example = make_doc(self.project.item)\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[\n            Spans([{\"label\": \"LOC\", \"start_offset\": 0, \"end_offset\": 5}]),\n            Spans([{\"label\": \"LOC\", \"start_offset\": 4, \"end_offset\": 10}]),\n        ],\n    )\n    def test_cannot_label_overlapping_span(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Span.objects.count(), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQUENCE_LABELING)\n        self.example = make_doc(self.project.item)\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"",
                                        "Function `test_cannot_label_overlapping_span`\nCode:\n    def test_cannot_label_overlapping_span(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Span.objects.count(), 1)",
                                        "Class `TestAutomatedTextLabeling`\nCode:\nclass TestAutomatedTextLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQ2SEQ)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\"auto_labeling.views.execute_pipeline\", side_effect=[Texts([{\"text\": \"foo\"}]), Texts([{\"text\": \"foo\"}])])\n    def test_cannot_label_same_text(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(TextLabel.objects.count(), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQ2SEQ)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"",
                                        "Function `test_cannot_label_same_text`\nCode:\n    def test_cannot_label_same_text(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(TextLabel.objects.count(), 1)"
                                    ],
                                    "code": "import pathlib\nfrom unittest.mock import patch\n\nfrom auto_labeling_pipeline.mappings import AmazonComprehendSentimentTemplate\nfrom auto_labeling_pipeline.models import RequestModelFactory\nfrom model_mommy import mommy\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom auto_labeling.pipeline.labels import Categories, Spans, Texts\nfrom examples.tests.utils import make_doc\nfrom labels.models import Category, Span, TextLabel\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\ndata_dir = pathlib.Path(__file__).parent / \"data\"\n\n\nclass TestTemplateList(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"auto_labeling_templates\", args=[self.project.item.id])\n\n    def test_allow_admin_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertIn(\"Custom REST Request\", response.data)\n        self.assertGreaterEqual(len(response.data), 1)\n\n    def test_deny_project_staff_to_fetch_template_list(self):\n        self.url += \"?task_name=DocumentClassification\"\n        for user in self.project.staffs:\n            self.assert_fetch(user, status.HTTP_403_FORBIDDEN)\n\n    def test_return_only_default_template_with_empty_task_name(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)\n\n    def test_return_only_default_template_with_wrong_task_name(self):\n        self.url += \"?task_name=foobar\"\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertIn(\"Custom REST Request\", response.data)\n\n\nclass TestConfigParameter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"GCP Entity Analysis\",\n            \"model_attrs\": {\"key\": \"hoge\", \"type\": \"PLAIN_TEXT\", \"language\": \"en\"},\n            \"text\": \"example\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_parameter_testing\", args=[self.project.item.id])\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_proper_model(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        expected = RequestModelFactory.create(self.data[\"model_name\"], self.data[\"model_attrs\"])\n        self.assertEqual(kwargs[\"model\"], expected)\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_text(self, mock):\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])\n\n    @patch(\"auto_labeling.views.RestAPIRequestTesting.send_request\", return_value={})\n    def test_called_with_image(self, mock):\n        self.data[\"text\"] = str(data_dir / \"images/1500x500.jpeg\")\n        self.assert_create(self.project.admin, status.HTTP_200_OK)\n        _, kwargs = mock.call_args\n        self.assertEqual(kwargs[\"example\"], self.data[\"text\"])\n\n\nclass TestTemplateMapping(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": {\n                \"Sentiment\": \"NEUTRAL\",\n                \"SentimentScore\": {\n                    \"Positive\": 0.004438233096152544,\n                    \"Negative\": 0.0005306027014739811,\n                    \"Neutral\": 0.9950305223464966,\n                    \"Mixed\": 5.80838445785048e-7,\n                },\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_template_test\", args=[self.project.item.id])\n\n    def test_template_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"NEUTRAL\"}]\n        self.assertEqual(response.json(), expected)\n\n    def test_json_decode_error(self):\n        self.data[\"template\"] = \"\"\n        self.assert_create(self.project.admin, status.HTTP_400_BAD_REQUEST)\n\n\nclass TestLabelMapping(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"response\": [{\"label\": \"NEGATIVE\"}],\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_mapping_test\", args=[self.project.item.id])\n\n    def test_label_mapping(self):\n        response = self.assert_create(self.project.admin, status.HTTP_200_OK)\n        expected = [{\"label\": \"Negative\"}]\n        self.assertEqual(response.json(), expected)\n\n\nclass TestConfigCreation(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.data = {\n            \"model_name\": \"Amazon Comprehend Sentiment Analysis\",\n            \"model_attrs\": {\n                \"aws_access_key\": \"str\",\n                \"aws_secret_access_key\": \"str\",\n                \"region_name\": \"us-east-1\",\n                \"language_code\": \"en\",\n            },\n            \"template\": AmazonComprehendSentimentTemplate().load(),\n            \"label_mapping\": {\"NEGATIVE\": \"Negative\"},\n            \"task_type\": \"Category\",\n        }\n        self.url = reverse(viewname=\"auto_labeling_configs\", args=[self.project.item.id])\n\n    def test_create_config(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"model_name\"], self.data[\"model_name\"])\n\n    def test_list_config(self):\n        mommy.make(\"AutoLabelingConfig\", project=self.project.item)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n\n\nclass TestAutomatedLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, single_class_classification=False)\n        self.example = make_doc(self.project.item)\n        self.category_pos = mommy.make(\"CategoryType\", project=self.project.item, text=\"POS\")\n        self.category_neg = mommy.make(\"CategoryType\", project=self.project.item, text=\"NEG\")\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"POS\"}]))\n    def test_category_labeling(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Category.objects.first().label, self.category_pos)\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"NEUTRAL\"}]))\n    def test_nonexistent_category(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[Categories([{\"label\": \"POS\"}]), Categories([{\"label\": \"NEG\"}])],\n    )\n    def test_multiple_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 2)\n        self.assertEqual(Category.objects.first().label, self.category_pos)\n        self.assertEqual(Category.objects.last().label, self.category_neg)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[Categories([{\"label\": \"POS\"}]), Categories([{\"label\": \"POS\"}])],\n    )\n    def test_cannot_label_same_category_type(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[\n            Categories([{\"label\": \"POS\"}]),\n            Spans([{\"label\": \"LOC\", \"start_offset\": 0, \"end_offset\": 5}]),\n        ],\n    )\n    def test_allow_multi_type_configs(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 1)\n        self.assertEqual(Span.objects.count(), 1)\n\n    @patch(\"auto_labeling.views.execute_pipeline\", return_value=Categories([{\"label\": \"POS\"}]))\n    def test_cannot_use_other_project_config(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Category\")\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Category.objects.count(), 0)\n\n\nclass TestAutomatedSpanLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQUENCE_LABELING)\n        self.example = make_doc(self.project.item)\n        self.loc = mommy.make(\"SpanType\", project=self.project.item, text=\"LOC\")\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\n        \"auto_labeling.views.execute_pipeline\",\n        side_effect=[\n            Spans([{\"label\": \"LOC\", \"start_offset\": 0, \"end_offset\": 5}]),\n            Spans([{\"label\": \"LOC\", \"start_offset\": 4, \"end_offset\": 10}]),\n        ],\n    )\n    def test_cannot_label_overlapping_span(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Span\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(Span.objects.count(), 1)\n\n\nclass TestAutomatedTextLabeling(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.SEQ2SEQ)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"auto_labeling\", args=[self.project.item.id])\n        self.url += f\"?example={self.example.id}\"\n\n    @patch(\"auto_labeling.views.execute_pipeline\", side_effect=[Texts([{\"text\": \"foo\"}]), Texts([{\"text\": \"foo\"}])])\n    def test_cannot_label_same_text(self, mock):\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        mommy.make(\"AutoLabelingConfig\", task_type=\"Text\", project=self.project.item)\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(TextLabel.objects.count(), 1)\n",
                                    "summary": "Class TestTemplateList and its associated functions provide a comprehensive test suite for verifying access control and response behavior of a template list endpoint in a document classification project, while additional classes like TestConfigParameter, TestTemplateMapping, TestLabelMapping, TestConfigCreation, TestAutomatedLabeling, TestAutomatedSpanLabeling, and TestAutomatedTextLabeling focus on validating various aspects of automated labeling functionalities, configuration creation, and handling of labels and spans across different project contexts.",
                                    "code_element_summaries": [
                                        "Class TestTemplateList: A test suite that verifies the access control and response behavior of a template list endpoint for different user roles in a document classification project.",
                                        "Function `setUp`: A setup method that initializes a project for document classification and constructs a URL for auto-labeling templates based on the project's item ID.",
                                        "Function `test_allow_admin_to_fetch_template_list`: A test case that verifies an admin user can successfully retrieve a list of templates related to document classification, ensuring the response contains specific data and at least one item.",
                                        "Function `test_deny_project_staff_to_fetch_template_list`: A test case that verifies project staff are forbidden from fetching the template list for the DocumentClassification task, expecting a 403 Forbidden status.",
                                        "Function `test_return_only_default_template_with_empty_task_name`: A test that verifies the response contains only the default template with an empty task name, ensuring the response status is 200 OK and includes \"Custom REST Request\".",
                                        "Function `test_return_only_default_template_with_wrong_task_name`: A test case that verifies the response contains only the default template when an invalid task name is provided.",
                                        "Class `TestConfigParameter`: A test case for validating the behavior of the auto-labeling parameter testing API, ensuring that the correct model, text, and image data are sent in requests.",
                                        "Function `setUp`: Prepares a test environment by initializing a project for document classification and setting up associated data and URL for auto-labeling parameter testing.",
                                        "Function `test_called_with_proper_model`: A test function that verifies the correct model is passed to a mock during the creation process in a project admin context.",
                                        "Function `test_called_with_text`: A test function that verifies the creation of a project admin and checks if the \"example\" argument in the mock call matches the expected text data.",
                                        "Function `test_called_with_image`: A test function that verifies the correct handling of an image file by asserting the expected example value against the provided data during a project creation process.",
                                        "Class `TestTemplateMapping`: A test case for verifying the functionality of template mapping in a document classification project, including handling of successful and erroneous responses.",
                                        "Function `setUp`: Prepares a project for document classification and initializes data containing sentiment analysis results and a template for auto-labeling tests.",
                                        "Function `test_template_mapping`: A test function that verifies the creation of a template mapping response with an expected label of \"NEUTRAL\" and checks for a successful HTTP 200 OK status.",
                                        "Function `test_json_decode_error`: Tests the behavior of the application when an empty template is provided, expecting a 400 Bad Request response.",
                                        "Class TestLabelMapping: A test case for verifying the label mapping functionality in a document classification project, ensuring that the response matches the expected label format.",
                                        "Function `setUp`: A setup method that initializes a project for document classification, prepares test data including a label mapping, and constructs a URL for a specific view related to auto-labeling.",
                                        "Function `test_label_mapping`: A test case that verifies the label mapping functionality by asserting that the response from a create operation matches the expected label output.",
                                        "Class TestConfigCreation: A test case for creating and listing auto-labeling configurations in a document classification project, verifying the correct setup and response from the API.",
                                        "Function `setUp`: A setup method that initializes a project for document classification and prepares configuration data for an Amazon Comprehend Sentiment Analysis model.",
                                        "Function `test_create_config`: A test function that verifies the successful creation of a configuration by asserting the response status and checking the model name in the response data.",
                                        "Function `test_list_config`: A test function that verifies the successful creation and retrieval of an `AutoLabelingConfig` instance, ensuring the response contains exactly one item.",
                                        "Class TestAutomatedLabeling: A test suite for verifying the functionality of automated labeling in a document classification project, ensuring correct category assignments and handling of multiple configurations.",
                                        "Function `setUp`: Prepares the test environment by creating a project for document classification, an example document, category types for positive and negative labels, a location span, and constructs a URL for auto-labeling with the example document's ID.",
                                        "Function `test_category_labeling`: A test function that verifies the creation of a category label in the AutoLabelingConfig for a project, ensuring the correct status and label assignment.",
                                        "Function `test_nonexistent_category`: A test case that verifies no categories are created when an AutoLabelingConfig is made for a Category task type.",
                                        "Function `test_multiple_configs`: A test function that verifies the creation of multiple AutoLabelingConfig instances and checks the resulting Category count and labels.",
                                        "Function `test_cannot_label_same_category_type`: A test case ensuring that only one category can be labeled for a given project, validating the creation of an `AutoLabelingConfig` and asserting that only one `Category` instance exists.",
                                        "Function `test_allow_multi_type_configs`: A test function that verifies the creation of multiple AutoLabelingConfig instances for different task types and checks the count of corresponding Category and Span objects.",
                                        "Function `test_cannot_use_other_project_config`: A test case that verifies the inability to create a category when using a configuration from a different project.",
                                        "Class `TestAutomatedSpanLabeling`: A test case for verifying the behavior of automated span labeling, ensuring that overlapping spans cannot be created in a sequence labeling project.",
                                        "Function `setUp`: Initializes a test environment by preparing a sequence labeling project, creating a document example, generating a span type for location, and constructing a URL for auto-labeling with the project's item ID and example ID.",
                                        "Function `test_cannot_label_overlapping_span`: A test case that ensures overlapping span labels cannot be created, confirming that only one span is recorded after attempting to create multiple configurations.",
                                        "Class TestAutomatedTextLabeling: A test case for the automated text labeling feature, ensuring that the same text cannot be labeled multiple times within a specific project context.",
                                        "Function `setUp`: Initializes a test environment by preparing a project, creating a document example, and constructing a URL for auto-labeling with the project's item ID and example ID.",
                                        "Function `test_cannot_label_same_text`: A test case that verifies the system prevents the creation of duplicate text labels for a project by ensuring only one label is created when attempting to add the same text label twice."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import (\n    AutomatedLabeling,\n    ConfigDetail,\n    ConfigList,\n    LabelExtractorTesting,\n    LabelMapperTesting,\n    RestAPIRequestTesting,\n    TemplateDetailAPI,\n    TemplateListAPI,\n)\n\nurlpatterns = [\n    path(route=\"auto-labeling/templates\", view=TemplateListAPI.as_view(), name=\"auto_labeling_templates\"),\n    path(\n        route=\"auto-labeling/templates/<str:option_name>\",\n        view=TemplateDetailAPI.as_view(),\n        name=\"auto_labeling_template\",\n    ),\n    path(route=\"auto-labeling/configs\", view=ConfigList.as_view(), name=\"auto_labeling_configs\"),\n    path(route=\"auto-labeling/configs/<int:config_id>\", view=ConfigDetail.as_view(), name=\"auto_labeling_config\"),\n    path(\n        route=\"auto-labeling/request-testing\",\n        view=RestAPIRequestTesting.as_view(),\n        name=\"auto_labeling_parameter_testing\",\n    ),\n    path(\n        route=\"auto-labeling/label-extractor-testing\",\n        view=LabelExtractorTesting.as_view(),\n        name=\"auto_labeling_template_test\",\n    ),\n    path(\n        route=\"auto-labeling/label-mapper-testing\", view=LabelMapperTesting.as_view(), name=\"auto_labeling_mapping_test\"\n    ),\n    path(route=\"auto-labeling\", view=AutomatedLabeling.as_view(), name=\"auto_labeling\"),\n]\n",
                            "summary": "URL patterns for the automated labeling feature, mapping various views to specific routes for templates, configurations, and testing functionalities in a Django application.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `TemplateListAPI`\nCode:\nclass TemplateListAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request: Request, *args, **kwargs):\n        task_name = request.query_params.get(\"task_name\")\n        options = Options.filter_by_task(task_name=task_name)\n        option_names = [o.name for o in options]\n        return Response(option_names, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request: Request, *args, **kwargs):\n        task_name = request.query_params.get(\"task_name\")\n        options = Options.filter_by_task(task_name=task_name)\n        option_names = [o.name for o in options]\n        return Response(option_names, status=status.HTTP_200_OK)",
                                "Class `TemplateDetailAPI`\nCode:\nclass TemplateDetailAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        option = Options.find(option_name=self.kwargs[\"option_name\"])\n        return Response(option.to_dict(), status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        option = Options.find(option_name=self.kwargs[\"option_name\"])\n        return Response(option.to_dict(), status=status.HTTP_200_OK)",
                                "Class `ConfigList`\nCode:\nclass ConfigList(generics.ListCreateAPIView):\n    serializer_class = AutoLabelingConfigSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get_queryset(self):\n        return AutoLabelingConfig.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])",
                                "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        return AutoLabelingConfig.objects.filter(project=self.kwargs[\"project_id\"])",
                                "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])",
                                "Class `ConfigDetail`\nCode:\nclass ConfigDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = AutoLabelingConfig.objects.all()\n    serializer_class = AutoLabelingConfigSerializer\n    lookup_url_kwarg = \"config_id\"\n    permission_classes = [IsAuthenticated & IsProjectAdmin]",
                                "Class `RestAPIRequestTesting`\nCode:\nclass RestAPIRequestTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def create_model(self):\n        model_name = self.request.data[\"model_name\"]\n        model_attrs = self.request.data[\"model_attrs\"]\n        try:\n            model = RequestModelFactory.create(model_name, model_attrs)\n            return model\n        except Exception:\n            model = RequestModelFactory.find(model_name)\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )\n\n    def send_request(self, model, example):\n        try:\n            return model.send(example)\n        except requests.exceptions.ConnectionError:\n            raise URLConnectionError\n        except botocore.exceptions.ClientError:\n            raise AWSTokenError()\n        except json.decoder.JSONDecodeError:\n            raise ResponseJSONDecodeError()\n        except Exception as e:\n            raise e\n\n    def prepare_example(self):\n        text = self.request.data[\"text\"]\n        if self.project.is_text_project:\n            return text\n        else:\n            tu = TemporaryUpload.objects.get(upload_id=text)\n            return tu.get_file_path()\n\n    def post(self, *args, **kwargs):\n        model = self.create_model()\n        example = self.prepare_example()\n        response = self.send_request(model=model, example=example)\n        return Response(response, status=status.HTTP_200_OK)",
                                "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                "Function `create_model`\nCode:\n    def create_model(self):\n        model_name = self.request.data[\"model_name\"]\n        model_attrs = self.request.data[\"model_attrs\"]\n        try:\n            model = RequestModelFactory.create(model_name, model_attrs)\n            return model\n        except Exception:\n            model = RequestModelFactory.find(model_name)\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )",
                                "Function `send_request`\nCode:\n    def send_request(self, model, example):\n        try:\n            return model.send(example)\n        except requests.exceptions.ConnectionError:\n            raise URLConnectionError\n        except botocore.exceptions.ClientError:\n            raise AWSTokenError()\n        except json.decoder.JSONDecodeError:\n            raise ResponseJSONDecodeError()\n        except Exception as e:\n            raise e",
                                "Function `prepare_example`\nCode:\n    def prepare_example(self):\n        text = self.request.data[\"text\"]\n        if self.project.is_text_project:\n            return text\n        else:\n            tu = TemporaryUpload.objects.get(upload_id=text)\n            return tu.get_file_path()",
                                "Function `post`\nCode:\n    def post(self, *args, **kwargs):\n        model = self.create_model()\n        example = self.prepare_example()\n        response = self.send_request(model=model, example=example)\n        return Response(response, status=status.HTTP_200_OK)",
                                "Class `LabelExtractorTesting`\nCode:\nclass LabelExtractorTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        template = self.request.data[\"template\"]\n        task_type = self.request.data[\"task_type\"]\n        label_collection = get_label_collection(task_type)\n        template = MappingTemplate(label_collection=label_collection, template=template)\n        try:\n            labels = template.render(response)\n        except json.decoder.JSONDecodeError:\n            raise TemplateMappingError()\n        if not labels.dict():\n            raise SampleDataException()\n        return Response(labels.dict(), status=status.HTTP_200_OK)",
                                "Function `post`\nCode:\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        template = self.request.data[\"template\"]\n        task_type = self.request.data[\"task_type\"]\n        label_collection = get_label_collection(task_type)\n        template = MappingTemplate(label_collection=label_collection, template=template)\n        try:\n            labels = template.render(response)\n        except json.decoder.JSONDecodeError:\n            raise TemplateMappingError()\n        if not labels.dict():\n            raise SampleDataException()\n        return Response(labels.dict(), status=status.HTTP_200_OK)",
                                "Class `LabelMapperTesting`\nCode:\nclass LabelMapperTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        task_type = self.request.data[\"task_type\"]\n        label_mapping = self.request.data[\"label_mapping\"]\n        label_collection = get_label_collection(task_type)\n        labels = label_collection(response)\n        post_processor = PostProcessor(label_mapping)\n        labels = post_processor.transform(labels)\n        return Response(labels.dict(), status=status.HTTP_200_OK)",
                                "Function `post`\nCode:\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        task_type = self.request.data[\"task_type\"]\n        label_mapping = self.request.data[\"label_mapping\"]\n        label_collection = get_label_collection(task_type)\n        labels = label_collection(response)\n        post_processor = PostProcessor(label_mapping)\n        labels = post_processor.transform(labels)\n        return Response(labels.dict(), status=status.HTTP_200_OK)",
                                "Class `AutomatedLabeling`\nCode:\nclass AutomatedLabeling(generics.CreateAPIView):\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    swagger_schema = None\n\n    def create(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        example = project.examples.get(pk=self.request.query_params[\"example\"])\n        configs = AutoLabelingConfig.objects.filter(project=project)\n        # Todo: make async calls or celery tasks to reduce waiting time.\n        for config in configs:\n            labels = execute_pipeline(example.data, config=config)\n            labels.save(project, example, self.request.user)\n        return Response({\"ok\": True}, status=status.HTTP_201_CREATED)",
                                "Function `create`\nCode:\n    def create(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        example = project.examples.get(pk=self.request.query_params[\"example\"])\n        configs = AutoLabelingConfig.objects.filter(project=project)\n        # Todo: make async calls or celery tasks to reduce waiting time.\n        for config in configs:\n            labels = execute_pipeline(example.data, config=config)\n            labels.save(project, example, self.request.user)\n        return Response({\"ok\": True}, status=status.HTTP_201_CREATED)"
                            ],
                            "code": "import json\n\nimport botocore.exceptions\nimport requests\nfrom auto_labeling_pipeline.mappings import MappingTemplate\nfrom auto_labeling_pipeline.menu import Options\nfrom auto_labeling_pipeline.models import RequestModelFactory\nfrom auto_labeling_pipeline.postprocessing import PostProcessor\nfrom django.shortcuts import get_object_or_404\nfrom django_drf_filepond.models import TemporaryUpload\nfrom rest_framework import generics, status\nfrom rest_framework.exceptions import ValidationError\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom .exceptions import (\n    AWSTokenError,\n    ResponseJSONDecodeError,\n    SampleDataException,\n    TemplateMappingError,\n    URLConnectionError,\n)\nfrom .models import AutoLabelingConfig\nfrom .pipeline.execution import execute_pipeline, get_label_collection\nfrom .serializers import AutoLabelingConfigSerializer\nfrom projects.models import Project\nfrom projects.permissions import IsProjectAdmin, IsProjectMember\n\n\nclass TemplateListAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request: Request, *args, **kwargs):\n        task_name = request.query_params.get(\"task_name\")\n        options = Options.filter_by_task(task_name=task_name)\n        option_names = [o.name for o in options]\n        return Response(option_names, status=status.HTTP_200_OK)\n\n\nclass TemplateDetailAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        option = Options.find(option_name=self.kwargs[\"option_name\"])\n        return Response(option.to_dict(), status=status.HTTP_200_OK)\n\n\nclass ConfigList(generics.ListCreateAPIView):\n    serializer_class = AutoLabelingConfigSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get_queryset(self):\n        return AutoLabelingConfig.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])\n\n\nclass ConfigDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = AutoLabelingConfig.objects.all()\n    serializer_class = AutoLabelingConfigSerializer\n    lookup_url_kwarg = \"config_id\"\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n\nclass RestAPIRequestTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def create_model(self):\n        model_name = self.request.data[\"model_name\"]\n        model_attrs = self.request.data[\"model_attrs\"]\n        try:\n            model = RequestModelFactory.create(model_name, model_attrs)\n            return model\n        except Exception:\n            model = RequestModelFactory.find(model_name)\n            schema = model.schema()\n            required_fields = \", \".join(schema[\"required\"]) if \"required\" in schema else \"\"\n            raise ValidationError(\n                \"The attributes does not match the model.\"\n                \"You need to correctly specify the required fields: {}\".format(required_fields)\n            )\n\n    def send_request(self, model, example):\n        try:\n            return model.send(example)\n        except requests.exceptions.ConnectionError:\n            raise URLConnectionError\n        except botocore.exceptions.ClientError:\n            raise AWSTokenError()\n        except json.decoder.JSONDecodeError:\n            raise ResponseJSONDecodeError()\n        except Exception as e:\n            raise e\n\n    def prepare_example(self):\n        text = self.request.data[\"text\"]\n        if self.project.is_text_project:\n            return text\n        else:\n            tu = TemporaryUpload.objects.get(upload_id=text)\n            return tu.get_file_path()\n\n    def post(self, *args, **kwargs):\n        model = self.create_model()\n        example = self.prepare_example()\n        response = self.send_request(model=model, example=example)\n        return Response(response, status=status.HTTP_200_OK)\n\n\nclass LabelExtractorTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        template = self.request.data[\"template\"]\n        task_type = self.request.data[\"task_type\"]\n        label_collection = get_label_collection(task_type)\n        template = MappingTemplate(label_collection=label_collection, template=template)\n        try:\n            labels = template.render(response)\n        except json.decoder.JSONDecodeError:\n            raise TemplateMappingError()\n        if not labels.dict():\n            raise SampleDataException()\n        return Response(labels.dict(), status=status.HTTP_200_OK)\n\n\nclass LabelMapperTesting(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        response = self.request.data[\"response\"]\n        task_type = self.request.data[\"task_type\"]\n        label_mapping = self.request.data[\"label_mapping\"]\n        label_collection = get_label_collection(task_type)\n        labels = label_collection(response)\n        post_processor = PostProcessor(label_mapping)\n        labels = post_processor.transform(labels)\n        return Response(labels.dict(), status=status.HTTP_200_OK)\n\n\nclass AutomatedLabeling(generics.CreateAPIView):\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    swagger_schema = None\n\n    def create(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        example = project.examples.get(pk=self.request.query_params[\"example\"])\n        configs = AutoLabelingConfig.objects.filter(project=project)\n        # Todo: make async calls or celery tasks to reduce waiting time.\n        for config in configs:\n            labels = execute_pipeline(example.data, config=config)\n            labels.save(project, example, self.request.user)\n        return Response({\"ok\": True}, status=status.HTTP_201_CREATED)\n",
                            "summary": "The content describes a series of Django API views, including TemplateListAPI, TemplateDetailAPI, ConfigList, ConfigDetail, RestAPIRequestTesting, LabelExtractorTesting, LabelMapperTesting, and AutomatedLabeling, each designed to handle specific tasks related to retrieving, creating, and managing project configurations, labels, and options, while enforcing authentication and project admin permissions.",
                            "code_element_summaries": [
                                "Class TemplateListAPI: An API view that retrieves and returns a list of option names filtered by a specified task name, requiring authentication and project admin permissions.",
                                "Function `get`: Retrieves a list of option names filtered by the specified task name from the request and returns them in a 200 OK response.",
                                "Class TemplateDetailAPI: An API view that retrieves and returns detailed information about a specified option for authenticated project administrators.",
                                "Function `get`: Retrieves an option based on the specified name from the request and returns its representation as a dictionary in a 200 OK response.",
                                "Class `ConfigList`: A view that handles the listing and creation of AutoLabelingConfig instances, restricted to authenticated project administrators and associated with a specific project.",
                                "Function `get_queryset`: Retrieves a queryset of AutoLabelingConfig objects filtered by a specific project ID.",
                                "Function `perform_create`: Saves a serializer with an associated project ID extracted from the function's keyword arguments.",
                                "Class ConfigDetail: A Django REST framework view that handles retrieving, updating, and deleting AutoLabelingConfig instances, with specific permissions and a custom lookup parameter.",
                                "Class `RestAPIRequestTesting`: An API view that handles authenticated requests for creating models and sending requests while managing project-specific data and error handling.",
                                "Function `project`: Retrieves a Project object based on the provided project ID, returning a 404 error if not found.",
                                "Function `create_model`: This function creates a model based on provided name and attributes, and raises a validation error if the attributes do not match the required fields of the model.",
                                "Function `send_request`: A function that attempts to send a request using a specified model and example, handling various exceptions related to connection errors, AWS client errors, JSON decoding errors, and general exceptions.",
                                "Function `prepare_example`: Retrieves text from the request data or, if the project is not a text project, fetches the file path of a temporary upload based on the provided upload ID.",
                                "Function `post`: A method that creates a model, prepares an example, sends a request with these parameters, and returns the response with a 200 OK status.",
                                "Class LabelExtractorTesting: An API view that processes incoming data to render labels based on a specified template and task type, handling errors related to template mapping and sample data.",
                                "Function `post`: A method that processes a request to render labels from a template based on the provided response and task type, handling potential errors in the mapping process.",
                                "Class LabelMapperTesting: An API view that processes label mappings based on task type and user response, returning transformed labels in dictionary form.",
                                "Function `post`: A method that processes incoming data to transform labels based on a task type and label mapping, returning the transformed labels in a structured response.",
                                "Class `AutomatedLabeling`: A Django API view that handles the creation of automated labeling for project examples, ensuring that only authenticated project members can access it.",
                                "Function `create`: A method that retrieves a project and its example, processes auto-labeling configurations, and saves the generated labels, returning a success response."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\auto_labeling\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "cli.py",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\cli.py",
                    "is_dir": false,
                    "code_elements": [
                        "Function `number_of_workers`\nCode:\ndef number_of_workers():\n    return (multiprocessing.cpu_count() * 2) + 1",
                        "Function `is_windows`\nCode:\ndef is_windows():\n    return platform.system() == \"Windows\"",
                        "Function `run_on_nix`\nCode:\ndef run_on_nix(args):\n    import gunicorn.app.base\n    import gunicorn.util\n\n    class StandaloneApplication(gunicorn.app.base.BaseApplication):\n        def __init__(self, options=None):\n            self.options = options or {}\n            super().__init__()\n\n        def load_config(self):\n            config = {\n                key: value for key, value in self.options.items() if key in self.cfg.settings and value is not None\n            }\n            for key, value in config.items():\n                self.cfg.set(key.lower(), value)\n\n        def load(self):\n            return gunicorn.util.import_app(\"config.wsgi\")\n\n    options = {\n        \"bind\": \"%s:%s\" % (\"0.0.0.0\", args.port),\n        \"workers\": args.workers,\n        \"chdir\": base,\n        \"capture_output\": True,\n        \"loglevel\": \"info\",\n    }\n    StandaloneApplication(options).run()",
                        "Class `StandaloneApplication`\nCode:\n    class StandaloneApplication(gunicorn.app.base.BaseApplication):\n        def __init__(self, options=None):\n            self.options = options or {}\n            super().__init__()\n\n        def load_config(self):\n            config = {\n                key: value for key, value in self.options.items() if key in self.cfg.settings and value is not None\n            }\n            for key, value in config.items():\n                self.cfg.set(key.lower(), value)\n\n        def load(self):\n            return gunicorn.util.import_app(\"config.wsgi\")",
                        "Function `__init__`\nCode:\n        def __init__(self, options=None):\n            self.options = options or {}\n            super().__init__()",
                        "Function `load_config`\nCode:\n        def load_config(self):\n            config = {\n                key: value for key, value in self.options.items() if key in self.cfg.settings and value is not None\n            }\n            for key, value in config.items():\n                self.cfg.set(key.lower(), value)",
                        "Function `load`\nCode:\n        def load(self):\n            return gunicorn.util.import_app(\"config.wsgi\")",
                        "Function `run_on_windows`\nCode:\ndef run_on_windows(args):\n    from waitress import serve\n\n    from config.wsgi import application\n\n    serve(application, port=args.port, threads=args.workers)",
                        "Function `command_db_init`\nCode:\ndef command_db_init(args):\n    print(\"Setup Database.\")\n    management.call_command(\"wait_for_db\")\n    management.call_command(\"migrate\")\n    management.call_command(\"create_roles\")",
                        "Function `command_user_create`\nCode:\ndef command_user_create(args):\n    print(\"Create admin user.\")\n    management.call_command(\n        \"create_admin\", \"--noinput\", username=args.username, password=args.password, email=args.email\n    )",
                        "Function `command_migrate`\nCode:\ndef command_migrate(args):\n    print(\"Start migration.\")\n    management.call_command(\"migrate\")",
                        "Function `command_run_webserver`\nCode:\ndef command_run_webserver(args):\n    print(f\"Starting server with port {args.port}.\")\n    if is_windows():\n        run_on_windows(args)\n    else:\n        run_on_nix(args)",
                        "Function `command_run_task_queue`\nCode:\ndef command_run_task_queue(args):\n    print(\"Starting task queue.\")\n    argv = [\n        \"--app=config\",\n        \"--workdir={}\".format(base),\n        \"worker\",\n        \"--loglevel=info\",\n        \"--concurrency={}\".format(args.concurrency),\n    ]\n    if is_windows():\n        argv.append(\"--pool=solo\")\n    app.worker_main(argv=argv)",
                        "Function `command_run_flower`\nCode:\ndef command_run_flower(args):\n    print(\"Starting flower.\")\n    argv = [\n        \"--app=config\",\n        \"--workdir={}\".format(base),\n        \"flower\",\n    ]\n    if args.basic_auth:\n        argv.append(\"--basic_auth={}\".format(args.basic_auth))\n    app.worker_main(argv=argv)",
                        "Function `command_help`\nCode:\ndef command_help(args):\n    print(parser.parse_args([args.command, \"--help\"]))",
                        "Function `main`\nCode:\ndef main():\n    # Create a command line parser.\n    subparsers = parser.add_subparsers()\n\n    # Create a parser for db initialization.\n    parser_init = subparsers.add_parser(\"init\", help=\"see `init -h`\")\n    parser_init.set_defaults(handler=command_db_init)\n\n    # Create a parser for migration.\n    parser_migration = subparsers.add_parser(\"migrate\", help=\"Updates database schema.\")\n    parser_migration.set_defaults(handler=command_migrate)\n\n    # Create a parser for user creation.\n    parser_create_user = subparsers.add_parser(\"createuser\", help=\"see `createuser -h`\")\n    parser_create_user.add_argument(\"--username\", type=str, default=\"admin\", help=\"admin username\")\n    parser_create_user.add_argument(\"--password\", type=str, default=\"password\", help=\"admin password\")\n    parser_create_user.add_argument(\"--email\", type=str, default=\"example@example.com\", help=\"admin email\")\n    parser_create_user.set_defaults(handler=command_user_create)\n\n    # Create a parser for web server.\n    parser_server = subparsers.add_parser(\"webserver\", help=\"see `webserver -h`\")\n    parser_server.add_argument(\"--port\", type=int, default=8000, help=\"port number\")\n    parser_server.add_argument(\"--workers\", type=int, default=number_of_workers(), help=\"the number of workers\")\n    parser_server.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_server.set_defaults(handler=command_run_webserver)\n\n    # Create a parser for task queue.\n    parser_queue = subparsers.add_parser(\"task\", help=\"see `task -h`\")\n    parser_queue.add_argument(\"--concurrency\", type=int, default=2, help=\"concurrency\")\n    parser_queue.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_queue.set_defaults(handler=command_run_task_queue)\n\n    parser_flower = subparsers.add_parser(\"flower\", help=\"see `flower -h`\")\n    parser_flower.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_flower.add_argument(\"--basic_auth\", type=str, help=\"username and password for basic authentication\")\n    parser_flower.set_defaults(handler=command_run_flower)\n\n    # Create a parser for help.\n    parser_help = subparsers.add_parser(\"help\", help=\"see `help -h`\")\n    parser_help.add_argument(\"command\", help=\"command name which help is shown\")\n    parser_help.set_defaults(handler=command_help)\n\n    # Dispatch handler.\n    args = parser.parse_args()\n    if hasattr(args, \"env_file\") and args.env_file and Path(args.env_file).is_file():\n        env.read_env(args.env_file, recurse=False, override=True)\n    if hasattr(args, \"handler\"):\n        django.setup()\n        args.handler(args)\n    else:\n        # If specified unknown command, show help.\n        parser.print_help()"
                    ],
                    "code": "import argparse\nimport multiprocessing\nimport os\nimport platform\nimport sys\nfrom pathlib import Path\n\nimport django\nfrom django.core import management\nfrom environs import Env\n\nfrom .config.celery import app\n\nenv = Env()\nDOCCANO_HOME = os.path.expanduser(os.environ.get(\"DOCCANO_HOME\", \"~/doccano\"))\nPath(DOCCANO_HOME).mkdir(parents=True, exist_ok=True)\nenv.bool(\"DEBUG\", False)\nos.environ[\"STANDALONE\"] = \"True\"\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings.production\")\nos.environ.setdefault(\"DATABASE_URL\", os.path.join(f\"sqlite:///{DOCCANO_HOME}\", \"db.sqlite3\"))\nos.environ.setdefault(\"MEDIA_ROOT\", os.path.join(DOCCANO_HOME, \"media\"))\nbase = os.path.abspath(os.path.dirname(__file__))\nsys.path.append(base)\nparser = argparse.ArgumentParser(description=\"doccano, text annotation for machine learning practitioners.\")\n\n\ndef number_of_workers():\n    return (multiprocessing.cpu_count() * 2) + 1\n\n\ndef is_windows():\n    return platform.system() == \"Windows\"\n\n\ndef run_on_nix(args):\n    import gunicorn.app.base\n    import gunicorn.util\n\n    class StandaloneApplication(gunicorn.app.base.BaseApplication):\n        def __init__(self, options=None):\n            self.options = options or {}\n            super().__init__()\n\n        def load_config(self):\n            config = {\n                key: value for key, value in self.options.items() if key in self.cfg.settings and value is not None\n            }\n            for key, value in config.items():\n                self.cfg.set(key.lower(), value)\n\n        def load(self):\n            return gunicorn.util.import_app(\"config.wsgi\")\n\n    options = {\n        \"bind\": \"%s:%s\" % (\"0.0.0.0\", args.port),\n        \"workers\": args.workers,\n        \"chdir\": base,\n        \"capture_output\": True,\n        \"loglevel\": \"info\",\n    }\n    StandaloneApplication(options).run()\n\n\ndef run_on_windows(args):\n    from waitress import serve\n\n    from config.wsgi import application\n\n    serve(application, port=args.port, threads=args.workers)\n\n\ndef command_db_init(args):\n    print(\"Setup Database.\")\n    management.call_command(\"wait_for_db\")\n    management.call_command(\"migrate\")\n    management.call_command(\"create_roles\")\n\n\ndef command_user_create(args):\n    print(\"Create admin user.\")\n    management.call_command(\n        \"create_admin\", \"--noinput\", username=args.username, password=args.password, email=args.email\n    )\n\n\ndef command_migrate(args):\n    print(\"Start migration.\")\n    management.call_command(\"migrate\")\n\n\ndef command_run_webserver(args):\n    print(f\"Starting server with port {args.port}.\")\n    if is_windows():\n        run_on_windows(args)\n    else:\n        run_on_nix(args)\n\n\ndef command_run_task_queue(args):\n    print(\"Starting task queue.\")\n    argv = [\n        \"--app=config\",\n        \"--workdir={}\".format(base),\n        \"worker\",\n        \"--loglevel=info\",\n        \"--concurrency={}\".format(args.concurrency),\n    ]\n    if is_windows():\n        argv.append(\"--pool=solo\")\n    app.worker_main(argv=argv)\n\n\ndef command_run_flower(args):\n    print(\"Starting flower.\")\n    argv = [\n        \"--app=config\",\n        \"--workdir={}\".format(base),\n        \"flower\",\n    ]\n    if args.basic_auth:\n        argv.append(\"--basic_auth={}\".format(args.basic_auth))\n    app.worker_main(argv=argv)\n\n\ndef command_help(args):\n    print(parser.parse_args([args.command, \"--help\"]))\n\n\ndef main():\n    # Create a command line parser.\n    subparsers = parser.add_subparsers()\n\n    # Create a parser for db initialization.\n    parser_init = subparsers.add_parser(\"init\", help=\"see `init -h`\")\n    parser_init.set_defaults(handler=command_db_init)\n\n    # Create a parser for migration.\n    parser_migration = subparsers.add_parser(\"migrate\", help=\"Updates database schema.\")\n    parser_migration.set_defaults(handler=command_migrate)\n\n    # Create a parser for user creation.\n    parser_create_user = subparsers.add_parser(\"createuser\", help=\"see `createuser -h`\")\n    parser_create_user.add_argument(\"--username\", type=str, default=\"admin\", help=\"admin username\")\n    parser_create_user.add_argument(\"--password\", type=str, default=\"password\", help=\"admin password\")\n    parser_create_user.add_argument(\"--email\", type=str, default=\"example@example.com\", help=\"admin email\")\n    parser_create_user.set_defaults(handler=command_user_create)\n\n    # Create a parser for web server.\n    parser_server = subparsers.add_parser(\"webserver\", help=\"see `webserver -h`\")\n    parser_server.add_argument(\"--port\", type=int, default=8000, help=\"port number\")\n    parser_server.add_argument(\"--workers\", type=int, default=number_of_workers(), help=\"the number of workers\")\n    parser_server.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_server.set_defaults(handler=command_run_webserver)\n\n    # Create a parser for task queue.\n    parser_queue = subparsers.add_parser(\"task\", help=\"see `task -h`\")\n    parser_queue.add_argument(\"--concurrency\", type=int, default=2, help=\"concurrency\")\n    parser_queue.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_queue.set_defaults(handler=command_run_task_queue)\n\n    parser_flower = subparsers.add_parser(\"flower\", help=\"see `flower -h`\")\n    parser_flower.add_argument(\"--env_file\", type=str, help=\"read in a file of environment variables\")\n    parser_flower.add_argument(\"--basic_auth\", type=str, help=\"username and password for basic authentication\")\n    parser_flower.set_defaults(handler=command_run_flower)\n\n    # Create a parser for help.\n    parser_help = subparsers.add_parser(\"help\", help=\"see `help -h`\")\n    parser_help.add_argument(\"command\", help=\"command name which help is shown\")\n    parser_help.set_defaults(handler=command_help)\n\n    # Dispatch handler.\n    args = parser.parse_args()\n    if hasattr(args, \"env_file\") and args.env_file and Path(args.env_file).is_file():\n        env.read_env(args.env_file, recurse=False, override=True)\n    if hasattr(args, \"handler\"):\n        django.setup()\n        args.handler(args)\n    else:\n        # If specified unknown command, show help.\n        parser.print_help()\n\n\nif __name__ == \"__main__\":\n    main()\n",
                    "summary": "Module Overview: This module provides functions and a class for managing a Gunicorn server and related tasks, including calculating optimal worker processes, checking the operating system, loading configurations, handling database initialization and migrations, creating users, running web servers, managing task queues, and offering a command-line interface for user interactions.",
                    "code_element_summaries": [
                        "Function `number_of_workers`: Calculates the optimal number of worker processes by doubling the number of CPU cores and adding one.",
                        "Function `is_windows`: A utility function that checks if the current operating system is Windows by comparing the system name.",
                        "Function `run_on_nix`: A function that sets up and runs a Gunicorn server with configurable options, including binding address, number of workers, and logging level.",
                        "Class StandaloneApplication: A subclass of gunicorn's BaseApplication that manages configuration loading and application instantiation for a standalone Gunicorn server.",
                        "Function `__init__`: Initializes an instance with optional parameters, defaulting to an empty dictionary, and calls the superclass initializer.",
                        "Function `load_config`: Loads configuration settings from options, filtering out keys that are not in the settings or have `None` values, and sets them in the configuration object in lowercase.",
                        "Function `load`: Loads the application using Gunicorn's utility to import the WSGI application defined in the configuration.",
                        "Function `run_on_windows`: A function that starts a Waitress server to serve a WSGI application on a specified port and with a defined number of worker threads.",
                        "Function `command_db_init`: Initializes the database by waiting for it to be ready, applying migrations, and creating necessary roles.",
                        "Function `command_user_create`: A function that creates an admin user by calling the management command with specified username, password, and email arguments.",
                        "Function `command_migrate`: Initiates the migration process by printing a start message and calling the Django management command to perform the migration.",
                        "Function `command_run_webserver`: Initiates a web server, printing the port number and executing the appropriate function based on the operating system.",
                        "Function `command_run_task_queue`: Initiates a task queue by setting up command-line arguments and starting a worker process with specified concurrency and logging options.",
                        "Function `command_run_flower`: Initiates the Flower monitoring tool for Celery with optional basic authentication and a specified working directory.",
                        "Function `command_help`: A function that prints the help information for a specified command by parsing its arguments.",
                        "Function `main`: Sets up a command-line interface with subcommands for database initialization, migration, user creation, web server management, task queue execution, and help, dispatching the appropriate handler based on user input."
                    ],
                    "children": []
                },
                {
                    "name": "config",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "Comprehensive setup guide for a Django project, covering Celery application initialization, detailed Django settings configuration, URL routing for API endpoints and static files, and WSGI configuration for the application.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "celery.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\celery.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "import os\n\nfrom celery import Celery\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings.production\")\n\napp = Celery(\"config\")\n\napp.config_from_object(\"django.conf:settings\", namespace=\"CELERY\")\n\napp.autodiscover_tasks(related_name=\"celery_tasks\")\n",
                            "summary": "Celery Application Setup: Initializes a Celery application for a Django project, configuring it with production settings and enabling automatic task discovery.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "settings",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Django settings configuration: This comprehensive setup details various configurations for a Django application, including middleware, AWS S3 and Google Cloud Storage integration, environment variable management for sensitive credentials, and logging setup, while providing guidance through official documentation links.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "aws.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\aws.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "from .base import *  # noqa: F403\nfrom .base import env\n\nMIDDLEWARE.append(\"api.middleware.RangesMiddleware\")  # noqa: F405\n\nDJANGO_DRF_FILEPOND_STORAGES_BACKEND = \"storages.backends.s3boto3.S3Boto3Storage\"\nAWS_ACCESS_KEY_ID = env(\"AWS_ACCESS_KEY_ID\")\nAWS_SECRET_ACCESS_KEY = env(\"AWS_SECRET_ACCESS_KEY\")\nAWS_S3_REGION_NAME = env(\"REGION_NAME\", \"us-west-1\")\nAWS_STORAGE_BUCKET_NAME = env(\"BUCKET_NAME\", \"doccano\")\nAWS_S3_ENDPOINT_URL = env(\"AWS_S3_ENDPOINT_URL\", None)\nAWS_DEFAULT_ACL = \"private\"\nAWS_BUCKET_ACL = \"private\"\nAWS_AUTO_CREATE_BUCKET = True\n",
                                    "summary": "Configuration settings for a Django application that includes middleware and AWS S3 storage parameters, utilizing environment variables for sensitive credentials.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "base.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\base.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "\"\"\"\nDjango settings for app project.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/2.0/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/2.0/ref/settings/\n\nAny setting that is configured via an environment variable may\nalso be set in a `.env` file in the project base directory.\n\"\"\"\nfrom os import path\n\nimport dj_database_url\nfrom environs import Env, EnvError\nfrom furl import furl\n\n# Build paths inside the project like this: path.join(BASE_DIR, ...)\nBASE_DIR = path.dirname(path.dirname(path.dirname(path.abspath(__file__))))\n\nenv = Env()\nenv.read_env(path.join(BASE_DIR, \".env\"), recurse=False)\n\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/2.0/howto/deployment/checklist/\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = env(\"SECRET_KEY\", \"v8sk33sy82!uw3ty=!jjv5vp7=s2phrzw(m(hrn^f7e_#1h2al\")\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = env.bool(\"DEBUG\", True)\n\n# Application definition\nINSTALLED_APPS = [\n    \"whitenoise.runserver_nostatic\",\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"api\",\n    \"roles\",\n    \"projects\",\n    \"metrics\",\n    \"users\",\n    \"data_import\",\n    \"data_export\",\n    \"auto_labeling\",\n    \"labels\",\n    \"label_types\",\n    \"examples\",\n    \"rest_framework\",\n    \"rest_framework.authtoken\",\n    \"django_filters\",\n    \"polymorphic\",\n    \"corsheaders\",\n    \"drf_yasg\",\n    \"allauth\",\n    \"allauth.account\",\n    \"allauth.socialaccount\",\n    \"allauth.socialaccount.providers.okta\",\n    \"dj_rest_auth\",\n    \"dj_rest_auth.registration\",\n    \"django.contrib.sites\",\n    \"django_celery_results\",\n    \"django_drf_filepond\",\n    \"health_check\",\n    \"health_check.cache\",\n    \"health_check.storage\",\n    \"health_check.contrib.migrations\",\n    \"health_check.contrib.celery\",\n    \"django_cleanup\",\n]\n\n\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"whitenoise.middleware.WhiteNoiseMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n    \"corsheaders.middleware.CorsMiddleware\",\n]\n\n\nROOT_URLCONF = \"config.urls\"\nWSGI_APPLICATION = \"config.wsgi.application\"\n\n# Django templates\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [path.join(BASE_DIR, \"client/dist\")],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n            ],\n        },\n    },\n]\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/2.0/howto/static-files/\nSTATIC_URL = \"/static/\"\nSTATIC_ROOT = path.join(BASE_DIR, \"staticfiles\")\nSTATICFILES_DIRS = [\n    path.join(BASE_DIR, \"client/dist/static\"),\n]\n# STATICFILES_STORAGE = \"whitenoise.storage.CompressedManifestStaticFilesStorage\"\nSTATICFILES_STORAGE = \"whitenoise.storage.CompressedStaticFilesStorage\"\n\n# Auth settings\nAUTHENTICATION_BACKENDS = [\n    \"django.contrib.auth.backends.ModelBackend\",\n]\nHEADER_AUTH_USER_NAME = env(\"HEADER_AUTH_USER_NAME\", \"\")\nHEADER_AUTH_USER_GROUPS = env(\"HEADER_AUTH_USER_GROUPS\", \"\")\nHEADER_AUTH_ADMIN_GROUP_NAME = env(\"HEADER_AUTH_ADMIN_GROUP_NAME\", \"\")\nHEADER_AUTH_GROUPS_SEPERATOR = env(\"HEADER_AUTH_GROUPS_SEPERATOR\", default=\",\")\nif HEADER_AUTH_USER_NAME and HEADER_AUTH_USER_GROUPS and HEADER_AUTH_ADMIN_GROUP_NAME:\n    MIDDLEWARE.append(\"api.middleware.HeaderAuthMiddleware\")\n    AUTHENTICATION_BACKENDS.append(\"django.contrib.auth.backends.RemoteUserBackend\")\n\n# Role settings\nROLE_PROJECT_ADMIN = env(\"ROLE_PROJECT_ADMIN\", \"project_admin\")\nROLE_ANNOTATOR = env(\"ROLE_ANNOTATOR\", \"annotator\")\nROLE_ANNOTATION_APPROVER = env(\"ROLE_ANNOTATION_APPROVER\", \"annotation_approver\")\n\n# Password validation\n# https://docs.djangoproject.com/en/2.0/ref/settings/#auth-password-validators\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n    },\n]\n\nREST_FRAMEWORK = {\n    # Use Django's standard `django.contrib.auth` permissions,\n    # or allow read-only access for unauthenticated users.\n    \"DEFAULT_PERMISSION_CLASSES\": [\n        \"rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly\",\n        \"rest_framework.permissions.IsAuthenticated\",\n    ],\n    \"DEFAULT_AUTHENTICATION_CLASSES\": (\n        \"rest_framework.authentication.SessionAuthentication\",\n        \"rest_framework.authentication.TokenAuthentication\",\n    ),\n    \"DEFAULT_PAGINATION_CLASS\": \"rest_framework.pagination.LimitOffsetPagination\",\n    \"PAGE_SIZE\": env.int(\"DOCCANO_PAGE_SIZE\", default=5),\n    \"DEFAULT_FILTER_BACKENDS\": (\"django_filters.rest_framework.DjangoFilterBackend\",),\n    \"SEARCH_PARAM\": \"q\",\n    \"DEFAULT_RENDERER_CLASSES\": (\n        \"rest_framework.renderers.JSONRenderer\",\n        \"rest_framework.renderers.BrowsableAPIRenderer\",\n        \"rest_framework_xml.renderers.XMLRenderer\",\n    ),\n}\n\n# Internationalization\n# https://docs.djangoproject.com/en/2.0/topics/i18n/\nLANGUAGE_CODE = \"en-us\"\nTIME_ZONE = \"UTC\"\nUSE_I18N = True\nUSE_L10N = True\nUSE_TZ = True\n\n# Testing\nTEST_RUNNER = \"xmlrunner.extra.djangotestrunner.XMLTestRunner\"\nTEST_OUTPUT_DIR = path.join(BASE_DIR, \"junitxml\")\n\nLOGIN_URL = \"/login/\"\nLOGIN_REDIRECT_URL = \"/projects/\"\nLOGOUT_REDIRECT_URL = \"/\"\n\n# Database\n# https://docs.djangoproject.com/en/2.0/ref/settings/#databases\nDATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": path.join(BASE_DIR, \"db.sqlite3\"),\n    }\n}\n# Change 'default' database configuration with $DATABASE_URL.\nDATABASES[\"default\"].update(\n    dj_database_url.config(\n        env=\"DATABASE_URL\",\n        conn_max_age=env.int(\"DATABASE_CONN_MAX_AGE\", 500),\n        ssl_require=\"sslmode\" not in furl(env(\"DATABASE_URL\", \"\")).args,\n    )\n)\n\n# work-around for dj-database-url: explicitly disable ssl for sqlite\nif DATABASES[\"default\"].get(\"ENGINE\") == \"django.db.backends.sqlite3\":\n    DATABASES[\"default\"].get(\"OPTIONS\", {}).pop(\"sslmode\", None)\n\n# work-around for dj-database-url: patch ssl for mysql\nif DATABASES[\"default\"].get(\"ENGINE\") == \"django.db.backends.mysql\":\n    DATABASES[\"default\"].get(\"OPTIONS\", {}).pop(\"sslmode\", None)\n    if env(\"MYSQL_SSL_CA\", None):\n        DATABASES[\"default\"].setdefault(\"OPTIONS\", {}).setdefault(\"ssl\", {}).setdefault(\"ca\", env(\"MYSQL_SSL_CA\", None))\n\n# default to a sensible modern driver for Azure SQL\nif DATABASES[\"default\"].get(\"ENGINE\") == \"sql_server.pyodbc\":\n    DATABASES[\"default\"].setdefault(\"OPTIONS\", {}).setdefault(\"driver\", \"ODBC Driver 17 for SQL Server\")\n\n\n# Sessions and CSRF\n# Honor the 'X-Forwarded-Proto' header for request.is_secure()\nSECURE_PROXY_SSL_HEADER = (\"HTTP_X_FORWARDED_PROTO\", \"https\")\nSESSION_COOKIE_SECURE = env.bool(\"SESSION_COOKIE_SECURE\", False)\nCSRF_COOKIE_SECURE = env.bool(\"CSRF_COOKIE_SECURE\", False)\nCSRF_TRUSTED_ORIGINS = env.list(\"CSRF_TRUSTED_ORIGINS\", [])\n\n# Allow all host headers\nALLOWED_HOSTS = [\"*\"]\n\nif DEBUG:\n    CORS_ORIGIN_ALLOW_ALL = True\n    CSRF_TRUSTED_ORIGINS = [\"http://127.0.0.1:3000\", \"http://0.0.0.0:3000\", \"http://localhost:3000\"]\n    CSRF_TRUSTED_ORIGINS += env.list(\"CSRF_TRUSTED_ORIGINS\", [])\n\n# Batch size for importing data\nIMPORT_BATCH_SIZE = env.int(\"IMPORT_BATCH_SIZE\", 1000)\n\n# Necessary for email verification of new accounts\nEMAIL_USE_TLS = env.bool(\"EMAIL_USE_TLS\", False)\nEMAIL_HOST = env(\"EMAIL_HOST\", None)\nEMAIL_HOST_USER = env(\"EMAIL_HOST_USER\", None)\nEMAIL_HOST_PASSWORD = env(\"EMAIL_HOST_PASSWORD\", None)\nEMAIL_PORT = env.int(\"EMAIL_PORT\", 587)\nDEFAULT_FROM_EMAIL = env(\"DEFAULT_FROM_EMAIL\", \"webmaster@localhost\")\nif not EMAIL_HOST:\n    EMAIL_BACKEND = \"django.core.mail.backends.console.EmailBackend\"\n\n\n# User media files\nMEDIA_ROOT = env(\"MEDIA_ROOT\", path.join(BASE_DIR, \"media\"))\nMEDIA_URL = \"/media/\"\n\n# Filepond settings\nDJANGO_DRF_FILEPOND_UPLOAD_TMP = path.join(BASE_DIR, \"filepond-temp-uploads\")\nDJANGO_DRF_FILEPOND_FILE_STORE_PATH = MEDIA_ROOT\n\n# File upload setting\nMAX_UPLOAD_SIZE = env.int(\"MAX_UPLOAD_SIZE\", pow(1024, 3))  # default: 1GB per a file\nENABLE_FILE_TYPE_CHECK = env.bool(\"ENABLE_FILE_TYPE_CHECK\", False)\n\n# Celery settings\nDJANGO_CELERY_RESULTS_TASK_ID_MAX_LENGTH = 191\nCELERY_RESULT_BACKEND = \"django-db\"\ntry:\n    CELERY_BROKER_URL = env(\"CELERY_BROKER_URL\")\nexcept EnvError:\n    try:\n        # quickfix for Heroku.\n        # See https://github.com/doccano/doccano/issues/1327.\n        uri = env(\"DATABASE_URL\")\n        if uri.startswith(\"postgres://\"):\n            uri = uri.replace(\"postgres://\", \"postgresql://\", 1)\n        CELERY_BROKER_URL = \"sqla+{}\".format(uri)\n    except EnvError:\n        CELERY_BROKER_URL = \"sqla+sqlite:///{}\".format(DATABASES[\"default\"][\"NAME\"])\nCELERY_ACCEPT_CONTENT = [\"application/json\"]\nCELERY_TASK_SERIALIZER = \"json\"\nCELERY_RESULT_SERIALIZER = \"json\"\n\nDEFAULT_AUTO_FIELD = \"django.db.models.AutoField\"\n\nSOCIALACCOUNT_PROVIDERS = {\n    \"okta\": {\n        \"OKTA_BASE_URL\": env(\"OAUTH_OKTA_OAUTH2_API_URL\", \"\"),\n        \"OAUTH_PKCE_ENABLED\": True,\n        \"APP\": {\"client_id\": env(\"OAUTH_OKTA_OAUTH2_KEY\", \"\"), \"secret\": env(\"OAUTH_OKTA_OAUTH2_SECRET\", \"\")},\n    }\n}\n\nSITE_ID = 1\n",
                                    "summary": "Django settings configuration: This file outlines the settings for a Django application, including database configurations, installed apps, middleware, authentication, and environment variable management, while providing links to official documentation for further reference.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "development.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\development.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "from .base import *  # noqa: F403\n\nMIDDLEWARE.append(\"api.middleware.RangesMiddleware\")  # noqa: F405\n# LOGGING = {\n#     'version': 1,\n#     'handlers': {\n#         'console': {\n#             'level': 'DEBUG',\n#             'class': 'logging.StreamHandler',\n#         }\n#     },\n#     'loggers': {\n#         'django.db.backends': {\n#             'level': 'DEBUG',\n#             'handlers': ['console'],\n#         },\n#     }\n# }\n",
                                    "summary": "Middleware Configuration: This code snippet appends the RangesMiddleware to the existing MIDDLEWARE list and includes commented-out logging configuration for debugging Django database backend queries.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "gcp.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\gcp.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "from google.oauth2 import service_account\n\nfrom .base import *  # noqa: F403\nfrom .base import env\n\nMIDDLEWARE.append(\"api.middleware.RangesMiddleware\")  # noqa: F405\n\nDJANGO_DRF_FILEPOND_STORAGES_BACKEND = \"storages.backends.gcloud.GoogleCloudStorage\"\nGS_BUCKET_NAME = env(\"BUCKET_NAME\", \"doccano\")\nGS_PROJECT_ID = env(\"GS_PROJECT_ID\")\n\n# for more details refer to\n# https://django-storages.readthedocs.io/en/latest/backends/gcloud.html#authentication-settings\n_google_application_credentials = env(\"GOOGLE_APPLICATION_CREDENTIALS\", \"\")\nif _google_application_credentials:\n    GS_CREDENTIALS = service_account.Credentials.from_service_account_file(_google_application_credentials)\n",
                                    "summary": "Django settings configuration for Google Cloud Storage, including middleware and environment variable management for authentication and storage backend setup.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "heroku.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\heroku.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "import django_heroku\n\nfrom .base import *  # noqa: F401,F403\n\ndjango_heroku.settings(locals(), test_runner=False, staticfiles=False)\n",
                                    "summary": "Configuration for integrating Django with Heroku, setting local settings while disabling the test runner and static files management.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "production.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\production.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "from .base import *  # noqa: F401,F403\n\nDEBUG = False\n\nLOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"standard\": {\n            \"format\": \"[%(asctime)s] [%(process)d] [%(levelname)s] [%(name)s::%(funcName)s::%(lineno)d] %(message)s\",\n            \"datefmt\": \"%Y-%m-%d %H:%M:%S %z\",\n        }\n    },\n    \"handlers\": {\n        \"console\": {\n            \"level\": \"INFO\",\n            \"class\": \"logging.StreamHandler\",\n            \"formatter\": \"standard\",\n        },\n    },\n    \"root\": {\n        \"handlers\": [\"console\"],\n        \"level\": \"INFO\",\n    },\n    \"loggers\": {\n        \"django\": {\n            \"handlers\": [\"console\"],\n            \"level\": \"INFO\",\n        },\n    },\n}\n",
                                    "summary": "Django logging configuration: This code sets up logging for a Django application with a console handler that outputs log messages in a specified format and sets the logging level to INFO.",
                                    "code_element_summaries": [],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\settings\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "\"\"\"app URL Configuration\n\nThe `urlpatterns` list routes URLs to views. For more information please see:\n    https://docs.djangoproject.com/en/2.0/topics/http/urls/\nExamples:\nFunction views\n    1. Add an import:  from my_app import views\n    2. Add a URL to urlpatterns:  path('', views.home, name='home')\nClass-based views\n    1. Add an import:  from other_app.views import Home\n    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\nIncluding another URLconf\n    1. Import the include() function: from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\"\"\"\nimport os\nimport re\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.contrib import admin\nfrom django.contrib.auth.views import TemplateView\nfrom django.urls import include, path, re_path\nfrom django.views.static import serve\nfrom drf_yasg import openapi\nfrom drf_yasg.views import get_schema_view\n\nschema_view = get_schema_view(\n    openapi.Info(\n        title=\"doccano API\",\n        default_version=\"v1\",\n        description=\"doccano API description\",\n        license=openapi.License(name=\"MIT License\"),\n    ),\n    public=True,\n)\n\nurlpatterns = []\nif settings.DEBUG or os.environ.get(\"STANDALONE\", False):\n    static_dir = Path(__file__).resolve().parent.parent / \"client\" / \"dist\"\n    # For showing images and audios in the case of pip and Docker.\n    urlpatterns.append(\n        re_path(\n            r\"^%s(?P<path>.*)$\" % re.escape(settings.MEDIA_URL.lstrip(\"/\")),\n            serve,\n            {\"document_root\": settings.MEDIA_ROOT},\n        )\n    )\n    # For showing favicon on the case of pip and Docker.\n    urlpatterns.append(path(\"favicon.ico\", serve, {\"document_root\": static_dir, \"path\": \"favicon.ico\"}))\n\nurlpatterns += [\n    path(\"admin/\", admin.site.urls),\n    path(\"api-auth/\", include(\"rest_framework.urls\")),\n    path(\"social/\", include(\"social.urls\")),\n    path(\"v1/social/\", include(\"social.v1_urls\")),\n    path(\"v1/health/\", include(\"health_check.urls\")),\n    path(\"v1/\", include(\"api.urls\")),\n    path(\"v1/\", include(\"roles.urls\")),\n    path(\"v1/\", include(\"users.urls\")),\n    path(\"v1/\", include(\"data_import.urls\")),\n    path(\"v1/\", include(\"data_export.urls\")),\n    path(\"v1/\", include(\"projects.urls\")),\n    path(\"v1/projects/<int:project_id>/metrics/\", include(\"metrics.urls\")),\n    path(\"v1/projects/<int:project_id>/\", include(\"auto_labeling.urls\")),\n    path(\"v1/projects/<int:project_id>/\", include(\"examples.urls\")),\n    path(\"v1/projects/<int:project_id>/\", include(\"labels.urls\")),\n    path(\"v1/projects/<int:project_id>/\", include(\"label_types.urls\")),\n    path(\"swagger/\", schema_view.with_ui(\"swagger\", cache_timeout=0), name=\"schema-swagger-ui\"),\n    re_path(\"\", TemplateView.as_view(template_name=\"index.html\")),\n]\n",
                            "summary": "Django URL Configuration: A setup that defines URL routing for the application, including API endpoints, admin access, and static file serving based on the project's settings.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "wsgi.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\wsgi.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "\"\"\"\nWSGI config for app project.\n\nIt exposes the WSGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/2.0/howto/deployment/wsgi/\n\"\"\"\n\nimport os\n\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings.production\")\n\napplication = get_wsgi_application()\n",
                            "summary": "WSGI config for a Django application that sets the environment variable for the settings module and exposes the WSGI callable as `application`.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\config\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from .celery import app as celery_app\n\n__all__ = (\"celery_app\",)\n",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "data_export",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content outlines a comprehensive framework for managing and exporting datasets in a Django application, featuring various proxy models for annotations and labels, utility functions for dataset creation and export, and API views for handling project-specific export requests, all supported by unit tests to ensure functionality and correctness.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\admin.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class ExportedBoundingBox: A proxy model of BoundingBox that provides methods to convert bounding box data into dictionary and tuple formats for easier data manipulation.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `DataExportConfig`\nCode:\nclass DataExportConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"data_export\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass DataExportConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"data_export\"\n",
                            "summary": "Class DataExportConfig: A Django application configuration class that defines the default auto field type and sets the application name to \"data_export\".",
                            "code_element_summaries": [
                                "Class DataExportConfig: A Django application configuration class that sets the default auto field type and specifies the application name as \"data_export\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "celery_tasks.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\celery_tasks.py",
                            "is_dir": false,
                            "code_elements": [
                                "Function `create_collaborative_dataset`\nCode:\ndef create_collaborative_dataset(project: Project, dirpath: str, confirmed_only: bool, formatters, writer):\n    is_text_project = project.is_text_project\n    if confirmed_only:\n        examples = ExportedExample.objects.confirmed(project)\n    else:\n        examples = ExportedExample.objects.filter(project=project)\n    labels = create_labels(project, examples)\n    comments = create_comment(examples)\n    dataset = Dataset(examples, labels, comments, is_text_project)\n\n    service = ExportApplicationService(dataset, formatters, writer)\n\n    filepath = os.path.join(dirpath, f\"all.{writer.extension}\")\n    service.export(filepath)",
                                "Function `create_individual_dataset`\nCode:\ndef create_individual_dataset(project: Project, dirpath: str, confirmed_only: bool, formatters, writer):\n    is_text_project = project.is_text_project\n    members = Member.objects.filter(project=project)\n    for member in members:\n        if confirmed_only:\n            examples = ExportedExample.objects.confirmed(project, user=member.user)\n        else:\n            examples = ExportedExample.objects.filter(project=project)\n        labels = create_labels(project, examples, member.user)\n        comments = create_comment(examples, member.user)\n        dataset = Dataset(examples, labels, comments, is_text_project)\n\n        service = ExportApplicationService(dataset, formatters, writer)\n\n        filepath = os.path.join(dirpath, f\"{member.username}.{writer.extension}\")\n        service.export(filepath)",
                                "Function `export_dataset`\nCode:\ndef export_dataset(project_id, file_format: str, confirmed_only=False):\n    project = get_object_or_404(Project, pk=project_id)\n    dirpath = os.path.join(settings.MEDIA_ROOT, str(uuid.uuid4()))\n    os.makedirs(dirpath, exist_ok=True)\n    formatters = create_formatter(project, file_format)\n    writer = create_writer(file_format)\n    if project.collaborative_annotation:\n        create_collaborative_dataset(project, dirpath, confirmed_only, formatters, writer)\n    else:\n        create_individual_dataset(project, dirpath, confirmed_only, formatters, writer)\n    zip_file = shutil.make_archive(dirpath, \"zip\", dirpath)\n    shutil.rmtree(dirpath)\n    return zip_file"
                            ],
                            "code": "import os\nimport shutil\nimport uuid\n\nfrom celery import shared_task\nfrom celery.utils.log import get_task_logger\nfrom django.conf import settings\nfrom django.shortcuts import get_object_or_404\n\nfrom .pipeline.dataset import Dataset\nfrom .pipeline.factories import (\n    create_comment,\n    create_formatter,\n    create_labels,\n    create_writer,\n)\nfrom .pipeline.services import ExportApplicationService\nfrom data_export.models import ExportedExample\nfrom projects.models import Member, Project\n\nlogger = get_task_logger(__name__)\n\n\ndef create_collaborative_dataset(project: Project, dirpath: str, confirmed_only: bool, formatters, writer):\n    is_text_project = project.is_text_project\n    if confirmed_only:\n        examples = ExportedExample.objects.confirmed(project)\n    else:\n        examples = ExportedExample.objects.filter(project=project)\n    labels = create_labels(project, examples)\n    comments = create_comment(examples)\n    dataset = Dataset(examples, labels, comments, is_text_project)\n\n    service = ExportApplicationService(dataset, formatters, writer)\n\n    filepath = os.path.join(dirpath, f\"all.{writer.extension}\")\n    service.export(filepath)\n\n\ndef create_individual_dataset(project: Project, dirpath: str, confirmed_only: bool, formatters, writer):\n    is_text_project = project.is_text_project\n    members = Member.objects.filter(project=project)\n    for member in members:\n        if confirmed_only:\n            examples = ExportedExample.objects.confirmed(project, user=member.user)\n        else:\n            examples = ExportedExample.objects.filter(project=project)\n        labels = create_labels(project, examples, member.user)\n        comments = create_comment(examples, member.user)\n        dataset = Dataset(examples, labels, comments, is_text_project)\n\n        service = ExportApplicationService(dataset, formatters, writer)\n\n        filepath = os.path.join(dirpath, f\"{member.username}.{writer.extension}\")\n        service.export(filepath)\n\n\n@shared_task(autoretry_for=(Exception,), retry_backoff=True, retry_jitter=True)\ndef export_dataset(project_id, file_format: str, confirmed_only=False):\n    project = get_object_or_404(Project, pk=project_id)\n    dirpath = os.path.join(settings.MEDIA_ROOT, str(uuid.uuid4()))\n    os.makedirs(dirpath, exist_ok=True)\n    formatters = create_formatter(project, file_format)\n    writer = create_writer(file_format)\n    if project.collaborative_annotation:\n        create_collaborative_dataset(project, dirpath, confirmed_only, formatters, writer)\n    else:\n        create_individual_dataset(project, dirpath, confirmed_only, formatters, writer)\n    zip_file = shutil.make_archive(dirpath, \"zip\", dirpath)\n    shutil.rmtree(dirpath)\n    return zip_file\n",
                            "summary": "Functions for creating and exporting datasets: `create_collaborative_dataset` generates a collaborative dataset with filtered examples and associated labels, `create_individual_dataset` creates and exports datasets for each project member, and `export_dataset` exports the project's dataset in the desired format, returning a zipped file of the data.",
                            "code_element_summaries": [
                                "Function `create_collaborative_dataset`: A function that generates a collaborative dataset from a given project, filtering examples based on confirmation status, creating associated labels and comments, and exporting the dataset using specified formatters and a writer.",
                                "Function `create_individual_dataset`: Generates and exports a dataset for each member of a project, including examples, labels, and comments, with options for confirmed examples and specific file formatting.",
                                "Function `export_dataset`: Exports a project's dataset in a specified file format, creating either a collaborative or individual dataset based on project settings, and returns a zipped file of the exported data."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A Django migration that creates multiple proxy models for label-related entities, including ExportedCategory, ExportedExample, ExportedRelation, ExportedSpan, ExportedText, ExportedBoundingBox, ExportedSegmentation, and ExportedComment, all derived from their respective existing models without adding new fields, indexes, or constraints.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"labels\", \"0012_add_uuid_field\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedCategory\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.category\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedExample\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"examples.example\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedRelation\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.relation\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedSpan\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.span\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedText\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.textlabel\",),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-05-12 02:27\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"labels\", \"0012_add_uuid_field\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedCategory\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.category\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedExample\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"examples.example\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedRelation\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.relation\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedSpan\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.span\",),\n        ),\n        migrations.CreateModel(\n            name=\"ExportedText\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.textlabel\",),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes proxy models for several label-related entities, such as ExportedCategory, ExportedExample, ExportedRelation, ExportedSpan, and ExportedText, while maintaining the existing fields and constraints.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates proxy models for various label-related entities, including ExportedCategory, ExportedExample, ExportedRelation, ExportedSpan, and ExportedText, without adding any new fields or constraints."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_exportedboundingbox.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations\\0002_exportedboundingbox.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0015_create_boundingbox_table\"),\n        (\"data_export\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedBoundingBox\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.boundingbox\",),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 02:44\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0015_create_boundingbox_table\"),\n        (\"data_export\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedBoundingBox\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.boundingbox\",),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes a proxy model `ExportedBoundingBox` derived from the existing `BoundingBox` model without introducing any new fields or constraints.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates a proxy model `ExportedBoundingBox` based on the existing `BoundingBox` model with no additional fields or constraints."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_exportedsegmentation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations\\0003_exportedsegmentation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0016_segmentation\"),\n        (\"data_export\", \"0002_exportedboundingbox\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedSegmentation\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.segmentation\",),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 06:57\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0016_segmentation\"),\n        (\"data_export\", \"0002_exportedboundingbox\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedSegmentation\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"labels.segmentation\",),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes a proxy model `ExportedSegmentation` derived from the `segmentation` model in the `labels` app, without introducing any new fields, indexes, or constraints.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates a proxy model `ExportedSegmentation` based on the `segmentation` model from the `labels` app, with no additional fields, indexes, or constraints."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_exportedcomment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations\\0004_exportedcomment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"data_export\", \"0003_exportedsegmentation\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedComment\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"examples.comment\",),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-07-25 05:07\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"data_export\", \"0003_exportedsegmentation\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ExportedComment\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"examples.comment\",),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes a proxy model `ExportedComment` derived from the existing `examples.comment` model without introducing any new fields, indexes, or constraints.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates a proxy model `ExportedComment` based on the existing `examples.comment` model, with no additional fields, indexes, or constraints."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ExportedExampleManager`\nCode:\nclass ExportedExampleManager(models.Manager):\n    def confirmed(self, project: Project, user=None):\n        if project.collaborative_annotation:\n            return self.filter(project=project).exclude(states=None)\n        else:\n            assert user is not None\n            return self.filter(project=project, states__confirmed_by=user)",
                                "Function `confirmed`\nCode:\n    def confirmed(self, project: Project, user=None):\n        if project.collaborative_annotation:\n            return self.filter(project=project).exclude(states=None)\n        else:\n            assert user is not None\n            return self.filter(project=project, states__confirmed_by=user)",
                                "Class `ExportedExample`\nCode:\nclass ExportedExample(Example):\n    objects = ExportedExampleManager()\n\n    def to_dict(self, is_text_project=True) -> Dict[str, Any]:\n        return {\"id\": self.id, DATA: self.text if is_text_project else self.upload_name, **self.meta}\n\n    class Meta:\n        proxy = True",
                                "Function `to_dict`\nCode:\n    def to_dict(self, is_text_project=True) -> Dict[str, Any]:\n        return {\"id\": self.id, DATA: self.text if is_text_project else self.upload_name, **self.meta}",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedLabel`\nCode:\nclass ExportedLabel(Protocol):\n    objects: models.Manager\n\n    def to_dict(self) -> Dict[str, Any]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    def to_string(self) -> str:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    def to_tuple(self) -> Tuple:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                "Function `to_dict`\nCode:\n    def to_dict(self) -> Dict[str, Any]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                "Function `to_string`\nCode:\n    def to_string(self) -> str:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                "Function `to_tuple`\nCode:\n    def to_tuple(self) -> Tuple:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                "Class `ExportedCategory`\nCode:\nclass ExportedCategory(Category):\n    def to_string(self) -> str:\n        return self.label.text\n\n    class Meta:\n        proxy = True",
                                "Function `to_string`\nCode:\n    def to_string(self) -> str:\n        return self.label.text",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedSpan`\nCode:\nclass ExportedSpan(Span):\n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"label\": self.label.text,\n            \"start_offset\": self.start_offset,\n            \"end_offset\": self.end_offset,\n        }\n\n    def to_tuple(self):\n        return self.start_offset, self.end_offset, self.label.text\n\n    class Meta:\n        proxy = True",
                                "Function `to_dict`\nCode:\n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"label\": self.label.text,\n            \"start_offset\": self.start_offset,\n            \"end_offset\": self.end_offset,\n        }",
                                "Function `to_tuple`\nCode:\n    def to_tuple(self):\n        return self.start_offset, self.end_offset, self.label.text",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedRelation`\nCode:\nclass ExportedRelation(Relation):\n    def to_dict(self):\n        return {\"id\": self.id, \"from_id\": self.from_id.id, \"to_id\": self.to_id.id, \"type\": self.type.text}\n\n    class Meta:\n        proxy = True",
                                "Function `to_dict`\nCode:\n    def to_dict(self):\n        return {\"id\": self.id, \"from_id\": self.from_id.id, \"to_id\": self.to_id.id, \"type\": self.type.text}",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedText`\nCode:\nclass ExportedText(TextLabel):\n    def to_string(self) -> str:\n        return self.text\n\n    class Meta:\n        proxy = True",
                                "Function `to_string`\nCode:\n    def to_string(self) -> str:\n        return self.text",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedComment`\nCode:\nclass ExportedComment(Comment):\n    def to_string(self) -> str:\n        return self.text\n\n    def to_dict(self):\n        return {\"id\": self.id, \"comment\": self.text}\n\n    class Meta:\n        proxy = True",
                                "Function `to_string`\nCode:\n    def to_string(self) -> str:\n        return self.text",
                                "Function `to_dict`\nCode:\n    def to_dict(self):\n        return {\"id\": self.id, \"comment\": self.text}",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedBoundingBox`\nCode:\nclass ExportedBoundingBox(BoundingBox):\n    def to_dict(self):\n        return {\n            \"uuid\": str(self.uuid),\n            \"x\": self.x,\n            \"y\": self.y,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"label\": self.label.text,\n        }\n\n    def to_tuple(self):\n        return self.x, self.y, self.width, self.height\n\n    class Meta:\n        proxy = True",
                                "Function `to_dict`\nCode:\n    def to_dict(self):\n        return {\n            \"uuid\": str(self.uuid),\n            \"x\": self.x,\n            \"y\": self.y,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"label\": self.label.text,\n        }",
                                "Function `to_tuple`\nCode:\n    def to_tuple(self):\n        return self.x, self.y, self.width, self.height",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True",
                                "Class `ExportedSegmentation`\nCode:\nclass ExportedSegmentation(Segmentation):\n    def to_dict(self):\n        return {\"uuid\": str(self.uuid), \"points\": self.points, \"label\": self.label.text}\n\n    class Meta:\n        proxy = True",
                                "Function `to_dict`\nCode:\n    def to_dict(self):\n        return {\"uuid\": str(self.uuid), \"points\": self.points, \"label\": self.label.text}",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True"
                            ],
                            "code": "from typing import Any, Dict, Protocol, Tuple\n\nfrom django.db import models\n\nfrom examples.models import Comment, Example\nfrom labels.models import BoundingBox, Category, Relation, Segmentation, Span, TextLabel\nfrom projects.models import Project\n\nDATA = \"data\"\n\n\nclass ExportedExampleManager(models.Manager):\n    def confirmed(self, project: Project, user=None):\n        if project.collaborative_annotation:\n            return self.filter(project=project).exclude(states=None)\n        else:\n            assert user is not None\n            return self.filter(project=project, states__confirmed_by=user)\n\n\nclass ExportedExample(Example):\n    objects = ExportedExampleManager()\n\n    def to_dict(self, is_text_project=True) -> Dict[str, Any]:\n        return {\"id\": self.id, DATA: self.text if is_text_project else self.upload_name, **self.meta}\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedLabel(Protocol):\n    objects: models.Manager\n\n    def to_dict(self) -> Dict[str, Any]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    def to_string(self) -> str:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    def to_tuple(self) -> Tuple:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n\nclass ExportedCategory(Category):\n    def to_string(self) -> str:\n        return self.label.text\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedSpan(Span):\n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"label\": self.label.text,\n            \"start_offset\": self.start_offset,\n            \"end_offset\": self.end_offset,\n        }\n\n    def to_tuple(self):\n        return self.start_offset, self.end_offset, self.label.text\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedRelation(Relation):\n    def to_dict(self):\n        return {\"id\": self.id, \"from_id\": self.from_id.id, \"to_id\": self.to_id.id, \"type\": self.type.text}\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedText(TextLabel):\n    def to_string(self) -> str:\n        return self.text\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedComment(Comment):\n    def to_string(self) -> str:\n        return self.text\n\n    def to_dict(self):\n        return {\"id\": self.id, \"comment\": self.text}\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedBoundingBox(BoundingBox):\n    def to_dict(self):\n        return {\n            \"uuid\": str(self.uuid),\n            \"x\": self.x,\n            \"y\": self.y,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"label\": self.label.text,\n        }\n\n    def to_tuple(self):\n        return self.x, self.y, self.width, self.height\n\n    class Meta:\n        proxy = True\n\n\nclass ExportedSegmentation(Segmentation):\n    def to_dict(self):\n        return {\"uuid\": str(self.uuid), \"points\": self.points, \"label\": self.label.text}\n\n    class Meta:\n        proxy = True\n",
                            "summary": "Class ExportedExampleManager: A Django model manager that retrieves confirmed examples based on project settings and user permissions; Class ExportedExample: A proxy model of Example that converts instances to dictionary format; Class ExportedLabel: A protocol for label object conversion methods; Class ExportedCategory: A proxy model of Category that provides string representation of labels; Class ExportedSpan: A proxy model of Span offering dictionary and tuple representations of span annotations; Class ExportedRelation: A proxy model of Relation that represents relationships in dictionary form; Class ExportedText: A proxy model of TextLabel that returns text as a string; Class ExportedComment: A proxy model of Comment providing methods for string and dictionary representations; Class ExportedBoundingBox: A proxy model of BoundingBox that converts bounding box data into dictionary and tuple formats; Class ExportedSegmentation: A proxy model of Segmentation that represents segmentation annotations in dictionary form.",
                            "code_element_summaries": [
                                "Class ExportedExampleManager: A Django model manager that retrieves confirmed examples based on project settings and user permissions.",
                                "Function `confirmed`: Filters annotations based on the project's collaborative status, returning confirmed states either for all users or specifically for a given user.",
                                "Class ExportedExample: A proxy model of Example that provides a method to convert the instance into a dictionary format, including conditional data based on the project type.",
                                "Function `to_dict`: Returns a dictionary representation of the object, including its ID and either the text or upload name based on the `is_text_project` flag, along with additional metadata.",
                                "Class Meta: A configuration class that indicates the model is a proxy model, allowing it to inherit behavior from another model without creating a new database table.",
                                "Class `ExportedLabel`: A protocol defining methods for converting label objects to dictionary, string, and tuple representations that must be implemented in subclasses.",
                                "Function `to_dict`: An abstract method that raises a NotImplementedError, indicating that it must be implemented in subclasses.",
                                "Function `to_string`: An abstract method that must be implemented in subclasses, designed to return a string representation.",
                                "Function `to_tuple`: An abstract method that raises a NotImplementedError, indicating that it must be implemented in a subclass.",
                                "Class ExportedCategory: A proxy model of Category that provides a method to return the category label as a string.",
                                "Function `to_string`: Returns the text representation of the label associated with the object.",
                                "Class Meta: A configuration class that indicates the model is a proxy, allowing for customization of the behavior of the original model without modifying its underlying structure.",
                                "Class ExportedSpan: A proxy model of Span that provides methods to represent span annotations in both dictionary and tuple formats.",
                                "Function `to_dict`: Converts the object's attributes into a dictionary format, including its ID, label, start offset, and end offset.",
                                "Function `to_tuple`: Returns a tuple containing the start and end offsets along with the label text.",
                                "Class Meta: A class that serves as a proxy for another model, allowing for custom behavior without creating a new database table.",
                                "Class ExportedRelation: A proxy model of Relation that represents relationship annotations in dictionary form.",
                                "Function `to_dict`: Returns a dictionary representation of an object, including its id, associated from_id and to_id, and type.",
                                "Class Meta: A configuration class that indicates the model is a proxy model, allowing it to inherit properties without creating a new database table.",
                                "Class ExportedText: A proxy model of TextLabel that provides a method to return the text as a string.",
                                "Function `to_string`: Returns the text representation of the object as a string.",
                                "Class Meta: A proxy model that allows for the customization of model behavior without creating a new database table.",
                                "Class ExportedComment: A proxy model of Comment that provides methods to represent comments as strings and dictionaries.",
                                "Function `to_string`: A method that returns the text representation of the object as a string.",
                                "Function `to_dict`: Converts an object into a dictionary representation containing its ID and comment text.",
                                "Class Meta: A configuration class that indicates the model is a proxy model, allowing it to inherit behavior from another model without creating a new database table.",
                                "Class ExportedBoundingBox: A proxy model of BoundingBox that provides methods to convert bounding box data into dictionary and tuple formats.",
                                "Function `to_dict`: Converts the object's attributes into a dictionary format, including its UUID, coordinates, dimensions, and label text.",
                                "Function `to_tuple`: Returns a tuple containing the x, y coordinates and the width and height of the bounding box.",
                                "Class Meta: A configuration class that enables the use of a proxy model in Django, allowing for the extension of an existing model without creating a new database table.",
                                "Class ExportedSegmentation: A proxy model of Segmentation that represents segmentation annotations in dictionary form.",
                                "Function `to_dict`: Converts the object's attributes into a dictionary format, including the UUID, points, and label text.",
                                "Class Meta: A configuration class that is used to define metadata options for a Django model, in this case indicating that the model is a proxy."
                            ],
                            "children": []
                        },
                        {
                            "name": "pipeline",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content describes a framework consisting of various classes that manage file formats, comments, datasets, and labels for efficient data processing and exportation, with specific implementations for formatting and writing data to different file types.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "catalog.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\catalog.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Format`\nCode:\nclass Format:\n    name = \"\"\n\n    @classmethod\n    def dict(cls):\n        return {\n            \"name\": cls.name,\n        }",
                                        "Function `dict`\nCode:\n    def dict(cls):\n        return {\n            \"name\": cls.name,\n        }",
                                        "Class `CSV`\nCode:\nclass CSV(Format):\n    name = \"CSV\"",
                                        "Class `FastText`\nCode:\nclass FastText(Format):\n    name = \"fastText\"",
                                        "Class `JSON`\nCode:\nclass JSON(Format):\n    name = \"JSON\"",
                                        "Class `JSONL`\nCode:\nclass JSONL(Format):\n    name = \"JSONL\"",
                                        "Class `Options`\nCode:\nclass Options:\n    options: Dict[str, List] = defaultdict(list)\n\n    @classmethod\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        return [\n            {**file_format.dict(), \"example\": example}\n            for file_format, example, use_rel in options\n            if use_rel == use_relation\n        ]\n\n    @classmethod\n    def register(cls, task: str, file_format: Type[Format], file: Path, use_relation: bool = False):\n        example = cls.load_example(file)\n        cls.options[task].append((file_format, example, use_relation))\n\n    @staticmethod\n    def load_example(file):\n        with open(file, encoding=\"utf-8\") as f:\n            return f.read()",
                                        "Function `filter_by_task`\nCode:\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        return [\n            {**file_format.dict(), \"example\": example}\n            for file_format, example, use_rel in options\n            if use_rel == use_relation\n        ]",
                                        "Function `register`\nCode:\n    def register(cls, task: str, file_format: Type[Format], file: Path, use_relation: bool = False):\n        example = cls.load_example(file)\n        cls.options[task].append((file_format, example, use_relation))",
                                        "Function `load_example`\nCode:\n    def load_example(file):\n        with open(file, encoding=\"utf-8\") as f:\n            return f.read()"
                                    ],
                                    "code": "from collections import defaultdict\nfrom pathlib import Path\nfrom typing import Dict, List, Type\n\nfrom projects.models import ProjectType\n\nEXAMPLE_DIR = Path(__file__).parent.resolve() / \"examples\"\n\n\nclass Format:\n    name = \"\"\n\n    @classmethod\n    def dict(cls):\n        return {\n            \"name\": cls.name,\n        }\n\n\nclass CSV(Format):\n    name = \"CSV\"\n\n\nclass FastText(Format):\n    name = \"fastText\"\n\n\nclass JSON(Format):\n    name = \"JSON\"\n\n\nclass JSONL(Format):\n    name = \"JSONL\"\n\n\nclass Options:\n    options: Dict[str, List] = defaultdict(list)\n\n    @classmethod\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        return [\n            {**file_format.dict(), \"example\": example}\n            for file_format, example, use_rel in options\n            if use_rel == use_relation\n        ]\n\n    @classmethod\n    def register(cls, task: str, file_format: Type[Format], file: Path, use_relation: bool = False):\n        example = cls.load_example(file)\n        cls.options[task].append((file_format, example, use_relation))\n\n    @staticmethod\n    def load_example(file):\n        with open(file, encoding=\"utf-8\") as f:\n            return f.read()\n\n\n# Text Classification\nTEXT_CLASSIFICATION_DIR = EXAMPLE_DIR / \"text_classification\"\nOptions.register(ProjectType.DOCUMENT_CLASSIFICATION, CSV, TEXT_CLASSIFICATION_DIR / \"example.csv\")\nOptions.register(ProjectType.DOCUMENT_CLASSIFICATION, FastText, TEXT_CLASSIFICATION_DIR / \"example.txt\")\nOptions.register(ProjectType.DOCUMENT_CLASSIFICATION, JSON, TEXT_CLASSIFICATION_DIR / \"example.json\")\nOptions.register(ProjectType.DOCUMENT_CLASSIFICATION, JSONL, TEXT_CLASSIFICATION_DIR / \"example.jsonl\")\n\n# Sequence Labeling\nSEQUENCE_LABELING_DIR = EXAMPLE_DIR / \"sequence_labeling\"\nRELATION_EXTRACTION_DIR = EXAMPLE_DIR / \"relation_extraction\"\nOptions.register(ProjectType.SEQUENCE_LABELING, JSONL, SEQUENCE_LABELING_DIR / \"example.jsonl\")\nOptions.register(ProjectType.SEQUENCE_LABELING, JSONL, RELATION_EXTRACTION_DIR / \"example.jsonl\", True)\n\n# Sequence to sequence\nSEQ2SEQ_DIR = EXAMPLE_DIR / \"sequence_to_sequence\"\nOptions.register(ProjectType.SEQ2SEQ, CSV, SEQ2SEQ_DIR / \"example.csv\")\nOptions.register(ProjectType.SEQ2SEQ, JSON, SEQ2SEQ_DIR / \"example.json\")\nOptions.register(ProjectType.SEQ2SEQ, JSONL, SEQ2SEQ_DIR / \"example.jsonl\")\n\n# Intent detection and slot filling\nINTENT_DETECTION_DIR = EXAMPLE_DIR / \"intent_detection\"\nOptions.register(ProjectType.INTENT_DETECTION_AND_SLOT_FILLING, JSONL, INTENT_DETECTION_DIR / \"example.jsonl\")\n\n# Image Classification\nIMAGE_CLASSIFICATION_DIR = EXAMPLE_DIR / \"image_classification\"\nOptions.register(ProjectType.IMAGE_CLASSIFICATION, JSONL, IMAGE_CLASSIFICATION_DIR / \"example.jsonl\")\n\nBOUNDING_BOX_DIR = EXAMPLE_DIR / \"bounding_box\"\nOptions.register(ProjectType.BOUNDING_BOX, JSONL, BOUNDING_BOX_DIR / \"example.jsonl\")\n\nSEGMENTATION_DIR = EXAMPLE_DIR / \"segmentation\"\nOptions.register(ProjectType.SEGMENTATION, JSONL, SEGMENTATION_DIR / \"example.jsonl\")\n\nIMAGE_CAPTIONING_DIR = EXAMPLE_DIR / \"image_captioning\"\nOptions.register(ProjectType.IMAGE_CAPTIONING, JSONL, IMAGE_CAPTIONING_DIR / \"example.jsonl\")\n\n# Speech to Text\nSPEECH2TEXT_DIR = EXAMPLE_DIR / \"speech_to_text\"\nOptions.register(ProjectType.SPEECH2TEXT, JSONL, SPEECH2TEXT_DIR / \"example.jsonl\")\n",
                                    "summary": "Class Format and its subclasses (CSV, FastText, JSON, JSONL) define various file formats with methods for dictionary representation, while the Options class manages and filters task-specific options, allowing registration of file formats and their examples.",
                                    "code_element_summaries": [
                                        "Class Format: A class that defines a format with a name attribute and provides a class method to return its representation as a dictionary.",
                                        "Function `dict`: A class method that returns a dictionary representation of the class with its name attribute.",
                                        "Class CSV: A subclass of Format that represents the CSV file format with a specified name.",
                                        "Class FastText: A model that represents the fastText format for text representation.",
                                        "Class JSON: A subclass of Format that represents the JSON format with a specified name.",
                                        "Class JSONL: A subclass of Format that represents the JSON Lines file format with a specified name attribute.",
                                        "Class `Options`: A class that manages and filters task-specific options, allowing registration of file formats with examples and optional relation usage.",
                                        "Function `filter_by_task`: A class method that filters options based on a specified task name and an optional relation flag, returning a list of dictionaries containing file format details and examples.",
                                        "Function `register`: A class method that loads an example from a specified file and appends it to the options for a given task, along with the file format and a boolean indicating whether to use a relation.",
                                        "Function `load_example`: A utility function that reads the contents of a specified file and returns it as a string."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "comments.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\comments.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Comments`\nCode:\nclass Comments(abc.ABC):\n    comment_class = ExportedComment\n    column = \"Comments\"\n    fields: Tuple[str, ...] = (\"example\", \"user\")  # To boost performance\n\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.comment_groups = defaultdict(list)\n        comments = self.comment_class.objects.filter(example__in=examples)\n        if user:\n            comments = comments.filter(user=user)\n        for comment in comments.select_related(*self.fields):\n            self.comment_groups[comment.example.id].append(comment)\n\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedComment]]:\n        return {self.column: self.comment_groups[example_id]}",
                                        "Function `__init__`\nCode:\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.comment_groups = defaultdict(list)\n        comments = self.comment_class.objects.filter(example__in=examples)\n        if user:\n            comments = comments.filter(user=user)\n        for comment in comments.select_related(*self.fields):\n            self.comment_groups[comment.example.id].append(comment)",
                                        "Function `find_by`\nCode:\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedComment]]:\n        return {self.column: self.comment_groups[example_id]}"
                                    ],
                                    "code": "import abc\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\nfrom django.db.models import QuerySet\n\nfrom data_export.models import ExportedComment, ExportedExample\n\n\nclass Comments(abc.ABC):\n    comment_class = ExportedComment\n    column = \"Comments\"\n    fields: Tuple[str, ...] = (\"example\", \"user\")  # To boost performance\n\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.comment_groups = defaultdict(list)\n        comments = self.comment_class.objects.filter(example__in=examples)\n        if user:\n            comments = comments.filter(user=user)\n        for comment in comments.select_related(*self.fields):\n            self.comment_groups[comment.example.id].append(comment)\n\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedComment]]:\n        return {self.column: self.comment_groups[example_id]}\n",
                                    "summary": "Class Comments: An abstract base class that organizes comments into user-based groups for efficient retrieval and filtering, with methods to initialize and find comments by example ID.",
                                    "code_element_summaries": [
                                        "Class `Comments`: An abstract base class that organizes comments into groups based on examples, allowing for efficient retrieval and filtering by user.",
                                        "Function `__init__`: Initializes an instance by organizing comments into groups based on examples, optionally filtered by a specific user.",
                                        "Function `find_by`: A method that retrieves a dictionary mapping a specified column to a list of `ExportedComment` objects associated with a given example ID."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "dataset.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\dataset.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Dataset`\nCode:\nclass Dataset:\n    def __init__(\n        self, examples: QuerySet[ExportedExample], labels: List[Labels], comments: List[Comments], is_text_project=True\n    ):\n        self.examples = examples\n        self.labels = labels\n        self.is_text_project = is_text_project\n        self.comments = comments\n\n    def __iter__(self) -> Iterator[Dict[str, Any]]:\n        for example in self.examples:\n            data = example.to_dict(self.is_text_project)\n            for labels in self.labels:\n                data.update(**labels.find_by(example.id))\n            for comment in self.comments:\n                data.update(**comment.find_by(example.id))\n            yield data\n\n    def to_dataframe(self) -> pd.DataFrame:\n        return pd.DataFrame(self)",
                                        "Function `__init__`\nCode:\n    def __init__(\n        self, examples: QuerySet[ExportedExample], labels: List[Labels], comments: List[Comments], is_text_project=True\n    ):\n        self.examples = examples\n        self.labels = labels\n        self.is_text_project = is_text_project\n        self.comments = comments",
                                        "Function `__iter__`\nCode:\n    def __iter__(self) -> Iterator[Dict[str, Any]]:\n        for example in self.examples:\n            data = example.to_dict(self.is_text_project)\n            for labels in self.labels:\n                data.update(**labels.find_by(example.id))\n            for comment in self.comments:\n                data.update(**comment.find_by(example.id))\n            yield data",
                                        "Function `to_dataframe`\nCode:\n    def to_dataframe(self) -> pd.DataFrame:\n        return pd.DataFrame(self)"
                                    ],
                                    "code": "from typing import Any, Dict, Iterator, List\n\nimport pandas as pd\nfrom django.db.models.query import QuerySet\n\nfrom .comments import Comments\nfrom .labels import Labels\nfrom data_export.models import ExportedExample\n\n\nclass Dataset:\n    def __init__(\n        self, examples: QuerySet[ExportedExample], labels: List[Labels], comments: List[Comments], is_text_project=True\n    ):\n        self.examples = examples\n        self.labels = labels\n        self.is_text_project = is_text_project\n        self.comments = comments\n\n    def __iter__(self) -> Iterator[Dict[str, Any]]:\n        for example in self.examples:\n            data = example.to_dict(self.is_text_project)\n            for labels in self.labels:\n                data.update(**labels.find_by(example.id))\n            for comment in self.comments:\n                data.update(**comment.find_by(example.id))\n            yield data\n\n    def to_dataframe(self) -> pd.DataFrame:\n        return pd.DataFrame(self)\n",
                                    "summary": "Class `Dataset`: A data structure that manages examples, labels, and comments, offering methods for iteration and conversion to a Pandas DataFrame.",
                                    "code_element_summaries": [
                                        "Class `Dataset`: A data structure that encapsulates examples, labels, and comments, providing methods to iterate through the examples and convert the dataset into a pandas DataFrame.",
                                        "Function `__init__`: Initializes an instance with a queryset of examples, a list of labels, a list of comments, and a boolean indicating if it is a text project.",
                                        "Function `__iter__`: An iterator that yields dictionaries containing example data enriched with labels and comments based on the example's ID.",
                                        "Function `to_dataframe`: Converts the instance data into a Pandas DataFrame format."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "factories.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\factories.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `create_writer`\nCode:\ndef create_writer(file_format: str) -> writers.Writer:\n    mapping = {\n        CSV.name: writers.CsvWriter(),\n        JSON.name: writers.JsonWriter(),\n        JSONL.name: writers.JsonlWriter(),\n        FastText.name: writers.FastTextWriter(),\n    }\n    if file_format not in mapping:\n        ValueError(f\"Invalid format: {file_format}\")\n    return mapping[file_format]",
                                        "Function `create_formatter`\nCode:\ndef create_formatter(project: Project, file_format: str) -> List[Formatter]:\n    use_relation = getattr(project, \"use_relation\", False)\n    # text tasks\n    mapper_text_classification = {DATA: \"text\", Categories.column: \"label\"}\n    mapper_sequence_labeling = {DATA: \"text\", Spans.column: \"label\"}\n    mapper_seq2seq = {DATA: \"text\", Texts.column: \"label\"}\n    mapper_intent_detection = {DATA: \"text\", Categories.column: \"cats\"}\n    mapper_relation_extraction = {DATA: \"text\"}\n\n    # image tasks\n    mapper_image_classification = {DATA: \"filename\", Categories.column: \"label\"}\n    mapper_bounding_box = {DATA: \"filename\", BoundingBoxes.column: \"bbox\"}\n    mapper_segmentation = {DATA: \"filename\", BoundingBoxes.column: \"segmentation\"}\n    mapper_image_captioning = {DATA: \"filename\", Texts.column: \"label\"}\n\n    # audio tasks\n    mapper_speech2text = {DATA: \"filename\", Texts.column: \"label\"}\n\n    mapping: Dict[str, Dict[str, List[Formatter]]] = {\n        ProjectType.DOCUMENT_CLASSIFICATION: {\n            CSV.name: [\n                JoinedCategoryFormatter(Categories.column),\n                JoinedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            JSON.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            FastText.name: [FastTextCategoryFormatter(Categories.column)],\n        },\n        ProjectType.SEQUENCE_LABELING: {\n            JSONL.name: [\n                DictFormatter(Spans.column),\n                DictFormatter(Relations.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_relation_extraction),\n            ]\n            if use_relation\n            else [\n                TupledSpanFormatter(Spans.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_sequence_labeling),\n            ]\n        },\n        ProjectType.SEQ2SEQ: {\n            CSV.name: [\n                JoinedCategoryFormatter(Texts.column),\n                JoinedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n            JSON.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n        },\n        ProjectType.IMAGE_CLASSIFICATION: {\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_image_classification),\n            ],\n        },\n        ProjectType.SPEECH2TEXT: {\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_speech2text),\n            ],\n        },\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: {\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                TupledSpanFormatter(Spans.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_intent_detection),\n            ]\n        },\n        ProjectType.BOUNDING_BOX: {\n            JSONL.name: [\n                DictFormatter(BoundingBoxes.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_bounding_box),\n            ]\n        },\n        ProjectType.SEGMENTATION: {\n            JSONL.name: [\n                DictFormatter(Segments.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_segmentation),\n            ]\n        },\n        ProjectType.IMAGE_CAPTIONING: {\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_image_captioning),\n            ]\n        },\n    }\n    return mapping[project.project_type][file_format]",
                                        "Function `select_label_collection`\nCode:\ndef select_label_collection(project: Project) -> List[Type[Labels]]:\n    use_relation = getattr(project, \"use_relation\", False)\n    mapping: Dict[str, List[Type[Labels]]] = {\n        ProjectType.DOCUMENT_CLASSIFICATION: [Categories],\n        ProjectType.SEQUENCE_LABELING: [Spans, Relations] if use_relation else [Spans],\n        ProjectType.SEQ2SEQ: [Texts],\n        ProjectType.IMAGE_CLASSIFICATION: [Categories],\n        ProjectType.SPEECH2TEXT: [Texts],\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: [Categories, Spans],\n        ProjectType.BOUNDING_BOX: [BoundingBoxes],\n        ProjectType.SEGMENTATION: [Segments],\n        ProjectType.IMAGE_CAPTIONING: [Texts],\n    }\n    return mapping[project.project_type]",
                                        "Function `create_labels`\nCode:\ndef create_labels(project: Project, examples: QuerySet[ExportedExample], user=None) -> List[Labels]:\n    label_collections = select_label_collection(project)\n    labels = [label_collection(examples=examples, user=user) for label_collection in label_collections]\n    return labels",
                                        "Function `create_comment`\nCode:\ndef create_comment(examples: QuerySet[ExportedExample], user=None) -> List[Comments]:\n    return [Comments(examples=examples, user=user)]"
                                    ],
                                    "code": "from typing import Dict, List, Type\n\nfrom django.db.models import QuerySet\n\nfrom . import writers\nfrom .catalog import CSV, JSON, JSONL, FastText\nfrom .comments import Comments\nfrom .formatters import (\n    DictFormatter,\n    FastTextCategoryFormatter,\n    Formatter,\n    JoinedCategoryFormatter,\n    ListedCategoryFormatter,\n    RenameFormatter,\n    TupledSpanFormatter,\n)\nfrom .labels import BoundingBoxes, Categories, Labels, Relations, Segments, Spans, Texts\nfrom data_export.models import DATA, ExportedExample\nfrom projects.models import Project, ProjectType\n\n\ndef create_writer(file_format: str) -> writers.Writer:\n    mapping = {\n        CSV.name: writers.CsvWriter(),\n        JSON.name: writers.JsonWriter(),\n        JSONL.name: writers.JsonlWriter(),\n        FastText.name: writers.FastTextWriter(),\n    }\n    if file_format not in mapping:\n        ValueError(f\"Invalid format: {file_format}\")\n    return mapping[file_format]\n\n\ndef create_formatter(project: Project, file_format: str) -> List[Formatter]:\n    use_relation = getattr(project, \"use_relation\", False)\n    # text tasks\n    mapper_text_classification = {DATA: \"text\", Categories.column: \"label\"}\n    mapper_sequence_labeling = {DATA: \"text\", Spans.column: \"label\"}\n    mapper_seq2seq = {DATA: \"text\", Texts.column: \"label\"}\n    mapper_intent_detection = {DATA: \"text\", Categories.column: \"cats\"}\n    mapper_relation_extraction = {DATA: \"text\"}\n\n    # image tasks\n    mapper_image_classification = {DATA: \"filename\", Categories.column: \"label\"}\n    mapper_bounding_box = {DATA: \"filename\", BoundingBoxes.column: \"bbox\"}\n    mapper_segmentation = {DATA: \"filename\", BoundingBoxes.column: \"segmentation\"}\n    mapper_image_captioning = {DATA: \"filename\", Texts.column: \"label\"}\n\n    # audio tasks\n    mapper_speech2text = {DATA: \"filename\", Texts.column: \"label\"}\n\n    mapping: Dict[str, Dict[str, List[Formatter]]] = {\n        ProjectType.DOCUMENT_CLASSIFICATION: {\n            CSV.name: [\n                JoinedCategoryFormatter(Categories.column),\n                JoinedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            JSON.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_text_classification),\n            ],\n            FastText.name: [FastTextCategoryFormatter(Categories.column)],\n        },\n        ProjectType.SEQUENCE_LABELING: {\n            JSONL.name: [\n                DictFormatter(Spans.column),\n                DictFormatter(Relations.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_relation_extraction),\n            ]\n            if use_relation\n            else [\n                TupledSpanFormatter(Spans.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_sequence_labeling),\n            ]\n        },\n        ProjectType.SEQ2SEQ: {\n            CSV.name: [\n                JoinedCategoryFormatter(Texts.column),\n                JoinedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n            JSON.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_seq2seq),\n            ],\n        },\n        ProjectType.IMAGE_CLASSIFICATION: {\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_image_classification),\n            ],\n        },\n        ProjectType.SPEECH2TEXT: {\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_speech2text),\n            ],\n        },\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: {\n            JSONL.name: [\n                ListedCategoryFormatter(Categories.column),\n                TupledSpanFormatter(Spans.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_intent_detection),\n            ]\n        },\n        ProjectType.BOUNDING_BOX: {\n            JSONL.name: [\n                DictFormatter(BoundingBoxes.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_bounding_box),\n            ]\n        },\n        ProjectType.SEGMENTATION: {\n            JSONL.name: [\n                DictFormatter(Segments.column),\n                DictFormatter(Comments.column),\n                RenameFormatter(**mapper_segmentation),\n            ]\n        },\n        ProjectType.IMAGE_CAPTIONING: {\n            JSONL.name: [\n                ListedCategoryFormatter(Texts.column),\n                ListedCategoryFormatter(Comments.column),\n                RenameFormatter(**mapper_image_captioning),\n            ]\n        },\n    }\n    return mapping[project.project_type][file_format]\n\n\ndef select_label_collection(project: Project) -> List[Type[Labels]]:\n    use_relation = getattr(project, \"use_relation\", False)\n    mapping: Dict[str, List[Type[Labels]]] = {\n        ProjectType.DOCUMENT_CLASSIFICATION: [Categories],\n        ProjectType.SEQUENCE_LABELING: [Spans, Relations] if use_relation else [Spans],\n        ProjectType.SEQ2SEQ: [Texts],\n        ProjectType.IMAGE_CLASSIFICATION: [Categories],\n        ProjectType.SPEECH2TEXT: [Texts],\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: [Categories, Spans],\n        ProjectType.BOUNDING_BOX: [BoundingBoxes],\n        ProjectType.SEGMENTATION: [Segments],\n        ProjectType.IMAGE_CAPTIONING: [Texts],\n    }\n    return mapping[project.project_type]\n\n\ndef create_labels(project: Project, examples: QuerySet[ExportedExample], user=None) -> List[Labels]:\n    label_collections = select_label_collection(project)\n    labels = [label_collection(examples=examples, user=user) for label_collection in label_collections]\n    return labels\n\n\ndef create_comment(examples: QuerySet[ExportedExample], user=None) -> List[Comments]:\n    return [Comments(examples=examples, user=user)]\n",
                                    "summary": "Functions for creating writers, formatters, label collections, and comments that facilitate data processing and management based on project specifications and formats.",
                                    "code_element_summaries": [
                                        "Function `create_writer`: A factory function that returns an appropriate writer object based on the specified file format, raising a ValueError for invalid formats.",
                                        "Function `create_formatter`: Generates a list of formatters based on the project type and specified file format to facilitate data processing for various tasks such as text classification, image classification, and audio transcription.",
                                        "Function `select_label_collection`: Retrieves a list of label types associated with a given project based on its project type and whether relations are used.",
                                        "Function `create_labels`: Generates a list of label collections for a given project based on the provided examples and user.",
                                        "Function `create_comment`: A function that generates a list of `Comments` instances associated with given examples and an optional user."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "formatters.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\formatters.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Formatter`\nCode:\nclass Formatter(abc.ABC):\n    def __init__(self, target_column: str = \"labels\", **kwargs):\n        self.target_column = target_column\n        self.mapper = kwargs\n\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        if self.target_column not in dataset.columns:\n            return dataset\n        return self.apply(dataset)\n\n    @abc.abstractmethod\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `__init__`\nCode:\n    def __init__(self, target_column: str = \"labels\", **kwargs):\n        self.target_column = target_column\n        self.mapper = kwargs",
                                        "Function `format`\nCode:\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        if self.target_column not in dataset.columns:\n            return dataset\n        return self.apply(dataset)",
                                        "Function `apply`\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Class `JoinedCategoryFormatter`\nCode:\nclass JoinedCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `LabelA#LabelB` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \"#\".join(sorted(label.to_string() for label in labels))\n        )\n        return dataset",
                                        "Function `apply`: Format the label column to `LabelA#LabelB` format.\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `LabelA#LabelB` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \"#\".join(sorted(label.to_string() for label in labels))\n        )\n        return dataset",
                                        "Class `ListedCategoryFormatter`\nCode:\nclass ListedCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `['LabelA', 'LabelB']` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: sorted([label.to_string() for label in labels])\n        )\n        return dataset",
                                        "Function `apply`: Format the label column to `['LabelA', 'LabelB']` format.\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `['LabelA', 'LabelB']` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: sorted([label.to_string() for label in labels])\n        )\n        return dataset",
                                        "Class `FastTextCategoryFormatter`\nCode:\nclass FastTextCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `__label__LabelA __label__LabelB` format.\n        Also, drop the columns except for `data` and `self.target_column`.\n        \"\"\"\n        dataset = dataset[[DATA, self.target_column, \"Comments\"]]\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \" \".join(sorted(f\"__label__{label.to_string()}\" for label in labels))\n        )\n        dataset[self.target_column] = dataset[self.target_column].fillna(\"\")\n        dataset[\"Comments\"] = dataset[\"Comments\"].apply(\n            lambda comments: \" \".join(f\"__comment__{comment.to_string()}\" for comment in comments)\n        )\n        dataset = dataset[self.target_column] + \" \" + dataset[DATA] + \" \" + dataset[\"Comments\"]\n        return dataset",
                                        "Function `apply`: Format the label column to `__label__LabelA __label__LabelB` format.\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `__label__LabelA __label__LabelB` format.\n        Also, drop the columns except for `data` and `self.target_column`.\n        \"\"\"\n        dataset = dataset[[DATA, self.target_column, \"Comments\"]]\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \" \".join(sorted(f\"__label__{label.to_string()}\" for label in labels))\n        )\n        dataset[self.target_column] = dataset[self.target_column].fillna(\"\")\n        dataset[\"Comments\"] = dataset[\"Comments\"].apply(\n            lambda comments: \" \".join(f\"__comment__{comment.to_string()}\" for comment in comments)\n        )\n        dataset = dataset[self.target_column] + \" \" + dataset[DATA] + \" \" + dataset[\"Comments\"]\n        return dataset",
                                        "Class `TupledSpanFormatter`\nCode:\nclass TupledSpanFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the span column to `(start_offset, end_offset, label)` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda spans: sorted(span.to_tuple() for span in spans)\n        )\n        return dataset",
                                        "Function `apply`: Format the span column to `(start_offset, end_offset, label)` format\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the span column to `(start_offset, end_offset, label)` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda spans: sorted(span.to_tuple() for span in spans)\n        )\n        return dataset",
                                        "Class `DictFormatter`\nCode:\nclass DictFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the column to `{key: value}` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: [label.to_dict() for label in labels]\n        )\n        return dataset",
                                        "Function `apply`: Format the column to `{key: value}` format\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the column to `{key: value}` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: [label.to_dict() for label in labels]\n        )\n        return dataset",
                                        "Class `RenameFormatter`\nCode:\nclass RenameFormatter(Formatter):\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        return self.apply(dataset)\n\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Rename columns\"\"\"\n        dataset.rename(columns=self.mapper, inplace=True)\n        return dataset",
                                        "Function `format`\nCode:\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        return self.apply(dataset)",
                                        "Function `apply`: Rename columns\nCode:\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Rename columns\"\"\"\n        dataset.rename(columns=self.mapper, inplace=True)\n        return dataset"
                                    ],
                                    "code": "\"\"\"\nConvert a dataset to the specified format.\n\"\"\"\nimport abc\n\nimport pandas as pd\n\nfrom data_export.models import DATA\n\n\nclass Formatter(abc.ABC):\n    def __init__(self, target_column: str = \"labels\", **kwargs):\n        self.target_column = target_column\n        self.mapper = kwargs\n\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        if self.target_column not in dataset.columns:\n            return dataset\n        return self.apply(dataset)\n\n    @abc.abstractmethod\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n\nclass JoinedCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `LabelA#LabelB` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \"#\".join(sorted(label.to_string() for label in labels))\n        )\n        return dataset\n\n\nclass ListedCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `['LabelA', 'LabelB']` format.\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: sorted([label.to_string() for label in labels])\n        )\n        return dataset\n\n\nclass FastTextCategoryFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the label column to `__label__LabelA __label__LabelB` format.\n        Also, drop the columns except for `data` and `self.target_column`.\n        \"\"\"\n        dataset = dataset[[DATA, self.target_column, \"Comments\"]]\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: \" \".join(sorted(f\"__label__{label.to_string()}\" for label in labels))\n        )\n        dataset[self.target_column] = dataset[self.target_column].fillna(\"\")\n        dataset[\"Comments\"] = dataset[\"Comments\"].apply(\n            lambda comments: \" \".join(f\"__comment__{comment.to_string()}\" for comment in comments)\n        )\n        dataset = dataset[self.target_column] + \" \" + dataset[DATA] + \" \" + dataset[\"Comments\"]\n        return dataset\n\n\nclass TupledSpanFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the span column to `(start_offset, end_offset, label)` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda spans: sorted(span.to_tuple() for span in spans)\n        )\n        return dataset\n\n\nclass DictFormatter(Formatter):\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Format the column to `{key: value}` format\"\"\"\n        dataset[self.target_column] = dataset[self.target_column].apply(\n            lambda labels: [label.to_dict() for label in labels]\n        )\n        return dataset\n\n\nclass RenameFormatter(Formatter):\n    def format(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        return self.apply(dataset)\n\n    def apply(self, dataset: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Rename columns\"\"\"\n        dataset.rename(columns=self.mapper, inplace=True)\n        return dataset\n",
                                    "summary": "Class Formatter: An abstract base class for dataset formatting that mandates implementation of a transformation method in subclasses, with various concrete formatters like JoinedCategoryFormatter and DictFormatter providing specific label formatting functionalities for pandas DataFrames.",
                                    "code_element_summaries": [
                                        "Class Formatter: An abstract base class for formatting datasets that requires subclasses to implement a specific data transformation method while providing a default initialization and formatting behavior based on a target column.",
                                        "Function `__init__`: Initializes an instance with a specified target column for labels and accepts additional keyword arguments for configuration.",
                                        "Function `format`: A method that checks for the presence of a target column in a DataFrame and applies a transformation if the column exists, returning the modified DataFrame.",
                                        "Function `apply`: An abstract method intended to be implemented in subclasses, which takes a pandas DataFrame as input and returns a modified DataFrame.",
                                        "Class JoinedCategoryFormatter: A formatter that transforms the label column of a DataFrame into a concatenated string format of `LabelA#LabelB`.",
                                        "Function `apply`: Formats the label column of a DataFrame to a concatenated string format of `LabelA#LabelB`.",
                                        "Class `ListedCategoryFormatter`: A formatter that modifies the label column of a DataFrame to ensure it is presented in a sorted list format.",
                                        "Function `apply`: Formats the label column of a DataFrame to a sorted list of string labels in the `['LabelA', 'LabelB']` format.",
                                        "Class `FastTextCategoryFormatter`: A formatter that transforms the label column of a DataFrame into a specific format while retaining only relevant columns and formatting comments.",
                                        "Function `apply`: Formats the label column of a DataFrame to a specific label format while dropping unnecessary columns and concatenating relevant data into a single string.",
                                        "Class TupledSpanFormatter: A formatter that transforms span data in a DataFrame into a tuple format of `(start_offset, end_offset, label)`.",
                                        "Function `apply`: Transforms the span column of a DataFrame into a structured format of tuples containing start offset, end offset, and label.",
                                        "Class `DictFormatter`: A formatter that transforms a specified column of a pandas DataFrame into a list of dictionaries, where each dictionary represents an object in that column.",
                                        "Function `apply`: Formats the specified column of a DataFrame by transforming its values into a list of dictionaries in the `{key: value}` format.",
                                        "Class `RenameFormatter`: A subclass of Formatter that renames columns in a given pandas DataFrame according to a specified mapping.",
                                        "Function `format`: A method that applies a transformation to a given pandas DataFrame and returns the modified DataFrame.",
                                        "Function `apply`: Renames the columns of a given DataFrame based on a specified mapping."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "labels.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\labels.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Labels`\nCode:\nclass Labels(abc.ABC):\n    label_class = ExportedLabel\n    column = \"labels\"\n    fields: Tuple[str, ...] = (\"example\", \"label\")  # To boost performance\n\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.label_groups = defaultdict(list)\n        labels = self.label_class.objects.filter(example__in=examples)\n        if user:\n            labels = labels.filter(user=user)\n        for label in labels.select_related(*self.fields):\n            self.label_groups[label.example.id].append(label)\n\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedLabel]]:\n        return {self.column: self.label_groups[example_id]}",
                                        "Function `__init__`\nCode:\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.label_groups = defaultdict(list)\n        labels = self.label_class.objects.filter(example__in=examples)\n        if user:\n            labels = labels.filter(user=user)\n        for label in labels.select_related(*self.fields):\n            self.label_groups[label.example.id].append(label)",
                                        "Function `find_by`\nCode:\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedLabel]]:\n        return {self.column: self.label_groups[example_id]}",
                                        "Class `Categories`\nCode:\nclass Categories(Labels):\n    label_class = ExportedCategory\n    column = \"categories\"\n    fields = (\"example\", \"label\")",
                                        "Class `Spans`\nCode:\nclass Spans(Labels):\n    label_class = ExportedSpan\n    column = \"entities\"\n    fields = (\"example\", \"label\")",
                                        "Class `Relations`\nCode:\nclass Relations(Labels):\n    label_class = ExportedRelation\n    column = \"relations\"\n    fields = (\"example\", \"type\")",
                                        "Class `Texts`\nCode:\nclass Texts(Labels):\n    label_class = ExportedText\n    column = \"labels\"\n    fields = (\"example\",)",
                                        "Class `BoundingBoxes`\nCode:\nclass BoundingBoxes(Labels):\n    label_class = ExportedBoundingBox\n    column = \"labels\"\n    fields = (\"example\", \"label\")",
                                        "Class `Segments`\nCode:\nclass Segments(Labels):\n    label_class = ExportedSegmentation\n    column = \"labels\"\n    fields = (\"example\", \"label\")"
                                    ],
                                    "code": "\"\"\"\nRepresents label collection.\n\"\"\"\nimport abc\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\nfrom django.db.models import QuerySet\n\nfrom data_export.models import (\n    ExportedBoundingBox,\n    ExportedCategory,\n    ExportedExample,\n    ExportedLabel,\n    ExportedRelation,\n    ExportedSegmentation,\n    ExportedSpan,\n    ExportedText,\n)\n\n\nclass Labels(abc.ABC):\n    label_class = ExportedLabel\n    column = \"labels\"\n    fields: Tuple[str, ...] = (\"example\", \"label\")  # To boost performance\n\n    def __init__(self, examples: QuerySet[ExportedExample], user=None):\n        self.label_groups = defaultdict(list)\n        labels = self.label_class.objects.filter(example__in=examples)\n        if user:\n            labels = labels.filter(user=user)\n        for label in labels.select_related(*self.fields):\n            self.label_groups[label.example.id].append(label)\n\n    def find_by(self, example_id: int) -> Dict[str, List[ExportedLabel]]:\n        return {self.column: self.label_groups[example_id]}\n\n\nclass Categories(Labels):\n    label_class = ExportedCategory\n    column = \"categories\"\n    fields = (\"example\", \"label\")\n\n\nclass Spans(Labels):\n    label_class = ExportedSpan\n    column = \"entities\"\n    fields = (\"example\", \"label\")\n\n\nclass Relations(Labels):\n    label_class = ExportedRelation\n    column = \"relations\"\n    fields = (\"example\", \"type\")\n\n\nclass Texts(Labels):\n    label_class = ExportedText\n    column = \"labels\"\n    fields = (\"example\",)\n\n\nclass BoundingBoxes(Labels):\n    label_class = ExportedBoundingBox\n    column = \"labels\"\n    fields = (\"example\", \"label\")\n\n\nclass Segments(Labels):\n    label_class = ExportedSegmentation\n    column = \"labels\"\n    fields = (\"example\", \"label\")\n",
                                    "summary": "Class Labels: An abstract base class for organizing and retrieving labeled data, with subclasses defining specific annotation types such as Categories, Spans, Relations, Texts, BoundingBoxes, and Segments, while optimizing performance through selective field loading and user filtering.",
                                    "code_element_summaries": [
                                        "Class Labels: An abstract base class that organizes and retrieves labeled data for examples, optimizing performance through selective field loading and user filtering.",
                                        "Function `__init__`: Initializes an instance by organizing labels into groups based on examples, with optional filtering by user.",
                                        "Function `find_by`: Retrieves a dictionary mapping a specified column to a list of `ExportedLabel` objects associated with a given example ID.",
                                        "Class Categories: A model that extends Labels to define category annotations with specific fields and a designated label class.",
                                        "Class Spans: A subclass of Labels that defines a label class and specifies the column and fields for span annotations.",
                                        "Class Relations: A model that extends Labels to define a relation with specified fields and a designated label class.",
                                        "Class Texts: A subclass of Labels that specifies the label class as ExportedText and defines the associated column and fields for text annotations.",
                                        "Class BoundingBoxes: A model that extends Labels to manage bounding box annotations with a specified label class and designated fields.",
                                        "Class Segments: A model that extends Labels to define segmentation annotations with a specified label class and associated fields."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "services.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\services.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ExportApplicationService`\nCode:\nclass ExportApplicationService:\n    def __init__(self, dataset: Dataset, formatters: List[Formatter], writer: Writer):\n        self.dataset = dataset\n        self.formatters = formatters\n        self.writer = writer\n\n    def export(self, file):\n        dataset = self.dataset.to_dataframe()\n        for formatter in self.formatters:\n            dataset = formatter.format(dataset)\n        self.writer.write(file, dataset)\n        return file",
                                        "Function `__init__`\nCode:\n    def __init__(self, dataset: Dataset, formatters: List[Formatter], writer: Writer):\n        self.dataset = dataset\n        self.formatters = formatters\n        self.writer = writer",
                                        "Function `export`\nCode:\n    def export(self, file):\n        dataset = self.dataset.to_dataframe()\n        for formatter in self.formatters:\n            dataset = formatter.format(dataset)\n        self.writer.write(file, dataset)\n        return file"
                                    ],
                                    "code": "from typing import List\n\nfrom .dataset import Dataset\nfrom .formatters import Formatter\nfrom .writers import Writer\n\n\nclass ExportApplicationService:\n    def __init__(self, dataset: Dataset, formatters: List[Formatter], writer: Writer):\n        self.dataset = dataset\n        self.formatters = formatters\n        self.writer = writer\n\n    def export(self, file):\n        dataset = self.dataset.to_dataframe()\n        for formatter in self.formatters:\n            dataset = formatter.format(dataset)\n        self.writer.write(file, dataset)\n        return file\n",
                                    "summary": "Class `ExportApplicationService`: A service that handles the export of a dataset to a specified file format by utilizing formatters and a writer, with methods for initialization and exporting the formatted dataset.",
                                    "code_element_summaries": [
                                        "Class `ExportApplicationService`: A service that exports a dataset to a specified file format using a series of formatters and a writer.",
                                        "Function `__init__`: Initializes an instance with a dataset, a list of formatters, and a writer.",
                                        "Function `export`: A method that converts a dataset to a dataframe, applies formatters, writes the formatted dataset to a specified file, and returns the file."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "writers.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\writers.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Writer`\nCode:\nclass Writer(abc.ABC):\n    extension = \"\"\n\n    @staticmethod\n    @abc.abstractmethod\n    def write(file, dataset: pd.DataFrame):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `write`\nCode:\n    def write(file, dataset: pd.DataFrame):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Class `CsvWriter`\nCode:\nclass CsvWriter(Writer):\n    extension = \"csv\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\")",
                                        "Function `write`\nCode:\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\")",
                                        "Class `JsonWriter`\nCode:\nclass JsonWriter(Writer):\n    extension = \"json\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False)",
                                        "Function `write`\nCode:\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False)",
                                        "Class `JsonlWriter`\nCode:\nclass JsonlWriter(Writer):\n    extension = \"jsonl\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False, lines=True)",
                                        "Function `write`\nCode:\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False, lines=True)",
                                        "Class `FastTextWriter`\nCode:\nclass FastTextWriter(Writer):\n    extension = \"txt\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\", header=False)",
                                        "Function `write`\nCode:\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\", header=False)"
                                    ],
                                    "code": "import abc\n\nimport pandas as pd\n\n\nclass Writer(abc.ABC):\n    extension = \"\"\n\n    @staticmethod\n    @abc.abstractmethod\n    def write(file, dataset: pd.DataFrame):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n\nclass CsvWriter(Writer):\n    extension = \"csv\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\")\n\n\nclass JsonWriter(Writer):\n    extension = \"json\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False)\n\n\nclass JsonlWriter(Writer):\n    extension = \"jsonl\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_json(file, orient=\"records\", force_ascii=False, lines=True)\n\n\nclass FastTextWriter(Writer):\n    extension = \"txt\"\n\n    @staticmethod\n    def write(file, dataset: pd.DataFrame):\n        dataset.to_csv(file, index=False, encoding=\"utf-8\", header=False)\n",
                                    "summary": "Class Writer: An abstract base class for writing pandas DataFrames to various file formats, with subclasses CsvWriter, JsonWriter, JsonlWriter, and FastTextWriter implementing specific write functionalities for CSV, JSON, JSON Lines, and text file formats, respectively.",
                                    "code_element_summaries": [
                                        "Class Writer: An abstract base class for writers that requires subclasses to implement a method for writing a Pandas DataFrame to a specified file format.",
                                        "Function `write`: An abstract method that raises a NotImplementedError, indicating that it must be implemented in a subclass for writing a dataset to a specified file.",
                                        "Class CsvWriter: A subclass of Writer that provides functionality to write a pandas DataFrame to a CSV file with UTF-8 encoding.",
                                        "Function `write`: A utility function that saves a pandas DataFrame to a CSV file without including the index, using UTF-8 encoding.",
                                        "Class JsonWriter: A subclass of Writer that facilitates writing a pandas DataFrame to a JSON file with a specified file extension.",
                                        "Function `write`: A function that saves a given pandas DataFrame to a JSON file in a records format while preserving non-ASCII characters.",
                                        "Class `JsonlWriter`: A subclass of Writer that provides functionality to write a Pandas DataFrame to a JSON Lines format file.",
                                        "Function `write`: A utility function that writes a pandas DataFrame to a JSON file in a record-oriented format with support for non-ASCII characters.",
                                        "Class FastTextWriter: A subclass of Writer that outputs a DataFrame to a text file in CSV format without headers or indices.",
                                        "Function `write`: A function that exports a pandas DataFrame to a CSV file without including the index or header."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\pipeline\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content outlines multiple unit test classes designed to validate the functionality and correctness of various classes and data writers in a collaborative dataset export context, covering options, datasets, formatters, labels, and download permissions across different annotation types.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_catalog.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_catalog.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestOptions`\nCode:\nclass TestOptions(unittest.TestCase):\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)",
                                        "Function `test_return_at_least_one_option`\nCode:\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)"
                                    ],
                                    "code": "import unittest\n\nfrom ..pipeline.catalog import Options\nfrom projects.models import ProjectType\n\n\nclass TestOptions(unittest.TestCase):\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)\n",
                                    "summary": "Class TestOptions: A unit test case that ensures the Options class provides at least one option for each ProjectType task.",
                                    "code_element_summaries": [
                                        "Class TestOptions: A unit test case that verifies that the Options class returns at least one option for each ProjectType task.",
                                        "Function `test_return_at_least_one_option`: A test case that verifies that there is at least one option available for each task in the ProjectType enumeration."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_dataset.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_dataset.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestDataset`\nCode:\nclass TestDataset(unittest.TestCase):\n    def setUp(self):\n        example = MagicMock()\n        example.to_dict.return_value = {\"data\": \"example\"}\n        self.examples = MagicMock()\n        self.examples.__iter__.return_value = [example]\n        label = MagicMock()\n        label.find_by.return_value = {\"labels\": [\"label\"]}\n        self.labels = MagicMock()\n        self.labels.__iter__.return_value = [label]\n        comment = MagicMock()\n        comment.find_by.return_value = {\"comments\": [\"comment\"]}\n        self.comments = MagicMock()\n        self.comments.__iter__.return_value = [comment]\n\n    def test_to_dataframe(self):\n        dataset = Dataset(self.examples, self.labels, self.comments)\n        df = dataset.to_dataframe()\n        expected = pd.DataFrame([{\"data\": \"example\", \"labels\": [\"label\"], \"comments\": [\"comment\"]}])\n        assert_frame_equal(df, expected)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        example = MagicMock()\n        example.to_dict.return_value = {\"data\": \"example\"}\n        self.examples = MagicMock()\n        self.examples.__iter__.return_value = [example]\n        label = MagicMock()\n        label.find_by.return_value = {\"labels\": [\"label\"]}\n        self.labels = MagicMock()\n        self.labels.__iter__.return_value = [label]\n        comment = MagicMock()\n        comment.find_by.return_value = {\"comments\": [\"comment\"]}\n        self.comments = MagicMock()\n        self.comments.__iter__.return_value = [comment]",
                                        "Function `test_to_dataframe`\nCode:\n    def test_to_dataframe(self):\n        dataset = Dataset(self.examples, self.labels, self.comments)\n        df = dataset.to_dataframe()\n        expected = pd.DataFrame([{\"data\": \"example\", \"labels\": [\"label\"], \"comments\": [\"comment\"]}])\n        assert_frame_equal(df, expected)"
                                    ],
                                    "code": "import unittest\nfrom unittest.mock import MagicMock\n\nimport pandas as pd\nfrom pandas.testing import assert_frame_equal\n\nfrom data_export.pipeline.dataset import Dataset\n\n\nclass TestDataset(unittest.TestCase):\n    def setUp(self):\n        example = MagicMock()\n        example.to_dict.return_value = {\"data\": \"example\"}\n        self.examples = MagicMock()\n        self.examples.__iter__.return_value = [example]\n        label = MagicMock()\n        label.find_by.return_value = {\"labels\": [\"label\"]}\n        self.labels = MagicMock()\n        self.labels.__iter__.return_value = [label]\n        comment = MagicMock()\n        comment.find_by.return_value = {\"comments\": [\"comment\"]}\n        self.comments = MagicMock()\n        self.comments.__iter__.return_value = [comment]\n\n    def test_to_dataframe(self):\n        dataset = Dataset(self.examples, self.labels, self.comments)\n        df = dataset.to_dataframe()\n        expected = pd.DataFrame([{\"data\": \"example\", \"labels\": [\"label\"], \"comments\": [\"comment\"]}])\n        assert_frame_equal(df, expected)\n",
                                    "summary": "Class `TestDataset`: A unit test case that validates the `Dataset` class's conversion to a DataFrame by using mocked examples, labels, and comments, with a setup method to initialize these mocks and a test function to ensure accurate conversion.",
                                    "code_element_summaries": [
                                        "Class `TestDataset`: A unit test case that verifies the functionality of the `Dataset` class by checking its conversion to a DataFrame using mocked examples, labels, and comments.",
                                        "Function `setUp`: A setup method that initializes mock objects for examples, labels, and comments, each configured to return specific data when called.",
                                        "Function `test_to_dataframe`: A test function that verifies the correct conversion of a Dataset object into a pandas DataFrame format."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_formatters.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_formatters.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestDictFormatter`\nCode:\nclass TestDictFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = {\"label\": \"Label\"}\n        label = MagicMock()\n        label.to_dict.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = DictFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.return_value = {\"label\": \"Label\"}\n        label = MagicMock()\n        label.to_dict.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        formatter = DictFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Class `TestJoinedCategoryFormatter`\nCode:\nclass TestJoinedCategoryFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = JoinedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: self.return_value}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        formatter = JoinedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: self.return_value}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Class `TestListedCategoryFormatter`\nCode:\nclass TestListedCategoryFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = ListedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        formatter = ListedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Class `TestTupledSpanFormatter`\nCode:\nclass TestTupledSpanFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = (0, 1, \"Label\")\n        label = MagicMock()\n        label.to_tuple.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = TupledSpanFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.return_value = (0, 1, \"Label\")\n        label = MagicMock()\n        label.to_tuple.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        formatter = TupledSpanFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Class `TestFastTextFormatter`\nCode:\nclass TestFastTextFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value_label = \"Label\"\n        self.return_value_comment = \"Comment\"\n        label = MagicMock()\n        comment = MagicMock()\n        label.to_string.return_value = self.return_value_label\n        comment.to_string.return_value = self.return_value_comment\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label], DATA: \"example\", \"Comments\": [comment]}])\n\n    def test_format(self):\n        formatter = FastTextCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame(\n            [f\"__label__{self.return_value_label} example __comment__{self.return_value_comment}\"]\n        )\n        self.assertEqual(dataset.to_csv(index=False, header=None), expected_dataset.to_csv(index=False, header=None))",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.return_value_label = \"Label\"\n        self.return_value_comment = \"Comment\"\n        label = MagicMock()\n        comment = MagicMock()\n        label.to_string.return_value = self.return_value_label\n        comment.to_string.return_value = self.return_value_comment\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label], DATA: \"example\", \"Comments\": [comment]}])",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        formatter = FastTextCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame(\n            [f\"__label__{self.return_value_label} example __comment__{self.return_value_comment}\"]\n        )\n        self.assertEqual(dataset.to_csv(index=False, header=None), expected_dataset.to_csv(index=False, header=None))",
                                        "Class `TestRenameFormatter`\nCode:\nclass TestRenameFormatter(unittest.TestCase):\n    def test_format(self):\n        dataset = pd.DataFrame([{\"data\": \"example\"}])\n        formatter = RenameFormatter(**{\"data\": \"text\"})\n        dataset = formatter.format(dataset)\n        expected_dataset = pd.DataFrame([{\"text\": \"example\"}])\n        assert_frame_equal(dataset, expected_dataset)",
                                        "Function `test_format`\nCode:\n    def test_format(self):\n        dataset = pd.DataFrame([{\"data\": \"example\"}])\n        formatter = RenameFormatter(**{\"data\": \"text\"})\n        dataset = formatter.format(dataset)\n        expected_dataset = pd.DataFrame([{\"text\": \"example\"}])\n        assert_frame_equal(dataset, expected_dataset)"
                                    ],
                                    "code": "import unittest\nfrom unittest.mock import MagicMock\n\nimport pandas as pd\nfrom pandas.testing import assert_frame_equal\n\nfrom data_export.models import DATA\nfrom data_export.pipeline.formatters import (\n    DictFormatter,\n    FastTextCategoryFormatter,\n    JoinedCategoryFormatter,\n    ListedCategoryFormatter,\n    RenameFormatter,\n    TupledSpanFormatter,\n)\n\nTARGET_COLUMN = \"labels\"\n\n\nclass TestDictFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = {\"label\": \"Label\"}\n        label = MagicMock()\n        label.to_dict.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = DictFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)\n\n\nclass TestJoinedCategoryFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = JoinedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: self.return_value}])\n        assert_frame_equal(dataset, expected_dataset)\n\n\nclass TestListedCategoryFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = \"Label\"\n        label = MagicMock()\n        label.to_string.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = ListedCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)\n\n\nclass TestTupledSpanFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value = (0, 1, \"Label\")\n        label = MagicMock()\n        label.to_tuple.return_value = self.return_value\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label]}])\n\n    def test_format(self):\n        formatter = TupledSpanFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame([{TARGET_COLUMN: [self.return_value]}])\n        assert_frame_equal(dataset, expected_dataset)\n\n\nclass TestFastTextFormatter(unittest.TestCase):\n    def setUp(self):\n        self.return_value_label = \"Label\"\n        self.return_value_comment = \"Comment\"\n        label = MagicMock()\n        comment = MagicMock()\n        label.to_string.return_value = self.return_value_label\n        comment.to_string.return_value = self.return_value_comment\n        self.dataset = pd.DataFrame([{TARGET_COLUMN: [label], DATA: \"example\", \"Comments\": [comment]}])\n\n    def test_format(self):\n        formatter = FastTextCategoryFormatter(TARGET_COLUMN)\n        dataset = formatter.format(self.dataset)\n        expected_dataset = pd.DataFrame(\n            [f\"__label__{self.return_value_label} example __comment__{self.return_value_comment}\"]\n        )\n        self.assertEqual(dataset.to_csv(index=False, header=None), expected_dataset.to_csv(index=False, header=None))\n\n\nclass TestRenameFormatter(unittest.TestCase):\n    def test_format(self):\n        dataset = pd.DataFrame([{\"data\": \"example\"}])\n        formatter = RenameFormatter(**{\"data\": \"text\"})\n        dataset = formatter.format(dataset)\n        expected_dataset = pd.DataFrame([{\"text\": \"example\"}])\n        assert_frame_equal(dataset, expected_dataset)\n",
                                    "summary": "Multiple unit test classes that verify the functionality of various formatters (DictFormatter, JoinedCategoryFormatter, ListedCategoryFormatter, TupledSpanFormatter, FastTextCategoryFormatter, and RenameFormatter) by comparing their output against expected DataFrames or formats.",
                                    "code_element_summaries": [
                                        "Class TestDictFormatter: A unit test for the DictFormatter that verifies the formatting of a dataset containing labeled data into the expected dictionary format.",
                                        "Function `setUp`: A setup method that initializes a mock label and a DataFrame containing the label in a specified target column for testing purposes.",
                                        "Function `test_format`: A test function that verifies the output of the DictFormatter's format method against an expected DataFrame.",
                                        "Class TestJoinedCategoryFormatter: A unittest case that verifies the formatting of a dataset using the JoinedCategoryFormatter by comparing the output DataFrame with the expected result.",
                                        "Function `setUp`: A test setup method that initializes a mock label object with a predefined return value for its `to_string` method and creates a DataFrame containing this label.",
                                        "Function `test_format`: A test function that verifies the formatting of a dataset using the JoinedCategoryFormatter by comparing the formatted output to an expected DataFrame.",
                                        "Class TestListedCategoryFormatter: A unit test for the ListedCategoryFormatter that verifies the formatting of a dataset containing labeled categories.",
                                        "Function `setUp`: Initializes a test environment by creating a mock label object with a predefined return value and setting up a DataFrame containing that label.",
                                        "Function `test_format`: A unit test that verifies the formatting of a dataset using the ListedCategoryFormatter by comparing the formatted output to an expected DataFrame.",
                                        "Class TestTupledSpanFormatter: A unit test that verifies the functionality of the TupledSpanFormatter by checking if it correctly formats a DataFrame containing tuple representations of labeled spans.",
                                        "Function `setUp`: Prepares a test environment by creating a mock label with a predefined tuple return value and initializing a pandas DataFrame containing the mock label.",
                                        "Function `test_format`: A test function that verifies the formatting of a dataset using the TupledSpanFormatter by comparing the output with an expected DataFrame.",
                                        "Class TestFastTextFormatter: A unit test for the FastTextCategoryFormatter that verifies the formatting of a dataset into the expected FastText-compatible string format.",
                                        "Function `setUp`: Prepares a test environment by initializing mock objects for label and comment, and creates a DataFrame with specified structure for testing purposes.",
                                        "Function `test_format`: A unit test that verifies the formatting of a dataset using the FastTextCategoryFormatter by comparing the output with an expected DataFrame in CSV format.",
                                        "Class TestRenameFormatter: A unit test that verifies the functionality of the RenameFormatter by checking if it correctly renames DataFrame columns.",
                                        "Function `test_format`: A test that verifies the `RenameFormatter` correctly renames a column in a pandas DataFrame from \"data\" to \"text\"."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_labels.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_labels.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestLabels`\nCode:\nclass TestLabels(TestCase):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.examples = ExportedExample.objects.all()\n\n    def test_find_by(self):\n        categories = Categories(self.examples)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 1)\n        result = categories.find_by(self.example2.id)\n        self.assertEqual(len(result[Categories.column]), 0)\n\n    def test_find_by_with_user(self):\n        categories = Categories(self.examples, user=self.project.annotator)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 0)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.examples = ExportedExample.objects.all()",
                                        "Function `test_find_by`\nCode:\n    def test_find_by(self):\n        categories = Categories(self.examples)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 1)\n        result = categories.find_by(self.example2.id)\n        self.assertEqual(len(result[Categories.column]), 0)",
                                        "Function `test_find_by_with_user`\nCode:\n    def test_find_by_with_user(self):\n        categories = Categories(self.examples, user=self.project.annotator)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 0)"
                                    ],
                                    "code": "from django.test import TestCase\nfrom model_mommy import mommy\n\nfrom ..pipeline.labels import Categories\nfrom data_export.models import ExportedExample\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestLabels(TestCase):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.examples = ExportedExample.objects.all()\n\n    def test_find_by(self):\n        categories = Categories(self.examples)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 1)\n        result = categories.find_by(self.example2.id)\n        self.assertEqual(len(result[Categories.column]), 0)\n\n    def test_find_by_with_user(self):\n        categories = Categories(self.examples, user=self.project.annotator)\n        result = categories.find_by(self.example1.id)\n        self.assertEqual(len(result[Categories.column]), 0)\n",
                                    "summary": "Class TestLabels: A test case designed to validate the functionality of the Categories class, specifically its ability to find associated categories based on user permissions and example IDs, through various test functions.",
                                    "code_element_summaries": [
                                        "Class TestLabels: A test case for verifying the functionality of the Categories class in finding associated categories for examples based on user permissions and example IDs.",
                                        "Function `setUp`: Initializes a test environment by preparing a document classification project and creating associated examples and categories for testing purposes.",
                                        "Function `test_find_by`: A test function that verifies the behavior of the `find_by` method in the Categories class, ensuring it correctly returns the expected number of results based on example IDs.",
                                        "Function `test_find_by_with_user`: A test function that verifies the `find_by` method of the `Categories` class returns an empty result for a specific example ID when called with a user."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_models.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_models.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExportedExample`\nCode:\nclass TestExportedExample(TestCase):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n\n    def test_collaborative(self):\n        self.prepare_data(collaborative=True)\n        examples = ExportedExample.objects.confirmed(self.project.item)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)\n\n    def test_filter_by_confirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.admin)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)\n\n    def test_filter_by_unconfirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.annotator)\n        self.assertEqual(examples.count(), 0)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)",
                                        "Function `test_collaborative`\nCode:\n    def test_collaborative(self):\n        self.prepare_data(collaborative=True)\n        examples = ExportedExample.objects.confirmed(self.project.item)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)",
                                        "Function `test_filter_by_confirmed_user`\nCode:\n    def test_filter_by_confirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.admin)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)",
                                        "Function `test_filter_by_unconfirmed_user`\nCode:\n    def test_filter_by_unconfirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.annotator)\n        self.assertEqual(examples.count(), 0)"
                                    ],
                                    "code": "from django.test import TestCase\nfrom model_mommy import mommy\n\nfrom data_export.models import ExportedExample\nfrom projects.tests.utils import prepare_project\n\n\nclass TestExportedExample(TestCase):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n\n    def test_collaborative(self):\n        self.prepare_data(collaborative=True)\n        examples = ExportedExample.objects.confirmed(self.project.item)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)\n\n    def test_filter_by_confirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.admin)\n        self.assertEqual(examples.count(), 1)\n        self.assertEqual(examples.first(), self.example1)\n\n    def test_filter_by_unconfirmed_user(self):\n        self.prepare_data(collaborative=False)\n        examples = ExportedExample.objects.confirmed(self.project.item, user=self.project.annotator)\n        self.assertEqual(examples.count(), 0)\n",
                                    "summary": "Class TestExportedExample: A test suite designed to validate the functionality of confirmed `ExportedExample` instances in collaborative settings, including data preparation and user-specific filtering of confirmed examples.",
                                    "code_element_summaries": [
                                        "Class TestExportedExample: A test case for verifying the behavior of confirmed `ExportedExample` instances based on collaborative settings and user filters.",
                                        "Function `prepare_data`: Prepares project data by creating instances of `ExportedExample` and `ExampleState` based on the collaborative annotation setting.",
                                        "Function `test_collaborative`: A test function that verifies the correct preparation and confirmation of collaborative examples in a project, ensuring that only one confirmed example exists and it matches a predefined example.",
                                        "Function `test_filter_by_confirmed_user`: A test that verifies the filtering of confirmed examples by a specific user in a collaborative project, ensuring that only the expected example is returned.",
                                        "Function `test_filter_by_unconfirmed_user`: A test case that verifies that no confirmed examples are returned for an unconfirmed user in the specified project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_task.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_task.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `read_zip_content`\nCode:\ndef read_zip_content(file):\n    datasets = {}\n    with zipfile.ZipFile(file) as z:\n        for file in z.filelist:\n            username = file.filename.split(\".\")[0]\n            with z.open(file) as f:\n                try:\n                    df = pd.read_json(f, lines=True)\n                except pd.errors.EmptyDataError:\n                    continue\n            datasets[username] = df.to_dict(orient=\"records\")\n    return datasets",
                                        "Class `TestExport`\nCode:\nclass TestExport(TestCase):\n    def export_dataset(self, confirmed_only=False):\n        file = export_dataset(self.project.id, \"JSONL\", confirmed_only)\n        if self.project.item.collaborative_annotation:\n            dataset = pd.read_json(file, lines=True).to_dict(orient=\"records\")\n        else:\n            dataset = read_zip_content(file)\n        os.remove(file)\n        return dataset\n\n    def data_to_text(self, example):\n        d = example.to_dict()\n        d[\"text\"] = d.pop(DATA)\n        return d\n\n    def data_to_filename(self, example):\n        d = example.to_dict(is_text_project=False)\n        d[\"filename\"] = d.pop(DATA)\n        return d",
                                        "Function `export_dataset`\nCode:\n    def export_dataset(self, confirmed_only=False):\n        file = export_dataset(self.project.id, \"JSONL\", confirmed_only)\n        if self.project.item.collaborative_annotation:\n            dataset = pd.read_json(file, lines=True).to_dict(orient=\"records\")\n        else:\n            dataset = read_zip_content(file)\n        os.remove(file)\n        return dataset",
                                        "Function `data_to_text`\nCode:\n    def data_to_text(self, example):\n        d = example.to_dict()\n        d[\"text\"] = d.pop(DATA)\n        return d",
                                        "Function `data_to_filename`\nCode:\n    def data_to_filename(self, example):\n        d = example.to_dict(is_text_project=False)\n        d[\"filename\"] = d.pop(DATA)\n        return d",
                                        "Class `TestExportCategory`\nCode:\nclass TestExportCategory(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example1\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example2\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example1\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example2\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportSeq2seq`\nCode:\nclass TestExportSeq2seq(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportIntentDetectionAndSlotFilling`\nCode:\nclass TestExportIntentDetectionAndSlotFilling(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.INTENT_DETECTION_AND_SLOT_FILLING, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.span = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [],\n                    \"cats\": [self.category2.to_string()],\n                    \"Comments\": [self.comment2.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"cats\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.INTENT_DETECTION_AND_SLOT_FILLING, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.span = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [],\n                    \"cats\": [self.category2.to_string()],\n                    \"Comments\": [self.comment2.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"cats\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportSequenceLabeling`\nCode:\nclass TestExportSequenceLabeling(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=1, end_offset=2\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [list(self.span2.to_tuple())], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=1, end_offset=2\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [list(self.span2.to_tuple())], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportSpeechToText`\nCode:\nclass TestExportSpeechToText(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SPEECH2TEXT, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SPEECH2TEXT, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportImageClassification`\nCode:\nclass TestExportImageClassification(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportBoundingBox`\nCode:\nclass TestExportBoundingBox(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.BOUNDING_BOX, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.bbox1 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.admin, x=0, y=0, width=10, height=10\n        )\n        self.bbox2 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.annotator, x=10, y=10, width=20, height=20\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"bbox\": [self.bbox1.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"bbox\": [], \"Comments\": []},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"bbox\": [self.bbox2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"bbox\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"bbox\": [self.bbox1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.BOUNDING_BOX, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.bbox1 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.admin, x=0, y=0, width=10, height=10\n        )\n        self.bbox2 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.annotator, x=10, y=10, width=20, height=20\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"bbox\": [self.bbox1.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"bbox\": [], \"Comments\": []},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"bbox\": [self.bbox2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"bbox\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"bbox\": [self.bbox1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportSegmentation`\nCode:\nclass TestExportSegmentation(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEGMENTATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.seg1 = mommy.make(\"ExportedSegmentation\", example=self.example1, user=self.project.admin, points=[0, 1])\n        self.seg2 = mommy.make(\n            \"ExportedSegmentation\", example=self.example1, user=self.project.annotator, points=[1, 2]\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"segmentation\"\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.seg2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEGMENTATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.seg1 = mommy.make(\"ExportedSegmentation\", example=self.example1, user=self.project.admin, points=[0, 1])\n        self.seg2 = mommy.make(\n            \"ExportedSegmentation\", example=self.example1, user=self.project.annotator, points=[1, 2]\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"segmentation\"",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.seg2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportImageCaptioning`\nCode:\nclass TestExportImageCaptioning(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CAPTIONING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"label\"\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CAPTIONING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"label\"",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Class `TestExportRelation`\nCode:\nclass TestExportRelation(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, use_relation=True, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=1, end_offset=2\n        )\n        self.span3 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=2, end_offset=3\n        )\n        self.relation = mommy.make(\n            \"ExportedRelation\", from_id=self.span1, to_id=self.span2, example=self.example1, user=self.project.admin\n        )\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span3.to_dict()],\n                    \"relations\": [],\n                    \"Comments\": [self.comment2.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"relations\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `prepare_data`\nCode:\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, use_relation=True, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=1, end_offset=2\n        )\n        self.span3 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=2, end_offset=3\n        )\n        self.relation = mommy.make(\n            \"ExportedRelation\", from_id=self.span1, to_id=self.span2, example=self.example1, user=self.project.admin\n        )\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)",
                                        "Function `test_unconfirmed_and_non_collaborative`\nCode:\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span3.to_dict()],\n                    \"relations\": [],\n                    \"Comments\": [self.comment2.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"relations\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)",
                                        "Function `test_unconfirmed_and_collaborative`\nCode:\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)",
                                        "Function `test_confirmed_and_non_collaborative`\nCode:\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])",
                                        "Function `test_confirmed_and_collaborative`\nCode:\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)"
                                    ],
                                    "code": "import os\nimport zipfile\n\nimport pandas as pd\nfrom django.test import TestCase, override_settings\nfrom model_mommy import mommy\n\nfrom ..celery_tasks import export_dataset\nfrom data_export.models import DATA\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\ndef read_zip_content(file):\n    datasets = {}\n    with zipfile.ZipFile(file) as z:\n        for file in z.filelist:\n            username = file.filename.split(\".\")[0]\n            with z.open(file) as f:\n                try:\n                    df = pd.read_json(f, lines=True)\n                except pd.errors.EmptyDataError:\n                    continue\n            datasets[username] = df.to_dict(orient=\"records\")\n    return datasets\n\n\n@override_settings(MEDIA_URL=os.path.dirname(__file__))\nclass TestExport(TestCase):\n    def export_dataset(self, confirmed_only=False):\n        file = export_dataset(self.project.id, \"JSONL\", confirmed_only)\n        if self.project.item.collaborative_annotation:\n            dataset = pd.read_json(file, lines=True).to_dict(orient=\"records\")\n        else:\n            dataset = read_zip_content(file)\n        os.remove(file)\n        return dataset\n\n    def data_to_text(self, example):\n        d = example.to_dict()\n        d[\"text\"] = d.pop(DATA)\n        return d\n\n    def data_to_filename(self, example):\n        d = example.to_dict(is_text_project=False)\n        d[\"filename\"] = d.pop(DATA)\n        return d\n\n\nclass TestExportCategory(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example1\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example2\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportSeq2seq(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportIntentDetectionAndSlotFilling(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.INTENT_DETECTION_AND_SLOT_FILLING, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.span = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [],\n                    \"cats\": [self.category2.to_string()],\n                    \"Comments\": [self.comment2.to_string()],\n                },\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"cats\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"entities\": [], \"cats\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [list(self.span.to_tuple())],\n                    \"cats\": [self.category1.to_string()],\n                    \"Comments\": [self.comment1.to_string()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [list(self.span.to_tuple())],\n                \"cats\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportSequenceLabeling(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=1, end_offset=2\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [list(self.span2.to_tuple())], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [list(self.span1.to_tuple())], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(dataset, datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": [list(self.span1.to_tuple()), list(self.span2.to_tuple())],\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportSpeechToText(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SPEECH2TEXT, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportImageClassification(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CLASSIFICATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.category1 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.admin)\n        self.category2 = mommy.make(\"ExportedCategory\", example=self.example1, user=self.project.annotator)\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"label\": [], \"Comments\": []},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"label\": [self.category2.to_string()], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, \"label\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, \"label\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"label\": [self.category1.to_string()], \"Comments\": [self.comment1.to_string()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"label\": sorted([self.category1.to_string(), self.category2.to_string()]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportBoundingBox(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.BOUNDING_BOX, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.bbox1 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.admin, x=0, y=0, width=10, height=10\n        )\n        self.bbox2 = mommy.make(\n            \"ExportedBoundingBox\", example=self.example1, user=self.project.annotator, x=10, y=10, width=20, height=20\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"bbox\": [self.bbox1.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"bbox\": [], \"Comments\": []},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, \"bbox\": [self.bbox2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, \"bbox\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"bbox\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, \"bbox\": [self.bbox1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"bbox\": [self.bbox1.to_dict(), self.bbox2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportSegmentation(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.SEGMENTATION, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.seg1 = mommy.make(\"ExportedSegmentation\", example=self.example1, user=self.project.admin, points=[0, 1])\n        self.seg2 = mommy.make(\n            \"ExportedSegmentation\", example=self.example1, user=self.project.annotator, points=[1, 2]\n        )\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"segmentation\"\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.seg2.to_dict()], \"Comments\": [self.comment2.to_dict()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.seg1.to_dict()], \"Comments\": [self.comment1.to_dict()]}\n            ]\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: [self.seg1.to_dict(), self.seg2.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportImageCaptioning(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(ProjectType.IMAGE_CAPTIONING, collaborative_annotation=collaborative)\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"confirmed\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        self.text1 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.admin)\n        self.text2 = mommy.make(\"TextLabel\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_filename(self.example1)\n        self.data2 = self.data_to_filename(self.example2)\n        self.column = \"label\"\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, self.column: [], \"Comments\": []},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {**self.data1, self.column: [self.text2.text], \"Comments\": [self.comment2.to_string()]},\n                {**self.data2, self.column: [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            },\n            {**self.data2, self.column: [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {**self.data1, self.column: [self.text1.text], \"Comments\": [self.comment1.to_string()]},\n            ],\n            self.project.approver.username: [],\n            self.project.annotator.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                self.column: sorted([self.text1.text, self.text2.text]),\n                \"Comments\": sorted([self.comment1.to_string(), self.comment2.to_string()]),\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n\nclass TestExportRelation(TestExport):\n    def prepare_data(self, collaborative=False):\n        self.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, use_relation=True, collaborative_annotation=collaborative\n        )\n        self.example1 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"example\")\n        self.example2 = mommy.make(\"ExportedExample\", project=self.project.item, text=\"unconfirmed\")\n        self.span1 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=0, end_offset=1\n        )\n        self.span2 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.admin, start_offset=1, end_offset=2\n        )\n        self.span3 = mommy.make(\n            \"ExportedSpan\", example=self.example1, user=self.project.annotator, start_offset=2, end_offset=3\n        )\n        self.relation = mommy.make(\n            \"ExportedRelation\", from_id=self.span1, to_id=self.span2, example=self.example1, user=self.project.admin\n        )\n        self.comment1 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.admin)\n        self.comment2 = mommy.make(\"ExportedComment\", example=self.example1, user=self.project.annotator)\n        mommy.make(\"ExampleState\", example=self.example1, confirmed_by=self.project.admin)\n        self.data1 = self.data_to_text(self.example1)\n        self.data2 = self.data_to_text(self.example2)\n\n    def test_unconfirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset()\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.annotator.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span3.to_dict()],\n                    \"relations\": [],\n                    \"Comments\": [self.comment2.to_dict()],\n                },\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n            self.project.approver.username: [\n                {**self.data1, \"entities\": [], \"relations\": [], \"Comments\": []},\n                {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n            ],\n        }\n        for username, dataset in expected_datasets.items():\n            self.assertEqual(datasets[username], dataset)\n\n    def test_unconfirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset()\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            },\n            {**self.data2, \"entities\": [], \"relations\": [], \"Comments\": []},\n        ]\n        self.assertEqual(dataset, expected_dataset)\n\n    def test_confirmed_and_non_collaborative(self):\n        self.prepare_data()\n        datasets = self.export_dataset(confirmed_only=True)\n        expected_datasets = {\n            self.project.admin.username: [\n                {\n                    **self.data1,\n                    \"entities\": [self.span1.to_dict(), self.span2.to_dict()],\n                    \"relations\": [self.relation.to_dict()],\n                    \"Comments\": [self.comment1.to_dict()],\n                },\n            ],\n            self.project.annotator.username: [],\n            self.project.approver.username: [],\n        }\n        for username, dataset in datasets.items():\n            self.assertEqual(dataset, expected_datasets[username])\n\n    def test_confirmed_and_collaborative(self):\n        self.prepare_data(collaborative=True)\n        dataset = self.export_dataset(confirmed_only=True)\n        expected_dataset = [\n            {\n                **self.data1,\n                \"entities\": [self.span1.to_dict(), self.span2.to_dict(), self.span3.to_dict()],\n                \"relations\": [self.relation.to_dict()],\n                \"Comments\": [self.comment1.to_dict(), self.comment2.to_dict()],\n            }\n        ]\n        self.assertEqual(dataset, expected_dataset)\n",
                                    "summary": "The content outlines various test suites and functions designed for exporting datasets across multiple annotation types, including JSONL, image classification, segmentation, and bounding box data, while ensuring the correctness of outputs in collaborative and non-collaborative contexts, as well as for confirmed and unconfirmed entries.",
                                    "code_element_summaries": [
                                        "Function `read_zip_content`: Reads a ZIP file containing JSON datasets, extracts them by username, and returns a dictionary of dataframes in record format.",
                                        "Class `TestExport`: A test case that handles dataset exports in JSONL format, converting data examples to text and filenames while managing collaborative annotation scenarios.",
                                        "Function `export_dataset`: Exports the dataset in JSONL format, optionally filtering for confirmed items, and returns it as a dictionary of records or reads from a zip file based on the project's collaborative annotation setting.",
                                        "Function `data_to_text`: Converts an example object to a dictionary and replaces the key `DATA` with `text`.",
                                        "Function `data_to_filename`: Converts an example object to a dictionary format and modifies it by replacing the key associated with `DATA` with `filename`.",
                                        "Class `TestExportCategory`: A test suite for exporting category and comment data from a document classification project, validating outputs for various conditions of collaboration and confirmation.",
                                        "Function `prepare_data`: Prepares and populates a document classification project with examples, categories, comments, and states, while optionally supporting collaborative annotation.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test function that verifies the correctness of exported datasets for different user roles by comparing them against expected datasets.",
                                        "Function `test_unconfirmed_and_collaborative`: A unit test that verifies the correct export of a dataset with labels and comments when collaborative data preparation is enabled.",
                                        "Function `test_confirmed_and_non_collaborative`: A test method that verifies the export of confirmed datasets for non-collaborative users against expected output.",
                                        "Function `test_confirmed_and_collaborative`: A test function that validates the dataset export for confirmed and collaborative entries by comparing the output with an expected dataset structure.",
                                        "Class TestExportSeq2seq: A test suite for exporting datasets in both collaborative and non-collaborative contexts, validating the inclusion of labels and comments based on the confirmation status of examples.",
                                        "Function `prepare_data`: Prepares project data by creating examples, text labels, comments, and states for a sequence-to-sequence project, with options for collaborative annotation.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test case that verifies the dataset export functionality for different user roles by comparing the generated datasets against expected values based on their annotations and comments.",
                                        "Function `test_unconfirmed_and_collaborative`: A test function that verifies the correct export of a dataset with collaborative labels and comments against an expected dataset structure.",
                                        "Function `test_confirmed_and_non_collaborative`: A test case that verifies the correct export of datasets for users with confirmed annotations while ensuring non-collaborative users receive empty datasets.",
                                        "Function `test_confirmed_and_collaborative`: A test function that verifies the exported dataset for confirmed and collaborative entries matches the expected structure and content.",
                                        "Class TestExportIntentDetectionAndSlotFilling: A test suite for exporting datasets related to intent detection and slot filling, verifying the handling of confirmed and unconfirmed examples in both collaborative and non-collaborative settings.",
                                        "Function `prepare_data`: Prepares a project for intent detection and slot filling by creating examples, categories, comments, spans, and states, and converting example data to text format.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A unit test that verifies the export of datasets for different user roles, ensuring the correct structure and content of the datasets based on the project data.",
                                        "Function `test_unconfirmed_and_collaborative`: A test case that prepares collaborative data and asserts that the exported dataset matches the expected structure and content.",
                                        "Function `test_confirmed_and_non_collaborative`: A test case that verifies the correct export of confirmed datasets for a project, ensuring that only the expected data is returned for each user role.",
                                        "Function `test_confirmed_and_collaborative`: A test case that verifies the correctness of a dataset export with confirmed and collaborative annotations against an expected dataset structure.",
                                        "Class TestExportSequenceLabeling: A test suite for exporting sequence labeling datasets, verifying the correct handling of confirmed and unconfirmed examples in both collaborative and non-collaborative contexts.",
                                        "Function `prepare_data`: Prepares a sequence labeling project by creating examples, spans, comments, and states, and converting the examples to text format.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A unit test that verifies the exported dataset structure for unconfirmed and non-collaborative users against expected values.",
                                        "Function `test_unconfirmed_and_collaborative`: A test function that verifies the correct export of a dataset with collaborative annotations and comments, comparing the generated dataset against an expected structure.",
                                        "Function `test_confirmed_and_non_collaborative`: A test case that verifies the dataset export functionality for confirmed annotations while ensuring that non-collaborative users receive empty datasets.",
                                        "Function `test_confirmed_and_collaborative`: A unit test that verifies the correctness of the exported dataset when only confirmed and collaborative data is included, comparing it against an expected dataset structure.",
                                        "Class TestExportSpeechToText: A test suite for exporting speech-to-text datasets, verifying the behavior of data preparation and export under various conditions of collaboration and confirmation status.",
                                        "Function `prepare_data`: Prepares a project for speech-to-text annotation by creating examples, text labels, comments, and states, while optionally supporting collaborative annotation.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test case that validates the exported datasets for different user roles in a project by comparing the actual output with the expected datasets.",
                                        "Function `test_unconfirmed_and_collaborative`: A test function that verifies the correctness of the exported dataset when collaborative data is prepared, ensuring the labels and comments are sorted as expected.",
                                        "Function `test_confirmed_and_non_collaborative`: A test case that verifies the exported datasets for confirmed annotations, ensuring that only the admin's data is included while the annotator and approver receive empty datasets.",
                                        "Function `test_confirmed_and_collaborative`: A test case that verifies the export of a dataset containing confirmed and collaborative entries, ensuring the output matches the expected format with sorted labels and comments.",
                                        "Class `TestExportImageClassification`: A test suite for exporting image classification datasets, verifying the behavior of confirmed and unconfirmed data in both collaborative and non-collaborative settings.",
                                        "Function `prepare_data`: Prepares a project for image classification by creating examples, categories, comments, and states, and generates filenames for the data.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test function that verifies the correct export of datasets for different user roles, ensuring the data matches expected values for labels and comments.",
                                        "Function `test_unconfirmed_and_collaborative`: A test function that verifies the correct export of a dataset with collaborative labels and comments against an expected output.",
                                        "Function `test_confirmed_and_non_collaborative`: A test function that verifies the correctness of exported datasets for confirmed entries only, comparing the actual output to expected values.",
                                        "Function `test_confirmed_and_collaborative`: A test case that verifies the correctness of a dataset export for confirmed and collaborative entries by comparing the output with an expected dataset structure.",
                                        "Class TestExportBoundingBox: A test suite for exporting bounding box data, validating the output for various scenarios including confirmed and unconfirmed states, as well as collaborative and non-collaborative settings.",
                                        "Function `prepare_data`: A method that sets up a project with bounding box annotations, creates associated examples and comments, and generates filenames for the data.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test case that verifies the correctness of exported datasets for different user roles by comparing them against expected datasets after preparing the data.",
                                        "Function `test_unconfirmed_and_collaborative`: A test case that verifies the correct export of a dataset containing collaborative bounding box annotations and comments.",
                                        "Function `test_confirmed_and_non_collaborative`: A unit test that verifies the exported dataset for confirmed entries matches the expected structure, including bounding box and comment data.",
                                        "Function `test_confirmed_and_collaborative`: A test case that verifies the correct export of a dataset containing confirmed and collaborative entries by comparing the output to an expected dataset structure.",
                                        "Class TestExportSegmentation: A test class that verifies the export functionality of segmentation data in various scenarios, including collaborative and non-collaborative settings, and confirmed versus unconfirmed states.",
                                        "Function `prepare_data`: Prepares project data for segmentation by creating examples, comments, segmentations, and associated states while managing collaborative annotations.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test case that verifies the correct export of datasets for different user roles based on their annotations and comments.",
                                        "Function `test_unconfirmed_and_collaborative`: A test function that verifies the correct export of a dataset with collaborative segments and associated comments against an expected output.",
                                        "Function `test_confirmed_and_non_collaborative`: A test function that verifies the correctness of exported datasets for confirmed entries while ensuring non-collaborative data is handled appropriately.",
                                        "Function `test_confirmed_and_collaborative`: A test that verifies the export of a dataset containing confirmed and collaborative entries matches the expected structure and content.",
                                        "Class TestExportImageCaptioning: A test suite for exporting image captioning datasets, verifying the handling of confirmed and unconfirmed examples in both collaborative and non-collaborative scenarios.",
                                        "Function `prepare_data`: Prepares project data for image captioning by creating examples, comments, text labels, and states, while also defining a column for labels.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test function that verifies the exported datasets for different user roles against expected datasets after preparing data, ensuring that the annotations and comments are correctly assigned based on user status.",
                                        "Function `test_unconfirmed_and_collaborative`: A test case that verifies the correct export of a dataset with collaborative comments and sorted text entries against an expected output.",
                                        "Function `test_confirmed_and_non_collaborative`: A unit test that verifies the export of datasets for confirmed users while ensuring that non-collaborative users receive empty datasets.",
                                        "Function `test_confirmed_and_collaborative`: A test function that verifies the dataset export functionality for confirmed and collaborative entries by comparing the generated dataset to an expected structure.",
                                        "Class `TestExportRelation`: A test suite for exporting relation data in different scenarios, verifying the correctness of datasets for both collaborative and non-collaborative annotation contexts.",
                                        "Function `prepare_data`: Prepares a project for sequence labeling by creating examples, spans, relations, comments, and states, while optionally supporting collaborative annotations.",
                                        "Function `test_unconfirmed_and_non_collaborative`: A test function that verifies the export of datasets for different user roles in a project, ensuring that the exported data matches the expected structure and content.",
                                        "Function `test_unconfirmed_and_collaborative`: A test case that verifies the exported dataset structure for collaborative data preparation, ensuring it matches the expected format with entities, relations, and comments.",
                                        "Function `test_confirmed_and_non_collaborative`: A test that verifies the export of datasets for confirmed annotations only, ensuring the output matches the expected structure for different user roles.",
                                        "Function `test_confirmed_and_collaborative`: A test case that verifies the exported dataset contains only confirmed entries while preparing data for collaborative review and comparing it against an expected structure."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestDownloadCatalog`\nCode:\nclass TestDownloadCatalog(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"download-format\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)\n\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"download-format\", args=[self.project.item.id])",
                                        "Function `test_allows_project_admin_to_list_catalog`\nCode:\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)",
                                        "Function `test_denies_project_staff_to_list_catalog`\nCode:\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestDownloadCatalog(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"download-format\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)\n\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Class TestDownloadCatalog: A test suite that checks permissions for project administrators and staff when accessing the download catalog, ensuring admins can list items while staff are denied access.",
                                    "code_element_summaries": [
                                        "Class TestDownloadCatalog: A test suite that verifies the permissions for project administrators and staff when accessing the download catalog for document classification projects.",
                                        "Function `setUp`: Prepares a project for document classification and constructs a URL for downloading the format associated with the project's item.",
                                        "Function `test_allows_project_admin_to_list_catalog`: A test that verifies a project admin can successfully list the catalog and that each item in the response contains a \"name\" field.",
                                        "Function `test_denies_project_staff_to_list_catalog`: A test that verifies project staff members are denied access to list the catalog, expecting a 403 Forbidden status for each member."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_writer.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\test_writer.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestWriter`\nCode:\nclass TestWriter(unittest.TestCase):\n    def setUp(self):\n        self.dataset = pd.DataFrame(\n            [\n                {\"id\": 0, \"text\": \"A\"},\n                {\"id\": 1, \"text\": \"B\"},\n                {\"id\": 2, \"text\": \"C\"},\n            ]\n        )\n        self.file = \"tmp.csv\"\n\n    def tearDown(self):\n        os.remove(self.file)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.dataset = pd.DataFrame(\n            [\n                {\"id\": 0, \"text\": \"A\"},\n                {\"id\": 1, \"text\": \"B\"},\n                {\"id\": 2, \"text\": \"C\"},\n            ]\n        )\n        self.file = \"tmp.csv\"",
                                        "Function `tearDown`\nCode:\n    def tearDown(self):\n        os.remove(self.file)",
                                        "Class `TestCSVWriter`\nCode:\nclass TestCSVWriter(TestWriter):\n    def test_write(self):\n        writer = CsvWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_csv(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Function `test_write`\nCode:\n    def test_write(self):\n        writer = CsvWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_csv(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Class `TestJsonWriter`\nCode:\nclass TestJsonWriter(TestWriter):\n    def test_write(self):\n        writer = JsonWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Function `test_write`\nCode:\n    def test_write(self):\n        writer = JsonWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Class `TestJsonlWriter`\nCode:\nclass TestJsonlWriter(TestWriter):\n    def test_write(self):\n        writer = JsonlWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file, lines=True)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Function `test_write`\nCode:\n    def test_write(self):\n        writer = JsonlWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file, lines=True)\n        assert_frame_equal(self.dataset, loaded_dataset)",
                                        "Class `TestFastText`\nCode:\nclass TestFastText(unittest.TestCase):\n    def setUp(self):\n        self.expected = \"__label__A exampleA\\n__label__B exampleB\"\n        self.dataset = pd.DataFrame([*zip(self.expected.split(\"\\n\"))])\n\n    def test_write(self):\n        file = \"tmp.txt\"\n        writer = FastTextWriter()\n        writer.write(file, self.dataset)\n        loaded_dataset = open(file, encoding=\"utf-8\").read().strip()\n        self.assertEqual(loaded_dataset, self.expected)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.expected = \"__label__A exampleA\\n__label__B exampleB\"\n        self.dataset = pd.DataFrame([*zip(self.expected.split(\"\\n\"))])",
                                        "Function `test_write`\nCode:\n    def test_write(self):\n        file = \"tmp.txt\"\n        writer = FastTextWriter()\n        writer.write(file, self.dataset)\n        loaded_dataset = open(file, encoding=\"utf-8\").read().strip()\n        self.assertEqual(loaded_dataset, self.expected)"
                                    ],
                                    "code": "import os\nimport unittest\n\nimport pandas as pd\nfrom pandas.testing import assert_frame_equal\n\nfrom ..pipeline.writers import CsvWriter, FastTextWriter, JsonlWriter, JsonWriter\n\n\nclass TestWriter(unittest.TestCase):\n    def setUp(self):\n        self.dataset = pd.DataFrame(\n            [\n                {\"id\": 0, \"text\": \"A\"},\n                {\"id\": 1, \"text\": \"B\"},\n                {\"id\": 2, \"text\": \"C\"},\n            ]\n        )\n        self.file = \"tmp.csv\"\n\n    def tearDown(self):\n        os.remove(self.file)\n\n\nclass TestCSVWriter(TestWriter):\n    def test_write(self):\n        writer = CsvWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_csv(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)\n\n\nclass TestJsonWriter(TestWriter):\n    def test_write(self):\n        writer = JsonWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file)\n        assert_frame_equal(self.dataset, loaded_dataset)\n\n\nclass TestJsonlWriter(TestWriter):\n    def test_write(self):\n        writer = JsonlWriter()\n        writer.write(self.file, self.dataset)\n        loaded_dataset = pd.read_json(self.file, lines=True)\n        assert_frame_equal(self.dataset, loaded_dataset)\n\n\nclass TestFastText(unittest.TestCase):\n    def setUp(self):\n        self.expected = \"__label__A exampleA\\n__label__B exampleB\"\n        self.dataset = pd.DataFrame([*zip(self.expected.split(\"\\n\"))])\n\n    def test_write(self):\n        file = \"tmp.txt\"\n        writer = FastTextWriter()\n        writer.write(file, self.dataset)\n        loaded_dataset = open(file, encoding=\"utf-8\").read().strip()\n        self.assertEqual(loaded_dataset, self.expected)\n",
                                    "summary": "The content describes a series of unit test cases for different data writers (CSV, JSON, JSON Lines, and FastText) that set up test environments, verify the correctness of data writing and loading functionalities, and ensure proper cleanup after tests.",
                                    "code_element_summaries": [
                                        "Class TestWriter: A unit test case that sets up a sample dataset and a temporary CSV file for testing, while ensuring cleanup after tests.",
                                        "Function `setUp`: Initializes a test environment by creating a DataFrame with sample data and defining a temporary CSV file name.",
                                        "Function `tearDown`: A method that deletes a specified file from the filesystem after a test case has run.",
                                        "Class `TestCSVWriter`: A test case for verifying the functionality of the CsvWriter by ensuring that the written CSV file matches the original dataset.",
                                        "Function `test_write`: A unit test that verifies the functionality of the CsvWriter by checking if the written CSV file matches the original dataset.",
                                        "Class TestJsonWriter: A test case for the JsonWriter that verifies the correct writing of a dataset to a JSON file and its accurate loading back into a DataFrame.",
                                        "Function `test_write`: A test function that verifies the correctness of the `JsonWriter` by writing a dataset to a file and asserting that the loaded data matches the original dataset.",
                                        "Class `TestJsonlWriter`: A test case for the `JsonlWriter` that validates the writing of a dataset to a JSON Lines file and ensures it matches the original dataset.",
                                        "Function `test_write`: A test function that verifies the correctness of writing a dataset to a JSON Lines file and subsequently reading it back for equality.",
                                        "Class TestFastText: A unit test case for the FastTextWriter that verifies the correct writing of a dataset to a file.",
                                        "Function `setUp`: Prepares a test environment by initializing an expected string and creating a DataFrame from the split lines of that string.",
                                        "Function `test_write`: A test method that verifies the functionality of the FastTextWriter by writing a dataset to a file and comparing the loaded content to the expected output."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import DatasetCatalog, DatasetExportAPI\n\nurlpatterns = [\n    path(route=\"projects/<int:project_id>/download-format\", view=DatasetCatalog.as_view(), name=\"download-format\"),\n    path(route=\"projects/<int:project_id>/download\", view=DatasetExportAPI.as_view(), name=\"download-dataset\"),\n]\n",
                            "summary": "URL configuration for Django that defines routes for downloading dataset formats and datasets associated with a specific project.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `DatasetCatalog`\nCode:\nclass DatasetCatalog(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)",
                                "Class `DatasetExportAPI`\nCode:\nclass DatasetExportAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        task_id = request.GET[\"taskId\"]\n        task = AsyncResult(task_id)\n        ready = task.ready()\n        if ready:\n            filename = task.result\n            return FileResponse(open(filename, mode=\"rb\"), as_attachment=True)\n        return Response({\"status\": \"Not ready\"})\n\n    def post(self, request, *args, **kwargs):\n        project_id = self.kwargs[\"project_id\"]\n        file_format = request.data.pop(\"format\")\n        export_approved = request.data.pop(\"exportApproved\", False)\n        task = export_dataset.delay(\n            project_id=project_id, file_format=file_format, confirmed_only=export_approved, **request.data\n        )\n        return Response({\"task_id\": task.task_id})",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        task_id = request.GET[\"taskId\"]\n        task = AsyncResult(task_id)\n        ready = task.ready()\n        if ready:\n            filename = task.result\n            return FileResponse(open(filename, mode=\"rb\"), as_attachment=True)\n        return Response({\"status\": \"Not ready\"})",
                                "Function `post`\nCode:\n    def post(self, request, *args, **kwargs):\n        project_id = self.kwargs[\"project_id\"]\n        file_format = request.data.pop(\"format\")\n        export_approved = request.data.pop(\"exportApproved\", False)\n        task = export_dataset.delay(\n            project_id=project_id, file_format=file_format, confirmed_only=export_approved, **request.data\n        )\n        return Response({\"task_id\": task.task_id})"
                            ],
                            "code": "from celery.result import AsyncResult\nfrom django.http import FileResponse\nfrom django.shortcuts import get_object_or_404\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom .celery_tasks import export_dataset\nfrom .pipeline.catalog import Options\nfrom projects.models import Project\nfrom projects.permissions import IsProjectAdmin\n\n\nclass DatasetCatalog(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)\n\n\nclass DatasetExportAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        task_id = request.GET[\"taskId\"]\n        task = AsyncResult(task_id)\n        ready = task.ready()\n        if ready:\n            filename = task.result\n            return FileResponse(open(filename, mode=\"rb\"), as_attachment=True)\n        return Response({\"status\": \"Not ready\"})\n\n    def post(self, request, *args, **kwargs):\n        project_id = self.kwargs[\"project_id\"]\n        file_format = request.data.pop(\"format\")\n        export_approved = request.data.pop(\"exportApproved\", False)\n        task = export_dataset.delay(\n            project_id=project_id, file_format=file_format, confirmed_only=export_approved, **request.data\n        )\n        return Response({\"task_id\": task.task_id})\n",
                            "summary": "Classes DatasetCatalog and DatasetExportAPI: API views that manage project-specific options and dataset export requests, ensuring user authentication and project admin permissions while providing methods to retrieve project options and handle export tasks.",
                            "code_element_summaries": [
                                "Class DatasetCatalog: An API view that retrieves and returns project-specific options based on the project type and relation usage, ensuring the user is authenticated and has project admin permissions.",
                                "Function `get`: Retrieves project options based on the project ID and type, returning them in a response with a 200 OK status.",
                                "Class `DatasetExportAPI`: An API view that handles dataset export requests, allowing authenticated project administrators to initiate exports and download results once they are ready.",
                                "Function `get`: Retrieves the status of a task based on its ID and returns the associated file if the task is complete; otherwise, it indicates that the task is not ready.",
                                "Function `post`: Handles a POST request to initiate a dataset export task, returning the task ID in the response."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_export\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "data_import",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content describes a comprehensive framework for managing dataset classes, file imports, and label annotations within a Django application, featuring proxy models, application configuration, validation functions, utility classes for data handling, and a suite of unit tests to ensure functionality and error management, along with defined API views and URL configurations for efficient data processing and integration.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\admin.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class ExportedBoundingBox: A proxy model of BoundingBox that provides methods to convert bounding box annotations into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `DataImportConfig`\nCode:\nclass DataImportConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"data_import\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass DataImportConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"data_import\"\n",
                            "summary": "Class DataImportConfig: A Django application configuration class that defines the default auto field type and names the application \"data_import\".",
                            "code_element_summaries": [
                                "Class DataImportConfig: A Django application configuration class that sets the default auto field type and specifies the application name as \"data_import\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "celery_tasks.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\celery_tasks.py",
                            "is_dir": false,
                            "code_elements": [
                                "Function `check_file_type`\nCode:\ndef check_file_type(filename, file_format: Format, filepath: str):\n    if not settings.ENABLE_FILE_TYPE_CHECK:\n        return\n    kind = filetype.guess(filepath)\n    if not file_format.validate_mime(kind.mime):\n        raise FileTypeException(filename, kind.mime, file_format.accept_types)",
                                "Function `check_uploaded_files`\nCode:\ndef check_uploaded_files(upload_ids: List[str], file_format: Format):\n    errors: List[FileImportException] = []\n    cleaned_ids = []\n    temporary_uploads = TemporaryUpload.objects.filter(upload_id__in=upload_ids)\n    for tu in temporary_uploads:\n        if tu.file.size > settings.MAX_UPLOAD_SIZE:\n            errors.append(MaximumFileSizeException(tu.upload_name, settings.MAX_UPLOAD_SIZE))\n            tu.delete()\n            continue\n        try:\n            check_file_type(tu.upload_name, file_format, tu.get_file_path())\n        except FileTypeException as e:\n            errors.append(e)\n            tu.delete()\n            continue\n        cleaned_ids.append(tu.upload_id)\n    return cleaned_ids, errors",
                                "Function `import_dataset`\nCode:\ndef import_dataset(user_id, project_id, file_format: str, upload_ids: List[str], task: str, **kwargs):\n    project = get_object_or_404(Project, pk=project_id)\n    user = get_object_or_404(get_user_model(), pk=user_id)\n    try:\n        fmt = create_file_format(file_format)\n        upload_ids, errors = check_uploaded_files(upload_ids, fmt)\n        temporary_uploads = TemporaryUpload.objects.filter(upload_id__in=upload_ids)\n        filenames = [\n            FileName(full_path=tu.get_file_path(), generated_name=tu.file.name, upload_name=tu.upload_name)\n            for tu in temporary_uploads\n        ]\n\n        dataset = load_dataset(task, fmt, filenames, project, **kwargs)\n        dataset.save(user, batch_size=settings.IMPORT_BATCH_SIZE)\n        upload_to_store(temporary_uploads)\n        errors.extend(dataset.errors)\n        return {\"error\": [e.dict() for e in errors]}\n    except FileImportException as e:\n        return {\"error\": [e.dict()]}",
                                "Function `upload_to_store`\nCode:\ndef upload_to_store(temporary_uploads):\n    for tu in temporary_uploads:\n        store_upload(tu.upload_id, destination_file_path=tu.file.name)"
                            ],
                            "code": "from typing import List\n\nimport filetype\nfrom celery import shared_task\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.shortcuts import get_object_or_404\nfrom django_drf_filepond.api import store_upload\nfrom django_drf_filepond.models import TemporaryUpload\n\nfrom .datasets import load_dataset\nfrom .pipeline.catalog import Format, create_file_format\nfrom .pipeline.exceptions import (\n    FileImportException,\n    FileTypeException,\n    MaximumFileSizeException,\n)\nfrom .pipeline.readers import FileName\nfrom projects.models import Project\n\n\ndef check_file_type(filename, file_format: Format, filepath: str):\n    if not settings.ENABLE_FILE_TYPE_CHECK:\n        return\n    kind = filetype.guess(filepath)\n    if not file_format.validate_mime(kind.mime):\n        raise FileTypeException(filename, kind.mime, file_format.accept_types)\n\n\ndef check_uploaded_files(upload_ids: List[str], file_format: Format):\n    errors: List[FileImportException] = []\n    cleaned_ids = []\n    temporary_uploads = TemporaryUpload.objects.filter(upload_id__in=upload_ids)\n    for tu in temporary_uploads:\n        if tu.file.size > settings.MAX_UPLOAD_SIZE:\n            errors.append(MaximumFileSizeException(tu.upload_name, settings.MAX_UPLOAD_SIZE))\n            tu.delete()\n            continue\n        try:\n            check_file_type(tu.upload_name, file_format, tu.get_file_path())\n        except FileTypeException as e:\n            errors.append(e)\n            tu.delete()\n            continue\n        cleaned_ids.append(tu.upload_id)\n    return cleaned_ids, errors\n\n\n@shared_task(autoretry_for=(Exception,), retry_backoff=True, retry_jitter=True)\ndef import_dataset(user_id, project_id, file_format: str, upload_ids: List[str], task: str, **kwargs):\n    project = get_object_or_404(Project, pk=project_id)\n    user = get_object_or_404(get_user_model(), pk=user_id)\n    try:\n        fmt = create_file_format(file_format)\n        upload_ids, errors = check_uploaded_files(upload_ids, fmt)\n        temporary_uploads = TemporaryUpload.objects.filter(upload_id__in=upload_ids)\n        filenames = [\n            FileName(full_path=tu.get_file_path(), generated_name=tu.file.name, upload_name=tu.upload_name)\n            for tu in temporary_uploads\n        ]\n\n        dataset = load_dataset(task, fmt, filenames, project, **kwargs)\n        dataset.save(user, batch_size=settings.IMPORT_BATCH_SIZE)\n        upload_to_store(temporary_uploads)\n        errors.extend(dataset.errors)\n        return {\"error\": [e.dict() for e in errors]}\n    except FileImportException as e:\n        return {\"error\": [e.dict()]}\n\n\ndef upload_to_store(temporary_uploads):\n    for tu in temporary_uploads:\n        store_upload(tu.upload_id, destination_file_path=tu.file.name)\n",
                            "summary": "Functions for validating file types, checking uploaded files, importing datasets, and storing uploads, ensuring compliance with specified criteria and handling errors throughout the process.",
                            "code_element_summaries": [
                                "Function `check_file_type`: Validates the MIME type of a file against an accepted format, raising a FileTypeException if the type does not match, contingent on a setting that enables file type checking.",
                                "Function `check_uploaded_files`: Validates uploaded files by checking their size and type against specified criteria, returning a list of valid upload IDs and any encountered errors.",
                                "Function `import_dataset`: A function that imports a dataset for a specified user and project, handling file uploads and errors while saving the dataset.",
                                "Function `upload_to_store`: Iterates over temporary uploads and stores each upload using its ID and file path."
                            ],
                            "children": []
                        },
                        {
                            "name": "datasets.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\datasets.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Dataset`\nCode:\nclass Dataset(abc.ABC):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        self.reader = reader\n        self.project = project\n        self.kwargs = kwargs\n\n    def save(self, user: User, batch_size: int = 1000):\n        raise NotImplementedError()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        raise NotImplementedError()",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        self.reader = reader\n        self.project = project\n        self.kwargs = kwargs",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        raise NotImplementedError()",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        raise NotImplementedError()",
                                "Class `PlainDataset`\nCode:\nclass PlainDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = ExampleMaker(project=project, data_class=TextData)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = ExampleMaker(project=project, data_class=TextData)",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors",
                                "Class `DatasetWithSingleLabelType`\nCode:\nclass DatasetWithSingleLabelType(Dataset):\n    data_class: Type[BaseData]\n    label_class: Type[Label]\n    label_type = LabelType\n    labels_class = Labels\n\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.types = LabelTypes(self.label_type)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=self.data_class,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN],\n        )\n        self.label_maker = LabelMaker(\n            column=kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN, label_class=self.label_class\n        )\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            labels = self.labels_class(self.label_maker.make(records), self.types)\n            labels.clean(self.project)\n            labels.save_types(self.project)\n\n            # create Labels\n            labels.save(user, examples)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.label_maker.errors",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.types = LabelTypes(self.label_type)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=self.data_class,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN],\n        )\n        self.label_maker = LabelMaker(\n            column=kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN, label_class=self.label_class\n        )",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            labels = self.labels_class(self.label_maker.make(records), self.types)\n            labels.clean(self.project)\n            labels.save_types(self.project)\n\n            # create Labels\n            labels.save(user, examples)",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.label_maker.errors",
                                "Class `BinaryDataset`\nCode:\nclass BinaryDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = BinaryExampleMaker(project=project, data_class=BinaryData)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = BinaryExampleMaker(project=project, data_class=BinaryData)",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors",
                                "Class `TextClassificationDataset`\nCode:\nclass TextClassificationDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = CategoryLabel\n    label_type = CategoryType\n    labels_class = Categories",
                                "Class `SequenceLabelingDataset`\nCode:\nclass SequenceLabelingDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = SpanLabel\n    label_type = SpanType\n    labels_class = Spans",
                                "Class `Seq2seqDataset`\nCode:\nclass Seq2seqDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = TextLabel\n    label_type = DummyLabelType\n    labels_class = Texts",
                                "Class `RelationExtractionDataset`\nCode:\nclass RelationExtractionDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.span_types = LabelTypes(SpanType)\n        self.relation_types = LabelTypes(RelationType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"entities\", \"relations\"],\n        )\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)\n        self.relation_maker = LabelMaker(column=\"relations\", label_class=RelationLabel)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            relations = Relations(self.relation_maker.make(records), self.relation_types)\n            relations.clean(self.project)\n            relations.save_types(self.project)\n\n            # create Labels\n            spans.save(user, examples)\n            relations.save(user, examples, spans=spans)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.span_maker.errors + self.relation_maker.errors",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.span_types = LabelTypes(SpanType)\n        self.relation_types = LabelTypes(RelationType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"entities\", \"relations\"],\n        )\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)\n        self.relation_maker = LabelMaker(column=\"relations\", label_class=RelationLabel)",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            relations = Relations(self.relation_maker.make(records), self.relation_types)\n            relations.clean(self.project)\n            relations.save_types(self.project)\n\n            # create Labels\n            spans.save(user, examples)\n            relations.save(user, examples, spans=spans)",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.span_maker.errors + self.relation_maker.errors",
                                "Class `CategoryAndSpanDataset`\nCode:\nclass CategoryAndSpanDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.category_types = LabelTypes(CategoryType)\n        self.span_types = LabelTypes(SpanType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"cats\", \"entities\"],\n        )\n        self.category_maker = LabelMaker(column=\"cats\", label_class=CategoryLabel)\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            categories = Categories(self.category_maker.make(records), self.category_types)\n            categories.clean(self.project)\n            categories.save_types(self.project)\n\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            # create Labels\n            categories.save(user, examples)\n            spans.save(user, examples)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.category_maker.errors + self.span_maker.errors",
                                "Function `__init__`\nCode:\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.category_types = LabelTypes(CategoryType)\n        self.span_types = LabelTypes(SpanType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"cats\", \"entities\"],\n        )\n        self.category_maker = LabelMaker(column=\"cats\", label_class=CategoryLabel)\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)",
                                "Function `save`\nCode:\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            categories = Categories(self.category_maker.make(records), self.category_types)\n            categories.clean(self.project)\n            categories.save_types(self.project)\n\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            # create Labels\n            categories.save(user, examples)\n            spans.save(user, examples)",
                                "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.category_maker.errors + self.span_maker.errors",
                                "Function `select_dataset`\nCode:\ndef select_dataset(project: Project, task: str, file_format: Format) -> Type[Dataset]:\n    mapping = {\n        ProjectType.DOCUMENT_CLASSIFICATION: TextClassificationDataset,\n        ProjectType.SEQUENCE_LABELING: SequenceLabelingDataset,\n        RELATION_EXTRACTION: RelationExtractionDataset,\n        ProjectType.SEQ2SEQ: Seq2seqDataset,\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: CategoryAndSpanDataset,\n        ProjectType.IMAGE_CLASSIFICATION: BinaryDataset,\n        ProjectType.IMAGE_CAPTIONING: BinaryDataset,\n        ProjectType.BOUNDING_BOX: BinaryDataset,\n        ProjectType.SEGMENTATION: BinaryDataset,\n        ProjectType.SPEECH2TEXT: BinaryDataset,\n    }\n    if task not in mapping:\n        task = project.project_type\n    if project.is_text_project and file_format.is_plain_text():\n        return PlainDataset\n    return mapping[task]",
                                "Function `load_dataset`\nCode:\ndef load_dataset(task: str, file_format: Format, data_files: List[FileName], project: Project, **kwargs) -> Dataset:\n    parser = create_parser(file_format, **kwargs)\n    reader = Reader(data_files, parser)\n    dataset_class = select_dataset(project, task, file_format)\n    return dataset_class(reader, project, **kwargs)"
                            ],
                            "code": "import abc\nfrom typing import List, Type\n\nfrom django.contrib.auth.models import User\n\nfrom .models import DummyLabelType\nfrom .pipeline.catalog import RELATION_EXTRACTION, Format\nfrom .pipeline.data import BaseData, BinaryData, TextData\nfrom .pipeline.examples import Examples\nfrom .pipeline.exceptions import FileParseException\nfrom .pipeline.factories import create_parser\nfrom .pipeline.label import CategoryLabel, Label, RelationLabel, SpanLabel, TextLabel\nfrom .pipeline.label_types import LabelTypes\nfrom .pipeline.labels import Categories, Labels, Relations, Spans, Texts\nfrom .pipeline.makers import BinaryExampleMaker, ExampleMaker, LabelMaker\nfrom .pipeline.readers import (\n    DEFAULT_LABEL_COLUMN,\n    DEFAULT_TEXT_COLUMN,\n    FileName,\n    Reader,\n)\nfrom label_types.models import CategoryType, LabelType, RelationType, SpanType\nfrom projects.models import Project, ProjectType\n\n\nclass Dataset(abc.ABC):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        self.reader = reader\n        self.project = project\n        self.kwargs = kwargs\n\n    def save(self, user: User, batch_size: int = 1000):\n        raise NotImplementedError()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        raise NotImplementedError()\n\n\nclass PlainDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = ExampleMaker(project=project, data_class=TextData)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors\n\n\nclass DatasetWithSingleLabelType(Dataset):\n    data_class: Type[BaseData]\n    label_class: Type[Label]\n    label_type = LabelType\n    labels_class = Labels\n\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.types = LabelTypes(self.label_type)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=self.data_class,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN],\n        )\n        self.label_maker = LabelMaker(\n            column=kwargs.get(\"column_label\") or DEFAULT_LABEL_COLUMN, label_class=self.label_class\n        )\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            labels = self.labels_class(self.label_maker.make(records), self.types)\n            labels.clean(self.project)\n            labels.save_types(self.project)\n\n            # create Labels\n            labels.save(user, examples)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.label_maker.errors\n\n\nclass BinaryDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.example_maker = BinaryExampleMaker(project=project, data_class=BinaryData)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors\n\n\nclass TextClassificationDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = CategoryLabel\n    label_type = CategoryType\n    labels_class = Categories\n\n\nclass SequenceLabelingDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = SpanLabel\n    label_type = SpanType\n    labels_class = Spans\n\n\nclass Seq2seqDataset(DatasetWithSingleLabelType):\n    data_class = TextData\n    label_class = TextLabel\n    label_type = DummyLabelType\n    labels_class = Texts\n\n\nclass RelationExtractionDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.span_types = LabelTypes(SpanType)\n        self.relation_types = LabelTypes(RelationType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"entities\", \"relations\"],\n        )\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)\n        self.relation_maker = LabelMaker(column=\"relations\", label_class=RelationLabel)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            relations = Relations(self.relation_maker.make(records), self.relation_types)\n            relations.clean(self.project)\n            relations.save_types(self.project)\n\n            # create Labels\n            spans.save(user, examples)\n            relations.save(user, examples, spans=spans)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.span_maker.errors + self.relation_maker.errors\n\n\nclass CategoryAndSpanDataset(Dataset):\n    def __init__(self, reader: Reader, project: Project, **kwargs):\n        super().__init__(reader, project, **kwargs)\n        self.category_types = LabelTypes(CategoryType)\n        self.span_types = LabelTypes(SpanType)\n        self.example_maker = ExampleMaker(\n            project=project,\n            data_class=TextData,\n            column_data=kwargs.get(\"column_data\") or DEFAULT_TEXT_COLUMN,\n            exclude_columns=[\"cats\", \"entities\"],\n        )\n        self.category_maker = LabelMaker(column=\"cats\", label_class=CategoryLabel)\n        self.span_maker = LabelMaker(column=\"entities\", label_class=SpanLabel)\n\n    def save(self, user: User, batch_size: int = 1000):\n        for records in self.reader.batch(batch_size):\n            # create examples\n            examples = Examples(self.example_maker.make(records))\n            examples.save()\n\n            # create label types\n            categories = Categories(self.category_maker.make(records), self.category_types)\n            categories.clean(self.project)\n            categories.save_types(self.project)\n\n            spans = Spans(self.span_maker.make(records), self.span_types)\n            spans.clean(self.project)\n            spans.save_types(self.project)\n\n            # create Labels\n            categories.save(user, examples)\n            spans.save(user, examples)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.reader.errors + self.example_maker.errors + self.category_maker.errors + self.span_maker.errors\n\n\ndef select_dataset(project: Project, task: str, file_format: Format) -> Type[Dataset]:\n    mapping = {\n        ProjectType.DOCUMENT_CLASSIFICATION: TextClassificationDataset,\n        ProjectType.SEQUENCE_LABELING: SequenceLabelingDataset,\n        RELATION_EXTRACTION: RelationExtractionDataset,\n        ProjectType.SEQ2SEQ: Seq2seqDataset,\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: CategoryAndSpanDataset,\n        ProjectType.IMAGE_CLASSIFICATION: BinaryDataset,\n        ProjectType.IMAGE_CAPTIONING: BinaryDataset,\n        ProjectType.BOUNDING_BOX: BinaryDataset,\n        ProjectType.SEGMENTATION: BinaryDataset,\n        ProjectType.SPEECH2TEXT: BinaryDataset,\n    }\n    if task not in mapping:\n        task = project.project_type\n    if project.is_text_project and file_format.is_plain_text():\n        return PlainDataset\n    return mapping[task]\n\n\ndef load_dataset(task: str, file_format: Format, data_files: List[FileName], project: Project, **kwargs) -> Dataset:\n    parser = create_parser(file_format, **kwargs)\n    reader = Reader(data_files, parser)\n    dataset_class = select_dataset(project, task, file_format)\n    return dataset_class(reader, project, **kwargs)\n",
                            "summary": "The content describes a hierarchy of dataset classes, including abstract base classes and specialized implementations for various data processing tasks, each with methods for initialization, saving data, and handling parsing errors, along with utility functions for selecting and loading appropriate datasets based on project specifications.",
                            "code_element_summaries": [
                                "Class `Dataset`: An abstract base class that requires implementations for saving data and retrieving parsing errors, initialized with a reader and project.",
                                "Function `__init__`: Initializes an instance with a Reader, a Project, and additional keyword arguments.",
                                "Function `save`: An abstract method intended for saving data, requiring implementation in subclasses, with parameters for user and batch size.",
                                "Function `errors`: An abstract method that raises a NotImplementedError, indicating that subclasses must provide their own implementation to return a list of FileParseException instances.",
                                "Class `PlainDataset`: A dataset class that processes records using a reader and an example maker, allowing for batch saving of examples and tracking of errors.",
                                "Function `__init__`: Initializes an instance by calling the superclass constructor and setting up an ExampleMaker for the specified project and data class.",
                                "Function `save`: A method that processes batches of records, creates examples from them, and saves those examples to the database.",
                                "Function `errors`: Returns a list of `FileParseException` instances by combining errors from both the reader and the example maker.",
                                "Class `DatasetWithSingleLabelType`: A specialized dataset class for managing and saving examples and labels with a single label type, utilizing various helper classes for data processing and error handling.",
                                "Function `__init__`: Initializes an instance by setting up the reader, project, label types, example maker, and label maker with specified parameters and defaults.",
                                "Function `save`: A method that processes records in batches to create and save examples, label types, and labels associated with a user and project.",
                                "Function `errors`: Returns a list of `FileParseException` instances by aggregating errors from the reader, example maker, and label maker components.",
                                "Class `BinaryDataset`: A dataset class that processes binary data, creates examples from records, and handles error reporting during data reading and example creation.",
                                "Function `__init__`: Initializes an instance of the class by calling the superclass's initializer and setting up a BinaryExampleMaker for the specified project and data class.",
                                "Function `save`: A method that processes records in batches and saves examples created from those records.",
                                "Function `errors`: Returns a list of `FileParseException` instances by combining errors from the reader and example maker.",
                                "Class `TextClassificationDataset`: A dataset model for text classification that utilizes specific classes for data, labels, and label types.",
                                "Class `SequenceLabelingDataset`: A dataset class for sequence labeling that utilizes text data and span labels, inheriting from `DatasetWithSingleLabelType`.",
                                "Class Seq2seqDataset: A dataset model that extends DatasetWithSingleLabelType to handle text data and associated labels for sequence-to-sequence tasks.",
                                "Class `RelationExtractionDataset`: A dataset management class for handling relation extraction tasks, which facilitates the creation, saving, and management of examples and their associated label types and relations.",
                                "Function `__init__`: Initializes an instance with specified reader and project, setting up label types and makers for spans and relations while allowing additional keyword arguments.",
                                "Function `save`: A method that processes records in batches to create and save examples, label types, spans, and relations associated with a user.",
                                "Function `errors`: Returns a list of `FileParseException` objects by aggregating errors from multiple components, including the reader, example maker, span maker, and relation maker.",
                                "Class `CategoryAndSpanDataset`: A dataset class that processes and saves labeled text data, managing category and span types while handling potential parsing errors.",
                                "Function `__init__`: Initializes an instance by setting up label types, example maker, and label makers for categories and spans using provided parameters and defaults.",
                                "Function `save`: This function processes records in batches to create and save examples, categories, and spans, while also associating labels with the provided user.",
                                "Function `errors`: Returns a list of `FileParseException` instances by aggregating errors from multiple components including the reader, example maker, category maker, and span maker.",
                                "Function `select_dataset`: A function that selects and returns the appropriate dataset type based on the project's type, task, and file format.",
                                "Function `load_dataset`: A function that initializes a dataset by creating a parser, reading data files, and selecting the appropriate dataset class based on the specified task and file format."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A Django migration that creates a proxy model named DummyLabelType based on the categorytype model from the label_types app, without adding any additional fields, indexes, or constraints.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"DummyLabelType\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"label_types.categorytype\",),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-05-17 23:01\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"DummyLabelType\",\n            fields=[],\n            options={\n                \"proxy\": True,\n                \"indexes\": [],\n                \"constraints\": [],\n            },\n            bases=(\"label_types.categorytype\",),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes a proxy model called DummyLabelType based on the categorytype model from the label_types app, without any extra fields, indexes, or constraints.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates a proxy model named DummyLabelType based on the categorytype model from the label_types app, with no additional fields, indexes, or constraints."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `DummyLabelType`\nCode:\nclass DummyLabelType(CategoryType):\n    objects = MagicMock()\n\n    class Meta:\n        proxy = True",
                                "Class `Meta`\nCode:\n    class Meta:\n        proxy = True"
                            ],
                            "code": "from unittest.mock import MagicMock\n\nfrom label_types.models import CategoryType\n\n\nclass DummyLabelType(CategoryType):\n    objects = MagicMock()\n\n    class Meta:\n        proxy = True\n",
                            "summary": "Class DummyLabelType: A proxy model of CategoryType that uses a MagicMock for testing, with a Meta class for proxy configuration in Django.",
                            "code_element_summaries": [
                                "Class DummyLabelType: A proxy model of CategoryType that utilizes a MagicMock for testing purposes.",
                                "Class Meta: A proxy class configuration that allows the creation of a proxy model in Django."
                            ],
                            "children": []
                        },
                        {
                            "name": "pipeline",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content outlines a comprehensive framework for managing various file formats and label annotations, featuring abstract and concrete classes for data representation, validation, and error handling, alongside utility classes for creating structured examples and parsers for reading diverse file formats efficiently.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "catalog.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\catalog.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Format`\nCode:\nclass Format:\n    name = \"\"\n    accept_types = \"\"\n\n    @classmethod\n    def dict(cls):\n        return {\"name\": cls.name, \"accept_types\": cls.accept_types}\n\n    def validate_mime(self, mime: str):\n        return True\n\n    @staticmethod\n    def is_plain_text():\n        return False",
                                        "Function `dict`\nCode:\n    def dict(cls):\n        return {\"name\": cls.name, \"accept_types\": cls.accept_types}",
                                        "Function `validate_mime`\nCode:\n    def validate_mime(self, mime: str):\n        return True",
                                        "Function `is_plain_text`\nCode:\n    def is_plain_text():\n        return False",
                                        "Class `CSV`\nCode:\nclass CSV(Format):\n    name = \"CSV\"\n    accept_types = \"text/csv\"",
                                        "Class `FastText`\nCode:\nclass FastText(Format):\n    name = \"fastText\"\n    accept_types = \"text/plain\"",
                                        "Class `JSON`\nCode:\nclass JSON(Format):\n    name = \"JSON\"\n    accept_types = \"application/json\"",
                                        "Class `JSONL`\nCode:\nclass JSONL(Format):\n    name = \"JSONL\"\n    accept_types = \"*\"",
                                        "Class `Excel`\nCode:\nclass Excel(Format):\n    name = \"Excel\"\n    accept_types = \"application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"",
                                        "Class `TextFile`\nCode:\nclass TextFile(Format):\n    name = \"TextFile\"\n    accept_types = \"text/*\"\n\n    @staticmethod\n    def is_plain_text():\n        return True",
                                        "Function `is_plain_text`\nCode:\n    def is_plain_text():\n        return True",
                                        "Class `TextLine`\nCode:\nclass TextLine(Format):\n    name = \"TextLine\"\n    accept_types = \"text/*\"\n\n    @staticmethod\n    def is_plain_text():\n        return True",
                                        "Function `is_plain_text`\nCode:\n    def is_plain_text():\n        return True",
                                        "Class `CoNLL`\nCode:\nclass CoNLL(Format):\n    name = \"CoNLL\"\n    accept_types = \"text/*\"",
                                        "Class `ImageFile`\nCode:\nclass ImageFile(Format):\n    name = \"ImageFile\"\n    accept_types = \"image/png, image/jpeg, image/bmp, image/gif\"\n\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types",
                                        "Function `validate_mime`\nCode:\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types",
                                        "Class `AudioFile`\nCode:\nclass AudioFile(Format):\n    name = \"AudioFile\"\n    accept_types = \"audio/ogg, audio/aac, audio/mpeg, audio/wav\"\n\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types",
                                        "Function `validate_mime`\nCode:\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types",
                                        "Class `ArgColumn`\nCode:\nclass ArgColumn(BaseModel):\n    encoding: encodings = \"utf_8\"\n    column_data: str = \"text\"\n    column_label: str = \"label\"",
                                        "Class `ArgDelimiter`\nCode:\nclass ArgDelimiter(ArgColumn):\n    encoding: encodings = \"utf_8\"\n    delimiter: Literal[\",\", \"\\t\", \";\", \"|\", \" \"] = \",\"",
                                        "Class `ArgEncoding`\nCode:\nclass ArgEncoding(BaseModel):\n    encoding: encodings = \"utf_8\"",
                                        "Class `ArgCoNLL`\nCode:\nclass ArgCoNLL(BaseModel):\n    encoding: encodings = \"utf_8\"\n    scheme: Literal[\"IOB2\", \"IOE2\", \"IOBES\", \"BILOU\"] = \"IOB2\"\n    delimiter: Literal[\" \", \"\"] = \" \"",
                                        "Class `ArgNone`\nCode:\nclass ArgNone(BaseModel):\n    pass",
                                        "Class `Option`\nCode:\nclass Option:\n    display_name: str\n    task_id: str\n    file_format: Type[Format]\n    arg: Type[BaseModel]\n    file: Path\n\n    @property\n    def example(self) -> str:\n        with open(self.file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n\n    def dict(self) -> Dict:\n        return {\n            **self.file_format.dict(),\n            **self.arg.schema(),\n            \"example\": self.example,\n            \"task_id\": self.task_id,\n            \"display_name\": self.display_name,\n        }",
                                        "Function `example`\nCode:\n    def example(self) -> str:\n        with open(self.file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()",
                                        "Function `dict`\nCode:\n    def dict(self) -> Dict:\n        return {\n            **self.file_format.dict(),\n            **self.arg.schema(),\n            \"example\": self.example,\n            \"task_id\": self.task_id,\n            \"display_name\": self.display_name,\n        }",
                                        "Function `create_file_format`\nCode:\ndef create_file_format(file_format: str) -> Format:\n    for format_class in Format.__subclasses__():\n        if format_class.name == file_format:\n            return format_class()\n    raise FileFormatException(file_format)",
                                        "Class `Options`\nCode:\nclass Options:\n    options: Dict[str, List] = defaultdict(list)\n\n    @classmethod\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        if use_relation:\n            options = cls.options[task_name] + cls.options[RELATION_EXTRACTION]\n        return [option.dict() for option in options]\n\n    @classmethod\n    def register(cls, option: Option):\n        cls.options[option.task_id].append(option)",
                                        "Function `filter_by_task`\nCode:\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        if use_relation:\n            options = cls.options[task_name] + cls.options[RELATION_EXTRACTION]\n        return [option.dict() for option in options]",
                                        "Function `register`\nCode:\n    def register(cls, option: Option):\n        cls.options[option.task_id].append(option)"
                                    ],
                                    "code": "from collections import defaultdict\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Type\n\nfrom pydantic import BaseModel\nfrom typing_extensions import Literal\n\nfrom .exceptions import FileFormatException\nfrom projects.models import ProjectType\n\n# Define the example directories\nEXAMPLE_DIR = Path(__file__).parent.resolve() / \"examples\"\nTASK_AGNOSTIC_DIR = EXAMPLE_DIR / \"task_agnostic\"\nTEXT_CLASSIFICATION_DIR = EXAMPLE_DIR / \"text_classification\"\nSEQUENCE_LABELING_DIR = EXAMPLE_DIR / \"sequence_labeling\"\nRELATION_EXTRACTION_DIR = EXAMPLE_DIR / \"relation_extraction\"\nSEQ2SEQ_DIR = EXAMPLE_DIR / \"sequence_to_sequence\"\nINTENT_DETECTION_DIR = EXAMPLE_DIR / \"intent_detection\"\nIMAGE_CLASSIFICATION_DIR = EXAMPLE_DIR / \"image_classification\"\nSPEECH_TO_TEXT_DIR = EXAMPLE_DIR / \"speech_to_text\"\n\n# Define the task identifiers\nRELATION_EXTRACTION = \"RelationExtraction\"\n\nencodings = Literal[\n    \"Auto\",\n    \"ascii\",\n    \"big5\",\n    \"big5hkscs\",\n    \"cp037\",\n    \"cp273\",\n    \"cp424\",\n    \"cp437\",\n    \"cp500\",\n    \"cp720\",\n    \"cp737\",\n    \"cp775\",\n    \"cp850\",\n    \"cp852\",\n    \"cp855\",\n    \"cp856\",\n    \"cp857\",\n    \"cp858\",\n    \"cp860\",\n    \"cp861\",\n    \"cp862\",\n    \"cp863\",\n    \"cp864\",\n    \"cp865\",\n    \"cp866\",\n    \"cp869\",\n    \"cp874\",\n    \"cp875\",\n    \"cp932\",\n    \"cp949\",\n    \"cp950\",\n    \"cp1006\",\n    \"cp1026\",\n    \"cp1125\",\n    \"cp1140\",\n    \"cp1250\",\n    \"cp1251\",\n    \"cp1252\",\n    \"cp1253\",\n    \"cp1254\",\n    \"cp1255\",\n    \"cp1256\",\n    \"cp1257\",\n    \"cp1258\",\n    \"cp65001\",\n    \"euc_jp\",\n    \"euc_jis_2004\",\n    \"euc_jisx0213\",\n    \"euc_kr\",\n    \"gb2312\",\n    \"gbk\",\n    \"gb18030\",\n    \"hz\",\n    \"iso2022_jp\",\n    \"iso2022_jp_1\",\n    \"iso2022_jp_2\",\n    \"iso2022_jp_2004\",\n    \"iso2022_jp_3\",\n    \"iso2022_jp_ext\",\n    \"iso2022_kr\",\n    \"latin_1\",\n    \"iso8859_2\",\n    \"iso8859_3\",\n    \"iso8859_4\",\n    \"iso8859_5\",\n    \"iso8859_6\",\n    \"iso8859_7\",\n    \"iso8859_8\",\n    \"iso8859_9\",\n    \"iso8859_10\",\n    \"iso8859_11\",\n    \"iso8859_13\",\n    \"iso8859_14\",\n    \"iso8859_15\",\n    \"iso8859_16\",\n    \"johab\",\n    \"koi8_r\",\n    \"koi8_t\",\n    \"koi8_u\",\n    \"kz1048\",\n    \"mac_cyrillic\",\n    \"mac_greek\",\n    \"mac_iceland\",\n    \"mac_latin2\",\n    \"mac_roman\",\n    \"mac_turkish\",\n    \"ptcp154\",\n    \"shift_jis\",\n    \"shift_jis_2004\",\n    \"shift_jisx0213\",\n    \"utf_32\",\n    \"utf_32_be\",\n    \"utf_32_le\",\n    \"utf_16\",\n    \"utf_16_be\",\n    \"utf_16_le\",\n    \"utf_7\",\n    \"utf_8\",\n    \"utf_8_sig\",\n]\n\n\nclass Format:\n    name = \"\"\n    accept_types = \"\"\n\n    @classmethod\n    def dict(cls):\n        return {\"name\": cls.name, \"accept_types\": cls.accept_types}\n\n    def validate_mime(self, mime: str):\n        return True\n\n    @staticmethod\n    def is_plain_text():\n        return False\n\n\nclass CSV(Format):\n    name = \"CSV\"\n    accept_types = \"text/csv\"\n\n\nclass FastText(Format):\n    name = \"fastText\"\n    accept_types = \"text/plain\"\n\n\nclass JSON(Format):\n    name = \"JSON\"\n    accept_types = \"application/json\"\n\n\nclass JSONL(Format):\n    name = \"JSONL\"\n    accept_types = \"*\"\n\n\nclass Excel(Format):\n    name = \"Excel\"\n    accept_types = \"application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n\n\nclass TextFile(Format):\n    name = \"TextFile\"\n    accept_types = \"text/*\"\n\n    @staticmethod\n    def is_plain_text():\n        return True\n\n\nclass TextLine(Format):\n    name = \"TextLine\"\n    accept_types = \"text/*\"\n\n    @staticmethod\n    def is_plain_text():\n        return True\n\n\nclass CoNLL(Format):\n    name = \"CoNLL\"\n    accept_types = \"text/*\"\n\n\nclass ImageFile(Format):\n    name = \"ImageFile\"\n    accept_types = \"image/png, image/jpeg, image/bmp, image/gif\"\n\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types\n\n\nclass AudioFile(Format):\n    name = \"AudioFile\"\n    accept_types = \"audio/ogg, audio/aac, audio/mpeg, audio/wav\"\n\n    def validate_mime(self, mime: str):\n        return mime in self.accept_types\n\n\nclass ArgColumn(BaseModel):\n    encoding: encodings = \"utf_8\"\n    column_data: str = \"text\"\n    column_label: str = \"label\"\n\n\nclass ArgDelimiter(ArgColumn):\n    encoding: encodings = \"utf_8\"\n    delimiter: Literal[\",\", \"\\t\", \";\", \"|\", \" \"] = \",\"\n\n\nclass ArgEncoding(BaseModel):\n    encoding: encodings = \"utf_8\"\n\n\nclass ArgCoNLL(BaseModel):\n    encoding: encodings = \"utf_8\"\n    scheme: Literal[\"IOB2\", \"IOE2\", \"IOBES\", \"BILOU\"] = \"IOB2\"\n    delimiter: Literal[\" \", \"\"] = \" \"\n\n\nclass ArgNone(BaseModel):\n    pass\n\n\n@dataclass\nclass Option:\n    display_name: str\n    task_id: str\n    file_format: Type[Format]\n    arg: Type[BaseModel]\n    file: Path\n\n    @property\n    def example(self) -> str:\n        with open(self.file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n\n    def dict(self) -> Dict:\n        return {\n            **self.file_format.dict(),\n            **self.arg.schema(),\n            \"example\": self.example,\n            \"task_id\": self.task_id,\n            \"display_name\": self.display_name,\n        }\n\n\ndef create_file_format(file_format: str) -> Format:\n    for format_class in Format.__subclasses__():\n        if format_class.name == file_format:\n            return format_class()\n    raise FileFormatException(file_format)\n\n\nclass Options:\n    options: Dict[str, List] = defaultdict(list)\n\n    @classmethod\n    def filter_by_task(cls, task_name: str, use_relation: bool = False):\n        options = cls.options[task_name]\n        if use_relation:\n            options = cls.options[task_name] + cls.options[RELATION_EXTRACTION]\n        return [option.dict() for option in options]\n\n    @classmethod\n    def register(cls, option: Option):\n        cls.options[option.task_id].append(option)\n\n\n# Text tasks\ntext_tasks = [\n    ProjectType.DOCUMENT_CLASSIFICATION,\n    ProjectType.SEQUENCE_LABELING,\n    ProjectType.SEQ2SEQ,\n    ProjectType.INTENT_DETECTION_AND_SLOT_FILLING,\n]\nfor task_id in text_tasks:\n    Options.register(\n        Option(\n            display_name=TextFile.name,\n            task_id=task_id,\n            file_format=TextFile,\n            arg=ArgEncoding,\n            file=TASK_AGNOSTIC_DIR / \"text_files.txt\",\n        )\n    )\n    Options.register(\n        Option(\n            display_name=TextLine.name,\n            task_id=task_id,\n            file_format=TextLine,\n            arg=ArgEncoding,\n            file=TASK_AGNOSTIC_DIR / \"text_lines.txt\",\n        )\n    )\n\n# Text Classification\nOptions.register(\n    Option(\n        display_name=CSV.name,\n        task_id=ProjectType.DOCUMENT_CLASSIFICATION,\n        file_format=CSV,\n        arg=ArgDelimiter,\n        file=TEXT_CLASSIFICATION_DIR / \"example.csv\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=FastText.name,\n        task_id=ProjectType.DOCUMENT_CLASSIFICATION,\n        file_format=FastText,\n        arg=ArgEncoding,\n        file=TEXT_CLASSIFICATION_DIR / \"example.txt\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=JSON.name,\n        task_id=ProjectType.DOCUMENT_CLASSIFICATION,\n        file_format=JSON,\n        arg=ArgColumn,\n        file=TEXT_CLASSIFICATION_DIR / \"example.json\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=JSONL.name,\n        task_id=ProjectType.DOCUMENT_CLASSIFICATION,\n        file_format=JSONL,\n        arg=ArgColumn,\n        file=TEXT_CLASSIFICATION_DIR / \"example.jsonl\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=Excel.name,\n        task_id=ProjectType.DOCUMENT_CLASSIFICATION,\n        file_format=Excel,\n        arg=ArgColumn,\n        file=TEXT_CLASSIFICATION_DIR / \"example.csv\",\n    )\n)\n\n# Sequence Labelling\nOptions.register(\n    Option(\n        display_name=JSONL.name,\n        task_id=ProjectType.SEQUENCE_LABELING,\n        file_format=JSONL,\n        arg=ArgColumn,\n        file=SEQUENCE_LABELING_DIR / \"example.jsonl\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=CoNLL.name,\n        task_id=ProjectType.SEQUENCE_LABELING,\n        file_format=CoNLL,\n        arg=ArgCoNLL,\n        file=SEQUENCE_LABELING_DIR / \"example.txt\",\n    )\n)\n\n# Relation Extraction\nOptions.register(\n    Option(\n        display_name=\"JSONL(Relation)\",\n        task_id=RELATION_EXTRACTION,\n        file_format=JSONL,\n        arg=ArgNone,\n        file=RELATION_EXTRACTION_DIR / \"example.jsonl\",\n    )\n)\n\n# Seq2seq\nOptions.register(\n    Option(\n        display_name=CSV.name,\n        task_id=ProjectType.SEQ2SEQ,\n        file_format=CSV,\n        arg=ArgDelimiter,\n        file=SEQ2SEQ_DIR / \"example.csv\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=JSON.name,\n        task_id=ProjectType.SEQ2SEQ,\n        file_format=JSON,\n        arg=ArgColumn,\n        file=SEQ2SEQ_DIR / \"example.json\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=JSONL.name,\n        task_id=ProjectType.SEQ2SEQ,\n        file_format=JSONL,\n        arg=ArgColumn,\n        file=SEQ2SEQ_DIR / \"example.jsonl\",\n    )\n)\nOptions.register(\n    Option(\n        display_name=Excel.name,\n        task_id=ProjectType.SEQ2SEQ,\n        file_format=Excel,\n        arg=ArgColumn,\n        file=SEQ2SEQ_DIR / \"example.csv\",\n    )\n)\n\n# Intent detection\nOptions.register(\n    Option(\n        display_name=JSONL.name,\n        task_id=ProjectType.INTENT_DETECTION_AND_SLOT_FILLING,\n        file_format=JSONL,\n        arg=ArgNone,\n        file=INTENT_DETECTION_DIR / \"example.jsonl\",\n    )\n)\n\n# Image tasks\nimage_tasks = [\n    ProjectType.IMAGE_CLASSIFICATION,\n    ProjectType.IMAGE_CAPTIONING,\n    ProjectType.BOUNDING_BOX,\n    ProjectType.SEGMENTATION,\n]\nfor task_name in image_tasks:\n    Options.register(\n        Option(\n            display_name=ImageFile.name,\n            task_id=task_name,\n            file_format=ImageFile,\n            arg=ArgNone,\n            file=IMAGE_CLASSIFICATION_DIR / \"image_files.txt\",\n        )\n    )\n\n# Speech to Text\nOptions.register(\n    Option(\n        display_name=AudioFile.name,\n        task_id=ProjectType.SPEECH2TEXT,\n        file_format=AudioFile,\n        arg=ArgNone,\n        file=SPEECH_TO_TEXT_DIR / \"audio_files.txt\",\n    )\n)\n",
                                    "summary": "Class Format and its subclasses define various file formats with attributes and methods for representation, validation, and management, including specific formats for CSV, JSON, text files, and more, while also providing functionality for options and configurations related to structured data.",
                                    "code_element_summaries": [
                                        "Class Format: A class that defines format attributes and provides methods for returning its properties as a dictionary, validating MIME types, and checking if the format is plain text.",
                                        "Function `dict`: A class method that returns a dictionary representation of the class, including its name and accepted types.",
                                        "Function `validate_mime`: A method that accepts a MIME type as a string and always returns `True`, indicating that the MIME type is considered valid.",
                                        "Function `is_plain_text`: A function that always returns `False`, indicating that the text is not plain.",
                                        "Class CSV: A subclass of Format that represents the CSV file format with a specified name and accepted MIME type.",
                                        "Class FastText: A format class that specifies the name \"fastText\" and accepts plain text as its input type.",
                                        "Class JSON: A subclass of Format that represents the JSON format with a specified name and accepted content type.",
                                        "Class JSONL: A subclass of Format that represents the JSON Lines format with a specified name and acceptance of all types.",
                                        "Class `Excel`: A subclass of Format that specifies the name \"Excel\" and the accepted MIME types for Excel file formats.",
                                        "Class TextFile: A subclass of Format that represents a text file format with a specified name and accepted types, and includes a static method to determine if it is plain text.",
                                        "Function `is_plain_text`: A function that always returns `True`, indicating that the content is plain text.",
                                        "Class `TextLine`: A subclass of Format that represents a text line with a specified name and acceptance for text types, and includes a static method to check if it is plain text.",
                                        "Function `is_plain_text`: A simple function that always returns `True`, indicating that the text is plain.",
                                        "Class CoNLL: A subclass of Format that represents the CoNLL format with a specified name and accepted types for text.",
                                        "Class ImageFile: A subclass of Format that defines acceptable image file types and includes a method to validate the MIME type against the accepted formats.",
                                        "Function `validate_mime`: Checks if a given MIME type is accepted by comparing it against a predefined list of accepted types.",
                                        "Class AudioFile: A subclass of Format that defines accepted audio file types and includes a method to validate MIME types against those accepted.",
                                        "Function `validate_mime`: Checks if a given MIME type is accepted based on predefined acceptable types.",
                                        "Class ArgColumn: A model that represents a column with encoding, data, and label attributes for structured data management.",
                                        "Class ArgDelimiter: A subclass of ArgColumn that defines default encoding and delimiter options for parsing arguments.",
                                        "Class ArgEncoding: A model that defines a character encoding attribute with a default value of \"utf_8\".",
                                        "Class ArgCoNLL: A model that defines encoding and annotation schemes for argument structure in CoNLL format with customizable delimiters.",
                                        "Class ArgNone: A minimal subclass of BaseModel that does not add any additional attributes or methods.",
                                        "Class Option: A model that encapsulates configuration options with properties for displaying an example, generating a dictionary representation, and storing task-related metadata.",
                                        "Function `example`: Reads the contents of a file specified by `self.file` and returns it as a string.",
                                        "Function `dict`: Returns a dictionary representation of the object, combining file format, schema, example, task ID, and display name attributes.",
                                        "Function `create_file_format`: A function that returns an instance of a subclass of Format based on the provided file format name, or raises a FileFormatException if no matching format is found.",
                                        "Class Options: A class that manages a collection of options for different tasks, allowing for filtering and registration of options.",
                                        "Function `filter_by_task`: A class method that retrieves options based on a specified task name, with an optional inclusion of related options, and returns them as a list of dictionaries.",
                                        "Function `register`: A class method that adds a given option to the list of options associated with a specific task ID in a class-level dictionary."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "data.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\data.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `BaseData`\nCode:\nclass BaseData(BaseModel, abc.ABC):\n    filename: str\n    upload_name: str\n    uuid: UUID4\n    meta: Dict[Any, Any] = {}\n\n    def __init__(self, **data):\n        super().__init__(**data)\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, filename: str, upload_name: str, text: str = \"\", **kwargs):\n        return cls(uuid=example_uuid, filename=filename, upload_name=upload_name, text=text, meta=kwargs)\n\n    def __hash__(self):\n        return hash(tuple(self.dict()))\n\n    @abc.abstractmethod\n    def create(self, project: Project) -> Example:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `__init__`\nCode:\n    def __init__(self, **data):\n        super().__init__(**data)",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, filename: str, upload_name: str, text: str = \"\", **kwargs):\n        return cls(uuid=example_uuid, filename=filename, upload_name=upload_name, text=text, meta=kwargs)",
                                        "Function `__hash__`\nCode:\n    def __hash__(self):\n        return hash(tuple(self.dict()))",
                                        "Function `create`\nCode:\n    def create(self, project: Project) -> Example:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Class `TextData`\nCode:\nclass TextData(BaseData):\n    text: str\n\n    @validator(\"text\")\n    def text_is_not_empty(cls, value: str):\n        if value:\n            return value\n        else:\n            raise ValueError(\"The empty text is not allowed.\")\n\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=self.text,\n            meta=self.meta,\n        )",
                                        "Function `text_is_not_empty`\nCode:\n    def text_is_not_empty(cls, value: str):\n        if value:\n            return value\n        else:\n            raise ValueError(\"The empty text is not allowed.\")",
                                        "Function `create`\nCode:\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=self.text,\n            meta=self.meta,\n        )",
                                        "Class `BinaryData`\nCode:\nclass BinaryData(BaseData):\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=None,\n            meta=self.meta,\n        )",
                                        "Function `create`\nCode:\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=None,\n            meta=self.meta,\n        )"
                                    ],
                                    "code": "import abc\nfrom typing import Any, Dict\n\nfrom pydantic import UUID4, BaseModel, validator\n\nfrom examples.models import Example\nfrom projects.models import Project\n\n\nclass BaseData(BaseModel, abc.ABC):\n    filename: str\n    upload_name: str\n    uuid: UUID4\n    meta: Dict[Any, Any] = {}\n\n    def __init__(self, **data):\n        super().__init__(**data)\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, filename: str, upload_name: str, text: str = \"\", **kwargs):\n        return cls(uuid=example_uuid, filename=filename, upload_name=upload_name, text=text, meta=kwargs)\n\n    def __hash__(self):\n        return hash(tuple(self.dict()))\n\n    @abc.abstractmethod\n    def create(self, project: Project) -> Example:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n\nclass TextData(BaseData):\n    text: str\n\n    @validator(\"text\")\n    def text_is_not_empty(cls, value: str):\n        if value:\n            return value\n        else:\n            raise ValueError(\"The empty text is not allowed.\")\n\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=self.text,\n            meta=self.meta,\n        )\n\n\nclass BinaryData(BaseData):\n    def create(self, project: Project) -> Example:\n        return Example(\n            uuid=self.uuid,\n            project=project,\n            filename=self.filename,\n            upload_name=self.upload_name,\n            text=None,\n            meta=self.meta,\n        )\n",
                                    "summary": "Class BaseData: An abstract model for data files that requires subclasses to implement a method for creating project examples, while providing initialization, parsing, and hashing functionalities; TextData and BinaryData are concrete implementations that validate input and create associated Example instances.",
                                    "code_element_summaries": [
                                        "Class BaseData: An abstract base model that encapsulates metadata for data files, providing methods for initialization, parsing, and hashing, while requiring subclasses to implement a method for creating project examples.",
                                        "Function `__init__`: Initializes an instance by calling the parent class's initializer with the provided keyword arguments.",
                                        "Function `parse`: A class method that creates an instance of the class using provided parameters including a UUID, filename, upload name, optional text, and additional keyword arguments.",
                                        "Function `__hash__`: Returns a hash value for the object based on its dictionary representation, allowing it to be used in hash-based collections.",
                                        "Function `create`: An abstract method that must be implemented in subclasses to create an Example associated with a given Project.",
                                        "Class `TextData`: A model that validates non-empty text and creates an Example instance associated with a project.",
                                        "Function `text_is_not_empty`: A class method that checks if a given string is non-empty and raises a ValueError if it is empty.",
                                        "Function `create`: A method that instantiates an Example object using the current instance's attributes and a provided Project.",
                                        "Class `BinaryData`: A model that facilitates the creation of `Example` instances associated with a specific project, encapsulating properties like UUID, filename, and metadata.",
                                        "Function `create`: A method that instantiates an Example object with specified attributes, including project and metadata."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "examples.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\examples.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Examples`\nCode:\nclass Examples:\n    def __init__(self, examples: List[Example]):\n        self.examples = examples\n        self.uuid_to_example: Dict[UUID4, Example] = {}\n\n    def __getitem__(self, uuid: UUID4) -> Example:\n        return self.uuid_to_example[uuid]\n\n    def __contains__(self, uuid: UUID4) -> bool:\n        return uuid in self.uuid_to_example\n\n    def save(self):\n        examples = Example.objects.bulk_create(self.examples)\n        self.uuid_to_example = {example.uuid: example for example in examples}",
                                        "Function `__init__`\nCode:\n    def __init__(self, examples: List[Example]):\n        self.examples = examples\n        self.uuid_to_example: Dict[UUID4, Example] = {}",
                                        "Function `__getitem__`\nCode:\n    def __getitem__(self, uuid: UUID4) -> Example:\n        return self.uuid_to_example[uuid]",
                                        "Function `__contains__`\nCode:\n    def __contains__(self, uuid: UUID4) -> bool:\n        return uuid in self.uuid_to_example",
                                        "Function `save`\nCode:\n    def save(self):\n        examples = Example.objects.bulk_create(self.examples)\n        self.uuid_to_example = {example.uuid: example for example in examples}"
                                    ],
                                    "code": "from typing import Dict, List\n\nfrom pydantic import UUID4\n\nfrom examples.models import Example\n\n\nclass Examples:\n    def __init__(self, examples: List[Example]):\n        self.examples = examples\n        self.uuid_to_example: Dict[UUID4, Example] = {}\n\n    def __getitem__(self, uuid: UUID4) -> Example:\n        return self.uuid_to_example[uuid]\n\n    def __contains__(self, uuid: UUID4) -> bool:\n        return uuid in self.uuid_to_example\n\n    def save(self):\n        examples = Example.objects.bulk_create(self.examples)\n        self.uuid_to_example = {example.uuid: example for example in examples}\n",
                                    "summary": "Class Examples: A container for managing Example objects that offers methods for retrieval, membership checking, and bulk saving, while initializing with a list of examples and mapping their UUIDs for efficient access.",
                                    "code_element_summaries": [
                                        "Class Examples: A container for managing a list of Example objects, providing methods for item retrieval, membership checking, and bulk saving to a database.",
                                        "Function `__init__`: Initializes an instance with a list of examples and creates a dictionary to map UUIDs to examples.",
                                        "Function `__getitem__`: Retrieves an `Example` object from the `uuid_to_example` mapping using a given UUID.",
                                        "Function `__contains__`: Checks if a given UUID is present in the `uuid_to_example` mapping.",
                                        "Function `save`: This method creates multiple Example instances in bulk and maps their UUIDs to the corresponding examples in a dictionary."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "exceptions.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\exceptions.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `FileImportException`\nCode:\nclass FileImportException(Exception):\n    def dict(self) -> Dict[str, Any]:\n        raise NotImplementedError()",
                                        "Function `dict`\nCode:\n    def dict(self) -> Dict[str, Any]:\n        raise NotImplementedError()",
                                        "Class `FileParseException`\nCode:\nclass FileParseException(FileImportException):\n    def __init__(self, filename: str, line_num: int, message: str):\n        self.filename = filename\n        self.line_num = line_num\n        self.message = message\n\n    def __str__(self):\n        return f\"ParseError: You cannot parse line {self.line_num} in {self.filename}: {self.message}\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": self.line_num, \"message\": self.message}",
                                        "Function `__init__`\nCode:\n    def __init__(self, filename: str, line_num: int, message: str):\n        self.filename = filename\n        self.line_num = line_num\n        self.message = message",
                                        "Function `__str__`\nCode:\n    def __str__(self):\n        return f\"ParseError: You cannot parse line {self.line_num} in {self.filename}: {self.message}\"",
                                        "Function `dict`\nCode:\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": self.line_num, \"message\": self.message}",
                                        "Class `MaximumFileSizeException`\nCode:\nclass MaximumFileSizeException(FileImportException):\n    def __init__(self, filename: str, max_size: int):\n        self.filename = filename\n        self.max_size = max_size\n\n    def __str__(self):\n        return f\"The maximum file size that can be uploaded is {self.max_size/1024/1024} MB\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}",
                                        "Function `__init__`\nCode:\n    def __init__(self, filename: str, max_size: int):\n        self.filename = filename\n        self.max_size = max_size",
                                        "Function `__str__`\nCode:\n    def __str__(self):\n        return f\"The maximum file size that can be uploaded is {self.max_size/1024/1024} MB\"",
                                        "Function `dict`\nCode:\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}",
                                        "Class `FileTypeException`\nCode:\nclass FileTypeException(FileImportException):\n    def __init__(self, filename: str, filetype: str, allowed_types=None):\n        self.filename = filename\n        self.filetype = filetype\n        self.allowed_types = allowed_types\n\n    def __str__(self):\n        return f\"The file type {self.filetype} is unexpected. Expected: {self.allowed_types}\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}",
                                        "Function `__init__`\nCode:\n    def __init__(self, filename: str, filetype: str, allowed_types=None):\n        self.filename = filename\n        self.filetype = filetype\n        self.allowed_types = allowed_types",
                                        "Function `__str__`\nCode:\n    def __str__(self):\n        return f\"The file type {self.filetype} is unexpected. Expected: {self.allowed_types}\"",
                                        "Function `dict`\nCode:\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}",
                                        "Class `FileFormatException`\nCode:\nclass FileFormatException(FileImportException):\n    def __init__(self, file_format: str):\n        self.file_format = file_format\n\n    def dict(self):\n        message = f\"Unknown file format: {self.file_format}\"\n        return {\"message\": message}",
                                        "Function `__init__`\nCode:\n    def __init__(self, file_format: str):\n        self.file_format = file_format",
                                        "Function `dict`\nCode:\n    def dict(self):\n        message = f\"Unknown file format: {self.file_format}\"\n        return {\"message\": message}"
                                    ],
                                    "code": "from typing import Any, Dict\n\n\nclass FileImportException(Exception):\n    def dict(self) -> Dict[str, Any]:\n        raise NotImplementedError()\n\n\nclass FileParseException(FileImportException):\n    def __init__(self, filename: str, line_num: int, message: str):\n        self.filename = filename\n        self.line_num = line_num\n        self.message = message\n\n    def __str__(self):\n        return f\"ParseError: You cannot parse line {self.line_num} in {self.filename}: {self.message}\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": self.line_num, \"message\": self.message}\n\n\nclass MaximumFileSizeException(FileImportException):\n    def __init__(self, filename: str, max_size: int):\n        self.filename = filename\n        self.max_size = max_size\n\n    def __str__(self):\n        return f\"The maximum file size that can be uploaded is {self.max_size/1024/1024} MB\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}\n\n\nclass FileTypeException(FileImportException):\n    def __init__(self, filename: str, filetype: str, allowed_types=None):\n        self.filename = filename\n        self.filetype = filetype\n        self.allowed_types = allowed_types\n\n    def __str__(self):\n        return f\"The file type {self.filetype} is unexpected. Expected: {self.allowed_types}\"\n\n    def dict(self):\n        return {\"filename\": self.filename, \"line\": -1, \"message\": str(self)}\n\n\nclass FileFormatException(FileImportException):\n    def __init__(self, file_format: str):\n        self.file_format = file_format\n\n    def dict(self):\n        message = f\"Unknown file format: {self.file_format}\"\n        return {\"message\": message}\n",
                                    "summary": "Classes and functions for custom exceptions related to file import and parsing errors, each providing methods for initialization, string representation, and dictionary representation to facilitate error handling and logging.",
                                    "code_element_summaries": [
                                        "Class FileImportException: A custom exception class that requires the implementation of a method to return a dictionary representation of the exception.",
                                        "Function `dict`: An abstract method that raises a NotImplementedError, indicating it must be implemented by subclasses to return a dictionary representation.",
                                        "Class `FileParseException`: A custom exception that captures details about file parsing errors, including the filename, line number, and an error message, and provides a string representation and a method to return the details as a dictionary.",
                                        "Function `__init__`: Initializes an instance with a filename, line number, and message for error handling or logging purposes.",
                                        "Function `__str__`: Returns a formatted string that describes a parsing error, including the line number, filename, and error message.",
                                        "Function `dict`: A method that returns a dictionary representation of an object, including its filename, line number, and message.",
                                        "Class `MaximumFileSizeException`: A custom exception that handles errors related to exceeding the maximum file size for uploads, providing a descriptive error message and a method to return its details as a dictionary.",
                                        "Function `__init__`: Initializes an instance with a specified filename and maximum size.",
                                        "Function `__str__`: Returns a string representation indicating the maximum file size that can be uploaded, expressed in megabytes.",
                                        "Function `dict`: Returns a dictionary representation of the object, including the filename and a message.",
                                        "Class FileTypeException: An exception that handles unexpected file types during file import, providing details about the filename, actual file type, and expected types in a dictionary format.",
                                        "Function `__init__`: Initializes an instance with a filename, filetype, and optional allowed types.",
                                        "Function `__str__`: Returns a formatted string indicating an unexpected file type along with the expected types.",
                                        "Function `dict`: Returns a dictionary representation of the object with its filename, a fixed line number of -1, and a string message of the object.",
                                        "Class `FileFormatException`: A custom exception class that inherits from `FileImportException`, designed to handle unknown file format errors and provide a descriptive message in dictionary form.",
                                        "Function `__init__`: Initializes an instance with a specified file format.",
                                        "Function `dict`: Returns a dictionary containing an error message for an unknown file format."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "factories.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\factories.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `create_parser`\nCode:\ndef create_parser(file_format: Format, **kwargs):\n    mapping = {\n        TextFile.name: TextFileParser,\n        TextLine.name: LineParser,\n        CSV.name: CSVParser,\n        JSONL.name: JSONLParser,\n        JSON.name: JSONParser,\n        FastText.name: FastTextParser,\n        Excel.name: ExcelParser,\n        CoNLL.name: CoNLLParser,\n        ImageFile.name: PlainParser,\n        AudioFile.name: PlainParser,\n    }\n    return mapping[file_format.name](**kwargs)"
                                    ],
                                    "code": "from .catalog import (\n    CSV,\n    JSON,\n    JSONL,\n    AudioFile,\n    CoNLL,\n    Excel,\n    FastText,\n    Format,\n    ImageFile,\n    TextFile,\n    TextLine,\n)\nfrom .parsers import (\n    CoNLLParser,\n    CSVParser,\n    ExcelParser,\n    FastTextParser,\n    JSONLParser,\n    JSONParser,\n    LineParser,\n    PlainParser,\n    TextFileParser,\n)\n\n\ndef create_parser(file_format: Format, **kwargs):\n    mapping = {\n        TextFile.name: TextFileParser,\n        TextLine.name: LineParser,\n        CSV.name: CSVParser,\n        JSONL.name: JSONLParser,\n        JSON.name: JSONParser,\n        FastText.name: FastTextParser,\n        Excel.name: ExcelParser,\n        CoNLL.name: CoNLLParser,\n        ImageFile.name: PlainParser,\n        AudioFile.name: PlainParser,\n    }\n    return mapping[file_format.name](**kwargs)\n",
                                    "summary": "Function `create_parser`: A function that selects and returns the suitable parser class according to the given file format.",
                                    "code_element_summaries": [
                                        "Function `create_parser`: A function that returns the appropriate parser class based on the specified file format."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "label.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\label.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Label`\nCode:\nclass Label(BaseModel, abc.ABC):\n    id: int = -1\n    uuid: UUID4\n    example_uuid: UUID4\n\n    def __init__(self, **data):\n        data[\"uuid\"] = uuid.uuid4()\n        super().__init__(**data)\n\n    @abc.abstractmethod\n    def __lt__(self, other):\n        return NotImplemented\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def create(self, user, example: Example, types: LabelTypes, **kwargs) -> LabelModel:\n        raise NotImplementedError\n\n    def __hash__(self):\n        return hash(tuple(self.dict()))",
                                        "Function `__init__`\nCode:\n    def __init__(self, **data):\n        data[\"uuid\"] = uuid.uuid4()\n        super().__init__(**data)",
                                        "Function `__lt__`\nCode:\n    def __lt__(self, other):\n        return NotImplemented",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        raise NotImplementedError()",
                                        "Function `create_type`\nCode:\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        raise NotImplementedError()",
                                        "Function `create`\nCode:\n    def create(self, user, example: Example, types: LabelTypes, **kwargs) -> LabelModel:\n        raise NotImplementedError",
                                        "Function `__hash__`\nCode:\n    def __hash__(self):\n        return hash(tuple(self.dict()))",
                                        "Class `CategoryLabel`\nCode:\nclass CategoryLabel(Label):\n    label: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.label < other.label\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, label=obj)  # type: ignore\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return CategoryType(text=self.label, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return CategoryModel(uuid=self.uuid, user=user, example=example, label=types[self.label])",
                                        "Function `__lt__`\nCode:\n    def __lt__(self, other):\n        return self.label < other.label",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, label=obj)  # type: ignore",
                                        "Function `create_type`\nCode:\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return CategoryType(text=self.label, project=project)",
                                        "Function `create`\nCode:\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return CategoryModel(uuid=self.uuid, user=user, example=example, label=types[self.label])",
                                        "Class `SpanLabel`\nCode:\nclass SpanLabel(Label):\n    label: constr(min_length=1)  # type: ignore\n    start_offset: NonNegativeInt\n    end_offset: NonNegativeInt\n\n    def __lt__(self, other):\n        return self.start_offset < other.start_offset\n\n    @root_validator(skip_on_failure=True)\n    def check_start_offset_is_less_than_end_offset(cls, values):\n        start_offset, end_offset = values.get(\"start_offset\"), values.get(\"end_offset\")\n        if start_offset >= end_offset:\n            raise ValueError(\"start_offset must be less than end_offset.\")\n        return values\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        if isinstance(obj, list) or isinstance(obj, tuple):\n            columns = [\"start_offset\", \"end_offset\", \"label\"]\n            obj = zip(columns, obj)\n            return cls(example_uuid=example_uuid, **dict(obj))\n        elif isinstance(obj, dict):\n            return cls(example_uuid=example_uuid, **obj)\n        raise ValueError(\"SpanLabel.parse()\")\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return SpanType(text=self.label, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return SpanModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            start_offset=self.start_offset,\n            end_offset=self.end_offset,\n            label=types[self.label],\n        )",
                                        "Function `__lt__`\nCode:\n    def __lt__(self, other):\n        return self.start_offset < other.start_offset",
                                        "Function `check_start_offset_is_less_than_end_offset`\nCode:\n    def check_start_offset_is_less_than_end_offset(cls, values):\n        start_offset, end_offset = values.get(\"start_offset\"), values.get(\"end_offset\")\n        if start_offset >= end_offset:\n            raise ValueError(\"start_offset must be less than end_offset.\")\n        return values",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        if isinstance(obj, list) or isinstance(obj, tuple):\n            columns = [\"start_offset\", \"end_offset\", \"label\"]\n            obj = zip(columns, obj)\n            return cls(example_uuid=example_uuid, **dict(obj))\n        elif isinstance(obj, dict):\n            return cls(example_uuid=example_uuid, **obj)\n        raise ValueError(\"SpanLabel.parse()\")",
                                        "Function `create_type`\nCode:\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return SpanType(text=self.label, project=project)",
                                        "Function `create`\nCode:\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return SpanModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            start_offset=self.start_offset,\n            end_offset=self.end_offset,\n            label=types[self.label],\n        )",
                                        "Class `TextLabel`\nCode:\nclass TextLabel(Label):\n    text: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.text < other.text\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, text=obj)  # type: ignore\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return None\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return TextLabelModel(uuid=self.uuid, user=user, example=example, text=self.text)",
                                        "Function `__lt__`\nCode:\n    def __lt__(self, other):\n        return self.text < other.text",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, text=obj)  # type: ignore",
                                        "Function `create_type`\nCode:\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return None",
                                        "Function `create`\nCode:\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return TextLabelModel(uuid=self.uuid, user=user, example=example, text=self.text)",
                                        "Class `RelationLabel`\nCode:\nclass RelationLabel(Label):\n    from_id: int\n    to_id: int\n    type: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.from_id < other.from_id\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, **obj)\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return RelationType(text=self.type, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return RelationModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            type=types[self.type],\n            from_id=kwargs[\"id_to_span\"][(self.from_id, str(self.example_uuid))],\n            to_id=kwargs[\"id_to_span\"][(self.to_id, str(self.example_uuid))],\n        )",
                                        "Function `__lt__`\nCode:\n    def __lt__(self, other):\n        return self.from_id < other.from_id",
                                        "Function `parse`\nCode:\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, **obj)",
                                        "Function `create_type`\nCode:\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return RelationType(text=self.type, project=project)",
                                        "Function `create`\nCode:\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return RelationModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            type=types[self.type],\n            from_id=kwargs[\"id_to_span\"][(self.from_id, str(self.example_uuid))],\n            to_id=kwargs[\"id_to_span\"][(self.to_id, str(self.example_uuid))],\n        )"
                                    ],
                                    "code": "import abc\nimport uuid\nfrom typing import Any, Optional\n\nfrom pydantic import UUID4, BaseModel, NonNegativeInt, constr, root_validator\n\nfrom .label_types import LabelTypes\nfrom examples.models import Example\nfrom label_types.models import CategoryType, LabelType, RelationType, SpanType\nfrom labels.models import Category as CategoryModel\nfrom labels.models import Label as LabelModel\nfrom labels.models import Relation as RelationModel\nfrom labels.models import Span as SpanModel\nfrom labels.models import TextLabel as TextLabelModel\nfrom projects.models import Project\n\n\nclass Label(BaseModel, abc.ABC):\n    id: int = -1\n    uuid: UUID4\n    example_uuid: UUID4\n\n    def __init__(self, **data):\n        data[\"uuid\"] = uuid.uuid4()\n        super().__init__(**data)\n\n    @abc.abstractmethod\n    def __lt__(self, other):\n        return NotImplemented\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def create(self, user, example: Example, types: LabelTypes, **kwargs) -> LabelModel:\n        raise NotImplementedError\n\n    def __hash__(self):\n        return hash(tuple(self.dict()))\n\n\nclass CategoryLabel(Label):\n    label: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.label < other.label\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, label=obj)  # type: ignore\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return CategoryType(text=self.label, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return CategoryModel(uuid=self.uuid, user=user, example=example, label=types[self.label])\n\n\nclass SpanLabel(Label):\n    label: constr(min_length=1)  # type: ignore\n    start_offset: NonNegativeInt\n    end_offset: NonNegativeInt\n\n    def __lt__(self, other):\n        return self.start_offset < other.start_offset\n\n    @root_validator(skip_on_failure=True)\n    def check_start_offset_is_less_than_end_offset(cls, values):\n        start_offset, end_offset = values.get(\"start_offset\"), values.get(\"end_offset\")\n        if start_offset >= end_offset:\n            raise ValueError(\"start_offset must be less than end_offset.\")\n        return values\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        if isinstance(obj, list) or isinstance(obj, tuple):\n            columns = [\"start_offset\", \"end_offset\", \"label\"]\n            obj = zip(columns, obj)\n            return cls(example_uuid=example_uuid, **dict(obj))\n        elif isinstance(obj, dict):\n            return cls(example_uuid=example_uuid, **obj)\n        raise ValueError(\"SpanLabel.parse()\")\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return SpanType(text=self.label, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return SpanModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            start_offset=self.start_offset,\n            end_offset=self.end_offset,\n            label=types[self.label],\n        )\n\n\nclass TextLabel(Label):\n    text: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.text < other.text\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, text=obj)  # type: ignore\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return None\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return TextLabelModel(uuid=self.uuid, user=user, example=example, text=self.text)\n\n\nclass RelationLabel(Label):\n    from_id: int\n    to_id: int\n    type: constr(min_length=1)  # type: ignore\n\n    def __lt__(self, other):\n        return self.from_id < other.from_id\n\n    @classmethod\n    def parse(cls, example_uuid: UUID4, obj: Any):\n        return cls(example_uuid=example_uuid, **obj)\n\n    def create_type(self, project: Project) -> Optional[LabelType]:\n        return RelationType(text=self.type, project=project)\n\n    def create(self, user, example: Example, types: LabelTypes, **kwargs):\n        return RelationModel(\n            uuid=self.uuid,\n            user=user,\n            example=example,\n            type=types[self.type],\n            from_id=kwargs[\"id_to_span\"][(self.from_id, str(self.example_uuid))],\n            to_id=kwargs[\"id_to_span\"][(self.to_id, str(self.example_uuid))],\n        )\n",
                                    "summary": "The content describes a hierarchy of label annotation classes, including an abstract base class `Label` and its subclasses `CategoryLabel`, `SpanLabel`, `TextLabel`, and `RelationLabel`, each implementing methods for comparison, parsing, and creation of label types and instances, while ensuring unique identification through UUIDs.",
                                    "code_element_summaries": [
                                        "Class `Label`: An abstract base model that defines a structure for label annotations, requiring implementations for comparison, parsing, and creation methods while automatically generating a UUID upon initialization.",
                                        "Function `__init__`: A constructor that initializes an object with a unique UUID and any additional data provided.",
                                        "Function `__lt__`: A method that defines the less-than comparison for instances, returning `NotImplemented` to indicate that the operation is not supported.",
                                        "Function `parse`: An abstract method in a class that requires implementation to process an object associated with a given UUID.",
                                        "Function `create_type`: An abstract method intended to be implemented in subclasses for creating a LabelType associated with a given Project.",
                                        "Function `create`: An abstract method intended to be implemented for creating a LabelModel based on a user, an example, and label types, but currently raises a NotImplementedError.",
                                        "Function `__hash__`: Returns a hash value for the object by converting its dictionary representation into a tuple.",
                                        "Class CategoryLabel: A subclass of Label that represents category labels with comparison functionality, parsing capabilities, and methods for creating associated label types and models.",
                                        "Function `__lt__`: Defines a less-than comparison method for objects based on their label attribute.",
                                        "Function `parse`: A class method that creates an instance of the class using a provided UUID and an object as a label.",
                                        "Function `create_type`: A method that creates and returns a `CategoryType` instance associated with a given project based on the label.",
                                        "Function `create`: A method that instantiates a CategoryModel with specified user, example, and label type, while using the current object's UUID.",
                                        "Class `SpanLabel`: A model that represents a labeled span with start and end offsets, including validation and methods for parsing and creating label types and instances.",
                                        "Function `__lt__`: A method that compares two objects based on their `start_offset` values to determine if the current object is less than the other.",
                                        "Function `check_start_offset_is_less_than_end_offset`: A class method that validates that the `start_offset` is less than the `end_offset`, raising a ValueError if the condition is not met.",
                                        "Function `parse`: A class method that constructs an instance of the class from a list, tuple, or dictionary representation of span label data, raising a ValueError for unsupported formats.",
                                        "Function `create_type`: Creates a `SpanType` instance with the specified label and associated project, returning it as an optional `LabelType`.",
                                        "Function `create`: A method that generates a new SpanModel instance using provided user, example, label types, and additional keyword arguments.",
                                        "Class TextLabel: A specialized label class that includes text validation, comparison, and methods for parsing and creating label instances.",
                                        "Function `__lt__`: A method that defines the less-than comparison between two objects based on their text attributes.",
                                        "Function `parse`: A class method that creates an instance of the class using a UUID and an object as parameters.",
                                        "Function `create_type`: A method that takes a Project object as an argument and returns None, indicating that no LabelType is created.",
                                        "Function `create`: A method that generates a new TextLabelModel instance using the provided user, example, label types, and additional keyword arguments.",
                                        "Class `RelationLabel`: A model that represents a labeled relation between two entities, providing methods for comparison, parsing, and creating relation instances in a project.",
                                        "Function `__lt__`: A method that compares two objects based on their `from_id` attribute to determine if the current object is less than the other.",
                                        "Function `parse`: A class method that constructs an instance of the class using a UUID and a dictionary of attributes.",
                                        "Function `create_type`: A method that creates and returns a `RelationType` object associated with a specified project.",
                                        "Function `create`: A method that generates a RelationModel instance using user data, an example, label types, and additional keyword arguments to establish relationships between spans."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "labels.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\labels.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Labels`\nCode:\nclass Labels(abc.ABC):\n    label_model = LabelModel\n\n    def __init__(self, labels: List[Label], types: LabelTypes):\n        self.labels = labels\n        self.types = types\n\n    def __len__(self) -> int:\n        return len(self.labels)\n\n    def clean(self, project: Project):\n        pass\n\n    def save_types(self, project: Project):\n        types = [label.create_type(project) for label in self.labels]\n        filtered_types = list(filter(None, types))\n        self.types.save(filtered_types)\n        self.types.update(project)\n\n    def save(self, user, examples: Examples, **kwargs):\n        labels = [\n            label.create(user, examples[label.example_uuid], self.types, **kwargs)\n            for label in self.labels\n            if label.example_uuid in examples\n        ]\n        self.label_model.objects.bulk_create(labels)",
                                        "Function `__init__`\nCode:\n    def __init__(self, labels: List[Label], types: LabelTypes):\n        self.labels = labels\n        self.types = types",
                                        "Function `__len__`\nCode:\n    def __len__(self) -> int:\n        return len(self.labels)",
                                        "Function `clean`\nCode:\n    def clean(self, project: Project):\n        pass",
                                        "Function `save_types`\nCode:\n    def save_types(self, project: Project):\n        types = [label.create_type(project) for label in self.labels]\n        filtered_types = list(filter(None, types))\n        self.types.save(filtered_types)\n        self.types.update(project)",
                                        "Function `save`\nCode:\n    def save(self, user, examples: Examples, **kwargs):\n        labels = [\n            label.create(user, examples[label.example_uuid], self.types, **kwargs)\n            for label in self.labels\n            if label.example_uuid in examples\n        ]\n        self.label_model.objects.bulk_create(labels)",
                                        "Class `Categories`\nCode:\nclass Categories(Labels):\n    label_model = CategoryModel\n\n    def clean(self, project: Project):\n        exclusive = getattr(project, \"single_class_classification\", False)\n        if exclusive:\n            groups = groupby(self.labels, lambda label: label.example_uuid)\n            self.labels = [next(group) for _, group in groups]",
                                        "Function `clean`\nCode:\n    def clean(self, project: Project):\n        exclusive = getattr(project, \"single_class_classification\", False)\n        if exclusive:\n            groups = groupby(self.labels, lambda label: label.example_uuid)\n            self.labels = [next(group) for _, group in groups]",
                                        "Class `Spans`\nCode:\nclass Spans(Labels):\n    label_model = SpanModel\n\n    def clean(self, project: Project):\n        allow_overlapping = getattr(project, \"allow_overlapping\", False)\n        if allow_overlapping:\n            return\n        spans = []\n        groups = groupby(self.labels, lambda label: label.example_uuid)\n        for _, group in groups:\n            labels = sorted(group)\n            last_offset = -1\n            for label in labels:\n                if getattr(label, \"start_offset\") >= last_offset:\n                    last_offset = getattr(label, \"end_offset\")\n                    spans.append(label)\n        self.labels = spans\n\n    @property\n    def id_to_span(self) -> Dict[Tuple[int, str], SpanModel]:\n        uuids = [str(span.uuid) for span in self.labels]\n        spans = SpanModel.objects.filter(uuid__in=uuids)\n        uuid_to_span = {span.uuid: span for span in spans}\n        return {(span.id, str(span.example_uuid)): uuid_to_span[span.uuid] for span in self.labels}",
                                        "Function `clean`\nCode:\n    def clean(self, project: Project):\n        allow_overlapping = getattr(project, \"allow_overlapping\", False)\n        if allow_overlapping:\n            return\n        spans = []\n        groups = groupby(self.labels, lambda label: label.example_uuid)\n        for _, group in groups:\n            labels = sorted(group)\n            last_offset = -1\n            for label in labels:\n                if getattr(label, \"start_offset\") >= last_offset:\n                    last_offset = getattr(label, \"end_offset\")\n                    spans.append(label)\n        self.labels = spans",
                                        "Function `id_to_span`\nCode:\n    def id_to_span(self) -> Dict[Tuple[int, str], SpanModel]:\n        uuids = [str(span.uuid) for span in self.labels]\n        spans = SpanModel.objects.filter(uuid__in=uuids)\n        uuid_to_span = {span.uuid: span for span in spans}\n        return {(span.id, str(span.example_uuid)): uuid_to_span[span.uuid] for span in self.labels}",
                                        "Class `Texts`\nCode:\nclass Texts(Labels):\n    label_model = TextLabelModel",
                                        "Class `Relations`\nCode:\nclass Relations(Labels):\n    label_model = RelationModel\n\n    def save(self, user, examples: Examples, **kwargs):\n        id_to_span = kwargs[\"spans\"].id_to_span\n        super().save(user, examples, id_to_span=id_to_span)",
                                        "Function `save`\nCode:\n    def save(self, user, examples: Examples, **kwargs):\n        id_to_span = kwargs[\"spans\"].id_to_span\n        super().save(user, examples, id_to_span=id_to_span)"
                                    ],
                                    "code": "import abc\nfrom itertools import groupby\nfrom typing import Dict, List, Tuple\n\nfrom .examples import Examples\nfrom .label import Label\nfrom .label_types import LabelTypes\nfrom labels.models import Category as CategoryModel\nfrom labels.models import Label as LabelModel\nfrom labels.models import Relation as RelationModel\nfrom labels.models import Span as SpanModel\nfrom labels.models import TextLabel as TextLabelModel\nfrom projects.models import Project\n\n\nclass Labels(abc.ABC):\n    label_model = LabelModel\n\n    def __init__(self, labels: List[Label], types: LabelTypes):\n        self.labels = labels\n        self.types = types\n\n    def __len__(self) -> int:\n        return len(self.labels)\n\n    def clean(self, project: Project):\n        pass\n\n    def save_types(self, project: Project):\n        types = [label.create_type(project) for label in self.labels]\n        filtered_types = list(filter(None, types))\n        self.types.save(filtered_types)\n        self.types.update(project)\n\n    def save(self, user, examples: Examples, **kwargs):\n        labels = [\n            label.create(user, examples[label.example_uuid], self.types, **kwargs)\n            for label in self.labels\n            if label.example_uuid in examples\n        ]\n        self.label_model.objects.bulk_create(labels)\n\n\nclass Categories(Labels):\n    label_model = CategoryModel\n\n    def clean(self, project: Project):\n        exclusive = getattr(project, \"single_class_classification\", False)\n        if exclusive:\n            groups = groupby(self.labels, lambda label: label.example_uuid)\n            self.labels = [next(group) for _, group in groups]\n\n\nclass Spans(Labels):\n    label_model = SpanModel\n\n    def clean(self, project: Project):\n        allow_overlapping = getattr(project, \"allow_overlapping\", False)\n        if allow_overlapping:\n            return\n        spans = []\n        groups = groupby(self.labels, lambda label: label.example_uuid)\n        for _, group in groups:\n            labels = sorted(group)\n            last_offset = -1\n            for label in labels:\n                if getattr(label, \"start_offset\") >= last_offset:\n                    last_offset = getattr(label, \"end_offset\")\n                    spans.append(label)\n        self.labels = spans\n\n    @property\n    def id_to_span(self) -> Dict[Tuple[int, str], SpanModel]:\n        uuids = [str(span.uuid) for span in self.labels]\n        spans = SpanModel.objects.filter(uuid__in=uuids)\n        uuid_to_span = {span.uuid: span for span in spans}\n        return {(span.id, str(span.example_uuid)): uuid_to_span[span.uuid] for span in self.labels}\n\n\nclass Texts(Labels):\n    label_model = TextLabelModel\n\n\nclass Relations(Labels):\n    label_model = RelationModel\n\n    def save(self, user, examples: Examples, **kwargs):\n        id_to_span = kwargs[\"spans\"].id_to_span\n        super().save(user, examples, id_to_span=id_to_span)\n",
                                    "summary": "Class Labels: An abstract base class for managing label annotations with methods for initialization, length calculation, validation, and bulk creation, along with subclasses Categories, Spans, Texts, and Relations that implement specific functionalities for single class classification, non-overlapping span management, and relation annotations.",
                                    "code_element_summaries": [
                                        "Class `Labels`: An abstract base class that manages a collection of label annotations, providing methods for cleaning, saving types, and bulk creating label instances in a project.",
                                        "Function `__init__`: Initializes an instance with a list of labels and their corresponding types.",
                                        "Function `__len__`: A method that returns the number of labels in the object by calculating the length of the `labels` attribute.",
                                        "Function `clean`: A placeholder method intended for cleaning or validating a `Project` instance, currently without implementation.",
                                        "Function `save_types`: Saves and updates the types of labels associated with a project by filtering out any None values from the created types.",
                                        "Function `save`: A method that creates and saves label instances for provided examples, filtering based on example UUIDs and using bulk creation for efficiency.",
                                        "Class Categories: A subclass of Labels that enforces single class classification by cleaning labels based on their example UUIDs.",
                                        "Function `clean`: A method that modifies the labels of a project by ensuring only one label per example UUID when single class classification is enabled.",
                                        "Class `Spans`: A model that manages span annotations, ensuring non-overlapping labels and providing a mapping of span IDs to their corresponding SpanModel instances.",
                                        "Function `clean`: A method that filters overlapping labels from a project based on their start and end offsets, maintaining only non-overlapping spans when overlapping is not allowed.",
                                        "Function `id_to_span`: Retrieves a dictionary mapping tuples of span IDs and example UUIDs to their corresponding SpanModel instances based on the UUIDs of the labels.",
                                        "Class Texts: A subclass of Labels that specifies the label model as TextLabelModel.",
                                        "Class Relations: A subclass of Labels that saves relation annotations, utilizing a specified label model and including span information during the save process.",
                                        "Function `save`: A method that overrides the parent class's save function to include additional span information when saving user and example data."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "label_types.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\label_types.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `LabelTypes`\nCode:\nclass LabelTypes:\n    def __init__(self, label_type_class: Type[LabelType]):\n        self.types: Dict[str, LabelType] = {}\n        self.label_type_class = label_type_class\n\n    def __contains__(self, text: str) -> bool:\n        return text in self.types\n\n    def __getitem__(self, text: str) -> LabelType:\n        return self.types[text]\n\n    def save(self, label_types: List[LabelType]):\n        self.label_type_class.objects.bulk_create(label_types, ignore_conflicts=True)\n\n    def update(self, project: Project):\n        types = self.label_type_class.objects.filter(project=project)\n        self.types = {label_type.text: label_type for label_type in types}",
                                        "Function `__init__`\nCode:\n    def __init__(self, label_type_class: Type[LabelType]):\n        self.types: Dict[str, LabelType] = {}\n        self.label_type_class = label_type_class",
                                        "Function `__contains__`\nCode:\n    def __contains__(self, text: str) -> bool:\n        return text in self.types",
                                        "Function `__getitem__`\nCode:\n    def __getitem__(self, text: str) -> LabelType:\n        return self.types[text]",
                                        "Function `save`\nCode:\n    def save(self, label_types: List[LabelType]):\n        self.label_type_class.objects.bulk_create(label_types, ignore_conflicts=True)",
                                        "Function `update`\nCode:\n    def update(self, project: Project):\n        types = self.label_type_class.objects.filter(project=project)\n        self.types = {label_type.text: label_type for label_type in types}"
                                    ],
                                    "code": "from typing import Dict, List, Type\n\nfrom label_types.models import LabelType\nfrom projects.models import Project\n\n\nclass LabelTypes:\n    def __init__(self, label_type_class: Type[LabelType]):\n        self.types: Dict[str, LabelType] = {}\n        self.label_type_class = label_type_class\n\n    def __contains__(self, text: str) -> bool:\n        return text in self.types\n\n    def __getitem__(self, text: str) -> LabelType:\n        return self.types[text]\n\n    def save(self, label_types: List[LabelType]):\n        self.label_type_class.objects.bulk_create(label_types, ignore_conflicts=True)\n\n    def update(self, project: Project):\n        types = self.label_type_class.objects.filter(project=project)\n        self.types = {label_type.text: label_type for label_type in types}\n",
                                    "summary": "Class LabelTypes: A manager for label types that facilitates checking existence, retrieving, saving, and updating label types linked to a project, with methods for initialization, containment checks, item retrieval, bulk saving, and updating.",
                                    "code_element_summaries": [
                                        "Class LabelTypes: A manager for handling label types that allows for checking existence, retrieving items, saving, and updating label types associated with a project.",
                                        "Function `__init__`: Initializes an instance with an empty dictionary for storing label types and a specified label type class.",
                                        "Function `__contains__`: Checks if a given text is present in the types collection, returning a boolean result.",
                                        "Function `__getitem__`: Retrieves a `LabelType` from the `types` dictionary using the provided string `text` as the key.",
                                        "Function `save`: A method that bulk creates label types in the database while ignoring any conflicts.",
                                        "Function `update`: Updates the `types` attribute by filtering label types associated with a given project and storing them in a dictionary with the label type text as keys."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "makers.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\makers.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ExampleMaker`\nCode:\nclass ExampleMaker:\n    def __init__(\n        self,\n        project: Project,\n        data_class: Type[BaseData],\n        column_data: str = DEFAULT_TEXT_COLUMN,\n        exclude_columns: Optional[List[str]] = None,\n    ):\n        self.project = project\n        self.data_class = data_class\n        self.column_data = column_data\n        self.exclude_columns = exclude_columns or []\n        self._errors: List[FileParseException] = []\n\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        if not self.check_column_existence(df):\n            return []\n        self.check_value_existence(df)\n        # make dataframe without exclude columns and missing data\n        df_with_data_column = df.loc[:, ~df.columns.isin(self.exclude_columns)]\n        df_with_data_column = df_with_data_column.dropna(subset=[self.column_data])\n\n        examples = []\n        for row in df_with_data_column.to_dict(orient=\"records\"):\n            line_num = row.pop(LINE_NUMBER_COLUMN, 0)\n            row[DEFAULT_TEXT_COLUMN] = row.pop(self.column_data)  # Rename column for parsing\n            try:\n                data = self.data_class.parse(**row)\n                example = data.create(self.project)\n                examples.append(example)\n            except ValueError:\n                message = f\"Invalid data in line {line_num}\"\n                error = FileParseException(row[UPLOAD_NAME_COLUMN], line_num, message)\n                self._errors.append(error)\n        return examples\n\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column_data} not found in the file\"\n        if self.column_data not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True\n\n    def check_value_existence(self, df: pd.DataFrame):\n        df_without_data_column = df[df[self.column_data].isnull()]\n        for row in df_without_data_column.to_dict(orient=\"records\"):\n            message = f\"Column {self.column_data} not found in record\"\n            error = FileParseException(row[UPLOAD_NAME_COLUMN], row.get(LINE_NUMBER_COLUMN, 0), message)\n            self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors",
                                        "Function `__init__`\nCode:\n    def __init__(\n        self,\n        project: Project,\n        data_class: Type[BaseData],\n        column_data: str = DEFAULT_TEXT_COLUMN,\n        exclude_columns: Optional[List[str]] = None,\n    ):\n        self.project = project\n        self.data_class = data_class\n        self.column_data = column_data\n        self.exclude_columns = exclude_columns or []\n        self._errors: List[FileParseException] = []",
                                        "Function `make`\nCode:\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        if not self.check_column_existence(df):\n            return []\n        self.check_value_existence(df)\n        # make dataframe without exclude columns and missing data\n        df_with_data_column = df.loc[:, ~df.columns.isin(self.exclude_columns)]\n        df_with_data_column = df_with_data_column.dropna(subset=[self.column_data])\n\n        examples = []\n        for row in df_with_data_column.to_dict(orient=\"records\"):\n            line_num = row.pop(LINE_NUMBER_COLUMN, 0)\n            row[DEFAULT_TEXT_COLUMN] = row.pop(self.column_data)  # Rename column for parsing\n            try:\n                data = self.data_class.parse(**row)\n                example = data.create(self.project)\n                examples.append(example)\n            except ValueError:\n                message = f\"Invalid data in line {line_num}\"\n                error = FileParseException(row[UPLOAD_NAME_COLUMN], line_num, message)\n                self._errors.append(error)\n        return examples",
                                        "Function `check_column_existence`\nCode:\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column_data} not found in the file\"\n        if self.column_data not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True",
                                        "Function `check_value_existence`\nCode:\n    def check_value_existence(self, df: pd.DataFrame):\n        df_without_data_column = df[df[self.column_data].isnull()]\n        for row in df_without_data_column.to_dict(orient=\"records\"):\n            message = f\"Column {self.column_data} not found in record\"\n            error = FileParseException(row[UPLOAD_NAME_COLUMN], row.get(LINE_NUMBER_COLUMN, 0), message)\n            self._errors.append(error)",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors",
                                        "Class `BinaryExampleMaker`\nCode:\nclass BinaryExampleMaker(ExampleMaker):\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        examples = []\n        for row in df.to_dict(orient=\"records\"):\n            data = self.data_class.parse(**row)\n            example = data.create(self.project)\n            examples.append(example)\n        return examples",
                                        "Function `make`\nCode:\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        examples = []\n        for row in df.to_dict(orient=\"records\"):\n            data = self.data_class.parse(**row)\n            example = data.create(self.project)\n            examples.append(example)\n        return examples",
                                        "Class `LabelMaker`\nCode:\nclass LabelMaker:\n    def __init__(self, column: str, label_class: Type[Label]):\n        self.column = column\n        self.label_class = label_class\n        self._errors: List[FileParseException] = []\n\n    def make(self, df: pd.DataFrame) -> List[Label]:\n        if not self.check_column_existence(df):\n            return []\n\n        df_label = df.explode(self.column)\n        df_label = df_label[[UUID_COLUMN, self.column]]\n        df_label.dropna(subset=[self.column], inplace=True)\n        labels = []\n        for row in df_label.to_dict(orient=\"records\"):\n            try:\n                label = self.label_class.parse(row[UUID_COLUMN], row[self.column])\n                labels.append(label)\n            except ValueError:\n                pass\n        return labels\n\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column} not found in the file\"\n        if self.column not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors",
                                        "Function `__init__`\nCode:\n    def __init__(self, column: str, label_class: Type[Label]):\n        self.column = column\n        self.label_class = label_class\n        self._errors: List[FileParseException] = []",
                                        "Function `make`\nCode:\n    def make(self, df: pd.DataFrame) -> List[Label]:\n        if not self.check_column_existence(df):\n            return []\n\n        df_label = df.explode(self.column)\n        df_label = df_label[[UUID_COLUMN, self.column]]\n        df_label.dropna(subset=[self.column], inplace=True)\n        labels = []\n        for row in df_label.to_dict(orient=\"records\"):\n            try:\n                label = self.label_class.parse(row[UUID_COLUMN], row[self.column])\n                labels.append(label)\n            except ValueError:\n                pass\n        return labels",
                                        "Function `check_column_existence`\nCode:\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column} not found in the file\"\n        if self.column not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors"
                                    ],
                                    "code": "from typing import List, Optional, Type\n\nimport pandas as pd\n\nfrom .data import BaseData\nfrom .exceptions import FileParseException\nfrom .label import Label\nfrom .readers import (\n    DEFAULT_TEXT_COLUMN,\n    LINE_NUMBER_COLUMN,\n    UPLOAD_NAME_COLUMN,\n    UUID_COLUMN,\n)\nfrom examples.models import Example\nfrom projects.models import Project\n\n\nclass ExampleMaker:\n    def __init__(\n        self,\n        project: Project,\n        data_class: Type[BaseData],\n        column_data: str = DEFAULT_TEXT_COLUMN,\n        exclude_columns: Optional[List[str]] = None,\n    ):\n        self.project = project\n        self.data_class = data_class\n        self.column_data = column_data\n        self.exclude_columns = exclude_columns or []\n        self._errors: List[FileParseException] = []\n\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        if not self.check_column_existence(df):\n            return []\n        self.check_value_existence(df)\n        # make dataframe without exclude columns and missing data\n        df_with_data_column = df.loc[:, ~df.columns.isin(self.exclude_columns)]\n        df_with_data_column = df_with_data_column.dropna(subset=[self.column_data])\n\n        examples = []\n        for row in df_with_data_column.to_dict(orient=\"records\"):\n            line_num = row.pop(LINE_NUMBER_COLUMN, 0)\n            row[DEFAULT_TEXT_COLUMN] = row.pop(self.column_data)  # Rename column for parsing\n            try:\n                data = self.data_class.parse(**row)\n                example = data.create(self.project)\n                examples.append(example)\n            except ValueError:\n                message = f\"Invalid data in line {line_num}\"\n                error = FileParseException(row[UPLOAD_NAME_COLUMN], line_num, message)\n                self._errors.append(error)\n        return examples\n\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column_data} not found in the file\"\n        if self.column_data not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True\n\n    def check_value_existence(self, df: pd.DataFrame):\n        df_without_data_column = df[df[self.column_data].isnull()]\n        for row in df_without_data_column.to_dict(orient=\"records\"):\n            message = f\"Column {self.column_data} not found in record\"\n            error = FileParseException(row[UPLOAD_NAME_COLUMN], row.get(LINE_NUMBER_COLUMN, 0), message)\n            self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors\n\n\nclass BinaryExampleMaker(ExampleMaker):\n    def make(self, df: pd.DataFrame) -> List[Example]:\n        examples = []\n        for row in df.to_dict(orient=\"records\"):\n            data = self.data_class.parse(**row)\n            example = data.create(self.project)\n            examples.append(example)\n        return examples\n\n\nclass LabelMaker:\n    def __init__(self, column: str, label_class: Type[Label]):\n        self.column = column\n        self.label_class = label_class\n        self._errors: List[FileParseException] = []\n\n    def make(self, df: pd.DataFrame) -> List[Label]:\n        if not self.check_column_existence(df):\n            return []\n\n        df_label = df.explode(self.column)\n        df_label = df_label[[UUID_COLUMN, self.column]]\n        df_label.dropna(subset=[self.column], inplace=True)\n        labels = []\n        for row in df_label.to_dict(orient=\"records\"):\n            try:\n                label = self.label_class.parse(row[UUID_COLUMN], row[self.column])\n                labels.append(label)\n            except ValueError:\n                pass\n        return labels\n\n    def check_column_existence(self, df: pd.DataFrame) -> bool:\n        message = f\"Column {self.column} not found in the file\"\n        if self.column not in df.columns:\n            for filename in df[UPLOAD_NAME_COLUMN].unique():\n                self._errors.append(FileParseException(filename, 0, message))\n            return False\n        return True\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        self._errors.sort(key=lambda error: error.line_num)\n        return self._errors\n",
                                    "summary": "Classes `ExampleMaker`, `BinaryExampleMaker`, and `LabelMaker`: Utility classes for creating examples and labels from a DataFrame, featuring error handling for missing columns and values, and methods for parsing and validating data into structured objects.",
                                    "code_element_summaries": [
                                        "Class `ExampleMaker`: A utility class for creating examples from a DataFrame, ensuring the presence of required columns and handling errors during data parsing.",
                                        "Function `__init__`: Initializes an instance with project, data class, column data, and optional excluded columns, while also preparing a list for errors.",
                                        "Function `make`: Creates a list of `Example` objects from a DataFrame by checking column existence, filtering out excluded columns and missing data, and handling potential parsing errors.",
                                        "Function `check_column_existence`: Checks if a specified column exists in a DataFrame and appends an error message for each unique filename if the column is not found.",
                                        "Function `check_value_existence`: Validates the presence of values in a specified DataFrame column and appends errors for any missing entries.",
                                        "Function `errors`: Returns a sorted list of file parsing exceptions based on their line numbers.",
                                        "Class `BinaryExampleMaker`: A subclass of ExampleMaker that generates a list of Example objects from a DataFrame by parsing each row and creating corresponding examples for a specified project.",
                                        "Function `make`: A method that converts a DataFrame into a list of `Example` objects by parsing each row and creating instances based on the parsed data.",
                                        "Class `LabelMaker`: A utility class for creating label instances from a specified column in a DataFrame, with error handling for missing columns.",
                                        "Function `__init__`: Initializes an instance with a specified column name and label class, while also preparing an empty list for error handling.",
                                        "Function `make`: A method that processes a DataFrame to extract and return a list of Label objects by checking for column existence, exploding the specified column, and parsing valid entries.",
                                        "Function `check_column_existence`: Checks if a specified column exists in a DataFrame and appends an error message for each unique filename if the column is not found.",
                                        "Function `errors`: Sorts and returns a list of `FileParseException` errors based on their line numbers."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "parsers.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\parsers.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `detect_encoding`: Detects character encoding automatically.\nCode:\ndef detect_encoding(filename: str, buffer_size: int = io.DEFAULT_BUFFER_SIZE) -> str:\n    \"\"\"Detects character encoding automatically.\n\n    If you want to know the supported encodings, please see the following document:\n    https://chardet.readthedocs.io/en/latest/supported-encodings.html\n\n    Args:\n        filename: the filename for detecting the encoding.\n        buffer_size: the buffer size to read file contents incrementally.\n\n    Returns:\n        The character encoding.\n    \"\"\"\n    # For a small file.\n    if os.path.getsize(filename) < buffer_size:\n        detected = chardet.detect(open(filename, \"rb\").read())\n        return detected.get(\"encoding\", \"utf-8\")\n\n    # For a large file, call the Universal Encoding Detector incrementally.\n    # It will stop as soon as it is confident enough to report its results.\n    # See: https://chardet.readthedocs.io/en/latest/usage.html\n    with open(filename, \"rb\") as f:\n        detector = UniversalDetector()\n        while True:\n            binary = f.read(buffer_size)\n            detector.feed(binary)\n            if binary == b\"\":\n                break\n            if detector.done:\n                break\n        if detector.done:\n            return detector.result[\"encoding\"] or \"utf-8\"\n        else:\n            return \"utf-8\"",
                                        "Function `decide_encoding`: Decide character encoding automatically.\nCode:\ndef decide_encoding(filename: str, encoding: str) -> str:\n    \"\"\"Decide character encoding automatically.\n\n    If the encoding is DEFAULT_ENCODING, detects it automatically.\n    Otherwise, return it as is.\n\n    Args:\n         filename: The filename for decide the encoding.\n         encoding: The specified encoding.\n\n    Returns:\n        The character encoding.\n    \"\"\"\n    if encoding == DEFAULT_ENCODING:\n        return detect_encoding(filename)\n    else:\n        return encoding",
                                        "Class `LineReader`: LineReader is a helper class to read a file line by line.\nCode:\nclass LineReader:\n    \"\"\"LineReader is a helper class to read a file line by line.\n\n    Attributes:\n        filename: The filename to read.\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, filename: str, encoding: str = DEFAULT_ENCODING):\n        self.filename = filename\n        self.encoding = encoding\n\n    def __iter__(self) -> Iterator[str]:\n        encoding = decide_encoding(self.filename, self.encoding)\n        with open(self.filename, encoding=encoding) as f:\n            for line in f:\n                yield line.rstrip()",
                                        "Function `__init__`\nCode:\n    def __init__(self, filename: str, encoding: str = DEFAULT_ENCODING):\n        self.filename = filename\n        self.encoding = encoding",
                                        "Function `__iter__`\nCode:\n    def __iter__(self) -> Iterator[str]:\n        encoding = decide_encoding(self.filename, self.encoding)\n        with open(self.filename, encoding=encoding) as f:\n            for line in f:\n                yield line.rstrip()",
                                        "Class `PlainParser`: PlainParser is a parser simply returns a dictionary.\nCode:\nclass PlainParser(Parser):\n    \"\"\"PlainParser is a parser simply returns a dictionary.\n\n    This is for a task without any text.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.kwargs = kwargs\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        yield {}",
                                        "Function `__init__`\nCode:\n    def __init__(self, **kwargs):\n        self.kwargs = kwargs",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        yield {}",
                                        "Class `LineParser`: LineParser is a parser to read a file line by line.\nCode:\nclass LineParser(Parser):\n    \"\"\"LineParser is a parser to read a file line by line.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            yield {DEFAULT_TEXT_COLUMN: line, LINE_NUMBER_COLUMN: line_num}",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            yield {DEFAULT_TEXT_COLUMN: line, LINE_NUMBER_COLUMN: line_num}",
                                        "Class `TextFileParser`: TextFileParser is a parser to read an entire file content.\nCode:\nclass TextFileParser(Parser):\n    \"\"\"TextFileParser is a parser to read an entire file content.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            yield {DEFAULT_TEXT_COLUMN: f.read()}",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            yield {DEFAULT_TEXT_COLUMN: f.read()}",
                                        "Class `CSVParser`: CSVParser is a parser to read a csv file and return its rows.\nCode:\nclass CSVParser(Parser):\n    \"\"\"CSVParser is a parser to read a csv file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n        delimiter: A one-character string used to separate fields. It defaults to ','.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \",\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            reader = csv.DictReader(f, delimiter=self.delimiter)\n            for line_num, row in enumerate(reader, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \",\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            reader = csv.DictReader(f, delimiter=self.delimiter)\n            for line_num, row in enumerate(reader, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}",
                                        "Class `JSONParser`: JSONParser is a parser to read a json file and return its rows.\nCode:\nclass JSONParser(Parser):\n    \"\"\"JSONParser is a parser to read a json file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            try:\n                rows = json.load(f)\n                for row in rows:\n                    yield row\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num=1, message=str(e))\n                self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            try:\n                rows = json.load(f)\n                for row in rows:\n                    yield row\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num=1, message=str(e))\n                self._errors.append(error)",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Class `JSONLParser`: JSONLParser is a parser to read a JSONL file and return its rows.\nCode:\nclass JSONLParser(Parser):\n    \"\"\"JSONLParser is a parser to read a JSONL file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            try:\n                row = json.loads(line)\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num, str(e))\n                self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            try:\n                row = json.loads(line)\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num, str(e))\n                self._errors.append(error)",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Class `ExcelParser`: ExcelParser is a parser to read a excel file.\nCode:\nclass ExcelParser(Parser):\n    \"\"\"ExcelParser is a parser to read a excel file.\"\"\"\n\n    def __init__(self, **kwargs):\n        self._errors = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        rows = pyexcel.iget_records(file_name=filename)\n        try:\n            for line_num, row in enumerate(rows, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n        except pyexcel.exceptions.FileTypeNotSupported as e:\n            error = FileParseException(filename, line_num=1, message=str(e))\n            self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Function `__init__`\nCode:\n    def __init__(self, **kwargs):\n        self._errors = []",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        rows = pyexcel.iget_records(file_name=filename)\n        try:\n            for line_num, row in enumerate(rows, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n        except pyexcel.exceptions.FileTypeNotSupported as e:\n            error = FileParseException(filename, line_num=1, message=str(e))\n            self._errors.append(error)",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Class `FastTextParser`: FastTextParser is a parser to read a fastText format and returns a text and labels.\nCode:\nclass FastTextParser(Parser):\n    \"\"\"FastTextParser is a parser to read a fastText format and returns a text and labels.\n\n    The example format is as follows:\n        __label__positive I really enjoyed this restaurant.\n    This format expects the category first, with the prefix ‘__label__’ before each category,\n    and then the input text, like so,\n\n    Attributes:\n        encoding: The character encoding.\n        label: The label prefix. It defaults to `__label__`.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, label: str = \"__label__\", **kwargs):\n        self.encoding = encoding\n        self.label = label\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            labels = []\n            tokens = []\n            for token in line.rstrip().split(\" \"):\n                if token.startswith(self.label):\n                    label_name = token[len(self.label) :]\n                    labels.append(label_name)\n                else:\n                    tokens.append(token)\n            text = \" \".join(tokens)\n            yield {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels, LINE_NUMBER_COLUMN: line_num}",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, label: str = \"__label__\", **kwargs):\n        self.encoding = encoding\n        self.label = label",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            labels = []\n            tokens = []\n            for token in line.rstrip().split(\" \"):\n                if token.startswith(self.label):\n                    label_name = token[len(self.label) :]\n                    labels.append(label_name)\n                else:\n                    tokens.append(token)\n            text = \" \".join(tokens)\n            yield {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels, LINE_NUMBER_COLUMN: line_num}",
                                        "Class `CoNLLParser`: CoNLLParser is a parser to read conll like format and returns a text and labels.\nCode:\nclass CoNLLParser(Parser):\n    \"\"\"CoNLLParser is a parser to read conll like format and returns a text and labels.\n\n    The example format is as follows:\n        EU  B-ORG\n        rejects O\n        German  B-MISC\n        call  O\n        to  O\n        boycott O\n        British B-MISC\n        lamb  O\n        . O\n\n        Peter B-PER\n        Blackburn I-PER\n    This format expects a token in the first column, and a tag in the second column.\n    The each data is separated by a new line.\n\n    Attributes:\n        encoding: The character encoding.\n        delimiter: A one-character string used to separate fields. It defaults to ' '.\n        scheme: The tagging scheme. It supports `IOB2`, `IOE2`, `IOBES`, and `BILOU`.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \" \", scheme: str = \"IOB2\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter\n        mapping = {\"IOB2\": IOB2, \"IOE2\": IOE2, \"IOBES\": IOBES, \"BILOU\": BILOU}\n        self._errors: List[FileParseException] = []\n        if scheme in mapping:\n            self.scheme = mapping[scheme]\n        else:\n            self.scheme = None\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        if not self.scheme:\n            message = \"The specified scheme is not supported.\"\n            error = FileParseException(filename, line_num=1, message=message)\n            self._errors.append(error)\n            return\n\n        reader = LineReader(filename, self.encoding)\n        words, tags = [], []\n        for line_num, line in enumerate(reader, start=1):\n            line = line.rstrip()\n            if line:\n                tokens = line.split(\"\\t\")\n                if len(tokens) != 2:\n                    message = \"A line must be separated by tab and has two columns.\"\n                    self._errors.append(FileParseException(filename, line_num, message))\n                    return\n                word, tag = tokens\n                words.append(word)\n                tags.append(tag)\n            else:\n                yield self.create_record(tags, words)\n                words, tags = [], []\n        if words:\n            yield self.create_record(tags, words)\n\n    def create_record(self, tags, words):\n        text = self.delimiter.join(words)\n        labels = self.align_span(words, tags)\n        return {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels}\n\n    def align_span(self, words: List[str], tags: List[str]) -> List[Tuple[int, int, str]]:\n        tokens = Tokens(tags, self.scheme)\n        labels = []\n        for entity in tokens.entities:\n            text = self.delimiter.join(words[: entity.start])\n            start = len(text) + len(self.delimiter) if text else len(text)\n            chunk = words[entity.start : entity.end]\n            text = self.delimiter.join(chunk)\n            end = start + len(text)\n            labels.append((start, end, entity.tag))\n        return labels",
                                        "Function `__init__`\nCode:\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \" \", scheme: str = \"IOB2\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter\n        mapping = {\"IOB2\": IOB2, \"IOE2\": IOE2, \"IOBES\": IOBES, \"BILOU\": BILOU}\n        self._errors: List[FileParseException] = []\n        if scheme in mapping:\n            self.scheme = mapping[scheme]\n        else:\n            self.scheme = None",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self._errors",
                                        "Function `parse`\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        if not self.scheme:\n            message = \"The specified scheme is not supported.\"\n            error = FileParseException(filename, line_num=1, message=message)\n            self._errors.append(error)\n            return\n\n        reader = LineReader(filename, self.encoding)\n        words, tags = [], []\n        for line_num, line in enumerate(reader, start=1):\n            line = line.rstrip()\n            if line:\n                tokens = line.split(\"\\t\")\n                if len(tokens) != 2:\n                    message = \"A line must be separated by tab and has two columns.\"\n                    self._errors.append(FileParseException(filename, line_num, message))\n                    return\n                word, tag = tokens\n                words.append(word)\n                tags.append(tag)\n            else:\n                yield self.create_record(tags, words)\n                words, tags = [], []\n        if words:\n            yield self.create_record(tags, words)",
                                        "Function `create_record`\nCode:\n    def create_record(self, tags, words):\n        text = self.delimiter.join(words)\n        labels = self.align_span(words, tags)\n        return {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels}",
                                        "Function `align_span`\nCode:\n    def align_span(self, words: List[str], tags: List[str]) -> List[Tuple[int, int, str]]:\n        tokens = Tokens(tags, self.scheme)\n        labels = []\n        for entity in tokens.entities:\n            text = self.delimiter.join(words[: entity.start])\n            start = len(text) + len(self.delimiter) if text else len(text)\n            chunk = words[entity.start : entity.end]\n            text = self.delimiter.join(chunk)\n            end = start + len(text)\n            labels.append((start, end, entity.tag))\n        return labels"
                                    ],
                                    "code": "import csv\nimport io\nimport json\nimport os\nfrom typing import Any, Dict, Iterator, List, Tuple\n\nimport chardet\nimport pyexcel\nimport pyexcel.exceptions\nfrom chardet import UniversalDetector\nfrom seqeval.scheme import BILOU, IOB2, IOBES, IOE2, Tokens\n\nfrom .exceptions import FileParseException\nfrom .readers import (\n    DEFAULT_LABEL_COLUMN,\n    DEFAULT_TEXT_COLUMN,\n    LINE_NUMBER_COLUMN,\n    Parser,\n)\n\nDEFAULT_ENCODING = \"Auto\"\n\n\ndef detect_encoding(filename: str, buffer_size: int = io.DEFAULT_BUFFER_SIZE) -> str:\n    \"\"\"Detects character encoding automatically.\n\n    If you want to know the supported encodings, please see the following document:\n    https://chardet.readthedocs.io/en/latest/supported-encodings.html\n\n    Args:\n        filename: the filename for detecting the encoding.\n        buffer_size: the buffer size to read file contents incrementally.\n\n    Returns:\n        The character encoding.\n    \"\"\"\n    # For a small file.\n    if os.path.getsize(filename) < buffer_size:\n        detected = chardet.detect(open(filename, \"rb\").read())\n        return detected.get(\"encoding\", \"utf-8\")\n\n    # For a large file, call the Universal Encoding Detector incrementally.\n    # It will stop as soon as it is confident enough to report its results.\n    # See: https://chardet.readthedocs.io/en/latest/usage.html\n    with open(filename, \"rb\") as f:\n        detector = UniversalDetector()\n        while True:\n            binary = f.read(buffer_size)\n            detector.feed(binary)\n            if binary == b\"\":\n                break\n            if detector.done:\n                break\n        if detector.done:\n            return detector.result[\"encoding\"] or \"utf-8\"\n        else:\n            return \"utf-8\"\n\n\ndef decide_encoding(filename: str, encoding: str) -> str:\n    \"\"\"Decide character encoding automatically.\n\n    If the encoding is DEFAULT_ENCODING, detects it automatically.\n    Otherwise, return it as is.\n\n    Args:\n         filename: The filename for decide the encoding.\n         encoding: The specified encoding.\n\n    Returns:\n        The character encoding.\n    \"\"\"\n    if encoding == DEFAULT_ENCODING:\n        return detect_encoding(filename)\n    else:\n        return encoding\n\n\nclass LineReader:\n    \"\"\"LineReader is a helper class to read a file line by line.\n\n    Attributes:\n        filename: The filename to read.\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, filename: str, encoding: str = DEFAULT_ENCODING):\n        self.filename = filename\n        self.encoding = encoding\n\n    def __iter__(self) -> Iterator[str]:\n        encoding = decide_encoding(self.filename, self.encoding)\n        with open(self.filename, encoding=encoding) as f:\n            for line in f:\n                yield line.rstrip()\n\n\nclass PlainParser(Parser):\n    \"\"\"PlainParser is a parser simply returns a dictionary.\n\n    This is for a task without any text.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.kwargs = kwargs\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        yield {}\n\n\nclass LineParser(Parser):\n    \"\"\"LineParser is a parser to read a file line by line.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            yield {DEFAULT_TEXT_COLUMN: line, LINE_NUMBER_COLUMN: line_num}\n\n\nclass TextFileParser(Parser):\n    \"\"\"TextFileParser is a parser to read an entire file content.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            yield {DEFAULT_TEXT_COLUMN: f.read()}\n\n\nclass CSVParser(Parser):\n    \"\"\"CSVParser is a parser to read a csv file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n        delimiter: A one-character string used to separate fields. It defaults to ','.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \",\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            reader = csv.DictReader(f, delimiter=self.delimiter)\n            for line_num, row in enumerate(reader, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n\n\nclass JSONParser(Parser):\n    \"\"\"JSONParser is a parser to read a json file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        encoding = decide_encoding(filename, self.encoding)\n        with open(filename, encoding=encoding) as f:\n            try:\n                rows = json.load(f)\n                for row in rows:\n                    yield row\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num=1, message=str(e))\n                self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors\n\n\nclass JSONLParser(Parser):\n    \"\"\"JSONLParser is a parser to read a JSONL file and return its rows.\n\n    Attributes:\n        encoding: The character encoding.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, **kwargs):\n        self.encoding = encoding\n        self._errors: List[FileParseException] = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            try:\n                row = json.loads(line)\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n            except json.decoder.JSONDecodeError as e:\n                error = FileParseException(filename, line_num, str(e))\n                self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors\n\n\nclass ExcelParser(Parser):\n    \"\"\"ExcelParser is a parser to read a excel file.\"\"\"\n\n    def __init__(self, **kwargs):\n        self._errors = []\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        rows = pyexcel.iget_records(file_name=filename)\n        try:\n            for line_num, row in enumerate(rows, start=1):\n                yield {LINE_NUMBER_COLUMN: line_num, **row}\n        except pyexcel.exceptions.FileTypeNotSupported as e:\n            error = FileParseException(filename, line_num=1, message=str(e))\n            self._errors.append(error)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors\n\n\nclass FastTextParser(Parser):\n    \"\"\"FastTextParser is a parser to read a fastText format and returns a text and labels.\n\n    The example format is as follows:\n        __label__positive I really enjoyed this restaurant.\n    This format expects the category first, with the prefix ‘__label__’ before each category,\n    and then the input text, like so,\n\n    Attributes:\n        encoding: The character encoding.\n        label: The label prefix. It defaults to `__label__`.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, label: str = \"__label__\", **kwargs):\n        self.encoding = encoding\n        self.label = label\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        reader = LineReader(filename, self.encoding)\n        for line_num, line in enumerate(reader, start=1):\n            labels = []\n            tokens = []\n            for token in line.rstrip().split(\" \"):\n                if token.startswith(self.label):\n                    label_name = token[len(self.label) :]\n                    labels.append(label_name)\n                else:\n                    tokens.append(token)\n            text = \" \".join(tokens)\n            yield {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels, LINE_NUMBER_COLUMN: line_num}\n\n\nclass CoNLLParser(Parser):\n    \"\"\"CoNLLParser is a parser to read conll like format and returns a text and labels.\n\n    The example format is as follows:\n        EU  B-ORG\n        rejects O\n        German  B-MISC\n        call  O\n        to  O\n        boycott O\n        British B-MISC\n        lamb  O\n        . O\n\n        Peter B-PER\n        Blackburn I-PER\n    This format expects a token in the first column, and a tag in the second column.\n    The each data is separated by a new line.\n\n    Attributes:\n        encoding: The character encoding.\n        delimiter: A one-character string used to separate fields. It defaults to ' '.\n        scheme: The tagging scheme. It supports `IOB2`, `IOE2`, `IOBES`, and `BILOU`.\n    \"\"\"\n\n    def __init__(self, encoding: str = DEFAULT_ENCODING, delimiter: str = \" \", scheme: str = \"IOB2\", **kwargs):\n        self.encoding = encoding\n        self.delimiter = delimiter\n        mapping = {\"IOB2\": IOB2, \"IOE2\": IOE2, \"IOBES\": IOBES, \"BILOU\": BILOU}\n        self._errors: List[FileParseException] = []\n        if scheme in mapping:\n            self.scheme = mapping[scheme]\n        else:\n            self.scheme = None\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self._errors\n\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        if not self.scheme:\n            message = \"The specified scheme is not supported.\"\n            error = FileParseException(filename, line_num=1, message=message)\n            self._errors.append(error)\n            return\n\n        reader = LineReader(filename, self.encoding)\n        words, tags = [], []\n        for line_num, line in enumerate(reader, start=1):\n            line = line.rstrip()\n            if line:\n                tokens = line.split(\"\\t\")\n                if len(tokens) != 2:\n                    message = \"A line must be separated by tab and has two columns.\"\n                    self._errors.append(FileParseException(filename, line_num, message))\n                    return\n                word, tag = tokens\n                words.append(word)\n                tags.append(tag)\n            else:\n                yield self.create_record(tags, words)\n                words, tags = [], []\n        if words:\n            yield self.create_record(tags, words)\n\n    def create_record(self, tags, words):\n        text = self.delimiter.join(words)\n        labels = self.align_span(words, tags)\n        return {DEFAULT_TEXT_COLUMN: text, DEFAULT_LABEL_COLUMN: labels}\n\n    def align_span(self, words: List[str], tags: List[str]) -> List[Tuple[int, int, str]]:\n        tokens = Tokens(tags, self.scheme)\n        labels = []\n        for entity in tokens.entities:\n            text = self.delimiter.join(words[: entity.start])\n            start = len(text) + len(self.delimiter) if text else len(text)\n            chunk = words[entity.start : entity.end]\n            text = self.delimiter.join(chunk)\n            end = start + len(text)\n            labels.append((start, end, entity.tag))\n        return labels\n",
                                    "summary": "The content describes a suite of parser classes and functions for reading various file formats (including text, CSV, JSON, Excel, and CoNLL) with customizable encoding and error handling capabilities, each designed to yield structured data while managing parsing errors efficiently.",
                                    "code_element_summaries": [
                                        "Function `detect_encoding`: Automatically detects the character encoding of a file by reading its contents either in full for small files or incrementally for larger files.",
                                        "Function `decide_encoding`: Automatically determines the character encoding of a file based on a specified encoding, returning the detected encoding if the default is used.",
                                        "Class `LineReader`: A helper class designed to read a file line by line, allowing for customizable filename and character encoding.",
                                        "Function `__init__`: Initializes an instance with a specified filename and an optional encoding, defaulting to DEFAULT_ENCODING.",
                                        "Function `__iter__`: An iterator that yields each line of a file, stripped of trailing whitespace, using the appropriate encoding determined by the filename.",
                                        "Class `PlainParser`: A parser that returns an empty dictionary, designed for tasks that do not involve any text.",
                                        "Function `__init__`: Initializes an instance by storing keyword arguments in an instance variable.",
                                        "Function `parse`: A generator function that takes a filename as input and yields an empty dictionary.",
                                        "Class LineParser: A parser that reads a file line by line and yields each line along with its line number as a dictionary.",
                                        "Function `__init__`: Initializes an instance with a specified encoding, defaulting to DEFAULT_ENCODING, and allows additional keyword arguments.",
                                        "Function `parse`: A generator function that reads lines from a specified file and yields dictionaries containing the line text and its corresponding line number.",
                                        "Class TextFileParser: A parser that reads the entire content of a file and yields it as a dictionary, with configurable character encoding.",
                                        "Function `__init__`: Initializes an instance with a specified encoding, defaulting to DEFAULT_ENCODING, and accepts additional keyword arguments.",
                                        "Function `parse`: A generator function that reads the contents of a specified file and yields a dictionary containing the file's text under a default column name.",
                                        "Class `CSVParser`: A parser that reads CSV files and yields their rows as dictionaries, with customizable encoding and field delimiter options.",
                                        "Function `__init__`: Initializes an instance with specified encoding and delimiter, defaulting to predefined values.",
                                        "Function `parse`: A generator function that reads a CSV file and yields each row as a dictionary, including the line number as an additional key.",
                                        "Class `JSONParser`: A parser that reads a JSON file and yields its rows, while also tracking any parsing errors that occur.",
                                        "Function `__init__`: Initializes an instance with a specified encoding and an empty list for error tracking.",
                                        "Function `parse`: A generator function that reads a JSON file, yielding its contents as dictionaries, while handling potential decoding errors by appending them to an error list.",
                                        "Function `errors`: Returns a list of `FileParseException` instances representing the errors encountered during file parsing.",
                                        "Class JSONLParser: A parser for reading JSONL files that yields each row as a dictionary while tracking any parsing errors.",
                                        "Function `__init__`: Initializes an instance with a specified encoding and an empty list for error tracking.",
                                        "Function `parse`: A generator function that reads a file line by line, attempting to parse each line as JSON and yielding a dictionary with the line number and parsed data, while collecting any parsing errors encountered.",
                                        "Function `errors`: Returns a list of `FileParseException` instances representing errors encountered during file parsing.",
                                        "Class `ExcelParser`: A parser that reads Excel files and yields their contents as dictionaries while tracking parsing errors.",
                                        "Function `__init__`: Initializes an instance with an empty list for storing errors, accepting any keyword arguments.",
                                        "Function `parse`: A generator function that reads records from a specified file and yields them as dictionaries, while handling file type errors by appending exceptions to an error list.",
                                        "Function `errors`: Returns a list of `FileParseException` instances stored in the `_errors` attribute.",
                                        "Class FastTextParser: A parser that reads fastText formatted data and extracts text and associated labels, with customizable encoding and label prefix options.",
                                        "Function `__init__`: Initializes an instance with specified encoding and label, allowing additional keyword arguments.",
                                        "Function `parse`: A generator function that reads a file line by line, extracting labels and text tokens, and yields a dictionary containing the text, labels, and line number for each line.",
                                        "Class `CoNLLParser`: A parser that reads CoNLL-like formatted text and returns the corresponding text and associated labels, supporting various tagging schemes.",
                                        "Function `__init__`: Initializes an object with specified encoding, delimiter, and scheme, while also setting up error handling for file parsing.",
                                        "Function `errors`: Returns a list of `FileParseException` objects representing errors encountered during file parsing.",
                                        "Function `parse`: A method that reads a file line by line, validates its content format, and yields records of words and tags while collecting errors for any parsing issues encountered.",
                                        "Function `create_record`: Constructs a dictionary containing concatenated words and their corresponding labels by aligning spans based on provided tags.",
                                        "Function `align_span`: Processes a list of words and their corresponding tags to produce a list of tuples representing the start and end indices of each entity along with its tag."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "readers.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\readers.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `BaseReader`: Reader has a role to parse files and return a Record iterator.\nCode:\nclass BaseReader(collections.abc.Iterable):\n    \"\"\"Reader has a role to parse files and return a Record iterator.\"\"\"\n\n    @abc.abstractmethod\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Creates an iterator for elements of this dataset.\n\n        Returns:\n            A `dict` for the elements of this dataset.\n        \"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @property\n    @abc.abstractmethod\n    def errors(self):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @abc.abstractmethod\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `__iter__`: Creates an iterator for elements of this dataset.\nCode:\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Creates an iterator for elements of this dataset.\n\n        Returns:\n            A `dict` for the elements of this dataset.\n        \"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `errors`\nCode:\n    def errors(self):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `batch`\nCode:\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Class `Parser`: The abstract file parser.\nCode:\nclass Parser(abc.ABC):\n    \"\"\"The abstract file parser.\"\"\"\n\n    @abc.abstractmethod\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Parses the file and returns the dictionary.\"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        \"\"\"Returns parsing errors.\"\"\"\n        return []",
                                        "Function `parse`: Parses the file and returns the dictionary.\nCode:\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Parses the file and returns the dictionary.\"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")",
                                        "Function `errors`: Returns parsing errors.\nCode:\n    def errors(self) -> List[FileParseException]:\n        \"\"\"Returns parsing errors.\"\"\"\n        return []",
                                        "Class `FileName`\nCode:\nclass FileName:\n    full_path: str\n    generated_name: str\n    upload_name: str",
                                        "Class `Reader`\nCode:\nclass Reader(BaseReader):\n    def __init__(self, filenames: List[FileName], parser: Parser):\n        self.filenames = filenames\n        self.parser = parser\n\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        for filename in self.filenames:\n            rows = self.parser.parse(filename.full_path)\n            for row in rows:\n                yield {\n                    UUID_COLUMN: uuid.uuid4(),\n                    FILE_NAME_COLUMN: filename.generated_name,\n                    UPLOAD_NAME_COLUMN: filename.upload_name,\n                    **row,\n                }\n\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        batch = []\n        for record in self:\n            batch.append(record)\n            if len(batch) == batch_size:\n                yield pd.DataFrame(batch)\n                batch = []\n        if batch:\n            yield pd.DataFrame(batch)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.parser.errors",
                                        "Function `__init__`\nCode:\n    def __init__(self, filenames: List[FileName], parser: Parser):\n        self.filenames = filenames\n        self.parser = parser",
                                        "Function `__iter__`\nCode:\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        for filename in self.filenames:\n            rows = self.parser.parse(filename.full_path)\n            for row in rows:\n                yield {\n                    UUID_COLUMN: uuid.uuid4(),\n                    FILE_NAME_COLUMN: filename.generated_name,\n                    UPLOAD_NAME_COLUMN: filename.upload_name,\n                    **row,\n                }",
                                        "Function `batch`\nCode:\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        batch = []\n        for record in self:\n            batch.append(record)\n            if len(batch) == batch_size:\n                yield pd.DataFrame(batch)\n                batch = []\n        if batch:\n            yield pd.DataFrame(batch)",
                                        "Function `errors`\nCode:\n    def errors(self) -> List[FileParseException]:\n        return self.parser.errors"
                                    ],
                                    "code": "import abc\nimport collections.abc\nimport dataclasses\nimport uuid\nfrom typing import Any, Dict, Iterator, List\n\nimport pandas as pd\n\nfrom .exceptions import FileParseException\n\nDEFAULT_TEXT_COLUMN = \"text\"\nDEFAULT_LABEL_COLUMN = \"label\"\nFILE_NAME_COLUMN = \"filename\"\nUPLOAD_NAME_COLUMN = \"upload_name\"\nUUID_COLUMN = \"example_uuid\"\nLINE_NUMBER_COLUMN = \"#line_number\"\n\n\nclass BaseReader(collections.abc.Iterable):\n    \"\"\"Reader has a role to parse files and return a Record iterator.\"\"\"\n\n    @abc.abstractmethod\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Creates an iterator for elements of this dataset.\n\n        Returns:\n            A `dict` for the elements of this dataset.\n        \"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @property\n    @abc.abstractmethod\n    def errors(self):\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @abc.abstractmethod\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n\nclass Parser(abc.ABC):\n    \"\"\"The abstract file parser.\"\"\"\n\n    @abc.abstractmethod\n    def parse(self, filename: str) -> Iterator[Dict[Any, Any]]:\n        \"\"\"Parses the file and returns the dictionary.\"\"\"\n        raise NotImplementedError(\"Please implement this method in the subclass.\")\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        \"\"\"Returns parsing errors.\"\"\"\n        return []\n\n\n@dataclasses.dataclass\nclass FileName:\n    full_path: str\n    generated_name: str\n    upload_name: str\n\n\nclass Reader(BaseReader):\n    def __init__(self, filenames: List[FileName], parser: Parser):\n        self.filenames = filenames\n        self.parser = parser\n\n    def __iter__(self) -> Iterator[Dict[Any, Any]]:\n        for filename in self.filenames:\n            rows = self.parser.parse(filename.full_path)\n            for row in rows:\n                yield {\n                    UUID_COLUMN: uuid.uuid4(),\n                    FILE_NAME_COLUMN: filename.generated_name,\n                    UPLOAD_NAME_COLUMN: filename.upload_name,\n                    **row,\n                }\n\n    def batch(self, batch_size: int) -> Iterator[pd.DataFrame]:\n        batch = []\n        for record in self:\n            batch.append(record)\n            if len(batch) == batch_size:\n                yield pd.DataFrame(batch)\n                batch = []\n        if batch:\n            yield pd.DataFrame(batch)\n\n    @property\n    def errors(self) -> List[FileParseException]:\n        return self.parser.errors\n",
                                    "summary": "Class BaseReader: An abstract iterable class for parsing files into dataset records, requiring subclasses to implement methods for iteration, error handling, and batch processing, while the Reader class provides a concrete implementation that yields parsed records and batches as pandas DataFrames.",
                                    "code_element_summaries": [
                                        "Class `BaseReader`: An abstract iterable class designed to parse files and provide an iterator for dataset records, requiring subclasses to implement specific methods for iteration and error handling.",
                                        "Function `__iter__`: An abstract method that, when implemented in a subclass, will provide an iterator for the dataset elements, returning them as dictionaries.",
                                        "Function `errors`: An abstract method that raises a NotImplementedError, indicating that subclasses must provide their own implementation.",
                                        "Function `batch`: An abstract method that requires implementation in subclasses to return an iterator of pandas DataFrames based on a specified batch size.",
                                        "Class Parser: An abstract base class for file parsers that requires subclasses to implement a parse method and provides a property for retrieving parsing errors.",
                                        "Function `parse`: An abstract method that requires implementation in a subclass to parse a file and return its contents as a dictionary.",
                                        "Function `errors`: A method that returns an empty list of parsing errors, represented as a list of `FileParseException`.",
                                        "Class FileName: A data structure that stores information about a file's full path, generated name, and upload name.",
                                        "Class `Reader`: A model that iterates over a list of filenames, parsing each file and yielding records as dictionaries, while also providing a method to yield batches of records as pandas DataFrames and a property to access parsing errors.",
                                        "Function `__init__`: Initializes an instance with a list of filenames and a parser object.",
                                        "Function `__iter__`: An iterator that yields dictionaries containing parsed data from filenames, including a unique UUID and file name details.",
                                        "Function `batch`: Yields batches of records as pandas DataFrames, with each batch containing a specified number of records.",
                                        "Function `errors`: Returns a list of parsing errors encountered by the parser as `FileParseException` instances."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\pipeline\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class TestOptions and related test cases: A comprehensive suite of unit tests designed to validate the functionality, creation, and management of various data types and options within document classification and sequence labeling projects, ensuring robust error handling and adherence to expected behaviors across multiple components.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_catalog.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_catalog.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestOptions`\nCode:\nclass TestOptions(unittest.TestCase):\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)",
                                        "Function `test_return_at_least_one_option`\nCode:\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)"
                                    ],
                                    "code": "import unittest\n\nfrom data_import.pipeline.catalog import Options\nfrom projects.models import ProjectType\n\n\nclass TestOptions(unittest.TestCase):\n    def test_return_at_least_one_option(self):\n        for task in ProjectType:\n            with self.subTest(task=task):\n                options = Options.filter_by_task(task)\n                self.assertGreaterEqual(len(options), 1)\n",
                                    "summary": "Class TestOptions: A unit test that ensures every task in the ProjectType enumeration has at least one corresponding option in the Options filter.",
                                    "code_element_summaries": [
                                        "Class TestOptions: A unit test that verifies at least one option is returned for each task in the ProjectType enumeration.",
                                        "Function `test_return_at_least_one_option`: A test that verifies each task in ProjectType has at least one associated option in the Options filter."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_data.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_data.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestTextData`\nCode:\nclass TestTextData(TestCase):\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n            \"text\": \"test\",\n        }\n        self.project = prepare_project()\n\n    def test_parse(self):\n        data = TextData.parse(**self.dic)\n        self.assertIsInstance(data, TextData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(data.filename, self.dic[\"filename\"])\n        self.assertEqual(data.upload_name, self.dic[\"upload_name\"])\n        self.assertEqual(data.text, self.dic[\"text\"])\n\n    def test_parse_empty_text(self):\n        self.dic[\"text\"] = \"\"\n        with self.assertRaises(ValueError):\n            TextData.parse(**self.dic)\n\n    def test_create(self):\n        data = TextData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n            \"text\": \"test\",\n        }\n        self.project = prepare_project()",
                                        "Function `test_parse`\nCode:\n    def test_parse(self):\n        data = TextData.parse(**self.dic)\n        self.assertIsInstance(data, TextData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(data.filename, self.dic[\"filename\"])\n        self.assertEqual(data.upload_name, self.dic[\"upload_name\"])\n        self.assertEqual(data.text, self.dic[\"text\"])",
                                        "Function `test_parse_empty_text`\nCode:\n    def test_parse_empty_text(self):\n        self.dic[\"text\"] = \"\"\n        with self.assertRaises(ValueError):\n            TextData.parse(**self.dic)",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        data = TextData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])",
                                        "Class `TestBinaryData`\nCode:\nclass TestBinaryData(TestCase):\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n        }\n        self.project = prepare_project()\n\n    def test_parse(self):\n        data = BinaryData.parse(**self.dic)\n        self.assertIsInstance(data, BinaryData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])\n\n    def test_create(self):\n        data = BinaryData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(example.text, None)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n        }\n        self.project = prepare_project()",
                                        "Function `test_parse`\nCode:\n    def test_parse(self):\n        data = BinaryData.parse(**self.dic)\n        self.assertIsInstance(data, BinaryData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        data = BinaryData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(example.text, None)"
                                    ],
                                    "code": "import uuid\n\nfrom django.test import TestCase\n\nfrom data_import.pipeline.data import BinaryData, TextData\nfrom examples.models import Example\nfrom projects.tests.utils import prepare_project\n\n\nclass TestTextData(TestCase):\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n            \"text\": \"test\",\n        }\n        self.project = prepare_project()\n\n    def test_parse(self):\n        data = TextData.parse(**self.dic)\n        self.assertIsInstance(data, TextData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(data.filename, self.dic[\"filename\"])\n        self.assertEqual(data.upload_name, self.dic[\"upload_name\"])\n        self.assertEqual(data.text, self.dic[\"text\"])\n\n    def test_parse_empty_text(self):\n        self.dic[\"text\"] = \"\"\n        with self.assertRaises(ValueError):\n            TextData.parse(**self.dic)\n\n    def test_create(self):\n        data = TextData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])\n\n\nclass TestBinaryData(TestCase):\n    def setUp(self):\n        self.dic = {\n            \"example_uuid\": uuid.uuid4(),\n            \"filename\": \"test.txt\",\n            \"upload_name\": \"test.txt\",\n        }\n        self.project = prepare_project()\n\n    def test_parse(self):\n        data = BinaryData.parse(**self.dic)\n        self.assertIsInstance(data, BinaryData)\n        self.assertEqual(data.uuid, self.dic[\"example_uuid\"])\n\n    def test_create(self):\n        data = BinaryData.parse(**self.dic)\n        example = data.create(self.project.item)\n        self.assertIsInstance(example, Example)\n        self.assertEqual(example.uuid, self.dic[\"example_uuid\"])\n        self.assertEqual(example.text, None)\n",
                                    "summary": "Classes `TestTextData` and `TestBinaryData`: Unit test cases that validate the parsing and creation of `TextData` and `BinaryData` instances, ensuring proper handling of both valid and empty inputs, along with verifying instance types and UUIDs.",
                                    "code_element_summaries": [
                                        "Class `TestTextData`: A unit test case for the `TextData` class that verifies the parsing and creation of text data instances, ensuring proper handling of valid and empty text inputs.",
                                        "Function `setUp`: A method that initializes a dictionary with example data and prepares a project for testing.",
                                        "Function `test_parse`: A unit test that verifies the correct parsing and instantiation of a TextData object from a dictionary of attributes.",
                                        "Function `test_parse_empty_text`: A unit test that verifies a `ValueError` is raised when attempting to parse an empty text string using the `TextData.parse` method.",
                                        "Function `test_create`: A unit test that verifies the creation of an Example instance from parsed TextData, ensuring it is of the correct type and has the expected UUID.",
                                        "Class TestBinaryData: A test case for the BinaryData class that verifies the parsing and creation of BinaryData instances using example data.",
                                        "Function `setUp`: Initializes a dictionary with a UUID and file details, and prepares a project for testing.",
                                        "Function `test_parse`: A unit test that verifies the parsing of binary data from a dictionary and checks the instance type and UUID of the resulting object.",
                                        "Function `test_create`: A test function that verifies the creation of a BinaryData instance and checks that it is of type Example with the correct UUID and a None text attribute."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_examples.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_examples.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExamples`\nCode:\nclass TestExamples(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example_uuid = uuid.uuid4()\n        example = Example(uuid=self.example_uuid, text=\"A\", project=self.project.item)\n        self.examples = Examples([example])\n\n    def test_save(self):\n        self.examples.save()\n        self.assertEqual(Example.objects.count(), 1)\n\n    def test_getitem(self):\n        self.examples.save()\n        example = self.examples[self.example_uuid]\n        self.assertEqual(example.uuid, self.example_uuid)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example_uuid = uuid.uuid4()\n        example = Example(uuid=self.example_uuid, text=\"A\", project=self.project.item)\n        self.examples = Examples([example])",
                                        "Function `test_save`\nCode:\n    def test_save(self):\n        self.examples.save()\n        self.assertEqual(Example.objects.count(), 1)",
                                        "Function `test_getitem`\nCode:\n    def test_getitem(self):\n        self.examples.save()\n        example = self.examples[self.example_uuid]\n        self.assertEqual(example.uuid, self.example_uuid)"
                                    ],
                                    "code": "import uuid\n\nfrom django.test import TestCase\n\nfrom data_import.pipeline.examples import Examples\nfrom examples.models import Example\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestExamples(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example_uuid = uuid.uuid4()\n        example = Example(uuid=self.example_uuid, text=\"A\", project=self.project.item)\n        self.examples = Examples([example])\n\n    def test_save(self):\n        self.examples.save()\n        self.assertEqual(Example.objects.count(), 1)\n\n    def test_getitem(self):\n        self.examples.save()\n        example = self.examples[self.example_uuid]\n        self.assertEqual(example.uuid, self.example_uuid)\n",
                                    "summary": "Class TestExamples: A test case for the Examples class that validates the saving functionality and retrieval of items by UUID in a document classification project.",
                                    "code_element_summaries": [
                                        "Class TestExamples: A test case for the Examples class that verifies saving functionality and item retrieval by UUID within a document classification project.",
                                        "Function `setUp`: Initializes a test environment by preparing a document classification project and creating an example with a unique identifier.",
                                        "Function `test_save`: A unit test that verifies the saving functionality of the `examples` object by asserting that the count of `Example` objects is one after the save operation.",
                                        "Function `test_getitem`: A unit test that verifies the retrieval of an example by its UUID from the examples collection."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_label.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_label.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestLabel`\nCode:\nclass TestLabel(TestCase):\n    task = \"Any\"\n\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item, text=\"hello world\")",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item, text=\"hello world\")",
                                        "Class `TestCategoryLabel`\nCode:\nclass TestCategoryLabel(TestLabel):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_comparison(self):\n        category1 = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category2 = CategoryLabel(label=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(category1, category2)\n\n    def test_empty_label_raises_value_error(self):\n        with self.assertRaises(ValueError):\n            CategoryLabel(label=\"\", example_uuid=uuid.uuid4())\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        category = CategoryLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(category.label, \"A\")\n        self.assertEqual(category.example_uuid, example_uuid)\n\n    def test_create_type(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category_type = category.create_type(self.project.item)\n        self.assertIsInstance(category_type, CategoryType)\n        self.assertEqual(category_type.text, \"A\")\n\n    def test_create(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(CategoryType, project=self.project.item)\n        category_model = category.create(self.user, self.example, types)\n        self.assertIsInstance(category_model, CategoryModel)",
                                        "Function `test_comparison`\nCode:\n    def test_comparison(self):\n        category1 = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category2 = CategoryLabel(label=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(category1, category2)",
                                        "Function `test_empty_label_raises_value_error`\nCode:\n    def test_empty_label_raises_value_error(self):\n        with self.assertRaises(ValueError):\n            CategoryLabel(label=\"\", example_uuid=uuid.uuid4())",
                                        "Function `test_parse`\nCode:\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        category = CategoryLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(category.label, \"A\")\n        self.assertEqual(category.example_uuid, example_uuid)",
                                        "Function `test_create_type`\nCode:\n    def test_create_type(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category_type = category.create_type(self.project.item)\n        self.assertIsInstance(category_type, CategoryType)\n        self.assertEqual(category_type.text, \"A\")",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(CategoryType, project=self.project.item)\n        category_model = category.create(self.user, self.example, types)\n        self.assertIsInstance(category_model, CategoryModel)",
                                        "Class `TestSpanLabel`\nCode:\nclass TestSpanLabel(TestLabel):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def test_comparison(self):\n        span1 = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span2 = SpanLabel(label=\"A\", start_offset=1, end_offset=2, example_uuid=uuid.uuid4())\n        self.assertLess(span1, span2)\n\n    def test_parse_tuple(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj=(0, 1, \"A\"))\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)\n\n    def test_parse_dict(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0, \"end_offset\": 1})\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)\n\n    def test_invalid_negative_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=-1, end_offset=1, example_uuid=uuid.uuid4())\n\n    def test_invalid_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=1, end_offset=0, example_uuid=uuid.uuid4())\n\n    def test_parse_invalid_dict(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0})\n\n    def test_create_type(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span_type = span.create_type(self.project.item)\n        self.assertIsInstance(span_type, SpanType)\n        self.assertEqual(span_type.text, \"A\")\n\n    def test_create(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(SpanType, project=self.project.item)\n        span_model = span.create(self.user, self.example, types)\n        self.assertIsInstance(span_model, SpanModel)",
                                        "Function `test_comparison`\nCode:\n    def test_comparison(self):\n        span1 = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span2 = SpanLabel(label=\"A\", start_offset=1, end_offset=2, example_uuid=uuid.uuid4())\n        self.assertLess(span1, span2)",
                                        "Function `test_parse_tuple`\nCode:\n    def test_parse_tuple(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj=(0, 1, \"A\"))\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)",
                                        "Function `test_parse_dict`\nCode:\n    def test_parse_dict(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0, \"end_offset\": 1})\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)",
                                        "Function `test_invalid_negative_offset`\nCode:\n    def test_invalid_negative_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=-1, end_offset=1, example_uuid=uuid.uuid4())",
                                        "Function `test_invalid_offset`\nCode:\n    def test_invalid_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=1, end_offset=0, example_uuid=uuid.uuid4())",
                                        "Function `test_parse_invalid_dict`\nCode:\n    def test_parse_invalid_dict(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0})",
                                        "Function `test_create_type`\nCode:\n    def test_create_type(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span_type = span.create_type(self.project.item)\n        self.assertIsInstance(span_type, SpanType)\n        self.assertEqual(span_type.text, \"A\")",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(SpanType, project=self.project.item)\n        span_model = span.create(self.user, self.example, types)\n        self.assertIsInstance(span_model, SpanModel)",
                                        "Class `TestTextLabel`\nCode:\nclass TestTextLabel(TestLabel):\n    task = ProjectType.SEQ2SEQ\n\n    def test_comparison(self):\n        text1 = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text2 = TextLabel(text=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(text1, text2)\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        text = TextLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(text.text, \"A\")\n\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            TextLabel.parse(example_uuid, obj=[])\n\n    def test_create_type(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text_type = text.create_type(self.project.item)\n        self.assertEqual(text_type, None)\n\n    def test_create(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        text_model = text.create(self.user, self.example, types)\n        self.assertIsInstance(text_model, TextModel)",
                                        "Function `test_comparison`\nCode:\n    def test_comparison(self):\n        text1 = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text2 = TextLabel(text=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(text1, text2)",
                                        "Function `test_parse`\nCode:\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        text = TextLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(text.text, \"A\")",
                                        "Function `test_parse_invalid_data`\nCode:\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            TextLabel.parse(example_uuid, obj=[])",
                                        "Function `test_create_type`\nCode:\n    def test_create_type(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text_type = text.create_type(self.project.item)\n        self.assertEqual(text_type, None)",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        text_model = text.create(self.user, self.example, types)\n        self.assertIsInstance(text_model, TextModel)",
                                        "Class `TestRelationLabel`\nCode:\nclass TestRelationLabel(TestLabel):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def test_comparison(self):\n        relation1 = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation2 = RelationLabel(type=\"A\", from_id=1, to_id=1, example_uuid=uuid.uuid4())\n        self.assertLess(relation1, relation2)\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        relation = RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0, \"to_id\": 1})\n        self.assertEqual(relation.type, \"A\")\n        self.assertEqual(relation.from_id, 0)\n        self.assertEqual(relation.to_id, 1)\n\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0})\n\n    def test_create_type(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation_type = relation.create_type(self.project.item)\n        self.assertIsInstance(relation_type, RelationType)\n        self.assertEqual(relation_type.text, \"A\")\n\n    def test_create(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=self.example.uuid)\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(RelationType, project=self.project.item)\n        id_to_span = {\n            (0, str(self.example.uuid)): mommy.make(SpanModel, start_offset=0, end_offset=1, example=self.example),\n            (1, str(self.example.uuid)): mommy.make(SpanModel, start_offset=2, end_offset=3, example=self.example),\n        }\n        relation_model = relation.create(self.user, self.example, types, id_to_span=id_to_span)\n        self.assertIsInstance(relation_model, RelationModel)",
                                        "Function `test_comparison`\nCode:\n    def test_comparison(self):\n        relation1 = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation2 = RelationLabel(type=\"A\", from_id=1, to_id=1, example_uuid=uuid.uuid4())\n        self.assertLess(relation1, relation2)",
                                        "Function `test_parse`\nCode:\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        relation = RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0, \"to_id\": 1})\n        self.assertEqual(relation.type, \"A\")\n        self.assertEqual(relation.from_id, 0)\n        self.assertEqual(relation.to_id, 1)",
                                        "Function `test_parse_invalid_data`\nCode:\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0})",
                                        "Function `test_create_type`\nCode:\n    def test_create_type(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation_type = relation.create_type(self.project.item)\n        self.assertIsInstance(relation_type, RelationType)\n        self.assertEqual(relation_type.text, \"A\")",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=self.example.uuid)\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(RelationType, project=self.project.item)\n        id_to_span = {\n            (0, str(self.example.uuid)): mommy.make(SpanModel, start_offset=0, end_offset=1, example=self.example),\n            (1, str(self.example.uuid)): mommy.make(SpanModel, start_offset=2, end_offset=3, example=self.example),\n        }\n        relation_model = relation.create(self.user, self.example, types, id_to_span=id_to_span)\n        self.assertIsInstance(relation_model, RelationModel)"
                                    ],
                                    "code": "import uuid\nfrom unittest.mock import MagicMock\n\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom data_import.pipeline.label import (\n    CategoryLabel,\n    RelationLabel,\n    SpanLabel,\n    TextLabel,\n)\nfrom label_types.models import CategoryType, RelationType, SpanType\nfrom labels.models import Category as CategoryModel\nfrom labels.models import Relation as RelationModel\nfrom labels.models import Span as SpanModel\nfrom labels.models import TextLabel as TextModel\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestLabel(TestCase):\n    task = \"Any\"\n\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item, text=\"hello world\")\n\n\nclass TestCategoryLabel(TestLabel):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_comparison(self):\n        category1 = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category2 = CategoryLabel(label=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(category1, category2)\n\n    def test_empty_label_raises_value_error(self):\n        with self.assertRaises(ValueError):\n            CategoryLabel(label=\"\", example_uuid=uuid.uuid4())\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        category = CategoryLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(category.label, \"A\")\n        self.assertEqual(category.example_uuid, example_uuid)\n\n    def test_create_type(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        category_type = category.create_type(self.project.item)\n        self.assertIsInstance(category_type, CategoryType)\n        self.assertEqual(category_type.text, \"A\")\n\n    def test_create(self):\n        category = CategoryLabel(label=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(CategoryType, project=self.project.item)\n        category_model = category.create(self.user, self.example, types)\n        self.assertIsInstance(category_model, CategoryModel)\n\n\nclass TestSpanLabel(TestLabel):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def test_comparison(self):\n        span1 = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span2 = SpanLabel(label=\"A\", start_offset=1, end_offset=2, example_uuid=uuid.uuid4())\n        self.assertLess(span1, span2)\n\n    def test_parse_tuple(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj=(0, 1, \"A\"))\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)\n\n    def test_parse_dict(self):\n        example_uuid = uuid.uuid4()\n        span = SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0, \"end_offset\": 1})\n        self.assertEqual(span.label, \"A\")\n        self.assertEqual(span.start_offset, 0)\n        self.assertEqual(span.end_offset, 1)\n\n    def test_invalid_negative_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=-1, end_offset=1, example_uuid=uuid.uuid4())\n\n    def test_invalid_offset(self):\n        with self.assertRaises(ValueError):\n            SpanLabel(label=\"A\", start_offset=1, end_offset=0, example_uuid=uuid.uuid4())\n\n    def test_parse_invalid_dict(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            SpanLabel.parse(example_uuid, obj={\"label\": \"A\", \"start_offset\": 0})\n\n    def test_create_type(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        span_type = span.create_type(self.project.item)\n        self.assertIsInstance(span_type, SpanType)\n        self.assertEqual(span_type.text, \"A\")\n\n    def test_create(self):\n        span = SpanLabel(label=\"A\", start_offset=0, end_offset=1, example_uuid=uuid.uuid4())\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(SpanType, project=self.project.item)\n        span_model = span.create(self.user, self.example, types)\n        self.assertIsInstance(span_model, SpanModel)\n\n\nclass TestTextLabel(TestLabel):\n    task = ProjectType.SEQ2SEQ\n\n    def test_comparison(self):\n        text1 = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text2 = TextLabel(text=\"B\", example_uuid=uuid.uuid4())\n        self.assertLess(text1, text2)\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        text = TextLabel.parse(example_uuid, obj=\"A\")\n        self.assertEqual(text.text, \"A\")\n\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            TextLabel.parse(example_uuid, obj=[])\n\n    def test_create_type(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        text_type = text.create_type(self.project.item)\n        self.assertEqual(text_type, None)\n\n    def test_create(self):\n        text = TextLabel(text=\"A\", example_uuid=uuid.uuid4())\n        types = MagicMock()\n        text_model = text.create(self.user, self.example, types)\n        self.assertIsInstance(text_model, TextModel)\n\n\nclass TestRelationLabel(TestLabel):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def test_comparison(self):\n        relation1 = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation2 = RelationLabel(type=\"A\", from_id=1, to_id=1, example_uuid=uuid.uuid4())\n        self.assertLess(relation1, relation2)\n\n    def test_parse(self):\n        example_uuid = uuid.uuid4()\n        relation = RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0, \"to_id\": 1})\n        self.assertEqual(relation.type, \"A\")\n        self.assertEqual(relation.from_id, 0)\n        self.assertEqual(relation.to_id, 1)\n\n    def test_parse_invalid_data(self):\n        example_uuid = uuid.uuid4()\n        with self.assertRaises(ValueError):\n            RelationLabel.parse(example_uuid, obj={\"type\": \"A\", \"from_id\": 0})\n\n    def test_create_type(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=uuid.uuid4())\n        relation_type = relation.create_type(self.project.item)\n        self.assertIsInstance(relation_type, RelationType)\n        self.assertEqual(relation_type.text, \"A\")\n\n    def test_create(self):\n        relation = RelationLabel(type=\"A\", from_id=0, to_id=1, example_uuid=self.example.uuid)\n        types = MagicMock()\n        types.__getitem__.return_value = mommy.make(RelationType, project=self.project.item)\n        id_to_span = {\n            (0, str(self.example.uuid)): mommy.make(SpanModel, start_offset=0, end_offset=1, example=self.example),\n            (1, str(self.example.uuid)): mommy.make(SpanModel, start_offset=2, end_offset=3, example=self.example),\n        }\n        relation_model = relation.create(self.user, self.example, types, id_to_span=id_to_span)\n        self.assertIsInstance(relation_model, RelationModel)\n",
                                    "summary": "Comprehensive test suites for various label classes (TestLabel, TestCategoryLabel, TestSpanLabel, TestTextLabel, TestRelationLabel) that validate functionalities such as comparison, parsing, creation, and error handling, ensuring robust behavior in sequence labeling tasks.",
                                    "code_element_summaries": [
                                        "Class TestLabel: A test case for validating functionalities related to a project and an example item within that project.",
                                        "Function `setUp`: Initializes the test environment by preparing a project, assigning an admin user, and creating an example instance with specified text.",
                                        "Class TestCategoryLabel: A test suite for the CategoryLabel class, validating comparison, error handling for empty labels, parsing functionality, and creation of category types and models.",
                                        "Function `test_comparison`: A unit test that verifies the comparison behavior of CategoryLabel instances by asserting that one instance is less than another based on their labels.",
                                        "Function `test_empty_label_raises_value_error`: A test case that verifies a ValueError is raised when attempting to create a CategoryLabel with an empty label.",
                                        "Function `test_parse`: A unit test that verifies the parsing of a CategoryLabel object with a specified UUID and label, ensuring that the parsed values match the expected inputs.",
                                        "Function `test_create_type`: A unit test that verifies the creation of a CategoryType from a CategoryLabel instance, ensuring it is of the correct type and has the expected text.",
                                        "Function `test_create`: A unit test that verifies the creation of a CategoryModel instance from a CategoryLabel using mocked types and asserts its type.",
                                        "Class `TestSpanLabel`: A test suite for the `SpanLabel` class that verifies its comparison, parsing from tuples and dictionaries, validation of offsets, and creation of span types and models in the context of sequence labeling tasks.",
                                        "Function `test_comparison`: A test case that compares two SpanLabel instances to ensure that the first instance is considered less than the second based on their offsets.",
                                        "Function `test_parse_tuple`: A test function that verifies the correct parsing of a tuple into a SpanLabel object by checking its label and offset values.",
                                        "Function `test_parse_dict`: A unit test that verifies the correct parsing of a dictionary into a SpanLabel object, checking its label and offset attributes against expected values.",
                                        "Function `test_invalid_negative_offset`: A test case that verifies a ValueError is raised when creating a SpanLabel with a negative start_offset.",
                                        "Function `test_invalid_offset`: A test case that verifies a ValueError is raised when a SpanLabel is created with an invalid offset where the end offset is less than the start offset.",
                                        "Function `test_parse_invalid_dict`: A test case that verifies that a ValueError is raised when attempting to parse an invalid dictionary input for the SpanLabel class.",
                                        "Function `test_create_type`: A unit test that verifies the creation of a SpanType from a SpanLabel instance, ensuring it is of the correct type and has the expected text.",
                                        "Function `test_create`: A unit test that verifies the creation of a SpanModel instance from a SpanLabel using mocked types and asserts its type.",
                                        "Class TestTextLabel: A test suite for the TextLabel class that verifies comparison, parsing, and creation functionalities, ensuring correct behavior and error handling.",
                                        "Function `test_comparison`: A test function that asserts that one `TextLabel` instance is considered less than another based on their text values.",
                                        "Function `test_parse`: A unit test that verifies the `parse` method of the `TextLabel` class correctly processes an object and assigns the expected text value.",
                                        "Function `test_parse_invalid_data`: A test case that verifies a ValueError is raised when attempting to parse invalid data using the TextLabel class.",
                                        "Function `test_create_type`: A test function that verifies the creation of a text type from a TextLabel instance, asserting that the result is None.",
                                        "Function `test_create`: A test function that verifies the creation of a TextModel instance from a TextLabel object.",
                                        "Class TestRelationLabel: A test suite for the RelationLabel class that verifies its comparison, parsing, creation, and error handling functionalities within a sequence labeling task.",
                                        "Function `test_comparison`: A unit test that compares two `RelationLabel` instances to verify that the first is less than the second based on their attributes.",
                                        "Function `test_parse`: A unit test that verifies the parsing of a RelationLabel object from a given UUID and attributes, ensuring the parsed values match the expected results.",
                                        "Function `test_parse_invalid_data`: A unit test that verifies a ValueError is raised when attempting to parse invalid data using the RelationLabel class.",
                                        "Function `test_create_type`: A unit test that verifies the creation of a RelationType from a RelationLabel and checks its type and text properties.",
                                        "Function `test_create`: A unit test that verifies the creation of a RelationModel instance using a mocked RelationType and SpanModel objects based on specified parameters."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_labels.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_labels.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestCategories`\nCode:\nclass TestCategories(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(CategoryType)\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            CategoryLabel(example_uuid=example_uuid, label=\"A\"),\n            CategoryLabel(example_uuid=example_uuid, label=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.categories = Categories(labels, self.types)\n\n    def test_clean(self):\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 2)\n\n    def test_clean_with_exclusive_labels(self):\n        self.project.item.single_class_classification = True\n        self.project.item.save()\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 1)\n\n    def test_save(self):\n        self.categories.save_types(self.project.item)\n        self.categories.save(self.user, self.examples)\n        self.assertEqual(Category.objects.count(), 2)\n\n    def test_save_types(self):\n        self.categories.save_types(self.project.item)\n        self.assertEqual(CategoryType.objects.count(), 2)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.types = LabelTypes(CategoryType)\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            CategoryLabel(example_uuid=example_uuid, label=\"A\"),\n            CategoryLabel(example_uuid=example_uuid, label=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.categories = Categories(labels, self.types)",
                                        "Function `test_clean`\nCode:\n    def test_clean(self):\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 2)",
                                        "Function `test_clean_with_exclusive_labels`\nCode:\n    def test_clean_with_exclusive_labels(self):\n        self.project.item.single_class_classification = True\n        self.project.item.save()\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 1)",
                                        "Function `test_save`\nCode:\n    def test_save(self):\n        self.categories.save_types(self.project.item)\n        self.categories.save(self.user, self.examples)\n        self.assertEqual(Category.objects.count(), 2)",
                                        "Function `test_save_types`\nCode:\n    def test_save_types(self):\n        self.categories.save_types(self.project.item)\n        self.assertEqual(CategoryType.objects.count(), 2)",
                                        "Class `TestSpans`\nCode:\nclass TestSpans(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(SpanType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=0, end_offset=3),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=3, end_offset=4),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.spans = Spans(labels, self.types)\n\n    def disable_overlapping(self):\n        self.project.item.allow_overlapping = False\n        self.project.item.save()\n\n    def test_clean(self):\n        self.disable_overlapping()\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 2)\n\n    def test_clean_with_overlapping(self):\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 3)\n\n    def test_clean_with_multiple_examples(self):\n        self.disable_overlapping()\n        example_uuid1 = uuid.uuid4()\n        example_uuid2 = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid1, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid2, label=\"B\", start_offset=0, end_offset=3),\n        ]\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid1)\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid2)\n        spans = Spans(labels, self.types)\n        spans.clean(self.project.item)\n        self.assertEqual(len(spans), 2)\n\n    def test_save(self):\n        self.spans.save_types(self.project.item)\n        self.spans.save(self.user, self.examples)\n        self.assertEqual(Span.objects.count(), 3)\n\n    def test_save_types(self):\n        self.spans.save_types(self.project.item)\n        self.assertEqual(SpanType.objects.count(), 2)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.types = LabelTypes(SpanType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=0, end_offset=3),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=3, end_offset=4),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.spans = Spans(labels, self.types)",
                                        "Function `disable_overlapping`\nCode:\n    def disable_overlapping(self):\n        self.project.item.allow_overlapping = False\n        self.project.item.save()",
                                        "Function `test_clean`\nCode:\n    def test_clean(self):\n        self.disable_overlapping()\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 2)",
                                        "Function `test_clean_with_overlapping`\nCode:\n    def test_clean_with_overlapping(self):\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 3)",
                                        "Function `test_clean_with_multiple_examples`\nCode:\n    def test_clean_with_multiple_examples(self):\n        self.disable_overlapping()\n        example_uuid1 = uuid.uuid4()\n        example_uuid2 = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid1, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid2, label=\"B\", start_offset=0, end_offset=3),\n        ]\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid1)\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid2)\n        spans = Spans(labels, self.types)\n        spans.clean(self.project.item)\n        self.assertEqual(len(spans), 2)",
                                        "Function `test_save`\nCode:\n    def test_save(self):\n        self.spans.save_types(self.project.item)\n        self.spans.save(self.user, self.examples)\n        self.assertEqual(Span.objects.count(), 3)",
                                        "Function `test_save_types`\nCode:\n    def test_save_types(self):\n        self.spans.save_types(self.project.item)\n        self.assertEqual(SpanType.objects.count(), 2)",
                                        "Class `TestTexts`\nCode:\nclass TestTexts(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(DummyLabelType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            TextLabel(example_uuid=example_uuid, text=\"A\"),\n            TextLabel(example_uuid=example_uuid, text=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.texts = Texts(labels, self.types)\n\n    def test_clean(self):\n        self.texts.clean(self.project.item)\n        self.assertEqual(len(self.texts), 2)\n\n    def test_save(self):\n        self.texts.save_types(self.project.item)\n        self.texts.save(self.user, self.examples)\n        self.assertEqual(TextLabelModel.objects.count(), 2)\n\n    def test_save_types(self):\n        # nothing happen\n        self.texts.save_types(self.project.item)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.types = LabelTypes(DummyLabelType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            TextLabel(example_uuid=example_uuid, text=\"A\"),\n            TextLabel(example_uuid=example_uuid, text=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.texts = Texts(labels, self.types)",
                                        "Function `test_clean`\nCode:\n    def test_clean(self):\n        self.texts.clean(self.project.item)\n        self.assertEqual(len(self.texts), 2)",
                                        "Function `test_save`\nCode:\n    def test_save(self):\n        self.texts.save_types(self.project.item)\n        self.texts.save(self.user, self.examples)\n        self.assertEqual(TextLabelModel.objects.count(), 2)",
                                        "Function `test_save_types`\nCode:\n    def test_save_types(self):\n        # nothing happen\n        self.texts.save_types(self.project.item)",
                                        "Class `TestRelations`\nCode:\nclass TestRelations(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(RelationType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, use_relation=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid, text=\"hello world\")\n        from_span = mommy.make(\"Span\", example=example, start_offset=0, end_offset=1)\n        to_span = mommy.make(\"Span\", example=example, start_offset=2, end_offset=3)\n        labels = [\n            RelationLabel(example_uuid=example_uuid, type=\"A\", from_id=from_span.id, to_id=to_span.id),\n        ]\n        self.relations = Relations(labels, self.types)\n        self.spans = MagicMock()\n        self.spans.id_to_span = {(from_span.id, str(example_uuid)): from_span, (to_span.id, str(example_uuid)): to_span}\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n\n    def test_clean(self):\n        self.relations.clean(self.project.item)\n        self.assertEqual(len(self.relations), 1)\n\n    def test_save(self):\n        self.relations.save_types(self.project.item)\n        self.relations.save(self.user, self.examples, spans=self.spans)\n        self.assertEqual(Relation.objects.count(), 1)\n\n    def test_save_types(self):\n        self.relations.save_types(self.project.item)\n        self.assertEqual(RelationType.objects.count(), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.types = LabelTypes(RelationType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, use_relation=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid, text=\"hello world\")\n        from_span = mommy.make(\"Span\", example=example, start_offset=0, end_offset=1)\n        to_span = mommy.make(\"Span\", example=example, start_offset=2, end_offset=3)\n        labels = [\n            RelationLabel(example_uuid=example_uuid, type=\"A\", from_id=from_span.id, to_id=to_span.id),\n        ]\n        self.relations = Relations(labels, self.types)\n        self.spans = MagicMock()\n        self.spans.id_to_span = {(from_span.id, str(example_uuid)): from_span, (to_span.id, str(example_uuid)): to_span}\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True",
                                        "Function `test_clean`\nCode:\n    def test_clean(self):\n        self.relations.clean(self.project.item)\n        self.assertEqual(len(self.relations), 1)",
                                        "Function `test_save`\nCode:\n    def test_save(self):\n        self.relations.save_types(self.project.item)\n        self.relations.save(self.user, self.examples, spans=self.spans)\n        self.assertEqual(Relation.objects.count(), 1)",
                                        "Function `test_save_types`\nCode:\n    def test_save_types(self):\n        self.relations.save_types(self.project.item)\n        self.assertEqual(RelationType.objects.count(), 1)"
                                    ],
                                    "code": "import uuid\nfrom unittest.mock import MagicMock\n\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom data_import.models import DummyLabelType\nfrom data_import.pipeline.label import (\n    CategoryLabel,\n    RelationLabel,\n    SpanLabel,\n    TextLabel,\n)\nfrom data_import.pipeline.label_types import LabelTypes\nfrom data_import.pipeline.labels import Categories, Relations, Spans, Texts\nfrom label_types.models import CategoryType, RelationType, SpanType\nfrom labels.models import Category, Relation, Span\nfrom labels.models import TextLabel as TextLabelModel\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestCategories(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(CategoryType)\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            CategoryLabel(example_uuid=example_uuid, label=\"A\"),\n            CategoryLabel(example_uuid=example_uuid, label=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.categories = Categories(labels, self.types)\n\n    def test_clean(self):\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 2)\n\n    def test_clean_with_exclusive_labels(self):\n        self.project.item.single_class_classification = True\n        self.project.item.save()\n        self.categories.clean(self.project.item)\n        self.assertEqual(len(self.categories), 1)\n\n    def test_save(self):\n        self.categories.save_types(self.project.item)\n        self.categories.save(self.user, self.examples)\n        self.assertEqual(Category.objects.count(), 2)\n\n    def test_save_types(self):\n        self.categories.save_types(self.project.item)\n        self.assertEqual(CategoryType.objects.count(), 2)\n\n\nclass TestSpans(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(SpanType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=0, end_offset=3),\n            SpanLabel(example_uuid=example_uuid, label=\"B\", start_offset=3, end_offset=4),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.spans = Spans(labels, self.types)\n\n    def disable_overlapping(self):\n        self.project.item.allow_overlapping = False\n        self.project.item.save()\n\n    def test_clean(self):\n        self.disable_overlapping()\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 2)\n\n    def test_clean_with_overlapping(self):\n        self.spans.clean(self.project.item)\n        self.assertEqual(len(self.spans), 3)\n\n    def test_clean_with_multiple_examples(self):\n        self.disable_overlapping()\n        example_uuid1 = uuid.uuid4()\n        example_uuid2 = uuid.uuid4()\n        labels = [\n            SpanLabel(example_uuid=example_uuid1, label=\"A\", start_offset=0, end_offset=1),\n            SpanLabel(example_uuid=example_uuid2, label=\"B\", start_offset=0, end_offset=3),\n        ]\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid1)\n        mommy.make(\"Example\", project=self.project.item, uuid=example_uuid2)\n        spans = Spans(labels, self.types)\n        spans.clean(self.project.item)\n        self.assertEqual(len(spans), 2)\n\n    def test_save(self):\n        self.spans.save_types(self.project.item)\n        self.spans.save(self.user, self.examples)\n        self.assertEqual(Span.objects.count(), 3)\n\n    def test_save_types(self):\n        self.spans.save_types(self.project.item)\n        self.assertEqual(SpanType.objects.count(), 2)\n\n\nclass TestTexts(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(DummyLabelType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        labels = [\n            TextLabel(example_uuid=example_uuid, text=\"A\"),\n            TextLabel(example_uuid=example_uuid, text=\"B\"),\n        ]\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid)\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n        self.texts = Texts(labels, self.types)\n\n    def test_clean(self):\n        self.texts.clean(self.project.item)\n        self.assertEqual(len(self.texts), 2)\n\n    def test_save(self):\n        self.texts.save_types(self.project.item)\n        self.texts.save(self.user, self.examples)\n        self.assertEqual(TextLabelModel.objects.count(), 2)\n\n    def test_save_types(self):\n        # nothing happen\n        self.texts.save_types(self.project.item)\n\n\nclass TestRelations(TestCase):\n    def setUp(self):\n        self.types = LabelTypes(RelationType)\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, use_relation=True)\n        self.user = self.project.admin\n        example_uuid = uuid.uuid4()\n        example = mommy.make(\"Example\", project=self.project.item, uuid=example_uuid, text=\"hello world\")\n        from_span = mommy.make(\"Span\", example=example, start_offset=0, end_offset=1)\n        to_span = mommy.make(\"Span\", example=example, start_offset=2, end_offset=3)\n        labels = [\n            RelationLabel(example_uuid=example_uuid, type=\"A\", from_id=from_span.id, to_id=to_span.id),\n        ]\n        self.relations = Relations(labels, self.types)\n        self.spans = MagicMock()\n        self.spans.id_to_span = {(from_span.id, str(example_uuid)): from_span, (to_span.id, str(example_uuid)): to_span}\n        self.examples = MagicMock()\n        self.examples.__getitem__.return_value = example\n        self.examples.__contains__.return_value = True\n\n    def test_clean(self):\n        self.relations.clean(self.project.item)\n        self.assertEqual(len(self.relations), 1)\n\n    def test_save(self):\n        self.relations.save_types(self.project.item)\n        self.relations.save(self.user, self.examples, spans=self.spans)\n        self.assertEqual(Relation.objects.count(), 1)\n\n    def test_save_types(self):\n        self.relations.save_types(self.project.item)\n        self.assertEqual(RelationType.objects.count(), 1)\n",
                                    "summary": "Class TestCategories, TestSpans, TestTexts, and TestRelations: A series of test cases designed to validate the functionality of category, span, text, and relation management in document and sequence labeling projects, focusing on cleaning, saving, and type management processes.",
                                    "code_element_summaries": [
                                        "Class TestCategories: A test case for validating the functionality of the Categories class, including cleaning and saving category labels and types in a document classification project.",
                                        "Function `setUp`: Initializes test environment by creating instances of LabelTypes, Project, User, CategoryLabels, and a mock for Examples, along with setting up Categories for testing.",
                                        "Function `test_clean`: A test function that verifies the cleaning of categories associated with a project item, ensuring that the number of categories is reduced to two.",
                                        "Function `test_clean_with_exclusive_labels`: A test that verifies the cleaning of categories results in a single category when the project item is set to single-class classification.",
                                        "Function `test_save`: A test function that verifies the correct saving of category types and examples, ensuring that the total count of Category objects is 2.",
                                        "Function `test_save_types`: A test function that verifies the saving of category types by checking that two category types are created in the database after saving.",
                                        "Class `TestSpans`: A test case for validating the functionality of the `Spans` class, focusing on cleaning overlapping labels and saving span types and instances in a sequence labeling project.",
                                        "Function `setUp`: Initializes test fixtures including label types, a project for sequence labeling, a user, example UUID, span labels, and a mock for example retrieval.",
                                        "Function `disable_overlapping`: Disables overlapping for items in the project by setting the `allow_overlapping` attribute to False and saving the changes.",
                                        "Function `test_clean`: A test that verifies the cleaning process of spans in a project item results in exactly two spans remaining after disabling overlapping.",
                                        "Function `test_clean_with_overlapping`: A test case that verifies the cleaning process of spans results in exactly three remaining spans after handling overlapping spans in a project item.",
                                        "Function `test_clean_with_multiple_examples`: A test case that verifies the cleaning process of spans with multiple labeled examples, ensuring that two spans are correctly created and validated without overlapping.",
                                        "Function `test_save`: A test function that verifies the saving of spans and asserts that the total count of Span objects is 3 after the operation.",
                                        "Function `test_save_types`: A test function that verifies the correct saving of span types, ensuring that two SpanType objects are created in the database.",
                                        "Class TestTexts: A test case for the Texts class that validates label cleaning, saving, and type management in a sequence labeling project.",
                                        "Function `setUp`: A method that initializes test data for a sequence labeling project, including label types, a project instance, a user, example data, and mocked examples and texts.",
                                        "Function `test_clean`: A test function that verifies the cleaning process of `self.texts` against `self.project.item`, ensuring that the length of `self.texts` is 2 after the operation.",
                                        "Function `test_save`: A test function that verifies the saving of text types and examples, ensuring that the count of `TextLabelModel` objects is equal to 2 after the operation.",
                                        "Function `test_save_types`: A method that saves the types of texts associated with a project item, but currently does not perform any actions.",
                                        "Class `TestRelations`: A test case for managing and validating relation labels in a sequence labeling project, ensuring proper cleaning and saving of relations and relation types.",
                                        "Function `setUp`: Initializes test data for a sequence labeling project, including label types, a project instance, a user, example spans, and relation labels, while mocking necessary components for testing.",
                                        "Function `test_clean`: A test case that verifies the cleaning of relations associated with a project item, ensuring that only one relation remains after the operation.",
                                        "Function `test_save`: A test function that verifies the saving of relation types and examples, ensuring that exactly one Relation object is created in the database.",
                                        "Function `test_save_types`: A test function that verifies the saving of relation types associated with a project item, asserting that one relation type is created."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_label_types.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_label_types.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestCategoryLabel`\nCode:\nclass TestCategoryLabel(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_create(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        self.assertEqual(CategoryType.objects.count(), 1)\n        self.assertEqual(CategoryType.objects.first().text, \"A\")\n\n    def test_update(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        label_types.update(self.project.item)\n        category_type = label_types[\"A\"]\n        self.assertEqual(category_type.text, \"A\")",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item)",
                                        "Function `test_create`\nCode:\n    def test_create(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        self.assertEqual(CategoryType.objects.count(), 1)\n        self.assertEqual(CategoryType.objects.first().text, \"A\")",
                                        "Function `test_update`\nCode:\n    def test_update(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        label_types.update(self.project.item)\n        category_type = label_types[\"A\"]\n        self.assertEqual(category_type.text, \"A\")"
                                    ],
                                    "code": "from django.test import TestCase\nfrom model_mommy import mommy\n\nfrom data_import.pipeline.label_types import LabelTypes\nfrom label_types.models import CategoryType\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestCategoryLabel(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.user = self.project.admin\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_create(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        self.assertEqual(CategoryType.objects.count(), 1)\n        self.assertEqual(CategoryType.objects.first().text, \"A\")\n\n    def test_update(self):\n        label_types = LabelTypes(CategoryType)\n        category_types = [CategoryType(text=\"A\", project=self.project.item)]\n        label_types.save(category_types)\n        label_types.update(self.project.item)\n        category_type = label_types[\"A\"]\n        self.assertEqual(category_type.text, \"A\")\n",
                                    "summary": "Class TestCategoryLabel: A test case designed to validate the creation and updating processes of category types within a document classification project.",
                                    "code_element_summaries": [
                                        "Class TestCategoryLabel: A test case that verifies the creation and updating of category types associated with a document classification project.",
                                        "Function `setUp`: Prepares a test environment by creating a project for document classification, assigning an admin user, and generating an example associated with the project.",
                                        "Function `test_create`: A test function that verifies the creation and persistence of a new category type labeled \"A\" in the database.",
                                        "Function `test_update`: A test function that verifies the update functionality of label types by creating a category type, saving it, and asserting that the category type's text matches the expected value."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_makers.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_makers.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExamplesMaker`\nCode:\nclass TestExamplesMaker(TestCase):\n    def setUp(self):\n        self.project = prepare_project()\n        self.label_column = \"label\"\n        self.text_column = \"text\"\n        self.record = {\n            LINE_NUMBER_COLUMN: 1,\n            UUID_COLUMN: uuid.uuid4(),\n            FILE_NAME_COLUMN: \"file1\",\n            UPLOAD_NAME_COLUMN: \"upload1\",\n            self.text_column: \"text1\",\n            self.label_column: [\"A\"],\n        }\n        self.maker = ExampleMaker(self.project.item, TextData, self.text_column, [self.label_column])\n\n    def test_make_examples(self):\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 1)\n\n    def test_check_column_existence(self):\n        self.record.pop(self.text_column)\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)\n\n    def test_empty_text_raises_error(self):\n        self.record[self.text_column] = \"\"\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.label_column = \"label\"\n        self.text_column = \"text\"\n        self.record = {\n            LINE_NUMBER_COLUMN: 1,\n            UUID_COLUMN: uuid.uuid4(),\n            FILE_NAME_COLUMN: \"file1\",\n            UPLOAD_NAME_COLUMN: \"upload1\",\n            self.text_column: \"text1\",\n            self.label_column: [\"A\"],\n        }\n        self.maker = ExampleMaker(self.project.item, TextData, self.text_column, [self.label_column])",
                                        "Function `test_make_examples`\nCode:\n    def test_make_examples(self):\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 1)",
                                        "Function `test_check_column_existence`\nCode:\n    def test_check_column_existence(self):\n        self.record.pop(self.text_column)\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)",
                                        "Function `test_empty_text_raises_error`\nCode:\n    def test_empty_text_raises_error(self):\n        self.record[self.text_column] = \"\"\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)",
                                        "Class `TestLabelFormatter`\nCode:\nclass TestLabelFormatter(TestCase):\n    def setUp(self):\n        self.label_column = \"label\"\n        self.label_class = CategoryLabel\n        self.df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"B\", \"C\"]},\n            ]\n        )\n\n    def test_make(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        labels = label_maker.make(self.df)\n        self.assertEqual(len(labels), 3)\n        with self.subTest():\n            for label, expected in zip(labels, [\"A\", \"B\", \"C\"]):\n                self.assertEqual(getattr(label, \"label\"), expected)\n\n    def test_format_without_specified_column(self):\n        label_maker = LabelMaker(column=\"invalid_column\", label_class=self.label_class)\n        with self.assertRaises(KeyError):\n            label_maker.make(self.df)\n\n    def test_format_with_partially_correct_column(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), \"invalid_column\": [\"B\"]},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4()},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4(), self.label_column: [{}]},\n            ]\n        )\n        labels = label_maker.make(df)\n        self.assertEqual(len(labels), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.label_column = \"label\"\n        self.label_class = CategoryLabel\n        self.df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"B\", \"C\"]},\n            ]\n        )",
                                        "Function `test_make`\nCode:\n    def test_make(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        labels = label_maker.make(self.df)\n        self.assertEqual(len(labels), 3)\n        with self.subTest():\n            for label, expected in zip(labels, [\"A\", \"B\", \"C\"]):\n                self.assertEqual(getattr(label, \"label\"), expected)",
                                        "Function `test_format_without_specified_column`\nCode:\n    def test_format_without_specified_column(self):\n        label_maker = LabelMaker(column=\"invalid_column\", label_class=self.label_class)\n        with self.assertRaises(KeyError):\n            label_maker.make(self.df)",
                                        "Function `test_format_with_partially_correct_column`\nCode:\n    def test_format_with_partially_correct_column(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), \"invalid_column\": [\"B\"]},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4()},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4(), self.label_column: [{}]},\n            ]\n        )\n        labels = label_maker.make(df)\n        self.assertEqual(len(labels), 1)"
                                    ],
                                    "code": "import uuid\n\nimport pandas as pd\nfrom django.test import TestCase\n\nfrom data_import.pipeline.data import TextData\nfrom data_import.pipeline.label import CategoryLabel\nfrom data_import.pipeline.makers import ExampleMaker, LabelMaker\nfrom data_import.pipeline.readers import (\n    FILE_NAME_COLUMN,\n    LINE_NUMBER_COLUMN,\n    UPLOAD_NAME_COLUMN,\n    UUID_COLUMN,\n)\nfrom projects.tests.utils import prepare_project\n\n\nclass TestExamplesMaker(TestCase):\n    def setUp(self):\n        self.project = prepare_project()\n        self.label_column = \"label\"\n        self.text_column = \"text\"\n        self.record = {\n            LINE_NUMBER_COLUMN: 1,\n            UUID_COLUMN: uuid.uuid4(),\n            FILE_NAME_COLUMN: \"file1\",\n            UPLOAD_NAME_COLUMN: \"upload1\",\n            self.text_column: \"text1\",\n            self.label_column: [\"A\"],\n        }\n        self.maker = ExampleMaker(self.project.item, TextData, self.text_column, [self.label_column])\n\n    def test_make_examples(self):\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 1)\n\n    def test_check_column_existence(self):\n        self.record.pop(self.text_column)\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)\n\n    def test_empty_text_raises_error(self):\n        self.record[self.text_column] = \"\"\n        df = pd.DataFrame([self.record])\n        examples = self.maker.make(df)\n        self.assertEqual(len(examples), 0)\n        self.assertEqual(len(self.maker.errors), 1)\n\n\nclass TestLabelFormatter(TestCase):\n    def setUp(self):\n        self.label_column = \"label\"\n        self.label_class = CategoryLabel\n        self.df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"B\", \"C\"]},\n            ]\n        )\n\n    def test_make(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        labels = label_maker.make(self.df)\n        self.assertEqual(len(labels), 3)\n        with self.subTest():\n            for label, expected in zip(labels, [\"A\", \"B\", \"C\"]):\n                self.assertEqual(getattr(label, \"label\"), expected)\n\n    def test_format_without_specified_column(self):\n        label_maker = LabelMaker(column=\"invalid_column\", label_class=self.label_class)\n        with self.assertRaises(KeyError):\n            label_maker.make(self.df)\n\n    def test_format_with_partially_correct_column(self):\n        label_maker = LabelMaker(column=self.label_column, label_class=self.label_class)\n        df = pd.DataFrame(\n            [\n                {LINE_NUMBER_COLUMN: 1, UUID_COLUMN: uuid.uuid4(), self.label_column: [\"A\"]},\n                {LINE_NUMBER_COLUMN: 2, UUID_COLUMN: uuid.uuid4(), \"invalid_column\": [\"B\"]},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4()},\n                {LINE_NUMBER_COLUMN: 3, UUID_COLUMN: uuid.uuid4(), self.label_column: [{}]},\n            ]\n        )\n        labels = label_maker.make(df)\n        self.assertEqual(len(labels), 1)\n",
                                    "summary": "Classes `TestExamplesMaker` and `TestLabelFormatter`: Unit test cases for the `ExampleMaker` and `LabelMaker` classes, respectively, validating example creation and label formatting from DataFrames while checking for errors related to missing or invalid data.",
                                    "code_element_summaries": [
                                        "Class `TestExamplesMaker`: A unit test case for the `ExampleMaker` class, validating the creation of examples from a DataFrame and checking for errors related to missing or empty text fields.",
                                        "Function `setUp`: Initializes a test environment by preparing a project, defining label and text columns, creating a record dictionary, and instantiating an ExampleMaker with relevant parameters.",
                                        "Function `test_make_examples`: A unit test that verifies the `make` method of the `maker` object produces one example from the given DataFrame containing a single record.",
                                        "Function `test_check_column_existence`: A test that verifies the absence of a specified column in a DataFrame results in zero examples being created and one error being recorded.",
                                        "Function `test_empty_text_raises_error`: A test that verifies an empty text input results in no examples being created and one error being recorded.",
                                        "Class `TestLabelFormatter`: A test case that verifies the functionality of the `LabelMaker` class in creating labels from a DataFrame, handling various scenarios including valid, invalid, and partially correct column inputs.",
                                        "Function `setUp`: Initializes a test environment by creating a label column and a DataFrame with sample data containing line numbers, UUIDs, and associated labels.",
                                        "Function `test_make`: A unit test that verifies the `LabelMaker` class correctly generates labels from a DataFrame, ensuring the output contains three labels matching expected values \"A\", \"B\", and \"C\".",
                                        "Function `test_format_without_specified_column`: A test case that verifies a KeyError is raised when attempting to create labels with an invalid column name in the LabelMaker class.",
                                        "Function `test_format_with_partially_correct_column`: A test function that verifies the behavior of the `LabelMaker` when processing a DataFrame with both valid and invalid label columns, ensuring that only valid labels are counted."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_parser.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_parser.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestParser`\nCode:\nclass TestParser(unittest.TestCase):\n    def setUp(self):\n        self.test_dir = tempfile.mkdtemp()\n        self.test_file = os.path.join(self.test_dir, \"test_file.csv\")\n\n    def tearDown(self):\n        shutil.rmtree(self.test_dir)\n\n    def create_file(self, content):\n        with open(self.test_file, \"w\") as f:\n            f.write(content)\n\n    def assert_record(self, content, parser, expected):\n        self.create_file(content)\n        it = parser.parse(self.test_file)\n        for expect in expected:\n            row = next(it)\n            row.pop(LINE_NUMBER_COLUMN, None)\n            self.assertEqual(row, expect)\n        with self.assertRaises(StopIteration):\n            next(it)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.test_dir = tempfile.mkdtemp()\n        self.test_file = os.path.join(self.test_dir, \"test_file.csv\")",
                                        "Function `tearDown`\nCode:\n    def tearDown(self):\n        shutil.rmtree(self.test_dir)",
                                        "Function `create_file`\nCode:\n    def create_file(self, content):\n        with open(self.test_file, \"w\") as f:\n            f.write(content)",
                                        "Function `assert_record`\nCode:\n    def assert_record(self, content, parser, expected):\n        self.create_file(content)\n        it = parser.parse(self.test_file)\n        for expect in expected:\n            row = next(it)\n            row.pop(LINE_NUMBER_COLUMN, None)\n            self.assertEqual(row, expect)\n        with self.assertRaises(StopIteration):\n            next(it)",
                                        "Class `TestPlainParser`\nCode:\nclass TestPlainParser(TestParser):\n    def test_read(self):\n        content = \"example\"\n        parser = parsers.PlainParser()\n        expected = [{}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = \"example\"\n        parser = parsers.PlainParser()\n        expected = [{}]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestLineParser`\nCode:\nclass TestLineParser(TestParser):\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.LineParser()\n        expected = [{\"text\": \"Hello, World!\"}, {\"text\": \"こんにちは\"}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.LineParser()\n        expected = [{\"text\": \"Hello, World!\"}, {\"text\": \"こんにちは\"}]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestTextFileParser`\nCode:\nclass TestTextFileParser(TestParser):\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.TextFileParser()\n        expected = [{\"text\": content}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.TextFileParser()\n        expected = [{\"text\": content}]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestCsvParser`\nCode:\nclass TestCsvParser(TestParser):\n    def test_read(self):\n        content = \"label,text\\nLabel,Text\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)\n\n    def test_can_change_delimiter(self):\n        content = \"label\\ttext\\nLabel\\tText\"\n        parser = parsers.CSVParser(delimiter=\"\\t\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)\n\n    def test_can_read_null_value(self):\n        content = \"text,label\\nText\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"text\": \"Text\", \"label\": None}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = \"label,text\\nLabel,Text\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_can_change_delimiter`\nCode:\n    def test_can_change_delimiter(self):\n        content = \"label\\ttext\\nLabel\\tText\"\n        parser = parsers.CSVParser(delimiter=\"\\t\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_can_read_null_value`\nCode:\n    def test_can_read_null_value(self):\n        content = \"text,label\\nText\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"text\": \"Text\", \"label\": None}]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestJSONParser`\nCode:\nclass TestJSONParser(TestParser):\n    def test_read(self):\n        content = json.dumps([{\"text\": \"line1\", \"labels\": \"Label1\"}, {\"text\": \"line2\", \"labels\": \"Label2\"}])\n        parser = parsers.JSONParser()\n        expected = json.loads(content)\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = json.dumps([{\"text\": \"line1\", \"labels\": \"Label1\"}, {\"text\": \"line2\", \"labels\": \"Label2\"}])\n        parser = parsers.JSONParser()\n        expected = json.loads(content)\n        self.assert_record(content, parser, expected)",
                                        "Class `TestJSONLParser`\nCode:\nclass TestJSONLParser(TestParser):\n    def test_read(self):\n        line1 = json.dumps({\"text\": \"line1\", \"labels\": \"Label1\"})\n        line2 = json.dumps({\"text\": \"line2\", \"labels\": \"Label2\"})\n        content = f\"{line1}\\n{line2}\"\n        parser = parsers.JSONLParser()\n        expected = [json.loads(line1), json.loads(line2)]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        line1 = json.dumps({\"text\": \"line1\", \"labels\": \"Label1\"})\n        line2 = json.dumps({\"text\": \"line2\", \"labels\": \"Label2\"})\n        content = f\"{line1}\\n{line2}\"\n        parser = parsers.JSONLParser()\n        expected = [json.loads(line1), json.loads(line2)]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestFastTextParser`\nCode:\nclass TestFastTextParser(TestParser):\n    def test_read(self):\n        content = \"__label__sauce __label__cheese Text\"\n        parser = parsers.FastTextParser()\n        expected = [{\"text\": \"Text\", \"label\": [\"sauce\", \"cheese\"]}]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_read`\nCode:\n    def test_read(self):\n        content = \"__label__sauce __label__cheese Text\"\n        parser = parsers.FastTextParser()\n        expected = [{\"text\": \"Text\", \"label\": [\"sauce\", \"cheese\"]}]\n        self.assert_record(content, parser, expected)",
                                        "Class `TestCoNLLParser`\nCode:\nclass TestCoNLLParser(TestParser):\n    def test_can_read(self):\n        content = \"\"\"EU\\tB-ORG\nrejects\\tO\nGerman\\tB-MISC\ncall\\tO\nto\\tO\nboycott\\tO\nBritish\\tB-MISC\nlamb\\tO\n.\\tO\n\nPeter\\tB-PER\nBlackburn\\tI-PER\n\n\"\"\"\n        parser = parsers.CoNLLParser()\n        expected = [\n            {\n                \"text\": \"EU rejects German call to boycott British lamb .\",\n                \"label\": [(0, 2, \"ORG\"), (11, 17, \"MISC\"), (34, 41, \"MISC\")],\n            },\n            {\"text\": \"Peter Blackburn\", \"label\": [(0, 15, \"PER\")]},\n        ]\n        self.assert_record(content, parser, expected)",
                                        "Function `test_can_read`\nCode:\n    def test_can_read(self):\n        content = \"\"\"EU\\tB-ORG\nrejects\\tO\nGerman\\tB-MISC\ncall\\tO\nto\\tO\nboycott\\tO\nBritish\\tB-MISC\nlamb\\tO\n.\\tO\n\nPeter\\tB-PER\nBlackburn\\tI-PER\n\n\"\"\"\n        parser = parsers.CoNLLParser()\n        expected = [\n            {\n                \"text\": \"EU rejects German call to boycott British lamb .\",\n                \"label\": [(0, 2, \"ORG\"), (11, 17, \"MISC\"), (34, 41, \"MISC\")],\n            },\n            {\"text\": \"Peter Blackburn\", \"label\": [(0, 15, \"PER\")]},\n        ]\n        self.assert_record(content, parser, expected)"
                                    ],
                                    "code": "import json\nimport os\nimport shutil\nimport tempfile\nimport unittest\n\nfrom data_import.pipeline import parsers\nfrom data_import.pipeline.readers import LINE_NUMBER_COLUMN\n\n\nclass TestParser(unittest.TestCase):\n    def setUp(self):\n        self.test_dir = tempfile.mkdtemp()\n        self.test_file = os.path.join(self.test_dir, \"test_file.csv\")\n\n    def tearDown(self):\n        shutil.rmtree(self.test_dir)\n\n    def create_file(self, content):\n        with open(self.test_file, \"w\") as f:\n            f.write(content)\n\n    def assert_record(self, content, parser, expected):\n        self.create_file(content)\n        it = parser.parse(self.test_file)\n        for expect in expected:\n            row = next(it)\n            row.pop(LINE_NUMBER_COLUMN, None)\n            self.assertEqual(row, expect)\n        with self.assertRaises(StopIteration):\n            next(it)\n\n\nclass TestPlainParser(TestParser):\n    def test_read(self):\n        content = \"example\"\n        parser = parsers.PlainParser()\n        expected = [{}]\n        self.assert_record(content, parser, expected)\n\n\nclass TestLineParser(TestParser):\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.LineParser()\n        expected = [{\"text\": \"Hello, World!\"}, {\"text\": \"こんにちは\"}]\n        self.assert_record(content, parser, expected)\n\n\nclass TestTextFileParser(TestParser):\n    def test_read(self):\n        content = \"Hello, World!\\nこんにちは\"\n        parser = parsers.TextFileParser()\n        expected = [{\"text\": content}]\n        self.assert_record(content, parser, expected)\n\n\nclass TestCsvParser(TestParser):\n    def test_read(self):\n        content = \"label,text\\nLabel,Text\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)\n\n    def test_can_change_delimiter(self):\n        content = \"label\\ttext\\nLabel\\tText\"\n        parser = parsers.CSVParser(delimiter=\"\\t\")\n        expected = [{\"label\": \"Label\", \"text\": \"Text\"}]\n        self.assert_record(content, parser, expected)\n\n    def test_can_read_null_value(self):\n        content = \"text,label\\nText\"\n        parser = parsers.CSVParser(delimiter=\",\")\n        expected = [{\"text\": \"Text\", \"label\": None}]\n        self.assert_record(content, parser, expected)\n\n\nclass TestJSONParser(TestParser):\n    def test_read(self):\n        content = json.dumps([{\"text\": \"line1\", \"labels\": \"Label1\"}, {\"text\": \"line2\", \"labels\": \"Label2\"}])\n        parser = parsers.JSONParser()\n        expected = json.loads(content)\n        self.assert_record(content, parser, expected)\n\n\nclass TestJSONLParser(TestParser):\n    def test_read(self):\n        line1 = json.dumps({\"text\": \"line1\", \"labels\": \"Label1\"})\n        line2 = json.dumps({\"text\": \"line2\", \"labels\": \"Label2\"})\n        content = f\"{line1}\\n{line2}\"\n        parser = parsers.JSONLParser()\n        expected = [json.loads(line1), json.loads(line2)]\n        self.assert_record(content, parser, expected)\n\n\nclass TestFastTextParser(TestParser):\n    def test_read(self):\n        content = \"__label__sauce __label__cheese Text\"\n        parser = parsers.FastTextParser()\n        expected = [{\"text\": \"Text\", \"label\": [\"sauce\", \"cheese\"]}]\n        self.assert_record(content, parser, expected)\n\n\nclass TestCoNLLParser(TestParser):\n    def test_can_read(self):\n        content = \"\"\"EU\\tB-ORG\nrejects\\tO\nGerman\\tB-MISC\ncall\\tO\nto\\tO\nboycott\\tO\nBritish\\tB-MISC\nlamb\\tO\n.\\tO\n\nPeter\\tB-PER\nBlackburn\\tI-PER\n\n\"\"\"\n        parser = parsers.CoNLLParser()\n        expected = [\n            {\n                \"text\": \"EU rejects German call to boycott British lamb .\",\n                \"label\": [(0, 2, \"ORG\"), (11, 17, \"MISC\"), (34, 41, \"MISC\")],\n            },\n            {\"text\": \"Peter Blackburn\", \"label\": [(0, 15, \"PER\")]},\n        ]\n        self.assert_record(content, parser, expected)\n",
                                    "summary": "Class TestParser and its subclasses provide comprehensive unit tests for various parsers (CSV, Plain, Line, TextFile, JSON, JSONL, FastText, and CoNLL), ensuring each parser's functionality, including reading, parsing, and handling of different content formats and edge cases.",
                                    "code_element_summaries": [
                                        "Class TestParser: A unit test case for testing a CSV parser, providing setup and teardown methods for file handling and assertions for record validation.",
                                        "Function `setUp`: Initializes a temporary directory and a test file path for use in unit tests.",
                                        "Function `tearDown`: Cleans up the test environment by removing the test directory after tests are executed.",
                                        "Function `create_file`: A method that writes the provided content to a specified test file.",
                                        "Function `assert_record`: A method that verifies parsed records against expected values while ensuring the parser raises a StopIteration exception when all records are processed.",
                                        "Class TestPlainParser: A test case for the PlainParser that verifies its ability to read and parse a given content string.",
                                        "Function `test_read`: A test function that verifies the output of the `PlainParser` against an expected result when given a specific content input.",
                                        "Class TestLineParser: A unit test for the LineParser that verifies the correct parsing of a string containing both English and Japanese text into a list of dictionaries.",
                                        "Function `test_read`: A test case that verifies the `LineParser` correctly parses a multilingual string into a list of dictionaries with text entries.",
                                        "Class TestTextFileParser: A test case for the TextFileParser that verifies the correct reading of text content, including multilingual characters.",
                                        "Function `test_read`: A test function that verifies the parsing of a text file containing mixed language content using the TextFileParser.",
                                        "Class TestCsvParser: A test suite for the CSVParser that verifies its ability to read CSV data with different delimiters and handle null values.",
                                        "Function `test_read`: A test case that verifies the functionality of the CSVParser by checking if it correctly parses a CSV string into a list of dictionaries.",
                                        "Function `test_can_change_delimiter`: A test case that verifies the ability of the CSVParser to correctly parse tab-delimited content into a list of dictionaries.",
                                        "Function `test_can_read_null_value`: A test case that verifies the CSV parser correctly handles null values in a CSV input.",
                                        "Class `TestJSONParser`: A test case for the JSONParser that verifies the correct reading of JSON formatted data by comparing the parsed output with the expected result.",
                                        "Function `test_read`: A test function that verifies the JSON parsing of a list of labeled text records against expected output.",
                                        "Class `TestJSONLParser`: A test case for the JSONLParser that verifies the correct reading and parsing of JSON lines into expected data structures.",
                                        "Function `test_read`: A unit test that verifies the JSONLParser correctly parses a JSONL formatted string into a list of expected dictionary objects.",
                                        "Class `TestFastTextParser`: A test case for the FastTextParser that verifies the correct parsing of labeled text input into a structured format.",
                                        "Function `test_read`: A unit test that verifies the parsing of text with labels using the FastTextParser, ensuring the output matches the expected format.",
                                        "Class TestCoNLLParser: A unit test for the CoNLLParser that verifies its ability to correctly parse CoNLL formatted text into structured records with corresponding labels.",
                                        "Function `test_can_read`: A test function that verifies the parsing of CoNLL formatted text into structured records with associated labels for named entities."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_reader.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_reader.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestReader`\nCode:\nclass TestReader(unittest.TestCase):\n    def setUp(self):\n        self.parser = MagicMock()\n        self.parser.parse.return_value = [{\"a\": 1}, {\"a\": 2}]\n        filename = MagicMock()\n        filename.generated_name = \"filename\"\n        filename.upload_name = \"upload_name\"\n        self.filenames = MagicMock()\n        self.filenames.__iter__.return_value = [filename]\n        self.rows = [\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 1,\n            },\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 2,\n            },\n        ]\n\n    @patch(\"data_import.pipeline.readers.uuid.uuid4\")\n    def test_iter_method(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        self.assertEqual(list(reader), self.rows)\n\n    @patch(\"data_import.pipeline.readers.uuid.uuid4\")\n    def test_batch(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        batch = next(reader.batch(2))\n        expected_df = pd.DataFrame(self.rows)\n        assert_frame_equal(batch, expected_df)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.parser = MagicMock()\n        self.parser.parse.return_value = [{\"a\": 1}, {\"a\": 2}]\n        filename = MagicMock()\n        filename.generated_name = \"filename\"\n        filename.upload_name = \"upload_name\"\n        self.filenames = MagicMock()\n        self.filenames.__iter__.return_value = [filename]\n        self.rows = [\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 1,\n            },\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 2,\n            },\n        ]",
                                        "Function `test_iter_method`\nCode:\n    def test_iter_method(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        self.assertEqual(list(reader), self.rows)",
                                        "Function `test_batch`\nCode:\n    def test_batch(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        batch = next(reader.batch(2))\n        expected_df = pd.DataFrame(self.rows)\n        assert_frame_equal(batch, expected_df)"
                                    ],
                                    "code": "import unittest\nfrom unittest.mock import MagicMock, patch\n\nimport pandas as pd\nfrom pandas.testing import assert_frame_equal\n\nfrom data_import.pipeline.readers import (\n    FILE_NAME_COLUMN,\n    UPLOAD_NAME_COLUMN,\n    UUID_COLUMN,\n    Reader,\n)\n\n\nclass TestReader(unittest.TestCase):\n    def setUp(self):\n        self.parser = MagicMock()\n        self.parser.parse.return_value = [{\"a\": 1}, {\"a\": 2}]\n        filename = MagicMock()\n        filename.generated_name = \"filename\"\n        filename.upload_name = \"upload_name\"\n        self.filenames = MagicMock()\n        self.filenames.__iter__.return_value = [filename]\n        self.rows = [\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 1,\n            },\n            {\n                UUID_COLUMN: \"uuid\",\n                FILE_NAME_COLUMN: filename.generated_name,\n                UPLOAD_NAME_COLUMN: filename.upload_name,\n                \"a\": 2,\n            },\n        ]\n\n    @patch(\"data_import.pipeline.readers.uuid.uuid4\")\n    def test_iter_method(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        self.assertEqual(list(reader), self.rows)\n\n    @patch(\"data_import.pipeline.readers.uuid.uuid4\")\n    def test_batch(self, mock):\n        mock.return_value = \"uuid\"\n        reader = Reader(self.filenames, self.parser)\n        batch = next(reader.batch(2))\n        expected_df = pd.DataFrame(self.rows)\n        assert_frame_equal(batch, expected_df)\n",
                                    "summary": "Class TestReader: A unit test case for the Reader class that ensures correct iteration and batching functionality through mocked data and parser responses.",
                                    "code_element_summaries": [
                                        "Class TestReader: A unit test case for the Reader class that verifies the iteration and batching functionality using mocked file names and parser responses.",
                                        "Function `setUp`: A setup method that initializes mock objects and prepares data for testing, including a parser and a list of rows with specific attributes.",
                                        "Function `test_iter_method`: A test function that verifies the iteration behavior of the Reader class by asserting that its output matches expected rows when a mock return value is used.",
                                        "Function `test_batch`: A test function that verifies the output of the `Reader` class's `batch` method against an expected DataFrame."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_tasks.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_tasks.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestImportData`\nCode:\nclass TestImportData(TestCase):\n    task = \"Any\"\n    annotation_class = Category\n\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()\n\n    def tearDown(self):\n        try:\n            su = StoredUpload.objects.get(upload_id=self.upload_id)\n            directory = pathlib.Path(su.get_absolute_file_path()).parent\n            shutil.rmtree(directory)\n        except StoredUpload.DoesNotExist:\n            pass\n\n    def import_dataset(self, filename, file_format, task, kwargs=None):\n        file_path = str(self.data_path / filename)\n        TemporaryUpload.objects.create(\n            upload_id=self.upload_id,\n            file_id=\"1\",\n            file=File(open(file_path, mode=\"rb\"), filename.split(\"/\")[-1]),\n            upload_name=filename,\n            upload_type=\"F\",\n        )\n        upload_ids = [self.upload_id]\n        kwargs = kwargs or {}\n        return import_dataset(self.user.id, self.project.item.id, file_format, upload_ids, task, **kwargs)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()",
                                        "Function `tearDown`\nCode:\n    def tearDown(self):\n        try:\n            su = StoredUpload.objects.get(upload_id=self.upload_id)\n            directory = pathlib.Path(su.get_absolute_file_path()).parent\n            shutil.rmtree(directory)\n        except StoredUpload.DoesNotExist:\n            pass",
                                        "Function `import_dataset`\nCode:\n    def import_dataset(self, filename, file_format, task, kwargs=None):\n        file_path = str(self.data_path / filename)\n        TemporaryUpload.objects.create(\n            upload_id=self.upload_id,\n            file_id=\"1\",\n            file=File(open(file_path, mode=\"rb\"), filename.split(\"/\")[-1]),\n            upload_name=filename,\n            upload_type=\"F\",\n        )\n        upload_ids = [self.upload_id]\n        kwargs = kwargs or {}\n        return import_dataset(self.user.id, self.project.item.id, file_format, upload_ids, task, **kwargs)",
                                        "Class `TestMaxFileSize`\nCode:\nclass TestMaxFileSize(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        response = self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"maximum file size\", response[\"error\"][0][\"message\"])",
                                        "Function `test_jsonl`\nCode:\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        response = self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"maximum file size\", response[\"error\"][0][\"message\"])",
                                        "Class `TestInvalidFileFormat`\nCode:\nclass TestInvalidFileFormat(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_invalid_file_format(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"INVALID_FORMAT\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)",
                                        "Function `test_invalid_file_format`\nCode:\n    def test_invalid_file_format(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"INVALID_FORMAT\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)",
                                        "Class `TestImportClassificationData`\nCode:\nclass TestImportClassificationData(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def assert_examples(self, dataset):\n        with self.subTest():\n            self.assertEqual(Example.objects.count(), len(dataset))\n            for text, expected_labels in dataset:\n                example = Example.objects.get(text=text)\n                labels = set(cat.label.text for cat in example.categories.all())\n                self.assertEqual(labels, set(expected_labels))\n\n    def assert_parse_error(self, response):\n        with self.subTest():\n            self.assertGreaterEqual(len(response[\"error\"]), 1)\n            self.assertEqual(Example.objects.count(), 0)\n            self.assertEqual(Category.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assert_examples(dataset)\n\n    def test_csv(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_csv_out_of_order_columns(self):\n        filename = \"text_classification/example_out_of_order_columns.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_fasttext(self):\n        filename = \"text_classification/example_fasttext.txt\"\n        file_format = \"fastText\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_excel(self):\n        filename = \"text_classification/example.xlsx\"\n        file_format = \"Excel\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_json(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_textfile(self):\n        filename = \"example.txt\"\n        file_format = \"TextFile\"\n        dataset = [(\"exampleA\\nexampleB\\n\\nexampleC\\n\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 0)\n\n    def test_textline(self):\n        filename = \"example.txt\"\n        file_format = \"TextLine\"\n        dataset = [(\"exampleA\", []), (\"exampleB\", []), (\"exampleC\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 1)\n\n    def test_wrong_jsonl(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_json(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSON\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_excel(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"Excel\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_csv(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"CSV\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Function `assert_examples`\nCode:\n    def assert_examples(self, dataset):\n        with self.subTest():\n            self.assertEqual(Example.objects.count(), len(dataset))\n            for text, expected_labels in dataset:\n                example = Example.objects.get(text=text)\n                labels = set(cat.label.text for cat in example.categories.all())\n                self.assertEqual(labels, set(expected_labels))",
                                        "Function `assert_parse_error`\nCode:\n    def assert_parse_error(self, response):\n        with self.subTest():\n            self.assertGreaterEqual(len(response[\"error\"]), 1)\n            self.assertEqual(Example.objects.count(), 0)\n            self.assertEqual(Category.objects.count(), 0)",
                                        "Function `test_jsonl`\nCode:\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assert_examples(dataset)",
                                        "Function `test_csv`\nCode:\n    def test_csv(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_csv_out_of_order_columns`\nCode:\n    def test_csv_out_of_order_columns(self):\n        filename = \"text_classification/example_out_of_order_columns.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_fasttext`\nCode:\n    def test_fasttext(self):\n        filename = \"text_classification/example_fasttext.txt\"\n        file_format = \"fastText\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_excel`\nCode:\n    def test_excel(self):\n        filename = \"text_classification/example.xlsx\"\n        file_format = \"Excel\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_json`\nCode:\n    def test_json(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_textfile`\nCode:\n    def test_textfile(self):\n        filename = \"example.txt\"\n        file_format = \"TextFile\"\n        dataset = [(\"exampleA\\nexampleB\\n\\nexampleC\\n\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 0)",
                                        "Function `test_textline`\nCode:\n    def test_textline(self):\n        filename = \"example.txt\"\n        file_format = \"TextLine\"\n        dataset = [(\"exampleA\", []), (\"exampleB\", []), (\"exampleC\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 1)",
                                        "Function `test_wrong_jsonl`\nCode:\n    def test_wrong_jsonl(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Function `test_wrong_json`\nCode:\n    def test_wrong_json(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSON\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Function `test_wrong_excel`\nCode:\n    def test_wrong_excel(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"Excel\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Function `test_wrong_csv`\nCode:\n    def test_wrong_csv(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"CSV\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Class `TestImportSequenceLabelingData`\nCode:\nclass TestImportSequenceLabelingData(TestImportData):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(labels, expected_labels)\n\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [[0, 1, \"LOC\"]]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_conll(self):\n        filename = \"sequence_labeling/example.conll\"\n        file_format = \"CoNLL\"\n        dataset = [(\"JAPAN GET\", [[0, 5, \"LOC\"]]), (\"Nadim Ladki\", [[0, 11, \"PER\"]])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_wrong_conll(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"CoNLL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_jsonl_with_overlapping(self):\n        filename = \"sequence_labeling/example_overlapping.jsonl\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 0)",
                                        "Function `assert_examples`\nCode:\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(labels, expected_labels)",
                                        "Function `assert_parse_error`\nCode:\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)",
                                        "Function `test_jsonl`\nCode:\n    def test_jsonl(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [[0, 1, \"LOC\"]]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_conll`\nCode:\n    def test_conll(self):\n        filename = \"sequence_labeling/example.conll\"\n        file_format = \"CoNLL\"\n        dataset = [(\"JAPAN GET\", [[0, 5, \"LOC\"]]), (\"Nadim Ladki\", [[0, 11, \"PER\"]])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_wrong_conll`\nCode:\n    def test_wrong_conll(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"CoNLL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)",
                                        "Function `test_jsonl_with_overlapping`\nCode:\n    def test_jsonl_with_overlapping(self):\n        filename = \"sequence_labeling/example_overlapping.jsonl\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 0)",
                                        "Class `TestImportRelationExtractionData`\nCode:\nclass TestImportRelationExtractionData(TestImportData):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def setUp(self):\n        self.project = prepare_project(self.task, use_relation=True)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_spans in dataset:\n            example = Example.objects.get(text=text)\n            spans = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(spans, expected_spans)\n            self.assertEqual(example.relations.count(), 3)\n\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"relation_extraction/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\n                \"Google was founded on September 4, 1998, by Larry Page and Sergey Brin.\",\n                [[0, 6, \"ORG\"], [22, 39, \"DATE\"], [44, 54, \"PERSON\"], [59, 70, \"PERSON\"]],\n            ),\n        ]\n        self.import_dataset(filename, file_format, RELATION_EXTRACTION)\n        self.assert_examples(dataset)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(self.task, use_relation=True)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()",
                                        "Function `assert_examples`\nCode:\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_spans in dataset:\n            example = Example.objects.get(text=text)\n            spans = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(spans, expected_spans)\n            self.assertEqual(example.relations.count(), 3)",
                                        "Function `assert_parse_error`\nCode:\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)",
                                        "Function `test_jsonl`\nCode:\n    def test_jsonl(self):\n        filename = \"relation_extraction/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\n                \"Google was founded on September 4, 1998, by Larry Page and Sergey Brin.\",\n                [[0, 6, \"ORG\"], [22, 39, \"DATE\"], [44, 54, \"PERSON\"], [59, 70, \"PERSON\"]],\n            ),\n        ]\n        self.import_dataset(filename, file_format, RELATION_EXTRACTION)\n        self.assert_examples(dataset)",
                                        "Class `TestImportSeq2seqData`\nCode:\nclass TestImportSeq2seqData(TestImportData):\n    task = ProjectType.SEQ2SEQ\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = set(text_label.text for text_label in example.texts.all())\n            self.assertEqual(labels, set(expected_labels))\n\n    def test_jsonl(self):\n        filename = \"seq2seq/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_json(self):\n        filename = \"seq2seq/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_csv(self):\n        filename = \"seq2seq/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `assert_examples`\nCode:\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = set(text_label.text for text_label in example.texts.all())\n            self.assertEqual(labels, set(expected_labels))",
                                        "Function `test_jsonl`\nCode:\n    def test_jsonl(self):\n        filename = \"seq2seq/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_json`\nCode:\n    def test_json(self):\n        filename = \"seq2seq/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `test_csv`\nCode:\n    def test_csv(self):\n        filename = \"seq2seq/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Class `TestImportIntentDetectionAndSlotFillingData`\nCode:\nclass TestImportIntentDetectionAndSlotFillingData(TestImportData):\n    task = ProjectType.INTENT_DETECTION_AND_SLOT_FILLING\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            cats = set(cat.label.text for cat in example.categories.all())\n            entities = [(span.start_offset, span.end_offset, span.label.text) for span in example.spans.all()]\n            self.assertEqual(cats, set(expected_labels[\"cats\"]))\n            self.assertEqual(entities, expected_labels[\"entities\"])\n\n    def test_entities_and_cats(self):\n        filename = \"intent/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\"exampleA\", {\"cats\": [\"positive\"], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleB\", {\"cats\": [\"positive\"], \"entities\": []}),\n            (\"exampleC\", {\"cats\": [], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleD\", {\"cats\": [], \"entities\": []}),\n        ]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Function `assert_examples`\nCode:\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            cats = set(cat.label.text for cat in example.categories.all())\n            entities = [(span.start_offset, span.end_offset, span.label.text) for span in example.spans.all()]\n            self.assertEqual(cats, set(expected_labels[\"cats\"]))\n            self.assertEqual(entities, expected_labels[\"entities\"])",
                                        "Function `test_entities_and_cats`\nCode:\n    def test_entities_and_cats(self):\n        filename = \"intent/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\"exampleA\", {\"cats\": [\"positive\"], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleB\", {\"cats\": [\"positive\"], \"entities\": []}),\n            (\"exampleC\", {\"cats\": [], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleD\", {\"cats\": [], \"entities\": []}),\n        ]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)",
                                        "Class `TestImportImageClassificationData`\nCode:\nclass TestImportImageClassificationData(TestImportData):\n    task = ProjectType.IMAGE_CLASSIFICATION\n\n    def test_example(self):\n        filename = \"images/1500x500.jpeg\"\n        file_format = \"ImageFile\"\n        self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(Example.objects.count(), 1)",
                                        "Function `test_example`\nCode:\n    def test_example(self):\n        filename = \"images/1500x500.jpeg\"\n        file_format = \"ImageFile\"\n        self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(Example.objects.count(), 1)",
                                        "Class `TestFileTypeChecking`\nCode:\nclass TestFileTypeChecking(TestImportData):\n    task = ProjectType.IMAGE_CLASSIFICATION\n\n    def test_example(self):\n        filename = \"images/example.ico\"\n        file_format = \"ImageFile\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"unexpected\", response[\"error\"][0][\"message\"])",
                                        "Function `test_example`\nCode:\n    def test_example(self):\n        filename = \"images/example.ico\"\n        file_format = \"ImageFile\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"unexpected\", response[\"error\"][0][\"message\"])"
                                    ],
                                    "code": "import os\nimport pathlib\nimport shutil\n\nfrom django.core.files import File\nfrom django.test import TestCase, override_settings\nfrom django_drf_filepond.models import StoredUpload, TemporaryUpload\nfrom django_drf_filepond.utils import _get_file_id\n\nfrom data_import.celery_tasks import import_dataset\nfrom data_import.pipeline.catalog import RELATION_EXTRACTION\nfrom examples.models import Example\nfrom label_types.models import SpanType\nfrom labels.models import Category, Span\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\n@override_settings(MEDIA_ROOT=os.path.join(os.path.dirname(__file__), \"data\"))\nclass TestImportData(TestCase):\n    task = \"Any\"\n    annotation_class = Category\n\n    def setUp(self):\n        self.project = prepare_project(self.task)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()\n\n    def tearDown(self):\n        try:\n            su = StoredUpload.objects.get(upload_id=self.upload_id)\n            directory = pathlib.Path(su.get_absolute_file_path()).parent\n            shutil.rmtree(directory)\n        except StoredUpload.DoesNotExist:\n            pass\n\n    def import_dataset(self, filename, file_format, task, kwargs=None):\n        file_path = str(self.data_path / filename)\n        TemporaryUpload.objects.create(\n            upload_id=self.upload_id,\n            file_id=\"1\",\n            file=File(open(file_path, mode=\"rb\"), filename.split(\"/\")[-1]),\n            upload_name=filename,\n            upload_type=\"F\",\n        )\n        upload_ids = [self.upload_id]\n        kwargs = kwargs or {}\n        return import_dataset(self.user.id, self.project.item.id, file_format, upload_ids, task, **kwargs)\n\n\n@override_settings(MAX_UPLOAD_SIZE=0)\nclass TestMaxFileSize(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        response = self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"maximum file size\", response[\"error\"][0][\"message\"])\n\n\nclass TestInvalidFileFormat(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def test_invalid_file_format(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"INVALID_FORMAT\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)\n\n\nclass TestImportClassificationData(TestImportData):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n\n    def assert_examples(self, dataset):\n        with self.subTest():\n            self.assertEqual(Example.objects.count(), len(dataset))\n            for text, expected_labels in dataset:\n                example = Example.objects.get(text=text)\n                labels = set(cat.label.text for cat in example.categories.all())\n                self.assertEqual(labels, set(expected_labels))\n\n    def assert_parse_error(self, response):\n        with self.subTest():\n            self.assertGreaterEqual(len(response[\"error\"]), 1)\n            self.assertEqual(Example.objects.count(), 0)\n            self.assertEqual(Category.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSONL\"\n        kwargs = {\"column_label\": \"labels\"}\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task, kwargs)\n        self.assert_examples(dataset)\n\n    def test_csv(self):\n        filename = \"text_classification/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_csv_out_of_order_columns(self):\n        filename = \"text_classification/example_out_of_order_columns.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_fasttext(self):\n        filename = \"text_classification/example_fasttext.txt\"\n        file_format = \"fastText\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_excel(self):\n        filename = \"text_classification/example.xlsx\"\n        file_format = \"Excel\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_json(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"positive\"]), (\"exampleB\", [\"positive\", \"negative\"]), (\"exampleC\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_textfile(self):\n        filename = \"example.txt\"\n        file_format = \"TextFile\"\n        dataset = [(\"exampleA\\nexampleB\\n\\nexampleC\\n\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 0)\n\n    def test_textline(self):\n        filename = \"example.txt\"\n        file_format = \"TextLine\"\n        dataset = [(\"exampleA\", []), (\"exampleB\", []), (\"exampleC\", [])]\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n        self.assertEqual(len(response[\"error\"]), 1)\n\n    def test_wrong_jsonl(self):\n        filename = \"text_classification/example.json\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_json(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"JSON\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_excel(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"Excel\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_wrong_csv(self):\n        filename = \"text_classification/example.jsonl\"\n        file_format = \"CSV\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n\nclass TestImportSequenceLabelingData(TestImportData):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(labels, expected_labels)\n\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [[0, 1, \"LOC\"]]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_conll(self):\n        filename = \"sequence_labeling/example.conll\"\n        file_format = \"CoNLL\"\n        dataset = [(\"JAPAN GET\", [[0, 5, \"LOC\"]]), (\"Nadim Ladki\", [[0, 11, \"PER\"]])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_wrong_conll(self):\n        filename = \"sequence_labeling/example.jsonl\"\n        file_format = \"CoNLL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assert_parse_error(response)\n\n    def test_jsonl_with_overlapping(self):\n        filename = \"sequence_labeling/example_overlapping.jsonl\"\n        file_format = \"JSONL\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 0)\n\n\nclass TestImportRelationExtractionData(TestImportData):\n    task = ProjectType.SEQUENCE_LABELING\n\n    def setUp(self):\n        self.project = prepare_project(self.task, use_relation=True)\n        self.user = self.project.admin\n        self.data_path = pathlib.Path(__file__).parent / \"data\"\n        self.upload_id = _get_file_id()\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_spans in dataset:\n            example = Example.objects.get(text=text)\n            spans = [[span.start_offset, span.end_offset, span.label.text] for span in example.spans.all()]\n            self.assertEqual(spans, expected_spans)\n            self.assertEqual(example.relations.count(), 3)\n\n    def assert_parse_error(self, response):\n        self.assertGreaterEqual(len(response[\"error\"]), 1)\n        self.assertEqual(Example.objects.count(), 0)\n        self.assertEqual(SpanType.objects.count(), 0)\n        self.assertEqual(Span.objects.count(), 0)\n\n    def test_jsonl(self):\n        filename = \"relation_extraction/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\n                \"Google was founded on September 4, 1998, by Larry Page and Sergey Brin.\",\n                [[0, 6, \"ORG\"], [22, 39, \"DATE\"], [44, 54, \"PERSON\"], [59, 70, \"PERSON\"]],\n            ),\n        ]\n        self.import_dataset(filename, file_format, RELATION_EXTRACTION)\n        self.assert_examples(dataset)\n\n\nclass TestImportSeq2seqData(TestImportData):\n    task = ProjectType.SEQ2SEQ\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            labels = set(text_label.text for text_label in example.texts.all())\n            self.assertEqual(labels, set(expected_labels))\n\n    def test_jsonl(self):\n        filename = \"seq2seq/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_json(self):\n        filename = \"seq2seq/example.json\"\n        file_format = \"JSON\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n    def test_csv(self):\n        filename = \"seq2seq/example.csv\"\n        file_format = \"CSV\"\n        dataset = [(\"exampleA\", [\"label1\"]), (\"exampleB\", [])]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n\nclass TestImportIntentDetectionAndSlotFillingData(TestImportData):\n    task = ProjectType.INTENT_DETECTION_AND_SLOT_FILLING\n\n    def assert_examples(self, dataset):\n        self.assertEqual(Example.objects.count(), len(dataset))\n        for text, expected_labels in dataset:\n            example = Example.objects.get(text=text)\n            cats = set(cat.label.text for cat in example.categories.all())\n            entities = [(span.start_offset, span.end_offset, span.label.text) for span in example.spans.all()]\n            self.assertEqual(cats, set(expected_labels[\"cats\"]))\n            self.assertEqual(entities, expected_labels[\"entities\"])\n\n    def test_entities_and_cats(self):\n        filename = \"intent/example.jsonl\"\n        file_format = \"JSONL\"\n        dataset = [\n            (\"exampleA\", {\"cats\": [\"positive\"], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleB\", {\"cats\": [\"positive\"], \"entities\": []}),\n            (\"exampleC\", {\"cats\": [], \"entities\": [(0, 1, \"LOC\")]}),\n            (\"exampleD\", {\"cats\": [], \"entities\": []}),\n        ]\n        self.import_dataset(filename, file_format, self.task)\n        self.assert_examples(dataset)\n\n\nclass TestImportImageClassificationData(TestImportData):\n    task = ProjectType.IMAGE_CLASSIFICATION\n\n    def test_example(self):\n        filename = \"images/1500x500.jpeg\"\n        file_format = \"ImageFile\"\n        self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(Example.objects.count(), 1)\n\n\n@override_settings(ENABLE_FILE_TYPE_CHECK=True)\nclass TestFileTypeChecking(TestImportData):\n    task = ProjectType.IMAGE_CLASSIFICATION\n\n    def test_example(self):\n        filename = \"images/example.ico\"\n        file_format = \"ImageFile\"\n        response = self.import_dataset(filename, file_format, self.task)\n        self.assertEqual(len(response[\"error\"]), 1)\n        self.assertIn(\"unexpected\", response[\"error\"][0][\"message\"])\n",
                                    "summary": "Class TestImportData and its associated test cases provide a comprehensive framework for validating the import functionality of various dataset formats, ensuring proper handling of errors, and verifying the correctness of imported examples across multiple data types used in document classification, sequence labeling, relation extraction, and intent detection.",
                                    "code_element_summaries": [
                                        "Class TestImportData: A test case for importing datasets, which sets up a project and user, manages temporary file uploads, and facilitates the import process while ensuring proper cleanup after tests.",
                                        "Function `setUp`: Initializes a test environment by preparing a project, assigning an admin user, setting the data path, and retrieving a file upload ID.",
                                        "Function `tearDown`: Cleans up by attempting to delete the directory associated with a stored upload, handling the case where the upload may not exist.",
                                        "Function `import_dataset`: This function handles the import of a dataset from a specified file, creating a temporary upload record and invoking the dataset import process with the necessary parameters.",
                                        "Class TestMaxFileSize: A test case for validating the maximum file size constraint when importing a JSONL dataset for document classification.",
                                        "Function `test_jsonl`: A test case that verifies the error handling for importing a JSONL dataset by checking for a specific error message related to maximum file size.",
                                        "Class TestInvalidFileFormat: A test case for handling invalid file formats during dataset import in the context of document classification.",
                                        "Function `test_invalid_file_format`: A test case that verifies the handling of an invalid file format during dataset import, expecting a single error in the response.",
                                        "Class TestImportClassificationData: A test suite for verifying the import functionality of various document classification data formats, ensuring correct parsing and error handling in the import process.",
                                        "Function `assert_examples`: A test method that verifies the count of Example objects matches the dataset length and checks that the labels of each example correspond to the expected labels.",
                                        "Function `assert_parse_error`: A test function that verifies the presence of an error in the response and ensures that no `Example` or `Category` objects exist in the database.",
                                        "Function `test_jsonl`: A test function that imports a JSONL dataset for text classification and verifies the imported examples against expected values.",
                                        "Function `test_csv`: A test function that imports a CSV dataset and asserts that the examples match the expected output.",
                                        "Function `test_csv_out_of_order_columns`: A test function that verifies the correct import and handling of a CSV file with out-of-order columns by comparing the imported dataset against expected examples.",
                                        "Function `test_fasttext`: A test function that imports a dataset from a specified file in fastText format and asserts the correctness of the examples against expected labels.",
                                        "Function `test_excel`: A test function that imports an Excel dataset and verifies its contents against expected examples.",
                                        "Function `test_json`: A test function that imports a JSON dataset and asserts that the imported examples match the expected dataset.",
                                        "Function `test_textfile`: A test case that verifies the import of a text file dataset, ensuring no errors occur during the import process.",
                                        "Function `test_textline`: A test function that imports a dataset from a text file and verifies the correctness of the import by checking the number of errors and asserting example data.",
                                        "Function `test_wrong_jsonl`: A test case that verifies the handling of a parsing error when importing a dataset from a malformed JSONL file.",
                                        "Function `test_wrong_json`: A test case that verifies the handling of parsing errors when attempting to import a dataset from a malformed JSONL file.",
                                        "Function `test_wrong_excel`: A test function that verifies the handling of an error when attempting to import a dataset from a JSONL file using an incorrect file format (Excel).",
                                        "Function `test_wrong_csv`: A test function that verifies the handling of a parsing error when importing a dataset from a CSV file format.",
                                        "Class `TestImportSequenceLabelingData`: A test case for importing sequence labeling datasets, verifying correct example counts and label assertions across various file formats including JSONL and CoNLL, while also handling error scenarios.",
                                        "Function `assert_examples`: A method that verifies the count of `Example` objects against a given dataset and checks that the labels of each example match the expected labels.",
                                        "Function `assert_parse_error`: A test function that verifies the presence of an error in the response and ensures that no Example, SpanType, or Span objects exist in the database.",
                                        "Function `test_jsonl`: A test function that imports a JSONL dataset and asserts the correctness of the imported examples against a predefined dataset.",
                                        "Function `test_conll`: A test function that imports a CoNLL formatted dataset and verifies its examples against expected labeled entities.",
                                        "Function `test_wrong_conll`: A test function that verifies the handling of parse errors when importing a dataset from a JSONL file in CoNLL format.",
                                        "Function `test_jsonl_with_overlapping`: A test function that verifies the successful import of a JSONL dataset with overlapping sequences by asserting that there are no errors in the response.",
                                        "Class TestImportRelationExtractionData: A test case for importing relation extraction data, verifying the correct handling of dataset examples and error responses during the import process.",
                                        "Function `setUp`: A setup method that initializes a project with a related task, assigns the project administrator to a user, specifies the data path, and retrieves a file upload ID.",
                                        "Function `assert_examples`: A method that verifies the number of Example objects matches a dataset and checks that the spans and relations of each example are as expected.",
                                        "Function `assert_parse_error`: A test function that verifies the presence of an error in the response and ensures that no Example, SpanType, or Span objects exist in the database.",
                                        "Function `test_jsonl`: A test function that imports a dataset from a JSONL file and verifies its examples for relation extraction.",
                                        "Class `TestImportSeq2seqData`: A test case for importing sequence-to-sequence datasets in various formats (JSONL, JSON, CSV) and verifying the correctness of the imported examples against expected labels.",
                                        "Function `assert_examples`: A method that verifies the count of Example objects against a provided dataset and checks if the labels associated with each example match the expected labels.",
                                        "Function `test_jsonl`: A test function that imports a JSONL dataset and asserts the examples against the expected dataset.",
                                        "Function `test_json`: A test function that imports a JSON dataset and verifies its examples against expected values.",
                                        "Function `test_csv`: A test function that imports a dataset from a CSV file and asserts the correctness of the imported examples.",
                                        "Class `TestImportIntentDetectionAndSlotFillingData`: A test case for importing and validating intent detection and slot filling data by asserting the correctness of examples against expected categories and entities.",
                                        "Function `assert_examples`: A method that verifies the count and content of `Example` objects against a provided dataset, ensuring that categories and entities match expected values.",
                                        "Function `test_entities_and_cats`: A test function that imports a dataset from a JSONL file and asserts the correctness of example entities and categories.",
                                        "Class TestImportImageClassificationData: A test case for importing image classification datasets, verifying the import process by checking the count of Example objects.",
                                        "Function `test_example`: A test function that imports a dataset from a specified image file and verifies that one Example object has been created.",
                                        "Class TestFileTypeChecking: A test case for verifying the handling of unexpected errors during the import of an image classification dataset.",
                                        "Function `test_example`: A test function that verifies the import of a dataset and checks for an expected error message related to an unexpected issue."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestImportCatalog`\nCode:\nclass TestImportCatalog(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"catalog\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)\n\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"catalog\", args=[self.project.item.id])",
                                        "Function `test_allows_project_admin_to_list_catalog`\nCode:\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)",
                                        "Function `test_denies_project_staff_to_list_catalog`\nCode:\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestImportCatalog(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.url = reverse(viewname=\"catalog\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_list_catalog(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        for item in response.data:\n            self.assertIn(\"name\", item)\n\n    def test_denies_project_staff_to_list_catalog(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Class TestImportCatalog: A test suite that checks access permissions for catalog listings, ensuring project admins can view the catalog while project staff are denied access.",
                                    "code_element_summaries": [
                                        "Class TestImportCatalog: A test suite for verifying access permissions to the catalog listing, allowing project admins to view the catalog and denying project staff access.",
                                        "Function `setUp`: Prepares a project for document classification and sets the URL for the catalog view based on the project's item ID.",
                                        "Function `test_allows_project_admin_to_list_catalog`: A test that verifies a project admin can successfully list the catalog and ensures each item in the response contains a \"name\" field.",
                                        "Function `test_denies_project_staff_to_list_catalog`: A test that verifies project staff members are forbidden from accessing the catalog, expecting a 403 Forbidden status for each staff member."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import include, path\n\nfrom .views import DatasetCatalog, DatasetImportAPI\n\nurlpatterns = [\n    path(\"fp/\", include(\"django_drf_filepond.urls\")),\n    path(route=\"projects/<int:project_id>/upload\", view=DatasetImportAPI.as_view(), name=\"upload\"),\n    path(route=\"projects/<int:project_id>/catalog\", view=DatasetCatalog.as_view(), name=\"catalog\"),\n]\n",
                            "summary": "URL Configuration: Defines routes for file uploads and dataset cataloging in a Django application, including integration with the django_drf_filepond library.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `DatasetCatalog`\nCode:\nclass DatasetCatalog(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)",
                                "Class `DatasetImportAPI`\nCode:\nclass DatasetImportAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, request, *args, **kwargs):\n        upload_ids = request.data.pop(\"uploadIds\")\n        file_format = request.data.pop(\"format\")\n        task = request.data.pop(\"task\")\n        celery_task = import_dataset.delay(\n            user_id=request.user.id,\n            project_id=self.kwargs[\"project_id\"],\n            file_format=file_format,\n            upload_ids=upload_ids,\n            task=task,\n            **request.data,\n        )\n        return Response({\"task_id\": celery_task.task_id})",
                                "Function `post`\nCode:\n    def post(self, request, *args, **kwargs):\n        upload_ids = request.data.pop(\"uploadIds\")\n        file_format = request.data.pop(\"format\")\n        task = request.data.pop(\"task\")\n        celery_task = import_dataset.delay(\n            user_id=request.user.id,\n            project_id=self.kwargs[\"project_id\"],\n            file_format=file_format,\n            upload_ids=upload_ids,\n            task=task,\n            **request.data,\n        )\n        return Response({\"task_id\": celery_task.task_id})"
                            ],
                            "code": "from django.shortcuts import get_object_or_404\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom .celery_tasks import import_dataset\nfrom .pipeline.catalog import Options\nfrom projects.models import Project\nfrom projects.permissions import IsProjectAdmin\n\n\nclass DatasetCatalog(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def get(self, request, *args, **kwargs):\n        project_id = kwargs[\"project_id\"]\n        project = get_object_or_404(Project, pk=project_id)\n        use_relation = getattr(project, \"use_relation\", False)\n        options = Options.filter_by_task(project.project_type, use_relation)\n        return Response(data=options, status=status.HTTP_200_OK)\n\n\nclass DatasetImportAPI(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, request, *args, **kwargs):\n        upload_ids = request.data.pop(\"uploadIds\")\n        file_format = request.data.pop(\"format\")\n        task = request.data.pop(\"task\")\n        celery_task = import_dataset.delay(\n            user_id=request.user.id,\n            project_id=self.kwargs[\"project_id\"],\n            file_format=file_format,\n            upload_ids=upload_ids,\n            task=task,\n            **request.data,\n        )\n        return Response({\"task_id\": celery_task.task_id})\n",
                            "summary": "Classes `DatasetCatalog` and `DatasetImportAPI`: API views for retrieving filtered project options for administrators and handling dataset import requests via asynchronous tasks, respectively.",
                            "code_element_summaries": [
                                "Class `DatasetCatalog`: An API view that retrieves and returns filtered options based on the project type and relation status for authenticated project administrators.",
                                "Function `get`: Retrieves project options based on the project ID and type, returning a response with the filtered options and a 200 OK status.",
                                "Class `DatasetImportAPI`: An API view that handles dataset import requests by initiating an asynchronous Celery task and returning the task ID.",
                                "Function `post`: Handles incoming requests to initiate a dataset import task using Celery, returning the task ID in the response."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\data_import\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "examples",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "Comprehensive Django application framework encompassing admin configurations, custom models, migrations, permissions, serializers, test suites, and API management for efficient handling of examples, comments, and assignments, with enhanced querying, role-based access control, and bulk operations.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ExampleAdmin`\nCode:\nclass ExampleAdmin(admin.ModelAdmin):\n    list_display = (\"text\", \"project\", \"meta\")\n    ordering = (\"project\",)\n    search_fields = (\"text\",)",
                                "Class `CommentAdmin`\nCode:\nclass CommentAdmin(admin.ModelAdmin):\n    list_display = (\n        \"user\",\n        \"example\",\n        \"text\",\n        \"created_at\",\n    )\n    ordering = (\n        \"user\",\n        \"created_at\",\n    )\n    search_fields = (\"user\",)"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import Comment, Example\n\n\nclass ExampleAdmin(admin.ModelAdmin):\n    list_display = (\"text\", \"project\", \"meta\")\n    ordering = (\"project\",)\n    search_fields = (\"text\",)\n\n\nclass CommentAdmin(admin.ModelAdmin):\n    list_display = (\n        \"user\",\n        \"example\",\n        \"text\",\n        \"created_at\",\n    )\n    ordering = (\n        \"user\",\n        \"created_at\",\n    )\n    search_fields = (\"user\",)\n\n\nadmin.site.register(Example, ExampleAdmin)\nadmin.site.register(Comment, CommentAdmin)\n",
                            "summary": "Classes ExampleAdmin and CommentAdmin: Django admin model configurations that customize the display, ordering, and search functionality for their respective associated models and comment entries.",
                            "code_element_summaries": [
                                "Class ExampleAdmin: A Django admin model configuration that customizes the display, ordering, and search functionality for the associated model.",
                                "Class CommentAdmin: A Django admin model that customizes the display, ordering, and search functionality for comment entries in the admin interface."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ExamplesConfig`\nCode:\nclass ExamplesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"examples\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass ExamplesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"examples\"\n",
                            "summary": "Class ExamplesConfig: A Django application configuration class that defines the default auto field type and sets the application name to \"examples.\"",
                            "code_element_summaries": [
                                "Class ExamplesConfig: A Django application configuration class that sets the default auto field type and specifies the application name as \"examples.\""
                            ],
                            "children": []
                        },
                        {
                            "name": "assignment",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\assignment",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Framework for assignment strategies featuring various selection methods and a factory function for instantiation, along with a bulk assignment function and models for workload management, ensuring efficient assignment based on weights and member identifiers.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "strategies.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\assignment\\strategies.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Assignment`\nCode:\nclass Assignment:\n    user: int\n    example: int",
                                        "Class `StrategyName`\nCode:\nclass StrategyName(enum.Enum):\n    weighted_sequential = enum.auto()\n    weighted_random = enum.auto()\n    sampling_without_replacement = enum.auto()",
                                        "Function `create_assignment_strategy`\nCode:\ndef create_assignment_strategy(strategy_name: StrategyName, dataset_size: int, weights: List[int]) -> \"BaseStrategy\":\n    if strategy_name == StrategyName.weighted_sequential:\n        return WeightedSequentialStrategy(dataset_size, weights)\n    elif strategy_name == StrategyName.weighted_random:\n        return WeightedRandomStrategy(dataset_size, weights)\n    elif strategy_name == StrategyName.sampling_without_replacement:\n        return SamplingWithoutReplacementStrategy(dataset_size, weights)\n    else:\n        raise ValueError(f\"Unknown strategy name: {strategy_name}\")",
                                        "Class `BaseStrategy`\nCode:\nclass BaseStrategy(abc.ABC):\n    @abc.abstractmethod\n    def assign(self) -> List[Assignment]:\n        ...",
                                        "Function `assign`\nCode:\n    def assign(self) -> List[Assignment]:\n        ...",
                                        "Class `WeightedSequentialStrategy`\nCode:\nclass WeightedSequentialStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        cumsum = np.cumsum([0] + self.weights)\n        ratio = np.round(cumsum / 100 * self.dataset_size).astype(int)\n        for user, (start, end) in enumerate(zip(ratio, ratio[1:])):  # Todo: use itertools.pairwise\n            assignments.extend([Assignment(user=user, example=example) for example in range(start, end)])\n        return assignments",
                                        "Function `__init__`\nCode:\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights",
                                        "Function `assign`\nCode:\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        cumsum = np.cumsum([0] + self.weights)\n        ratio = np.round(cumsum / 100 * self.dataset_size).astype(int)\n        for user, (start, end) in enumerate(zip(ratio, ratio[1:])):  # Todo: use itertools.pairwise\n            assignments.extend([Assignment(user=user, example=example) for example in range(start, end)])\n        return assignments",
                                        "Class `WeightedRandomStrategy`\nCode:\nclass WeightedRandomStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        proba = np.array(self.weights) / 100\n        assignees = np.random.choice(range(len(self.weights)), size=self.dataset_size, p=proba)\n        return [Assignment(user=user, example=example) for example, user in enumerate(assignees)]",
                                        "Function `__init__`\nCode:\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights",
                                        "Function `assign`\nCode:\n    def assign(self) -> List[Assignment]:\n        proba = np.array(self.weights) / 100\n        assignees = np.random.choice(range(len(self.weights)), size=self.dataset_size, p=proba)\n        return [Assignment(user=user, example=example) for example, user in enumerate(assignees)]",
                                        "Class `SamplingWithoutReplacementStrategy`\nCode:\nclass SamplingWithoutReplacementStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if not (0 <= sum(weights) <= 100 * len(weights)):\n            raise ValueError(\"Sum of weights must be between 0 and 100 x number of members\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        proba = np.array(self.weights) / 100\n        for user, p in enumerate(proba):\n            count = int(self.dataset_size * p)\n            examples = random.sample(range(self.dataset_size), count)\n            assignments.extend([Assignment(user=user, example=example) for example in examples])\n        return assignments",
                                        "Function `__init__`\nCode:\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if not (0 <= sum(weights) <= 100 * len(weights)):\n            raise ValueError(\"Sum of weights must be between 0 and 100 x number of members\")\n        self.dataset_size = dataset_size\n        self.weights = weights",
                                        "Function `assign`\nCode:\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        proba = np.array(self.weights) / 100\n        for user, p in enumerate(proba):\n            count = int(self.dataset_size * p)\n            examples = random.sample(range(self.dataset_size), count)\n            assignments.extend([Assignment(user=user, example=example) for example in examples])\n        return assignments"
                                    ],
                                    "code": "import abc\nimport dataclasses\nimport enum\nimport random\nfrom typing import List\n\nimport numpy as np\n\n\n@dataclasses.dataclass\nclass Assignment:\n    user: int\n    example: int\n\n\nclass StrategyName(enum.Enum):\n    weighted_sequential = enum.auto()\n    weighted_random = enum.auto()\n    sampling_without_replacement = enum.auto()\n\n\ndef create_assignment_strategy(strategy_name: StrategyName, dataset_size: int, weights: List[int]) -> \"BaseStrategy\":\n    if strategy_name == StrategyName.weighted_sequential:\n        return WeightedSequentialStrategy(dataset_size, weights)\n    elif strategy_name == StrategyName.weighted_random:\n        return WeightedRandomStrategy(dataset_size, weights)\n    elif strategy_name == StrategyName.sampling_without_replacement:\n        return SamplingWithoutReplacementStrategy(dataset_size, weights)\n    else:\n        raise ValueError(f\"Unknown strategy name: {strategy_name}\")\n\n\nclass BaseStrategy(abc.ABC):\n    @abc.abstractmethod\n    def assign(self) -> List[Assignment]:\n        ...\n\n\nclass WeightedSequentialStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        cumsum = np.cumsum([0] + self.weights)\n        ratio = np.round(cumsum / 100 * self.dataset_size).astype(int)\n        for user, (start, end) in enumerate(zip(ratio, ratio[1:])):  # Todo: use itertools.pairwise\n            assignments.extend([Assignment(user=user, example=example) for example in range(start, end)])\n        return assignments\n\n\nclass WeightedRandomStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if sum(weights) != 100:\n            raise ValueError(\"Sum of weights must be 100\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        proba = np.array(self.weights) / 100\n        assignees = np.random.choice(range(len(self.weights)), size=self.dataset_size, p=proba)\n        return [Assignment(user=user, example=example) for example, user in enumerate(assignees)]\n\n\nclass SamplingWithoutReplacementStrategy(BaseStrategy):\n    def __init__(self, dataset_size: int, weights: List[int]):\n        if not (0 <= sum(weights) <= 100 * len(weights)):\n            raise ValueError(\"Sum of weights must be between 0 and 100 x number of members\")\n        self.dataset_size = dataset_size\n        self.weights = weights\n\n    def assign(self) -> List[Assignment]:\n        assignments = []\n        proba = np.array(self.weights) / 100\n        for user, p in enumerate(proba):\n            count = int(self.dataset_size * p)\n            examples = random.sample(range(self.dataset_size), count)\n            assignments.extend([Assignment(user=user, example=example) for example in examples])\n        return assignments\n",
                                    "summary": "The content describes a framework for assignment strategies, including classes for different selection methods (WeightedSequentialStrategy, WeightedRandomStrategy, SamplingWithoutReplacementStrategy) and a factory function (create_assignment_strategy) to instantiate these strategies, all of which ensure that weights are properly managed and assignments are generated based on specified user and example identifiers.",
                                    "code_element_summaries": [
                                        "Class Assignment: A simple data structure representing an assignment with associated user and example identifiers.",
                                        "Class StrategyName: An enumeration defining various strategies for selection, including weighted sequential, weighted random, and sampling without replacement.",
                                        "Function `create_assignment_strategy`: A factory function that creates and returns a specific strategy object based on the provided strategy name, dataset size, and weights.",
                                        "Class BaseStrategy: An abstract base class that defines the blueprint for strategies requiring an assign method to be implemented, returning a list of Assignment objects.",
                                        "Function `assign`: A method that returns a list of Assignment objects.",
                                        "Class `WeightedSequentialStrategy`: A strategy that assigns examples to users based on specified weights, ensuring the total weight sums to 100 and distributing the dataset accordingly.",
                                        "Function `__init__`: Initializes an object with a specified dataset size and weights, ensuring that the sum of the weights equals 100.",
                                        "Function `assign`: Generates a list of `Assignment` objects by distributing dataset examples among users based on their weights and the total dataset size.",
                                        "Class `WeightedRandomStrategy`: A strategy for assigning users to examples based on specified weights that must sum to 100, ensuring probabilistic selection during assignment.",
                                        "Function `__init__`: Initializes an instance with a specified dataset size and a list of weights, ensuring the sum of weights equals 100.",
                                        "Function `assign`: Generates a list of Assignment objects by randomly assigning users to examples based on weighted probabilities.",
                                        "Class `SamplingWithoutReplacementStrategy`: A strategy for assigning examples to users based on specified weights, ensuring that the total weight is within valid limits and utilizing random sampling without replacement.",
                                        "Function `__init__`: Initializes an object with a specified dataset size and weights, ensuring the sum of weights is within a valid range.",
                                        "Function `assign`: Generates a list of `Assignment` objects by randomly selecting examples for each user based on their weighted probability distribution relative to the dataset size."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "usecase.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\assignment\\usecase.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `bulk_assign`\nCode:\ndef bulk_assign(project_id: int, strategy_name: StrategyName, member_ids: List[int], weights: List[int]) -> None:\n    project = get_object_or_404(Project, pk=project_id)\n    members = Member.objects.filter(project=project, pk__in=member_ids)\n    if len(members) != len(member_ids):\n        raise ValueError(\"Invalid member ids\")\n    # Sort members by member_ids\n    members = sorted(members, key=lambda m: member_ids.index(m.id))\n    index_to_user = {i: member.user for i, member in enumerate(members)}\n\n    unassigned_examples = Example.objects.filter(project=project, assignments__isnull=True)\n    index_to_example = {i: example for i, example in enumerate(unassigned_examples)}\n    dataset_size = unassigned_examples.count()\n\n    strategy = create_assignment_strategy(strategy_name, dataset_size, weights)\n    assignments = strategy.assign()\n    assignments = [\n        Assignment(\n            project=project,\n            example=index_to_example[assignment.example],\n            assignee=index_to_user[assignment.user],\n        )\n        for assignment in assignments\n    ]\n    Assignment.objects.bulk_create(assignments)"
                                    ],
                                    "code": "from typing import List\n\nfrom django.shortcuts import get_object_or_404\n\nfrom examples.assignment.strategies import StrategyName, create_assignment_strategy\nfrom examples.models import Assignment, Example\nfrom projects.models import Member, Project\n\n\ndef bulk_assign(project_id: int, strategy_name: StrategyName, member_ids: List[int], weights: List[int]) -> None:\n    project = get_object_or_404(Project, pk=project_id)\n    members = Member.objects.filter(project=project, pk__in=member_ids)\n    if len(members) != len(member_ids):\n        raise ValueError(\"Invalid member ids\")\n    # Sort members by member_ids\n    members = sorted(members, key=lambda m: member_ids.index(m.id))\n    index_to_user = {i: member.user for i, member in enumerate(members)}\n\n    unassigned_examples = Example.objects.filter(project=project, assignments__isnull=True)\n    index_to_example = {i: example for i, example in enumerate(unassigned_examples)}\n    dataset_size = unassigned_examples.count()\n\n    strategy = create_assignment_strategy(strategy_name, dataset_size, weights)\n    assignments = strategy.assign()\n    assignments = [\n        Assignment(\n            project=project,\n            example=index_to_example[assignment.example],\n            assignee=index_to_user[assignment.user],\n        )\n        for assignment in assignments\n    ]\n    Assignment.objects.bulk_create(assignments)\n",
                                    "summary": "Function `bulk_assign`: Assigns unassigned examples to project members using a defined strategy and weights while validating member IDs for efficient bulk assignment creation.",
                                    "code_element_summaries": [
                                        "Function `bulk_assign`: Assigns unassigned examples to project members based on a specified strategy and weights, ensuring valid member IDs and efficient bulk creation of assignments."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "workload.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\assignment\\workload.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Workload`\nCode:\nclass Workload(BaseModel):\n    weight: NonNegativeInt\n    member_id: int",
                                        "Class `WorkloadAllocation`\nCode:\nclass WorkloadAllocation(BaseModel):\n    workloads: List[Workload]\n\n    @property\n    def member_ids(self) -> List[int]:\n        return [w.member_id for w in self.workloads]\n\n    @property\n    def weights(self) -> List[int]:\n        return [w.weight for w in self.workloads]",
                                        "Function `member_ids`\nCode:\n    def member_ids(self) -> List[int]:\n        return [w.member_id for w in self.workloads]",
                                        "Function `weights`\nCode:\n    def weights(self) -> List[int]:\n        return [w.weight for w in self.workloads]"
                                    ],
                                    "code": "from typing import List\n\nfrom pydantic import BaseModel, NonNegativeInt\n\n\nclass Workload(BaseModel):\n    weight: NonNegativeInt\n    member_id: int\n\n\nclass WorkloadAllocation(BaseModel):\n    workloads: List[Workload]\n\n    @property\n    def member_ids(self) -> List[int]:\n        return [w.member_id for w in self.workloads]\n\n    @property\n    def weights(self) -> List[int]:\n        return [w.weight for w in self.workloads]\n",
                                    "summary": "Class Workload: A model representing a workload with a non-negative weight and an associated member ID; Class WorkloadAllocation: A model that aggregates multiple Workload instances, offering methods to retrieve lists of member IDs and weights from those workloads.",
                                    "code_element_summaries": [
                                        "Class Workload: A model representing a workload with a non-negative weight and an associated member ID.",
                                        "Class WorkloadAllocation: A model that aggregates a list of Workload instances, providing properties to retrieve member IDs and weights associated with the workloads.",
                                        "Function `member_ids`: Returns a list of member IDs extracted from the workloads associated with the instance.",
                                        "Function `weights`: Returns a list of weights from the workloads associated with the instance."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\assignment\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "filters.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\filters.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ExampleFilter`\nCode:\nclass ExampleFilter(FilterSet):\n    confirmed = BooleanFilter(field_name=\"states\", method=\"filter_by_state\")\n    label = CharFilter(method=\"filter_by_label\")\n    assignee = CharFilter(method=\"filter_by_assignee\")\n\n    def filter_by_state(self, queryset, field_name, is_confirmed: bool):\n        queryset = queryset.annotate(\n            num_confirm=Count(\n                expression=field_name,\n                filter=Q(**{f\"{field_name}__confirmed_by\": self.request.user})\n                | Q(project__collaborative_annotation=True),\n            )\n        )\n        if is_confirmed:\n            queryset = queryset.filter(num_confirm__gte=1)\n        else:\n            queryset = queryset.filter(num_confirm__lte=0)\n        return queryset\n\n    def filter_by_label(self, queryset: QuerySet, field_name: str, label: str) -> QuerySet:\n        \"\"\"Filter examples by a given label name.\n\n        This performs filtering on all of the following labels at once:\n        - categories\n        - spans\n        - relations\n        - bboxes\n        - segmentations\n\n        Todo: Consider project type to make filtering more efficient.\n\n        Args:\n            queryset (QuerySet): QuerySet to filter.\n            field_name (str): This equals to `label`.\n            label (str): The label name to filter.\n\n        Returns:\n            QuerySet: Filtered examples.\n        \"\"\"\n        queryset = queryset.filter(\n            Q(categories__label__text=label)\n            | Q(spans__label__text=label)\n            | Q(relations__type__text=label)\n            | Q(bboxes__label__text=label)\n            | Q(segmentations__label__text=label)\n        )\n        return queryset\n\n    def filter_by_assignee(self, queryset: QuerySet, field_name: str, assignee: str) -> QuerySet:\n        return queryset.filter(assignments__assignee__username=assignee)\n\n    class Meta:\n        model = Example\n        fields = (\"project\", \"text\", \"created_at\", \"updated_at\", \"label\", \"assignee\")",
                                "Function `filter_by_state`\nCode:\n    def filter_by_state(self, queryset, field_name, is_confirmed: bool):\n        queryset = queryset.annotate(\n            num_confirm=Count(\n                expression=field_name,\n                filter=Q(**{f\"{field_name}__confirmed_by\": self.request.user})\n                | Q(project__collaborative_annotation=True),\n            )\n        )\n        if is_confirmed:\n            queryset = queryset.filter(num_confirm__gte=1)\n        else:\n            queryset = queryset.filter(num_confirm__lte=0)\n        return queryset",
                                "Function `filter_by_label`: Filter examples by a given label name.\nCode:\n    def filter_by_label(self, queryset: QuerySet, field_name: str, label: str) -> QuerySet:\n        \"\"\"Filter examples by a given label name.\n\n        This performs filtering on all of the following labels at once:\n        - categories\n        - spans\n        - relations\n        - bboxes\n        - segmentations\n\n        Todo: Consider project type to make filtering more efficient.\n\n        Args:\n            queryset (QuerySet): QuerySet to filter.\n            field_name (str): This equals to `label`.\n            label (str): The label name to filter.\n\n        Returns:\n            QuerySet: Filtered examples.\n        \"\"\"\n        queryset = queryset.filter(\n            Q(categories__label__text=label)\n            | Q(spans__label__text=label)\n            | Q(relations__type__text=label)\n            | Q(bboxes__label__text=label)\n            | Q(segmentations__label__text=label)\n        )\n        return queryset",
                                "Function `filter_by_assignee`\nCode:\n    def filter_by_assignee(self, queryset: QuerySet, field_name: str, assignee: str) -> QuerySet:\n        return queryset.filter(assignments__assignee__username=assignee)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Example\n        fields = (\"project\", \"text\", \"created_at\", \"updated_at\", \"label\", \"assignee\")"
                            ],
                            "code": "from django.db.models import Count, Q, QuerySet\nfrom django_filters.rest_framework import BooleanFilter, CharFilter, FilterSet\n\nfrom .models import Example\n\n\nclass ExampleFilter(FilterSet):\n    confirmed = BooleanFilter(field_name=\"states\", method=\"filter_by_state\")\n    label = CharFilter(method=\"filter_by_label\")\n    assignee = CharFilter(method=\"filter_by_assignee\")\n\n    def filter_by_state(self, queryset, field_name, is_confirmed: bool):\n        queryset = queryset.annotate(\n            num_confirm=Count(\n                expression=field_name,\n                filter=Q(**{f\"{field_name}__confirmed_by\": self.request.user})\n                | Q(project__collaborative_annotation=True),\n            )\n        )\n        if is_confirmed:\n            queryset = queryset.filter(num_confirm__gte=1)\n        else:\n            queryset = queryset.filter(num_confirm__lte=0)\n        return queryset\n\n    def filter_by_label(self, queryset: QuerySet, field_name: str, label: str) -> QuerySet:\n        \"\"\"Filter examples by a given label name.\n\n        This performs filtering on all of the following labels at once:\n        - categories\n        - spans\n        - relations\n        - bboxes\n        - segmentations\n\n        Todo: Consider project type to make filtering more efficient.\n\n        Args:\n            queryset (QuerySet): QuerySet to filter.\n            field_name (str): This equals to `label`.\n            label (str): The label name to filter.\n\n        Returns:\n            QuerySet: Filtered examples.\n        \"\"\"\n        queryset = queryset.filter(\n            Q(categories__label__text=label)\n            | Q(spans__label__text=label)\n            | Q(relations__type__text=label)\n            | Q(bboxes__label__text=label)\n            | Q(segmentations__label__text=label)\n        )\n        return queryset\n\n    def filter_by_assignee(self, queryset: QuerySet, field_name: str, assignee: str) -> QuerySet:\n        return queryset.filter(assignments__assignee__username=assignee)\n\n    class Meta:\n        model = Example\n        fields = (\"project\", \"text\", \"created_at\", \"updated_at\", \"label\", \"assignee\")\n",
                            "summary": "Class `ExampleFilter`: A custom filter set for `Example` instances that provides enhanced querying capabilities based on confirmation status, label, and assignee through specialized filtering methods.",
                            "code_element_summaries": [
                                "Class `ExampleFilter`: A custom filter set for filtering `Example` instances based on confirmation status, label, and assignee, utilizing specific filtering methods for enhanced query capabilities.",
                                "Function `filter_by_state`: Filters a queryset based on the confirmation status of a specified field, returning results according to whether annotations are confirmed or not.",
                                "Function `filter_by_label`: Filters a given QuerySet of examples based on a specified label name across multiple label types, including categories, spans, relations, bounding boxes, and segmentations.",
                                "Function `filter_by_assignee`: Filters a queryset to return only those records assigned to a specific user based on their username.",
                                "Class Meta: A configuration class that specifies the model Example and the fields to be included in its representation."
                            ],
                            "children": []
                        },
                        {
                            "name": "managers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\managers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ExampleManager`\nCode:\nclass ExampleManager(Manager):\n    def bulk_create(self, objs, batch_size=None, ignore_conflicts=False):\n        super().bulk_create(objs, batch_size=batch_size, ignore_conflicts=ignore_conflicts)\n        uuids = [data.uuid for data in objs]\n        examples = self.in_bulk(uuids, field_name=\"uuid\")\n        return [examples[uid] for uid in uuids]",
                                "Function `bulk_create`\nCode:\n    def bulk_create(self, objs, batch_size=None, ignore_conflicts=False):\n        super().bulk_create(objs, batch_size=batch_size, ignore_conflicts=ignore_conflicts)\n        uuids = [data.uuid for data in objs]\n        examples = self.in_bulk(uuids, field_name=\"uuid\")\n        return [examples[uid] for uid in uuids]",
                                "Class `ExampleStateManager`\nCode:\nclass ExampleStateManager(Manager):\n    def count_done(self, examples, user=None):\n        if user:\n            queryset = self.filter(example_id__in=examples, confirmed_by=user)\n        else:\n            queryset = self.filter(example_id__in=examples)\n        return queryset.distinct().values(\"example\").count()\n\n    def measure_member_progress(self, examples, members):\n        done_count = (\n            self.filter(example_id__in=examples).values(\"confirmed_by__username\").annotate(total=Count(\"confirmed_by\"))\n        )\n        response = {\n            \"total\": examples.count(),\n            \"progress\": [{\"user\": obj[\"confirmed_by__username\"], \"done\": obj[\"total\"]} for obj in done_count],\n        }\n        members_with_progress = {o[\"confirmed_by__username\"] for o in done_count}\n        for member in members:\n            if member.username not in members_with_progress:\n                response[\"progress\"].append({\"user\": member.username, \"done\": 0})\n        return response",
                                "Function `count_done`\nCode:\n    def count_done(self, examples, user=None):\n        if user:\n            queryset = self.filter(example_id__in=examples, confirmed_by=user)\n        else:\n            queryset = self.filter(example_id__in=examples)\n        return queryset.distinct().values(\"example\").count()",
                                "Function `measure_member_progress`\nCode:\n    def measure_member_progress(self, examples, members):\n        done_count = (\n            self.filter(example_id__in=examples).values(\"confirmed_by__username\").annotate(total=Count(\"confirmed_by\"))\n        )\n        response = {\n            \"total\": examples.count(),\n            \"progress\": [{\"user\": obj[\"confirmed_by__username\"], \"done\": obj[\"total\"]} for obj in done_count],\n        }\n        members_with_progress = {o[\"confirmed_by__username\"] for o in done_count}\n        for member in members:\n            if member.username not in members_with_progress:\n                response[\"progress\"].append({\"user\": member.username, \"done\": 0})\n        return response"
                            ],
                            "code": "from django.db.models import Count, Manager\n\n\nclass ExampleManager(Manager):\n    def bulk_create(self, objs, batch_size=None, ignore_conflicts=False):\n        super().bulk_create(objs, batch_size=batch_size, ignore_conflicts=ignore_conflicts)\n        uuids = [data.uuid for data in objs]\n        examples = self.in_bulk(uuids, field_name=\"uuid\")\n        return [examples[uid] for uid in uuids]\n\n\nclass ExampleStateManager(Manager):\n    def count_done(self, examples, user=None):\n        if user:\n            queryset = self.filter(example_id__in=examples, confirmed_by=user)\n        else:\n            queryset = self.filter(example_id__in=examples)\n        return queryset.distinct().values(\"example\").count()\n\n    def measure_member_progress(self, examples, members):\n        done_count = (\n            self.filter(example_id__in=examples).values(\"confirmed_by__username\").annotate(total=Count(\"confirmed_by\"))\n        )\n        response = {\n            \"total\": examples.count(),\n            \"progress\": [{\"user\": obj[\"confirmed_by__username\"], \"done\": obj[\"total\"]} for obj in done_count],\n        }\n        members_with_progress = {o[\"confirmed_by__username\"] for o in done_count}\n        for member in members:\n            if member.username not in members_with_progress:\n                response[\"progress\"].append({\"user\": member.username, \"done\": 0})\n        return response\n",
                            "summary": "Class ExampleManager: A custom manager that enhances bulk creation of objects by returning them indexed by UUIDs, while ExampleStateManager provides functionality to count completed examples and measure user progress on tasks.",
                            "code_element_summaries": [
                                "Class ExampleManager: A custom manager that extends the bulk_create method to return a list of created objects indexed by their UUIDs.",
                                "Function `bulk_create`: A method that extends the bulk creation of objects while retrieving and returning the created objects by their UUIDs, handling batch sizes and conflict ignoring as needed.",
                                "Class `ExampleStateManager`: A custom manager that provides methods to count completed examples by a user and to measure the progress of members on example tasks.",
                                "Function `count_done`: A method that counts distinct examples filtered by user confirmation status from a given list of examples.",
                                "Function `measure_member_progress`: Calculates the progress of members on given examples, returning a summary that includes the total examples and a list of users with their corresponding completion counts."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A series of Django migrations that define and modify various models, including Example, Comment, and Assignment, with specific fields, relationships, and constraints to manage database schema changes effectively.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0034_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Example\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"uuid\", models.UUIDField(db_index=True, default=uuid.uuid4, editable=False, unique=True)),\n                        (\"meta\", models.JSONField(default=dict)),\n                        (\"filename\", models.FileField(default=\".\", max_length=1024, upload_to=\"\")),\n                        (\"text\", models.TextField(blank=True, null=True)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"annotations_approved_by\",\n                            models.ForeignKey(\n                                blank=True,\n                                null=True,\n                                on_delete=django.db.models.deletion.SET_NULL,\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"api.project\"\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"Comment\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.TextField()),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"comments\",\n                                to=\"examples.example\",\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"ExampleState\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"confirmed_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"confirmed_by\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"states\",\n                                to=\"examples.example\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"example\", \"confirmed_by\")},\n                    },\n                ),\n            ]\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-28 02:46\n\nimport uuid\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0034_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Example\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"uuid\", models.UUIDField(db_index=True, default=uuid.uuid4, editable=False, unique=True)),\n                        (\"meta\", models.JSONField(default=dict)),\n                        (\"filename\", models.FileField(default=\".\", max_length=1024, upload_to=\"\")),\n                        (\"text\", models.TextField(blank=True, null=True)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"annotations_approved_by\",\n                            models.ForeignKey(\n                                blank=True,\n                                null=True,\n                                on_delete=django.db.models.deletion.SET_NULL,\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"api.project\"\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"Comment\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.TextField()),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"comments\",\n                                to=\"examples.example\",\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"ExampleState\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"confirmed_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"confirmed_by\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"states\",\n                                to=\"examples.example\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"example\", \"confirmed_by\")},\n                    },\n                ),\n            ]\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes three models—Example, Comment, and ExampleState—with defined fields and relationships to maintain database state separation.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates three models—Example, Comment, and ExampleState—along with their fields and relationships, while ensuring database state separation."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_alter_example_project.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0002_alter_example_project.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"examples\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"example\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"examples\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"example\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"examples\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the 'project' field in the 'example' model to create a foreign key relationship with the 'projects.project' model.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the 'project' field in the 'example' model to establish a foreign key relationship with the 'projects.project' model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_alter_example_filename.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0003_alter_example_filename.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0002_alter_example_project\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"filename\",\n            field=models.FileField(\n                default=\".\",\n                max_length=1024,\n                storage=django_drf_filepond.models.FilePondLocalStoredStorage(),\n                upload_to=\"\",\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-04-05 02:46\n\nimport django_drf_filepond.models\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0002_alter_example_project\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"filename\",\n            field=models.FileField(\n                default=\".\",\n                max_length=1024,\n                storage=django_drf_filepond.models.FilePondLocalStoredStorage(),\n                upload_to=\"\",\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the `filename` field of the `example` model to utilize a FileField with designated storage options and default configurations.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A Django migration that alters the `filename` field of the `example` model to use a FileField with specific storage and default settings."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_example_upload_name.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0004_example_upload_name.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0003_alter_example_filename\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"upload_name\",\n            field=models.CharField(blank=True, max_length=512, null=True),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-04-05 02:46\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0003_alter_example_filename\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"upload_name\",\n            field=models.CharField(blank=True, max_length=512, null=True),\n        ),\n    ]\n",
                                    "summary": "Class `Migration`: A Django migration that introduces an optional `upload_name` field to the `example` model, enabling it to hold a string with a maximum length of 512 characters.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A Django migration that adds an optional `upload_name` field to the `example` model, allowing it to store a string of up to 512 characters."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_auto_20220405_0252.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0005_auto_20220405_0252.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `store_filename`\nCode:\ndef store_filename(apps, schema_editor):\n    Example = apps.get_model(\"examples\", \"Example\")\n    for example in Example.objects.all():\n        example.upload_name = os.path.basename(example.filename.name)\n        example.save()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0004_example_upload_name\"),\n    ]\n\n    operations = [migrations.RunPython(code=store_filename, reverse_code=migrations.RunPython.noop)]"
                                    ],
                                    "code": "import os\n\nfrom django.db import migrations\n\n\ndef store_filename(apps, schema_editor):\n    Example = apps.get_model(\"examples\", \"Example\")\n    for example in Example.objects.all():\n        example.upload_name = os.path.basename(example.filename.name)\n        example.save()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0004_example_upload_name\"),\n    ]\n\n    operations = [migrations.RunPython(code=store_filename, reverse_code=migrations.RunPython.noop)]\n",
                                    "summary": "Function store_filename: A database migration function that updates the `upload_name` field of all `Example` instances, while the Migration class defines the dependencies and operations for executing this function within a Django migration.",
                                    "code_element_summaries": [
                                        "Function `store_filename`: A database migration function that updates the `upload_name` field of all `Example` instances to the base name of their associated file names.",
                                        "Class Migration: A Django migration that defines dependencies and operations to execute a Python function for data storage."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0006_alter_example_upload_name.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0006_alter_example_upload_name.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0005_auto_20220405_0252\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"upload_name\",\n            field=models.CharField(max_length=512),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-04-05 02:59\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0005_auto_20220405_0252\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"example\",\n            name=\"upload_name\",\n            field=models.CharField(max_length=512),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the `upload_name` field of the `example` model to a maximum length of 512 characters, while depending on a prior migration.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the `upload_name` field of the `example` model to have a maximum length of 512 characters, with a dependency on a previous migration."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0007_example_score.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0007_example_score.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"score\",\n            field=models.FloatField(default=100),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.7 on 2022-10-21 07:37\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"example\",\n            name=\"score\",\n            field=models.FloatField(default=100),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that introduces a FloatField called \"score\" with a default value of 100 to the \"example\" model, contingent upon a prior migration.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that adds a new FloatField named \"score\" with a default value of 100 to the \"example\" model, depending on a previous migration."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0008_assignment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\0008_assignment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0008_project_allow_member_to_create_label_type_and_more\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"examples\", \"0007_example_score\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Assignment\",\n            fields=[\n                (\"id\", models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"assignee\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"assignments\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"assignments\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"assignee\")},\n            },\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.1.10 on 2023-07-24 05:39\n\nfrom django.conf import settings\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport uuid\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0008_project_allow_member_to_create_label_type_and_more\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"examples\", \"0007_example_score\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Assignment\",\n            fields=[\n                (\"id\", models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"assignee\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"assignments\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"project\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"assignments\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            options={\n                \"unique_together\": {(\"example\", \"assignee\")},\n            },\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes the Assignment model with ID, timestamp fields, and foreign key relationships to User, Example, and Project models, enforcing a unique constraint on the combination of example and assignee.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates the Assignment model with fields for ID, timestamps, and foreign key relationships to the User, Example, and Project models, while enforcing a unique constraint on the combination of example and assignee."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Example`\nCode:\nclass Example(models.Model):\n    objects = ExampleManager()\n\n    uuid = models.UUIDField(default=uuid.uuid4, editable=False, db_index=True, unique=True)\n    meta = models.JSONField(default=dict)\n    filename = models.FileField(default=\".\", max_length=1024, storage=DrfFilePondStoredStorage())\n    upload_name = models.CharField(max_length=512)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"examples\")\n    annotations_approved_by = models.ForeignKey(to=User, on_delete=models.SET_NULL, null=True, blank=True)\n    text = models.TextField(null=True, blank=True)\n    score = models.FloatField(default=100)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    @property\n    def comment_count(self):\n        return Comment.objects.filter(example=self.id).count()\n\n    @property\n    def data(self):\n        if self.project.is_text_project:\n            return self.text\n        else:\n            return str(self.filename)\n\n    class Meta:\n        ordering = [\"created_at\"]",
                                "Function `comment_count`\nCode:\n    def comment_count(self):\n        return Comment.objects.filter(example=self.id).count()",
                                "Function `data`\nCode:\n    def data(self):\n        if self.project.is_text_project:\n            return self.text\n        else:\n            return str(self.filename)",
                                "Class `Meta`\nCode:\n    class Meta:\n        ordering = [\"created_at\"]",
                                "Class `Assignment`\nCode:\nclass Assignment(models.Model):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"assignments\")\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"assignments\")\n    assignee = models.ForeignKey(to=User, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = ((\"example\", \"assignee\"),)\n\n    def clean(self):\n        # assignee must be a member of the project\n        if not self.project.members.filter(id=self.assignee.id).exists():\n            raise ValidationError(\"Assignee must be a member of the project\")\n\n        # example must be in the project\n        if not self.project.examples.filter(id=self.example.id).exists():\n            raise ValidationError(\"Example must be in the project\")\n\n        return super().clean()",
                                "Class `Meta`\nCode:\n    class Meta:\n        unique_together = ((\"example\", \"assignee\"),)",
                                "Function `clean`\nCode:\n    def clean(self):\n        # assignee must be a member of the project\n        if not self.project.members.filter(id=self.assignee.id).exists():\n            raise ValidationError(\"Assignee must be a member of the project\")\n\n        # example must be in the project\n        if not self.project.examples.filter(id=self.example.id).exists():\n            raise ValidationError(\"Example must be in the project\")\n\n        return super().clean()",
                                "Class `ExampleState`\nCode:\nclass ExampleState(models.Model):\n    objects = ExampleStateManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"states\")\n    confirmed_by = models.ForeignKey(to=User, on_delete=models.CASCADE)\n    confirmed_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = ((\"example\", \"confirmed_by\"),)",
                                "Class `Meta`\nCode:\n    class Meta:\n        unique_together = ((\"example\", \"confirmed_by\"),)",
                                "Class `Comment`\nCode:\nclass Comment(models.Model):\n    text = models.TextField()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"comments\")\n    user = models.ForeignKey(to=User, on_delete=models.CASCADE, null=True)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    @property\n    def username(self):\n        return self.user.username\n\n    class Meta:\n        ordering = [\"created_at\"]",
                                "Function `username`\nCode:\n    def username(self):\n        return self.user.username",
                                "Class `Meta`\nCode:\n    class Meta:\n        ordering = [\"created_at\"]"
                            ],
                            "code": "import uuid\n\nfrom django.contrib.auth.models import User\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django_drf_filepond.models import DrfFilePondStoredStorage\n\nfrom .managers import ExampleManager, ExampleStateManager\nfrom projects.models import Project\n\n\nclass Example(models.Model):\n    objects = ExampleManager()\n\n    uuid = models.UUIDField(default=uuid.uuid4, editable=False, db_index=True, unique=True)\n    meta = models.JSONField(default=dict)\n    filename = models.FileField(default=\".\", max_length=1024, storage=DrfFilePondStoredStorage())\n    upload_name = models.CharField(max_length=512)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"examples\")\n    annotations_approved_by = models.ForeignKey(to=User, on_delete=models.SET_NULL, null=True, blank=True)\n    text = models.TextField(null=True, blank=True)\n    score = models.FloatField(default=100)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    @property\n    def comment_count(self):\n        return Comment.objects.filter(example=self.id).count()\n\n    @property\n    def data(self):\n        if self.project.is_text_project:\n            return self.text\n        else:\n            return str(self.filename)\n\n    class Meta:\n        ordering = [\"created_at\"]\n\n\nclass Assignment(models.Model):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"assignments\")\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"assignments\")\n    assignee = models.ForeignKey(to=User, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = ((\"example\", \"assignee\"),)\n\n    def clean(self):\n        # assignee must be a member of the project\n        if not self.project.members.filter(id=self.assignee.id).exists():\n            raise ValidationError(\"Assignee must be a member of the project\")\n\n        # example must be in the project\n        if not self.project.examples.filter(id=self.example.id).exists():\n            raise ValidationError(\"Example must be in the project\")\n\n        return super().clean()\n\n\nclass ExampleState(models.Model):\n    objects = ExampleStateManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"states\")\n    confirmed_by = models.ForeignKey(to=User, on_delete=models.CASCADE)\n    confirmed_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = ((\"example\", \"confirmed_by\"),)\n\n\nclass Comment(models.Model):\n    text = models.TextField()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"comments\")\n    user = models.ForeignKey(to=User, on_delete=models.CASCADE, null=True)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    @property\n    def username(self):\n        return self.user.username\n\n    class Meta:\n        ordering = [\"created_at\"]\n",
                            "summary": "Class Example: A Django model that encapsulates metadata and file handling for examples, with methods for comment counting and data retrieval, accompanied by related models for assignments, states, and comments, each with their own constraints and validation rules.",
                            "code_element_summaries": [
                                "Class Example: A Django model representing an example with fields for metadata, file handling, project association, user annotations, and timestamps, along with properties for comment count and data retrieval based on project type.",
                                "Function `comment_count`: Returns the total number of comments associated with a specific example by filtering the Comment objects based on the example's ID.",
                                "Function `data`: Returns the text of the project if it is a text project; otherwise, it returns the filename as a string.",
                                "Class Meta: Defines the default ordering of a model's query results based on the `created_at` field.",
                                "Class Assignment: A Django model that represents an assignment of a user to an example within a project, ensuring that the assignee is a project member and the example belongs to the project.",
                                "Class Meta: Defines a unique constraint for the combination of the \"example\" and \"assignee\" fields.",
                                "Function `clean`: Validates that the assignee and example are members of the project, raising a ValidationError if either is not.",
                                "Class ExampleState: A Django model that represents the state of an example with relationships to the Example and User models, ensuring unique combinations of example and confirmer.",
                                "Class Meta: Defines a unique constraint for the combination of the fields \"example\" and \"confirmed_by\".",
                                "Class Comment: A Django model representing user comments associated with examples, including text, user information, and timestamps, with a property to retrieve the username of the commenter.",
                                "Function `username`: Returns the username of the associated user object.",
                                "Class Meta: A configuration class that specifies the default ordering of objects by their creation date."
                            ],
                            "children": []
                        },
                        {
                            "name": "permissions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\permissions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `IsOwnComment`\nCode:\nclass IsOwnComment(BasePermission):\n    @classmethod\n    def has_object_permission(cls, request, view, obj):\n        if request.user.is_superuser:\n            return True\n\n        return obj.user.id == request.user.id",
                                "Function `has_object_permission`\nCode:\n    def has_object_permission(cls, request, view, obj):\n        if request.user.is_superuser:\n            return True\n\n        return obj.user.id == request.user.id"
                            ],
                            "code": "from rest_framework.permissions import BasePermission\n\n\nclass IsOwnComment(BasePermission):\n    @classmethod\n    def has_object_permission(cls, request, view, obj):\n        if request.user.is_superuser:\n            return True\n\n        return obj.user.id == request.user.id\n",
                            "summary": "Class IsOwnComment: A permission class that grants access to superusers and owners of comment objects through the `has_object_permission` function.",
                            "code_element_summaries": [
                                "Class IsOwnComment: A permission class that allows access if the user is a superuser or if the user is the owner of the comment object.",
                                "Function `has_object_permission`: Determines if a user has permission to access a specific object, granting access to superusers and matching object owners."
                            ],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `CommentSerializer`\nCode:\nclass CommentSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Comment\n        fields = (\n            \"id\",\n            \"user\",\n            \"username\",\n            \"example\",\n            \"text\",\n            \"created_at\",\n        )\n        read_only_fields = (\"user\", \"example\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Comment\n        fields = (\n            \"id\",\n            \"user\",\n            \"username\",\n            \"example\",\n            \"text\",\n            \"created_at\",\n        )\n        read_only_fields = (\"user\", \"example\")",
                                "Class `AssignmentSerializer`\nCode:\nclass AssignmentSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Assignment\n        fields = (\"id\", \"assignee\", \"example\", \"created_at\", \"updated_at\")\n        read_only_fields = (\"id\", \"created_at\", \"updated_at\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Assignment\n        fields = (\"id\", \"assignee\", \"example\", \"created_at\", \"updated_at\")\n        read_only_fields = (\"id\", \"created_at\", \"updated_at\")",
                                "Class `ExampleSerializer`\nCode:\nclass ExampleSerializer(serializers.ModelSerializer):\n    annotation_approver = serializers.SerializerMethodField()\n    is_confirmed = serializers.SerializerMethodField()\n    assignments = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_annotation_approver(cls, instance):\n        approver = instance.annotations_approved_by\n        return approver.username if approver else None\n\n    def get_is_confirmed(self, instance):\n        user = self.context.get(\"request\").user\n        if instance.project.collaborative_annotation:\n            states = instance.states.all()\n        else:\n            states = instance.states.filter(confirmed_by_id=user.id)\n        return states.count() > 0\n\n    def get_assignments(self, instance):\n        return [\n            {\n                \"id\": assignment.id,\n                \"assignee\": assignment.assignee.username,\n                \"assignee_id\": assignment.assignee.id,\n            }\n            for assignment in instance.assignments.all()\n        ]\n\n    class Meta:\n        model = Example\n        fields = [\n            \"id\",\n            \"filename\",\n            \"meta\",\n            \"annotation_approver\",\n            \"comment_count\",\n            \"text\",\n            \"is_confirmed\",\n            \"upload_name\",\n            \"score\",\n            \"assignments\",\n        ]\n        read_only_fields = [\"filename\", \"is_confirmed\", \"upload_name\", \"assignments\"]",
                                "Function `get_annotation_approver`\nCode:\n    def get_annotation_approver(cls, instance):\n        approver = instance.annotations_approved_by\n        return approver.username if approver else None",
                                "Function `get_is_confirmed`\nCode:\n    def get_is_confirmed(self, instance):\n        user = self.context.get(\"request\").user\n        if instance.project.collaborative_annotation:\n            states = instance.states.all()\n        else:\n            states = instance.states.filter(confirmed_by_id=user.id)\n        return states.count() > 0",
                                "Function `get_assignments`\nCode:\n    def get_assignments(self, instance):\n        return [\n            {\n                \"id\": assignment.id,\n                \"assignee\": assignment.assignee.username,\n                \"assignee_id\": assignment.assignee.id,\n            }\n            for assignment in instance.assignments.all()\n        ]",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Example\n        fields = [\n            \"id\",\n            \"filename\",\n            \"meta\",\n            \"annotation_approver\",\n            \"comment_count\",\n            \"text\",\n            \"is_confirmed\",\n            \"upload_name\",\n            \"score\",\n            \"assignments\",\n        ]\n        read_only_fields = [\"filename\", \"is_confirmed\", \"upload_name\", \"assignments\"]",
                                "Class `ExampleStateSerializer`\nCode:\nclass ExampleStateSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = ExampleState\n        fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")\n        read_only_fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = ExampleState\n        fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")\n        read_only_fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")"
                            ],
                            "code": "from rest_framework import serializers\n\nfrom .models import Assignment, Comment, Example, ExampleState\n\n\nclass CommentSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Comment\n        fields = (\n            \"id\",\n            \"user\",\n            \"username\",\n            \"example\",\n            \"text\",\n            \"created_at\",\n        )\n        read_only_fields = (\"user\", \"example\")\n\n\nclass AssignmentSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Assignment\n        fields = (\"id\", \"assignee\", \"example\", \"created_at\", \"updated_at\")\n        read_only_fields = (\"id\", \"created_at\", \"updated_at\")\n\n\nclass ExampleSerializer(serializers.ModelSerializer):\n    annotation_approver = serializers.SerializerMethodField()\n    is_confirmed = serializers.SerializerMethodField()\n    assignments = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_annotation_approver(cls, instance):\n        approver = instance.annotations_approved_by\n        return approver.username if approver else None\n\n    def get_is_confirmed(self, instance):\n        user = self.context.get(\"request\").user\n        if instance.project.collaborative_annotation:\n            states = instance.states.all()\n        else:\n            states = instance.states.filter(confirmed_by_id=user.id)\n        return states.count() > 0\n\n    def get_assignments(self, instance):\n        return [\n            {\n                \"id\": assignment.id,\n                \"assignee\": assignment.assignee.username,\n                \"assignee_id\": assignment.assignee.id,\n            }\n            for assignment in instance.assignments.all()\n        ]\n\n    class Meta:\n        model = Example\n        fields = [\n            \"id\",\n            \"filename\",\n            \"meta\",\n            \"annotation_approver\",\n            \"comment_count\",\n            \"text\",\n            \"is_confirmed\",\n            \"upload_name\",\n            \"score\",\n            \"assignments\",\n        ]\n        read_only_fields = [\"filename\", \"is_confirmed\", \"upload_name\", \"assignments\"]\n\n\nclass ExampleStateSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = ExampleState\n        fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")\n        read_only_fields = (\"id\", \"example\", \"confirmed_by\", \"confirmed_at\")\n",
                            "summary": "Classes and functions for serializers in a Django REST framework application that define how Comment, Assignment, Example, and ExampleState models are represented, including read-only fields and custom methods for retrieving annotation approval, confirmation status, and assignments.",
                            "code_element_summaries": [
                                "Class `CommentSerializer`: A Django REST framework serializer for the Comment model that includes specific fields and designates certain fields as read-only.",
                                "Class `Meta`: A configuration class that defines the model and fields for the Comment serializer, specifying read-only fields for certain attributes.",
                                "Class AssignmentSerializer: A serializer for the Assignment model that specifies the fields to be included and marks certain fields as read-only.",
                                "Class Meta: A configuration class that defines the model Assignment with specified fields and read-only attributes for serialization.",
                                "Class ExampleSerializer: A serializer for the Example model that includes custom fields for annotation approval, confirmation status, and assignments, while defining which fields are read-only.",
                                "Function `get_annotation_approver`: Retrieves the username of the user who approved the annotations for a given instance, returning None if no approver exists.",
                                "Function `get_is_confirmed`: Determines whether an instance has any confirmed states based on the user's involvement and the project's collaborative annotation setting.",
                                "Function `get_assignments`: Retrieves a list of assignments for a given instance, returning each assignment's ID, assignee's username, and assignee's ID in dictionary format.",
                                "Class Meta: A configuration class that defines the model Example with specified fields and read-only fields for data serialization.",
                                "Class ExampleStateSerializer: A serializer for the ExampleState model that defines the fields to be included and marks certain fields as read-only.",
                                "Class `Meta`: Defines metadata for the ExampleState model, specifying the fields to include and marking certain fields as read-only."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Test suites and classes designed to verify access control, functionality, and CRUD operations for assignments, comments, examples, and example states within project management, ensuring proper role-based permissions and error handling, while also providing utility functions for model instance creation.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_assignment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_assignment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestAssignmentList`\nCode:\nclass TestAssignmentList(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        make_assignment(self.project.item, self.example, self.project.admin)\n        self.data = {\"example\": self.example.id, \"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_list\", args=[self.project.item.id])\n\n    def test_allow_project_member_to_list_assignments(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_denies_non_project_member_to_list_assignments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_assignments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_assign(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"example\"], self.data[\"example\"])\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])\n\n    def test_denies_non_admin_to_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        make_assignment(self.project.item, self.example, self.project.admin)\n        self.data = {\"example\": self.example.id, \"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_list\", args=[self.project.item.id])",
                                        "Function `test_allow_project_member_to_list_assignments`\nCode:\n    def test_allow_project_member_to_list_assignments(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)",
                                        "Function `test_denies_non_project_member_to_list_assignments`\nCode:\n    def test_denies_non_project_member_to_list_assignments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_list_assignments`\nCode:\n    def test_denies_unauthenticated_user_to_list_assignments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_assign`\nCode:\n    def test_allows_project_admin_to_assign(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"example\"], self.data[\"example\"])\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])",
                                        "Function `test_denies_non_admin_to_assign`\nCode:\n    def test_denies_non_admin_to_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_assign`\nCode:\n    def test_denies_non_project_member_to_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_assign`\nCode:\n    def test_denies_unauthenticated_user_to_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestAssignmentDetail`\nCode:\nclass TestAssignmentDetail(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        assignment = make_assignment(self.project.item, example, self.project.admin)\n        self.data = {\"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_detail\", args=[self.project.item.id, assignment.id])\n\n    def test_allows_project_member_to_get_assignment(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_denies_non_project_member_to_get_assignment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_assignment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_reassign(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])\n\n    def test_denies_non_admin_to_reassign(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_reassign(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_reassign(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_unassign(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_admin_to_unassign(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_unassign(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_unassign(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        assignment = make_assignment(self.project.item, example, self.project.admin)\n        self.data = {\"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_detail\", args=[self.project.item.id, assignment.id])",
                                        "Function `test_allows_project_member_to_get_assignment`\nCode:\n    def test_allows_project_member_to_get_assignment(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)",
                                        "Function `test_denies_non_project_member_to_get_assignment`\nCode:\n    def test_denies_non_project_member_to_get_assignment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_get_assignment`\nCode:\n    def test_denies_unauthenticated_user_to_get_assignment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_reassign`\nCode:\n    def test_allows_project_admin_to_reassign(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])",
                                        "Function `test_denies_non_admin_to_reassign`\nCode:\n    def test_denies_non_admin_to_reassign(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_reassign`\nCode:\n    def test_denies_non_project_member_to_reassign(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_reassign`\nCode:\n    def test_denies_unauthenticated_user_to_reassign(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_unassign`\nCode:\n    def test_allows_project_admin_to_unassign(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_non_admin_to_unassign`\nCode:\n    def test_denies_non_admin_to_unassign(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_unassign`\nCode:\n    def test_denies_non_project_member_to_unassign(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_unassign`\nCode:\n    def test_denies_unauthenticated_user_to_unassign(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestAssignmentBulk`\nCode:\nclass TestAssignmentBulk(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        members = Member.objects.filter(project=self.project.item)\n        workloads = [{\"member_id\": member.id, \"weight\": 100} for member in members]\n        self.data = {\"strategy_name\": \"sampling_without_replacement\", \"workloads\": workloads}\n        self.url = reverse(viewname=\"bulk_assignment\", args=[self.project.item.id])\n\n    def test_denies_non_admin_to_bulk_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_bulk_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_bulk_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_bulk_assign(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        expected = self.project.item.examples.count() * len(self.project.members)\n        self.assertEqual(Assignment.objects.count(), expected)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        members = Member.objects.filter(project=self.project.item)\n        workloads = [{\"member_id\": member.id, \"weight\": 100} for member in members]\n        self.data = {\"strategy_name\": \"sampling_without_replacement\", \"workloads\": workloads}\n        self.url = reverse(viewname=\"bulk_assignment\", args=[self.project.item.id])",
                                        "Function `test_denies_non_admin_to_bulk_assign`\nCode:\n    def test_denies_non_admin_to_bulk_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_bulk_assign`\nCode:\n    def test_denies_non_project_member_to_bulk_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_bulk_assign`\nCode:\n    def test_denies_unauthenticated_user_to_bulk_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_bulk_assign`\nCode:\n    def test_allows_project_admin_to_bulk_assign(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        expected = self.project.item.examples.count() * len(self.project.members)\n        self.assertEqual(Assignment.objects.count(), expected)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import make_assignment, make_doc\nfrom api.tests.utils import CRUDMixin\nfrom examples.models import Assignment\nfrom projects.models import Member\nfrom projects.tests.utils import prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestAssignmentList(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        make_assignment(self.project.item, self.example, self.project.admin)\n        self.data = {\"example\": self.example.id, \"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_list\", args=[self.project.item.id])\n\n    def test_allow_project_member_to_list_assignments(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_denies_non_project_member_to_list_assignments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_assignments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_assign(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"example\"], self.data[\"example\"])\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])\n\n    def test_denies_non_admin_to_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestAssignmentDetail(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        assignment = make_assignment(self.project.item, example, self.project.admin)\n        self.data = {\"assignee\": self.project.staffs[0].id}\n        self.url = reverse(viewname=\"assignment_detail\", args=[self.project.item.id, assignment.id])\n\n    def test_allows_project_member_to_get_assignment(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_denies_non_project_member_to_get_assignment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_assignment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_reassign(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"assignee\"], self.data[\"assignee\"])\n\n    def test_denies_non_admin_to_reassign(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_reassign(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_reassign(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_unassign(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_admin_to_unassign(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_unassign(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_unassign(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestAssignmentBulk(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        members = Member.objects.filter(project=self.project.item)\n        workloads = [{\"member_id\": member.id, \"weight\": 100} for member in members]\n        self.data = {\"strategy_name\": \"sampling_without_replacement\", \"workloads\": workloads}\n        self.url = reverse(viewname=\"bulk_assignment\", args=[self.project.item.id])\n\n    def test_denies_non_admin_to_bulk_assign(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_bulk_assign(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_bulk_assign(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_bulk_assign(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        expected = self.project.item.examples.count() * len(self.project.members)\n        self.assertEqual(Assignment.objects.count(), expected)\n",
                                    "summary": "Class `TestAssignmentList` and `TestAssignmentDetail`: Test suites that verify access control and functionality for listing, assigning, and managing assignments within a project, ensuring that actions are restricted based on user roles and authentication status, while `TestAssignmentBulk` focuses on bulk assignment permissions exclusively for project admins.",
                                    "code_element_summaries": [
                                        "Class `TestAssignmentList`: A test suite that verifies access control for listing and assigning assignments within a project, ensuring only authorized users can perform these actions.",
                                        "Function `setUp`: A setup method that initializes a project, creates a user and a document, assigns the document to the project admin, and prepares data and URL for testing assignment listing.",
                                        "Function `test_allow_project_member_to_list_assignments`: A test that verifies all members of a project can successfully list their assignments with a 200 OK response status.",
                                        "Function `test_denies_non_project_member_to_list_assignments`: A test case that verifies that a non-project member receives a 403 Forbidden status when attempting to list assignments.",
                                        "Function `test_denies_unauthenticated_user_to_list_assignments`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to list assignments.",
                                        "Function `test_allows_project_admin_to_assign`: A test function that verifies a project admin's ability to create an assignment and checks the correctness of the response data.",
                                        "Function `test_denies_non_admin_to_assign`: A test that verifies non-admin staff members are forbidden from assigning roles within a project, expecting a 403 Forbidden status.",
                                        "Function `test_denies_non_project_member_to_assign`: A test case that verifies a non-project member receives a forbidden status when attempting to assign a task.",
                                        "Function `test_denies_unauthenticated_user_to_assign`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to assign.",
                                        "Class `TestAssignmentDetail`: A test suite for verifying the permissions and functionality of assignment management in a project context, ensuring that access is correctly restricted based on user roles and authentication status.",
                                        "Function `setUp`: Prepares a test environment by creating a project, a non-member user, a document, an assignment, and initializes data and URL for assignment detail retrieval.",
                                        "Function `test_allows_project_member_to_get_assignment`: A test that verifies all members of a project can successfully fetch assignment data with an HTTP 200 OK status.",
                                        "Function `test_denies_non_project_member_to_get_assignment`: A test case that verifies non-project members receive a 403 Forbidden status when attempting to access an assignment.",
                                        "Function `test_denies_unauthenticated_user_to_get_assignment`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to access an assignment.",
                                        "Function `test_allows_project_admin_to_reassign`: A test that verifies a project admin can successfully reassign a task and receive a 200 OK status with the correct assignee in the response.",
                                        "Function `test_denies_non_admin_to_reassign`: A test that verifies non-admin staff members are denied permission to reassign project roles, expecting a 403 Forbidden status.",
                                        "Function `test_denies_non_project_member_to_reassign`: A test case that verifies a non-project member is denied permission to reassign with a 403 Forbidden status.",
                                        "Function `test_denies_unauthenticated_user_to_reassign`: A test case that verifies an unauthenticated user receives a forbidden status when attempting to reassign.",
                                        "Function `test_allows_project_admin_to_unassign`: A test case that verifies a project administrator's ability to unassign resources, expecting a successful deletion response with HTTP status 204.",
                                        "Function `test_denies_non_admin_to_unassign`: A test case that verifies non-admin staff members are forbidden from unassigning project resources, expecting an HTTP 403 Forbidden response.",
                                        "Function `test_denies_non_project_member_to_unassign`: A test case that verifies non-project members receive a 403 Forbidden status when attempting to unassign.",
                                        "Function `test_denies_unauthenticated_user_to_unassign`: A test function that asserts an unauthenticated user receives a 403 Forbidden status when attempting to unassign a resource.",
                                        "Class `TestAssignmentBulk`: A test case for verifying bulk assignment permissions, ensuring that only project admins can perform bulk assignments while denying access to non-admins, non-project members, and unauthenticated users.",
                                        "Function `setUp`: Initializes a test environment by preparing a project, creating a non-member user, generating a document, and setting up workloads for project members, along with the corresponding URL for bulk assignment.",
                                        "Function `test_denies_non_admin_to_bulk_assign`: A test case that verifies non-admin staff members are denied permission to perform bulk assignment operations, expecting a 403 Forbidden status.",
                                        "Function `test_denies_non_project_member_to_bulk_assign`: A test case that verifies a non-project member receives a forbidden status when attempting to perform a bulk assignment.",
                                        "Function `test_denies_unauthenticated_user_to_bulk_assign`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to perform a bulk assignment.",
                                        "Function `test_allows_project_admin_to_bulk_assign`: A test case that verifies if a project admin can successfully bulk assign items to project members, ensuring the correct number of assignments is created."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_comment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_comment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestCommentListDocAPI`\nCode:\nclass TestCommentListDocAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        doc1 = make_doc(cls.project.item)\n        doc2 = make_doc(cls.project.item)\n        make_comment(doc1, cls.project.admin)\n        make_comment(doc2, cls.project.admin)\n        cls.data = {\"text\": \"example\"}\n        cls.url = reverse(viewname=\"comment_list\", args=[cls.project.item.id])\n        cls.url += f\"?example={doc1.id}\"\n\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_member_to_create_comment(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_non_project_member_to_create_comment(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_comment(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        doc1 = make_doc(cls.project.item)\n        doc2 = make_doc(cls.project.item)\n        make_comment(doc1, cls.project.admin)\n        make_comment(doc2, cls.project.admin)\n        cls.data = {\"text\": \"example\"}\n        cls.url = reverse(viewname=\"comment_list\", args=[cls.project.item.id])\n        cls.url += f\"?example={doc1.id}\"",
                                        "Function `test_allows_project_member_to_list_comments`\nCode:\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)",
                                        "Function `test_denies_non_project_member_to_list_comments`\nCode:\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_list_comments`\nCode:\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_member_to_create_comment`\nCode:\n    def test_allows_project_member_to_create_comment(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Function `test_denies_non_project_member_to_create_comment`\nCode:\n    def test_denies_non_project_member_to_create_comment(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_create_comment`\nCode:\n    def test_denies_unauthenticated_user_to_create_comment(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestCommentListProjectAPI`\nCode:\nclass TestCommentListProjectAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        make_comment(self.doc, self.project.admin)\n        self.url = reverse(viewname=\"comment_list\", args=[self.project.item.id])\n\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        ids = [item.id for item in self.doc.comments.all()]\n        if user:\n            self.client.force_login(user)\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n\n    def test_allows_project_member_to_delete_comments(self):\n        # Todo: Disallow non admin to delete comments.\n        for member in self.project.members:\n            self.assert_bulk_delete(member, status.HTTP_204_NO_CONTENT)\n            response = self.client.get(self.url)\n            self.assertEqual(response.data[\"count\"], 0)\n\n    def test_denies_non_project_member_to_delete_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        make_comment(self.doc, self.project.admin)\n        self.url = reverse(viewname=\"comment_list\", args=[self.project.item.id])",
                                        "Function `test_allows_project_member_to_list_comments`\nCode:\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)",
                                        "Function `test_denies_non_project_member_to_list_comments`\nCode:\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_list_comments`\nCode:\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `assert_bulk_delete`\nCode:\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        ids = [item.id for item in self.doc.comments.all()]\n        if user:\n            self.client.force_login(user)\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)",
                                        "Function `test_allows_project_member_to_delete_comments`\nCode:\n    def test_allows_project_member_to_delete_comments(self):\n        # Todo: Disallow non admin to delete comments.\n        for member in self.project.members:\n            self.assert_bulk_delete(member, status.HTTP_204_NO_CONTENT)\n            response = self.client.get(self.url)\n            self.assertEqual(response.data[\"count\"], 0)",
                                        "Function `test_denies_non_project_member_to_delete_comments`\nCode:\n    def test_denies_non_project_member_to_delete_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_delete_comments`\nCode:\n    def test_denies_unauthenticated_user_to_delete_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestCommentDetailAPI`\nCode:\nclass TestCommentDetailAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        comment = make_comment(doc, self.project.admin)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"comment_detail\", args=[self.project.item.id, comment.id])\n\n    def test_allows_comment_owner_to_get_comment(self):\n        # Todo: Allows project member to get comment.\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_comment_owner_to_get_comment(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_get_comment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_comment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_comment_owner_to_update_comment(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_comment_owner_to_update_comment(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_comment(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_update_comment(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_comment_owner_to_delete_comment(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_comment_owner_to_delete_comment(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_comment(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_comment(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        comment = make_comment(doc, self.project.admin)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"comment_detail\", args=[self.project.item.id, comment.id])",
                                        "Function `test_allows_comment_owner_to_get_comment`\nCode:\n    def test_allows_comment_owner_to_get_comment(self):\n        # Todo: Allows project member to get comment.\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_non_comment_owner_to_get_comment`\nCode:\n    def test_denies_non_comment_owner_to_get_comment(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_get_comment`\nCode:\n    def test_denies_non_project_member_to_get_comment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_get_comment`\nCode:\n    def test_denies_unauthenticated_user_to_get_comment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_comment_owner_to_update_comment`\nCode:\n    def test_allows_comment_owner_to_update_comment(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])",
                                        "Function `test_denies_non_comment_owner_to_update_comment`\nCode:\n    def test_denies_non_comment_owner_to_update_comment(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_update_comment`\nCode:\n    def test_denies_non_project_member_to_update_comment(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_update_comment`\nCode:\n    def test_denies_unauthenticated_user_to_update_comment(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_comment_owner_to_delete_comment`\nCode:\n    def test_allows_comment_owner_to_delete_comment(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_non_comment_owner_to_delete_comment`\nCode:\n    def test_denies_non_comment_owner_to_delete_comment(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_delete_comment`\nCode:\n    def test_denies_non_project_member_to_delete_comment(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_delete_comment`\nCode:\n    def test_denies_unauthenticated_user_to_delete_comment(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import make_comment, make_doc\nfrom api.tests.utils import CRUDMixin\nfrom projects.tests.utils import prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestCommentListDocAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        doc1 = make_doc(cls.project.item)\n        doc2 = make_doc(cls.project.item)\n        make_comment(doc1, cls.project.admin)\n        make_comment(doc2, cls.project.admin)\n        cls.data = {\"text\": \"example\"}\n        cls.url = reverse(viewname=\"comment_list\", args=[cls.project.item.id])\n        cls.url += f\"?example={doc1.id}\"\n\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_member_to_create_comment(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_non_project_member_to_create_comment(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_comment(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestCommentListProjectAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        make_comment(self.doc, self.project.admin)\n        self.url = reverse(viewname=\"comment_list\", args=[self.project.item.id])\n\n    def test_allows_project_member_to_list_comments(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_denies_non_project_member_to_list_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        ids = [item.id for item in self.doc.comments.all()]\n        if user:\n            self.client.force_login(user)\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n\n    def test_allows_project_member_to_delete_comments(self):\n        # Todo: Disallow non admin to delete comments.\n        for member in self.project.members:\n            self.assert_bulk_delete(member, status.HTTP_204_NO_CONTENT)\n            response = self.client.get(self.url)\n            self.assertEqual(response.data[\"count\"], 0)\n\n    def test_denies_non_project_member_to_delete_comments(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_comments(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestCommentDetailAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        comment = make_comment(doc, self.project.admin)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"comment_detail\", args=[self.project.item.id, comment.id])\n\n    def test_allows_comment_owner_to_get_comment(self):\n        # Todo: Allows project member to get comment.\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_comment_owner_to_get_comment(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_get_comment(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_comment(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_comment_owner_to_update_comment(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_comment_owner_to_update_comment(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_comment(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_update_comment(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_comment_owner_to_delete_comment(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_comment_owner_to_delete_comment(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_comment(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_comment(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Test suites for comment-related APIs, validating access control and functionality for project members while denying access to non-members and unauthenticated users for listing, creating, retrieving, updating, and deleting comments.",
                                    "code_element_summaries": [
                                        "Class `TestCommentListDocAPI`: A test suite for validating access control and functionality of comment listing and creation for project members, ensuring appropriate responses for non-members and unauthenticated users.",
                                        "Function `setUpTestData`: A class method that prepares test data for a project by creating users, documents, comments, and setting up a URL for accessing the comment list.",
                                        "Function `test_allows_project_member_to_list_comments`: A test that verifies each member of a project can successfully retrieve a list of comments, expecting a 200 OK status and a count of 1 comment.",
                                        "Function `test_denies_non_project_member_to_list_comments`: A test case that verifies a non-project member receives a 403 Forbidden status when attempting to list comments.",
                                        "Function `test_denies_unauthenticated_user_to_list_comments`: A test that verifies an unauthenticated user receives a 403 Forbidden status when attempting to list comments.",
                                        "Function `test_allows_project_member_to_create_comment`: A test that verifies each member of the project is permitted to create a comment, expecting a successful creation response.",
                                        "Function test_denies_non_project_member_to_create_comment: A test that verifies non-project members receive a 403 Forbidden status when attempting to create a comment.",
                                        "Function `test_denies_unauthenticated_user_to_create_comment`: A test that verifies an unauthenticated user receives a 403 Forbidden status when attempting to create a comment.",
                                        "Class `TestCommentListProjectAPI`: A test suite for verifying that project members can list and delete comments, while non-members and unauthenticated users are denied access.",
                                        "Function `setUp`: Initializes a test environment by preparing a project, creating a non-member user, generating a document associated with the project, adding a comment, and setting the URL for the comment list view.",
                                        "Function `test_allows_project_member_to_list_comments`: A test that verifies each member of a project can successfully fetch and list comments, expecting a 200 OK status and a count of 1 comment.",
                                        "Function `test_denies_non_project_member_to_list_comments`: A test case that verifies non-project members receive a forbidden status when attempting to list comments.",
                                        "Function `test_denies_unauthenticated_user_to_list_comments`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to list comments.",
                                        "Function `assert_bulk_delete`: A test utility that verifies the HTTP response status when attempting to bulk delete comments, optionally logging in a user before the deletion request.",
                                        "Function `test_allows_project_member_to_delete_comments`: A test that verifies project members can delete comments, ensuring that the comment count is zero after deletion.",
                                        "Function `test_denies_non_project_member_to_delete_comments`: A test case that asserts a non-project member receives a forbidden status when attempting to delete comments.",
                                        "Function `test_denies_unauthenticated_user_to_delete_comments`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to delete comments.",
                                        "Class TestCommentDetailAPI: A test suite for verifying the permissions and functionalities related to comment retrieval, updating, and deletion in a project, ensuring that only authorized users can perform these actions.",
                                        "Function `setUp`: A setup method that initializes a project, a non-member user, a document, a comment, and prepares data and a URL for testing comment details.",
                                        "Function `test_allows_comment_owner_to_get_comment`: A test case that verifies a project member's ability to successfully fetch a comment with a 200 OK status.",
                                        "Function `test_denies_non_comment_owner_to_get_comment`: A test that verifies non-comment owners receive a 403 Forbidden status when attempting to access a comment.",
                                        "Function `test_denies_non_project_member_to_get_comment`: A test case that verifies non-project members receive a 403 Forbidden status when attempting to fetch comments.",
                                        "Function `test_denies_unauthenticated_user_to_get_comment`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to fetch a comment.",
                                        "Function `test_allows_comment_owner_to_update_comment`: A test case that verifies if the owner of a comment can successfully update their comment, expecting a 200 OK status and matching text in the response.",
                                        "Function `test_denies_non_comment_owner_to_update_comment`: A test that verifies non-owners of a comment receive a forbidden status when attempting to update it.",
                                        "Function `test_denies_non_project_member_to_update_comment`: A test case that asserts a non-project member receives a 403 Forbidden status when attempting to update a comment.",
                                        "Function `test_denies_unauthenticated_user_to_update_comment`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to update a comment.",
                                        "Function `test_allows_comment_owner_to_delete_comment`: A test that verifies if the owner of a comment can successfully delete their comment, expecting a 204 No Content status.",
                                        "Function `test_denies_non_comment_owner_to_delete_comment`: A test case that asserts non-comment owners receive a forbidden status when attempting to delete a comment.",
                                        "Function `test_denies_non_project_member_to_delete_comment`: A test that verifies a non-project member receives a 403 Forbidden status when attempting to delete a comment.",
                                        "Function test_denies_unauthenticated_user_to_delete_comment: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to delete a comment."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_example.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_example.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExampleListAPI`\nCode:\nclass TestExampleListAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n\n    def test_allows_project_member_to_list_examples(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertIn(\"results\", response.data)\n            for item in response.data[\"results\"]:\n                self.assertIn(\"text\", item)\n\n    def test_denies_non_project_member_to_list_examples(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_examples(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_create_example(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_admin_to_create_example(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_example(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_example_is_not_approved_if_another_user_approve_it(self):\n        make_example_state(self.example, self.project.admin)\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertFalse(response.data[\"results\"][0][\"is_confirmed\"])",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])",
                                        "Function `test_allows_project_member_to_list_examples`\nCode:\n    def test_allows_project_member_to_list_examples(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertIn(\"results\", response.data)\n            for item in response.data[\"results\"]:\n                self.assertIn(\"text\", item)",
                                        "Function `test_denies_non_project_member_to_list_examples`\nCode:\n    def test_denies_non_project_member_to_list_examples(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_list_examples`\nCode:\n    def test_denies_unauthenticated_user_to_list_examples(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_create_example`\nCode:\n    def test_allows_project_admin_to_create_example(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])",
                                        "Function `test_denies_non_admin_to_create_example`\nCode:\n    def test_denies_non_admin_to_create_example(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_create_example`\nCode:\n    def test_denies_unauthenticated_user_to_create_example(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_example_is_not_approved_if_another_user_approve_it`\nCode:\n    def test_example_is_not_approved_if_another_user_approve_it(self):\n        make_example_state(self.example, self.project.admin)\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertFalse(response.data[\"results\"][0][\"is_confirmed\"])",
                                        "Class `TestExampleListCollaborative`\nCode:\nclass TestExampleListCollaborative(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n\n    def test_example_is_approved_if_someone_approve_it(self):\n        admin = self.project.admin\n        approver = self.project.approver\n\n        make_example_state(self.example, admin)\n        response = self.assert_fetch(admin, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])\n        response = self.assert_fetch(approver, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])",
                                        "Function `test_example_is_approved_if_someone_approve_it`\nCode:\n    def test_example_is_approved_if_someone_approve_it(self):\n        admin = self.project.admin\n        approver = self.project.approver\n\n        make_example_state(self.example, admin)\n        response = self.assert_fetch(admin, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])\n        response = self.assert_fetch(approver, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])",
                                        "Class `TestExampleListFilter`\nCode:\nclass TestExampleListFilter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        example1 = make_doc(self.project.item)\n        example2 = make_doc(self.project.item)\n        example3 = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, example1, member)\n            make_assignment(self.project.item, example2, member)\n            make_assignment(self.project.item, example3, member)\n        make_example_state(example1, self.project.admin)\n\n    def reverse(self, query_kwargs=None):\n        base_url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n        self.url = \"{}?{}\".format(base_url, urlencode(query_kwargs))\n\n    def assert_filter(self, data, user, expected):\n        self.reverse(query_kwargs=data)\n        response = self.assert_fetch(user, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], expected)\n\n    def test_returns_only_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=1)\n\n    def test_returns_only_non_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"False\"}, user=user, expected=2)\n\n    def test_returns_all_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"\"}, user=user, expected=3)\n\n    def test_does_not_return_approved_example_to_another_user(self):\n        user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=0)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        example1 = make_doc(self.project.item)\n        example2 = make_doc(self.project.item)\n        example3 = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, example1, member)\n            make_assignment(self.project.item, example2, member)\n            make_assignment(self.project.item, example3, member)\n        make_example_state(example1, self.project.admin)",
                                        "Function `reverse`\nCode:\n    def reverse(self, query_kwargs=None):\n        base_url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n        self.url = \"{}?{}\".format(base_url, urlencode(query_kwargs))",
                                        "Function `assert_filter`\nCode:\n    def assert_filter(self, data, user, expected):\n        self.reverse(query_kwargs=data)\n        response = self.assert_fetch(user, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], expected)",
                                        "Function `test_returns_only_approved_examples`\nCode:\n    def test_returns_only_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=1)",
                                        "Function `test_returns_only_non_approved_examples`\nCode:\n    def test_returns_only_non_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"False\"}, user=user, expected=2)",
                                        "Function `test_returns_all_examples`\nCode:\n    def test_returns_all_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"\"}, user=user, expected=3)",
                                        "Function `test_does_not_return_approved_example_to_another_user`\nCode:\n    def test_does_not_return_approved_example_to_another_user(self):\n        user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=0)",
                                        "Class `TestExampleDetail`\nCode:\nclass TestExampleDetail(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_detail\", args=[self.project.item.id, example.id])\n\n    def test_allows_project_member_to_get_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertIn(\"text\", response.data)\n\n    def test_denies_non_project_member_to_get_example(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_example(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_update_example(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_admin_to_update_example(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_example(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_delete_example(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_admin_to_delete_example(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_example(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_detail\", args=[self.project.item.id, example.id])",
                                        "Function `test_allows_project_member_to_get_example`\nCode:\n    def test_allows_project_member_to_get_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertIn(\"text\", response.data)",
                                        "Function `test_denies_non_project_member_to_get_example`\nCode:\n    def test_denies_non_project_member_to_get_example(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_get_example`\nCode:\n    def test_denies_unauthenticated_user_to_get_example(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_update_example`\nCode:\n    def test_allows_project_admin_to_update_example(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])",
                                        "Function `test_denies_non_admin_to_update_example`\nCode:\n    def test_denies_non_admin_to_update_example(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_update_example`\nCode:\n    def test_denies_non_project_member_to_update_example(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_delete_example`\nCode:\n    def test_allows_project_admin_to_delete_example(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_non_admin_to_delete_example`\nCode:\n    def test_denies_non_admin_to_delete_example(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_delete_example`\nCode:\n    def test_denies_non_project_member_to_delete_example(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from django.utils.http import urlencode\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import make_assignment, make_doc, make_example_state\nfrom api.tests.utils import CRUDMixin\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestExampleListAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n\n    def test_allows_project_member_to_list_examples(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertIn(\"results\", response.data)\n            for item in response.data[\"results\"]:\n                self.assertIn(\"text\", item)\n\n    def test_denies_non_project_member_to_list_examples(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_list_examples(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_create_example(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_admin_to_create_example(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_example(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_example_is_not_approved_if_another_user_approve_it(self):\n        make_example_state(self.example, self.project.admin)\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertFalse(response.data[\"results\"][0][\"is_confirmed\"])\n\n\nclass TestExampleListCollaborative(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, self.example, member)\n        self.url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n\n    def test_example_is_approved_if_someone_approve_it(self):\n        admin = self.project.admin\n        approver = self.project.approver\n\n        make_example_state(self.example, admin)\n        response = self.assert_fetch(admin, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])\n        response = self.assert_fetch(approver, status.HTTP_200_OK)\n        self.assertTrue(response.data[\"results\"][0][\"is_confirmed\"])\n\n\nclass TestExampleListFilter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        example1 = make_doc(self.project.item)\n        example2 = make_doc(self.project.item)\n        example3 = make_doc(self.project.item)\n        for member in self.project.members:\n            make_assignment(self.project.item, example1, member)\n            make_assignment(self.project.item, example2, member)\n            make_assignment(self.project.item, example3, member)\n        make_example_state(example1, self.project.admin)\n\n    def reverse(self, query_kwargs=None):\n        base_url = reverse(viewname=\"example_list\", args=[self.project.item.id])\n        self.url = \"{}?{}\".format(base_url, urlencode(query_kwargs))\n\n    def assert_filter(self, data, user, expected):\n        self.reverse(query_kwargs=data)\n        response = self.assert_fetch(user, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], expected)\n\n    def test_returns_only_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=1)\n\n    def test_returns_only_non_approved_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"False\"}, user=user, expected=2)\n\n    def test_returns_all_examples(self):\n        user = self.project.admin\n        self.assert_filter(data={\"confirmed\": \"\"}, user=user, expected=3)\n\n    def test_does_not_return_approved_example_to_another_user(self):\n        user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, user=user, expected=0)\n\n\nclass TestExampleDetail(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.non_member = make_user()\n        example = make_doc(self.project.item)\n        self.data = {\"text\": \"example\"}\n        self.url = reverse(viewname=\"example_detail\", args=[self.project.item.id, example.id])\n\n    def test_allows_project_member_to_get_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertIn(\"text\", response.data)\n\n    def test_denies_non_project_member_to_get_example(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_example(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_update_example(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_non_admin_to_update_example(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_example(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_delete_example(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_admin_to_delete_example(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_example(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Class `TestExampleListAPI`: A comprehensive test suite that evaluates access permissions and CRUD operations for the Example List API, ensuring appropriate behavior for project members, non-members, unauthenticated users, and project admins in various scenarios, including listing, creating, approving, and filtering examples.",
                                    "code_element_summaries": [
                                        "Class `TestExampleListAPI`: A test suite for the Example List API that verifies access permissions for project members, non-members, and unauthenticated users, as well as the ability of project admins to create examples and the approval state of examples by different users.",
                                        "Function `setUp`: Prepares a test environment by initializing a project for document classification, creating a user and a document, assigning the document to project members, and setting up necessary data and URL for testing.",
                                        "Function `test_allows_project_member_to_list_examples`: A test that verifies project members can successfully list examples, ensuring the response includes a count of 1 and that each result contains a \"text\" field.",
                                        "Function `test_denies_non_project_member_to_list_examples`: A test case that verifies non-project members receive a forbidden status when attempting to list examples.",
                                        "Function `test_denies_unauthenticated_user_to_list_examples`: A test case that asserts an unauthenticated user receives a 403 Forbidden status when attempting to list examples.",
                                        "Function `test_allows_project_admin_to_create_example`: A test function that verifies a project admin can successfully create an example and checks if the response text matches the expected data.",
                                        "Function `test_denies_non_admin_to_create_example`: A test that verifies non-admin staff members are forbidden from creating an example, expecting a 403 Forbidden status.",
                                        "Function `test_denies_unauthenticated_user_to_create_example`: A test case that checks if an unauthenticated user receives a 403 Forbidden status when attempting to create an example.",
                                        "Function `test_example_is_not_approved_if_another_user_approve_it`: A test that verifies an example remains unapproved when another user attempts to approve it.",
                                        "Class TestExampleListCollaborative: A test case that verifies the approval status of examples in a collaborative annotation project, ensuring that if one member approves an example, it reflects as approved for all members.",
                                        "Function `setUp`: Initializes a test environment by preparing a document classification project, creating a document example, assigning it to project members, and setting the URL for the example list view.",
                                        "Function `test_example_is_approved_if_someone_approve_it`: A test case that verifies an example's approval status is correctly updated when an admin and an approver confirm it.",
                                        "Class `TestExampleListFilter`: A test case that verifies the functionality of filtering document examples based on their approval status for different users.",
                                        "Function `setUp`: Prepares a project for document classification by creating example documents and assigning them to project members, along with setting the state for one example.",
                                        "Function `reverse`: Constructs a URL for the `example_list` view by appending query parameters from `query_kwargs` to the base URL derived from the project's item ID.",
                                        "Function `assert_filter`: Validates that a filtered response for a given user matches the expected count after reversing query parameters.",
                                        "Function `test_returns_only_approved_examples`: A test case that verifies the filtering of examples to ensure only approved ones are returned for a given user.",
                                        "Function `test_returns_only_non_approved_examples`: A test function that verifies the filter returns only non-approved examples for a given user, expecting two results.",
                                        "Function `test_returns_all_examples`: A test function that verifies the filtering of confirmed examples for a project admin, expecting a total of 3 results.",
                                        "Function `test_does_not_return_approved_example_to_another_user`: A test case that verifies an approver user does not receive any approved examples when filtered.",
                                        "Class `TestExampleDetail`: A test suite for verifying access control and CRUD operations for example details in a document classification project, ensuring that permissions are enforced for project members, admins, and non-members.",
                                        "Function `setUp`: Prepares a test environment by initializing a project for document classification, creating a non-member user, generating an example document, and setting up data and URL for accessing the example's details.",
                                        "Function `test_allows_project_member_to_get_example`: A test case that verifies all members of a project can successfully fetch an example with a 200 OK status and confirms the presence of \"text\" in the response data.",
                                        "Function `test_denies_non_project_member_to_get_example`: A test case that verifies a non-project member receives a 403 Forbidden status when attempting to access a specific resource.",
                                        "Function `test_denies_unauthenticated_user_to_get_example`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to access a specific resource.",
                                        "Function `test_allows_project_admin_to_update_example`: A test case that verifies if a project admin can successfully update an example and checks that the returned text matches the expected data.",
                                        "Function `test_denies_non_admin_to_update_example`: A test that verifies non-admin staff members are forbidden from updating project details, returning a 403 Forbidden status.",
                                        "Function `test_denies_non_project_member_to_update_example`: A test case that verifies non-project members receive a 403 Forbidden status when attempting to update an example.",
                                        "Function `test_allows_project_admin_to_delete_example`: Tests that a project admin can successfully delete an example, expecting a 204 No Content status response.",
                                        "Function `test_denies_non_admin_to_delete_example`: A test case that verifies non-admin staff members are denied permission to delete an example, expecting a 403 Forbidden status.",
                                        "Function `test_denies_non_project_member_to_delete_example`: A test case that verifies a non-project member receives a 403 Forbidden status when attempting to delete an example."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_example_state.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_example_state.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExampleStateList`\nCode:\nclass TestExampleStateList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project()\n        cls.example = make_doc(cls.project.item)\n        for member in cls.project.members:\n            make_example_state(cls.example, member)\n        cls.url = reverse(viewname=\"example_state_list\", args=[cls.project.item.id, cls.example.id])\n\n    def test_returns_example_state_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_does_not_return_example_state_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_example_state_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project()\n        cls.example = make_doc(cls.project.item)\n        for member in cls.project.members:\n            make_example_state(cls.example, member)\n        cls.url = reverse(viewname=\"example_state_list\", args=[cls.project.item.id, cls.example.id])",
                                        "Function `test_returns_example_state_to_project_member`\nCode:\n    def test_returns_example_state_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)",
                                        "Function `test_does_not_return_example_state_to_non_project_member`\nCode:\n    def test_does_not_return_example_state_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_does_not_return_example_state_to_unauthenticated_user`\nCode:\n    def test_does_not_return_example_state_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestExampleStateConfirm`\nCode:\nclass TestExampleStateConfirm(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])\n\n    def test_allows_member_to_confirm_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n            self.assert_create(member, status.HTTP_201_CREATED)  # confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assert_create(member, status.HTTP_201_CREATED)  # toggle confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])",
                                        "Function `test_allows_member_to_confirm_example`\nCode:\n    def test_allows_member_to_confirm_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n            self.assert_create(member, status.HTTP_201_CREATED)  # confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assert_create(member, status.HTTP_201_CREATED)  # toggle confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)",
                                        "Class `TestExampleStateConfirmCollaborative`\nCode:\nclass TestExampleStateConfirmCollaborative(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])\n\n    def test_initial_state(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n\n    def test_can_approve_state(self):\n        admin = self.project.admin\n        self.assert_create(admin, status.HTTP_201_CREATED)\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])",
                                        "Function `test_initial_state`\nCode:\n    def test_initial_state(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)",
                                        "Function `test_can_approve_state`\nCode:\n    def test_can_approve_state(self):\n        admin = self.project.admin\n        self.assert_create(admin, status.HTTP_201_CREATED)\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import make_doc, make_example_state\nfrom api.tests.utils import CRUDMixin\nfrom projects.tests.utils import prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestExampleStateList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project()\n        cls.example = make_doc(cls.project.item)\n        for member in cls.project.members:\n            make_example_state(cls.example, member)\n        cls.url = reverse(viewname=\"example_state_list\", args=[cls.project.item.id, cls.example.id])\n\n    def test_returns_example_state_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n\n    def test_does_not_return_example_state_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_example_state_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestExampleStateConfirm(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])\n\n    def test_allows_member_to_confirm_example(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n            self.assert_create(member, status.HTTP_201_CREATED)  # confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assert_create(member, status.HTTP_201_CREATED)  # toggle confirm\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n\n\nclass TestExampleStateConfirmCollaborative(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(collaborative_annotation=True)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"example_state_list\", args=[self.project.item.id, self.example.id])\n\n    def test_initial_state(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 0)\n\n    def test_can_approve_state(self):\n        admin = self.project.admin\n        self.assert_create(admin, status.HTTP_201_CREATED)\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"count\"], 1)\n",
                                    "summary": "Class TestExampleStateList: A test suite that verifies access to example state data for project members and ensures appropriate forbidden responses for non-members and unauthenticated users, along with functionality for confirming and toggling example states.",
                                    "code_element_summaries": [
                                        "Class TestExampleStateList: A test suite for verifying access to example state data, ensuring that project members can retrieve data while non-members and unauthenticated users receive appropriate forbidden responses.",
                                        "Function `setUpTestData`: A class method that prepares test data by creating a user, a project, a document, example states for project members, and a URL for accessing the example state list.",
                                        "Function `test_returns_example_state_to_project_member`: A test that verifies each project member receives a successful response with a data count of one when fetching example state.",
                                        "Function `test_does_not_return_example_state_to_non_project_member`: A test case that verifies a non-project member receives a forbidden status when attempting to fetch the example state.",
                                        "Function `test_does_not_return_example_state_to_unauthenticated_user`: A test that verifies an unauthenticated user receives a forbidden status when attempting to fetch an example state.",
                                        "Class TestExampleStateConfirm: A test case that verifies the functionality for project members to confirm and toggle the confirmation status of examples, ensuring correct response counts.",
                                        "Function `setUp`: Initializes the testing environment by preparing a project, creating an example document, and generating a URL for accessing the example state list.",
                                        "Function `test_allows_member_to_confirm_example`: A test case that verifies a project member can confirm and toggle their confirmation status, ensuring the count of confirmations updates accordingly.",
                                        "Class `TestExampleStateConfirmCollaborative`: A test case for verifying the initial state and approval functionality of collaborative annotations in a project.",
                                        "Function `setUp`: Prepares a project with collaborative annotation enabled and sets up the URL for accessing the example state list based on the project's item and example document.",
                                        "Function `test_initial_state`: A test function that verifies all members of a project have an initial count of zero by asserting the HTTP response status and data count.",
                                        "Function `test_can_approve_state`: A test that verifies an admin can create a resource and that all project members can fetch the resource, confirming the expected count of resources returned."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_filters.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_filters.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestFilterMixin`\nCode:\nclass TestFilterMixin(TestCase):\n    def prepare(self, project):\n        self.example = make_doc(project.item)\n        self.request = MagicMock()\n        self.queryset = Example.objects.all()\n        make_example_state(self.example, project.admin)\n        self.request.user = project.admin\n\n    def assert_filter(self, data, expected):\n        f = ExampleFilter(data=data, queryset=self.queryset, request=self.request)\n        self.assertEqual(f.qs.count(), expected)",
                                        "Function `prepare`\nCode:\n    def prepare(self, project):\n        self.example = make_doc(project.item)\n        self.request = MagicMock()\n        self.queryset = Example.objects.all()\n        make_example_state(self.example, project.admin)\n        self.request.user = project.admin",
                                        "Function `assert_filter`\nCode:\n    def assert_filter(self, data, expected):\n        f = ExampleFilter(data=data, queryset=self.queryset, request=self.request)\n        self.assertEqual(f.qs.count(), expected)",
                                        "Class `TestExampleFilter`\nCode:\nclass TestExampleFilter(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\")\n        self.prepare(project=self.project)\n\n    def test_returns_example_if_confirmed_is_true(self):\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)\n\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)\n\n    def test_returns_example_if_confirmed_is_empty(self):\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)\n\n    def test_does_not_return_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=0)\n\n    def test_returns_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=1)\n\n    def test_returns_example_if_user_is_different_and_confirmed_is_empty(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\")\n        self.prepare(project=self.project)",
                                        "Function `test_returns_example_if_confirmed_is_true`\nCode:\n    def test_returns_example_if_confirmed_is_true(self):\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)",
                                        "Function `test_does_not_return_example_if_confirmed_is_false`\nCode:\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)",
                                        "Function `test_returns_example_if_confirmed_is_empty`\nCode:\n    def test_returns_example_if_confirmed_is_empty(self):\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)",
                                        "Function `test_does_not_return_example_if_user_is_different`\nCode:\n    def test_does_not_return_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=0)",
                                        "Function `test_returns_example_if_user_is_different`\nCode:\n    def test_returns_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=1)",
                                        "Function `test_returns_example_if_user_is_different_and_confirmed_is_empty`\nCode:\n    def test_returns_example_if_user_is_different_and_confirmed_is_empty(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)",
                                        "Class `TestLabelFilter`\nCode:\nclass TestLabelFilter(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.prepare(project=self.project)\n        self.label_type = mommy.make(\"CategoryType\", project=self.project.item, text=\"positive\")\n        mommy.make(\"Category\", example=self.example, label=self.label_type)\n\n    def test_returns_example_with_positive_label(self):\n        self.assert_filter(data={\"label\": self.label_type.text}, expected=1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.prepare(project=self.project)\n        self.label_type = mommy.make(\"CategoryType\", project=self.project.item, text=\"positive\")\n        mommy.make(\"Category\", example=self.example, label=self.label_type)",
                                        "Function `test_returns_example_with_positive_label`\nCode:\n    def test_returns_example_with_positive_label(self):\n        self.assert_filter(data={\"label\": self.label_type.text}, expected=1)",
                                        "Class `TestExampleFilterOnCollaborative`\nCode:\nclass TestExampleFilterOnCollaborative(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\", collaborative_annotation=True)\n        self.prepare(project=self.project)\n\n    def test_returns_example_if_confirmed_is_true(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)\n\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)\n\n    def test_returns_example_if_confirmed_is_empty(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"\"}, expected=1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\", collaborative_annotation=True)\n        self.prepare(project=self.project)",
                                        "Function `test_returns_example_if_confirmed_is_true`\nCode:\n    def test_returns_example_if_confirmed_is_true(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)",
                                        "Function `test_does_not_return_example_if_confirmed_is_false`\nCode:\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)",
                                        "Function `test_returns_example_if_confirmed_is_empty`\nCode:\n    def test_returns_example_if_confirmed_is_empty(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"\"}, expected=1)"
                                    ],
                                    "code": "from unittest.mock import MagicMock\n\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom .utils import make_doc, make_example_state\nfrom examples.filters import ExampleFilter\nfrom examples.models import Example\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestFilterMixin(TestCase):\n    def prepare(self, project):\n        self.example = make_doc(project.item)\n        self.request = MagicMock()\n        self.queryset = Example.objects.all()\n        make_example_state(self.example, project.admin)\n        self.request.user = project.admin\n\n    def assert_filter(self, data, expected):\n        f = ExampleFilter(data=data, queryset=self.queryset, request=self.request)\n        self.assertEqual(f.qs.count(), expected)\n\n\nclass TestExampleFilter(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\")\n        self.prepare(project=self.project)\n\n    def test_returns_example_if_confirmed_is_true(self):\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)\n\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)\n\n    def test_returns_example_if_confirmed_is_empty(self):\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)\n\n    def test_does_not_return_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"True\"}, expected=0)\n\n    def test_returns_example_if_user_is_different(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"False\"}, expected=1)\n\n    def test_returns_example_if_user_is_different_and_confirmed_is_empty(self):\n        self.request.user = self.project.approver\n        self.assert_filter(data={\"confirmed\": \"\"}, expected=1)\n\n\nclass TestLabelFilter(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        self.prepare(project=self.project)\n        self.label_type = mommy.make(\"CategoryType\", project=self.project.item, text=\"positive\")\n        mommy.make(\"Category\", example=self.example, label=self.label_type)\n\n    def test_returns_example_with_positive_label(self):\n        self.assert_filter(data={\"label\": self.label_type.text}, expected=1)\n\n\nclass TestExampleFilterOnCollaborative(TestFilterMixin):\n    def setUp(self):\n        self.project = prepare_project(task=\"DocumentClassification\", collaborative_annotation=True)\n        self.prepare(project=self.project)\n\n    def test_returns_example_if_confirmed_is_true(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"True\"}, expected=1)\n\n    def test_does_not_return_example_if_confirmed_is_false(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"False\"}, expected=0)\n\n    def test_returns_example_if_confirmed_is_empty(self):\n        for member in self.project.members:\n            self.request.user = member\n            self.assert_filter(data={\"confirmed\": \"\"}, expected=1)\n",
                                    "summary": "Class TestFilterMixin: A mixin that sets up a mock request and queryset for filtering examples in a document classification project, along with methods to assert the correctness of filter results; includes test cases for various filtering scenarios based on confirmation status and user permissions.",
                                    "code_element_summaries": [
                                        "Class TestFilterMixin: A test case mixin that prepares a mock request and queryset for filtering examples, providing an assertion method to verify the filter results against expected counts.",
                                        "Function `prepare`: Initializes an example document and sets up a mock request and queryset for a given project, while configuring the example's state for the project's admin user.",
                                        "Function `assert_filter`: A method that verifies the count of filtered results from a queryset against an expected value using an instance of ExampleFilter.",
                                        "Class TestExampleFilter: A test suite that verifies the behavior of filtering examples based on the confirmation status and user permissions in a Document Classification project.",
                                        "Function `setUp`: A method that initializes a project for document classification and prepares it for testing.",
                                        "Function `test_returns_example_if_confirmed_is_true`: A test function that verifies the filter returns an expected result when the confirmed status is set to true.",
                                        "Function `test_does_not_return_example_if_confirmed_is_false`: A test case that verifies no examples are returned when the confirmed status is set to false.",
                                        "Function `test_returns_example_if_confirmed_is_empty`: A test case that verifies the filter behavior when the \"confirmed\" field is empty, expecting one result.",
                                        "Function `test_does_not_return_example_if_user_is_different`: A test case that verifies no examples are returned when the requesting user is different from the project's approver while filtering confirmed entries.",
                                        "Function `test_returns_example_if_user_is_different`: A test case that verifies the filter behavior when the request user is set to the project's approver, expecting one confirmed false result.",
                                        "Function `test_returns_example_if_user_is_different_and_confirmed_is_empty`: A test case that verifies the filter behavior when the user is different and the confirmed parameter is empty, expecting one result.",
                                        "Class TestLabelFilter: A test case that verifies the filtering functionality for examples with a specific positive label in a document classification project.",
                                        "Function `setUp`: A setup method that prepares a document classification project and creates a positive label type and associated category for testing purposes.",
                                        "Function `test_returns_example_with_positive_label`: A test case that verifies the filter functionality by asserting that the count of items with a specific positive label matches the expected value.",
                                        "Class `TestExampleFilterOnCollaborative`: A test case that verifies the filtering of examples based on the confirmation status for members of a collaborative annotation project.",
                                        "Function `setUp`: Initializes a project for document classification with collaborative annotation and prepares it for testing.",
                                        "Function `test_returns_example_if_confirmed_is_true`: A test case that verifies the filter functionality by asserting that when the confirmed parameter is set to true, the expected number of results is returned for each project member.",
                                        "Function `test_does_not_return_example_if_confirmed_is_false`: A test case that verifies no examples are returned when the confirmed status is set to false for project members.",
                                        "Function `test_returns_example_if_confirmed_is_empty`: A test case that verifies the filter behavior when the 'confirmed' parameter is an empty string for each member of the project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_models.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_models.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestExampleState`\nCode:\nclass TestExampleState(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.other = mommy.make(\"Example\", project=self.project.item)\n        self.examples = self.project.item.examples.all()\n\n    def test_initial_done(self):\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 0)\n\n    def test_done_confirmed_by_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)\n\n    def test_done_confirmed_by_multiple_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)\n\n    def test_done_confirmed_by_different_example(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.other, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples, self.project.admin)\n        self.assertEqual(done, 1)\n\n    def test_initial_user(self):\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})\n\n    def test_user_count_after_confirmation(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})\n\n    def test_user_count_after_multiple_user_confirmation(self):\n        user1 = self.project.admin\n        user2 = self.project.approver\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user1)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user2)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        expected_progress[1][\"done\"] = 1\n        self.assertEqual(progress[\"total\"], 2)\n        self.assertCountEqual(progress[\"progress\"], expected_progress)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.other = mommy.make(\"Example\", project=self.project.item)\n        self.examples = self.project.item.examples.all()",
                                        "Function `test_initial_done`\nCode:\n    def test_initial_done(self):\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 0)",
                                        "Function `test_done_confirmed_by_user`\nCode:\n    def test_done_confirmed_by_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)",
                                        "Function `test_done_confirmed_by_multiple_user`\nCode:\n    def test_done_confirmed_by_multiple_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)",
                                        "Function `test_done_confirmed_by_different_example`\nCode:\n    def test_done_confirmed_by_different_example(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.other, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples, self.project.admin)\n        self.assertEqual(done, 1)",
                                        "Function `test_initial_user`\nCode:\n    def test_initial_user(self):\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})",
                                        "Function `test_user_count_after_confirmation`\nCode:\n    def test_user_count_after_confirmation(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})",
                                        "Function `test_user_count_after_multiple_user_confirmation`\nCode:\n    def test_user_count_after_multiple_user_confirmation(self):\n        user1 = self.project.admin\n        user2 = self.project.approver\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user1)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user2)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        expected_progress[1][\"done\"] = 1\n        self.assertEqual(progress[\"total\"], 2)\n        self.assertCountEqual(progress[\"progress\"], expected_progress)",
                                        "Class `TestExample`\nCode:\nclass TestExample(TestCase):\n    def test_text_project_returns_text_as_data_property(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(example.text, example.data)\n\n    def test_image_project_returns_filename_as_data_property(self):\n        project = prepare_project(ProjectType.IMAGE_CLASSIFICATION)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(str(example.filename), example.data)",
                                        "Function `test_text_project_returns_text_as_data_property`\nCode:\n    def test_text_project_returns_text_as_data_property(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(example.text, example.data)",
                                        "Function `test_image_project_returns_filename_as_data_property`\nCode:\n    def test_image_project_returns_filename_as_data_property(self):\n        project = prepare_project(ProjectType.IMAGE_CLASSIFICATION)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(str(example.filename), example.data)"
                                    ],
                                    "code": "from django.test import TestCase\nfrom model_mommy import mommy\n\nfrom examples.models import ExampleState\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestExampleState(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.other = mommy.make(\"Example\", project=self.project.item)\n        self.examples = self.project.item.examples.all()\n\n    def test_initial_done(self):\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 0)\n\n    def test_done_confirmed_by_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)\n\n    def test_done_confirmed_by_multiple_user(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples)\n        self.assertEqual(done, 1)\n\n    def test_done_confirmed_by_different_example(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        mommy.make(\"ExampleState\", example=self.other, confirmed_by=self.project.approver)\n        done = ExampleState.objects.count_done(self.examples, self.project.admin)\n        self.assertEqual(done, 1)\n\n    def test_initial_user(self):\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})\n\n    def test_user_count_after_confirmation(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(progress, {\"total\": 2, \"progress\": expected_progress})\n\n    def test_user_count_after_multiple_user_confirmation(self):\n        user1 = self.project.admin\n        user2 = self.project.approver\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user1)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=user2)\n        progress = ExampleState.objects.measure_member_progress(self.examples, self.project.members)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        expected_progress[1][\"done\"] = 1\n        self.assertEqual(progress[\"total\"], 2)\n        self.assertCountEqual(progress[\"progress\"], expected_progress)\n\n\nclass TestExample(TestCase):\n    def test_text_project_returns_text_as_data_property(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(example.text, example.data)\n\n    def test_image_project_returns_filename_as_data_property(self):\n        project = prepare_project(ProjectType.IMAGE_CLASSIFICATION)\n        example = mommy.make(\"Example\", project=project.item)\n        self.assertEqual(str(example.filename), example.data)\n",
                                    "summary": "Class TestExampleState: A test suite that validates the functionality of counting and measuring progress in example states within a sequence labeling project, alongside the TestExample class which ensures correct assignment of the `data` property for examples in both sequence labeling and image classification projects.",
                                    "code_element_summaries": [
                                        "Class TestExampleState: A test case that verifies the functionality of counting and measuring the progress of example states within a sequence labeling project, ensuring proper handling of confirmations by users.",
                                        "Function `setUp`: A setup method that prepares a sequence labeling project and creates two example instances associated with it for testing purposes.",
                                        "Function `test_initial_done`: A test case that verifies the count of completed examples in the ExampleState model is initially zero.",
                                        "Function `test_done_confirmed_by_user`: A test case that verifies the counting of \"done\" states in the ExampleState model when an example is confirmed by a user.",
                                        "Function `test_done_confirmed_by_multiple_user`: A unit test that verifies the correct count of completed examples when multiple users confirm the same example state.",
                                        "Function `test_done_confirmed_by_different_example`: A unit test that verifies the count of completed `ExampleState` instances confirmed by different users in a project.",
                                        "Function `test_initial_user`: A test that verifies the initial progress of project members, ensuring it matches the expected format and values.",
                                        "Function `test_user_count_after_confirmation`: A unit test that verifies the user count and progress measurement after a confirmation event in the ExampleState model.",
                                        "Function `test_user_count_after_multiple_user_confirmation`: A test that verifies the user count and progress of confirmed examples after multiple users confirm their states in a project.",
                                        "Class `TestExample`: A test case that verifies the correct assignment of the `data` property for examples in sequence labeling and image classification projects.",
                                        "Function `test_text_project_returns_text_as_data_property`: A test function that verifies the text property of an example matches its data property within a sequence labeling project.",
                                        "Function `test_image_project_returns_filename_as_data_property`: A test that verifies the filename of an example in an image classification project matches its data property."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_usecase.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\test_usecase.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestBulkAssignment`\nCode:\nclass TestBulkAssignment(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.member_ids = list(Member.objects.values_list(\"id\", flat=True))\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_raise_error_if_weights_is_invalid(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [0] * len(self.member_ids)\n            )\n\n    def test_raise_error_if_passing_wrong_member_ids(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id,\n                StrategyName.weighted_sequential,\n                self.member_ids + [100],\n                [0] * len(self.member_ids),\n            )\n\n    def test_assign_examples(self):\n        bulk_assign(self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [100, 0, 0])\n        self.assertEqual(self.example.assignments.count(), 1)\n        self.assertEqual(self.example.assignments.first().assignee, self.project.admin)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.member_ids = list(Member.objects.values_list(\"id\", flat=True))\n        self.example = mommy.make(\"Example\", project=self.project.item)",
                                        "Function `test_raise_error_if_weights_is_invalid`\nCode:\n    def test_raise_error_if_weights_is_invalid(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [0] * len(self.member_ids)\n            )",
                                        "Function `test_raise_error_if_passing_wrong_member_ids`\nCode:\n    def test_raise_error_if_passing_wrong_member_ids(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id,\n                StrategyName.weighted_sequential,\n                self.member_ids + [100],\n                [0] * len(self.member_ids),\n            )",
                                        "Function `test_assign_examples`\nCode:\n    def test_assign_examples(self):\n        bulk_assign(self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [100, 0, 0])\n        self.assertEqual(self.example.assignments.count(), 1)\n        self.assertEqual(self.example.assignments.first().assignee, self.project.admin)"
                                    ],
                                    "code": "from django.test import TestCase\nfrom model_mommy import mommy\n\nfrom examples.assignment.usecase import StrategyName, bulk_assign\nfrom projects.models import Member, ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestBulkAssignment(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        self.member_ids = list(Member.objects.values_list(\"id\", flat=True))\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_raise_error_if_weights_is_invalid(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [0] * len(self.member_ids)\n            )\n\n    def test_raise_error_if_passing_wrong_member_ids(self):\n        with self.assertRaises(ValueError):\n            bulk_assign(\n                self.project.item.id,\n                StrategyName.weighted_sequential,\n                self.member_ids + [100],\n                [0] * len(self.member_ids),\n            )\n\n    def test_assign_examples(self):\n        bulk_assign(self.project.item.id, StrategyName.weighted_sequential, self.member_ids, [100, 0, 0])\n        self.assertEqual(self.example.assignments.count(), 1)\n        self.assertEqual(self.example.assignments.first().assignee, self.project.admin)\n",
                                    "summary": "Class `TestBulkAssignment`: A test case designed to validate the `bulk_assign` method's functionality, including error handling for invalid inputs and successful assignment of examples to members.",
                                    "code_element_summaries": [
                                        "Class `TestBulkAssignment`: A test case that verifies the functionality of the `bulk_assign` method, including error handling for invalid weights and member IDs, and confirms successful assignment of examples.",
                                        "Function `setUp`: Initializes a test environment by preparing a sequence labeling project, retrieving member IDs, and creating an example associated with the project.",
                                        "Function `test_raise_error_if_weights_is_invalid`: A unit test that verifies a ValueError is raised when invalid weights are provided to the `bulk_assign` function.",
                                        "Function `test_raise_error_if_passing_wrong_member_ids`: A test case that verifies a ValueError is raised when invalid member IDs are passed to the `bulk_assign` function.",
                                        "Function `test_assign_examples`: A test function that verifies the assignment of examples to members using a weighted sequential strategy, ensuring the correct count and assignee."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `make_comment`\nCode:\ndef make_comment(doc, user):\n    return mommy.make(\"Comment\", example=doc, user=user)",
                                        "Function `make_doc`\nCode:\ndef make_doc(project):\n    return mommy.make(\"Example\", text=\"example\", project=project)",
                                        "Function `make_image`\nCode:\ndef make_image(project, filepath):\n    return mommy.make(\"Example\", filename=filepath, project=project)",
                                        "Function `make_example_state`\nCode:\ndef make_example_state(example, user):\n    return mommy.make(\"ExampleState\", example=example, confirmed_by=user)",
                                        "Function `make_assignment`\nCode:\ndef make_assignment(project, example, user):\n    return mommy.make(\"Assignment\", project=project, example=example, assignee=user)"
                                    ],
                                    "code": "from model_mommy import mommy\n\n\ndef make_comment(doc, user):\n    return mommy.make(\"Comment\", example=doc, user=user)\n\n\ndef make_doc(project):\n    return mommy.make(\"Example\", text=\"example\", project=project)\n\n\ndef make_image(project, filepath):\n    return mommy.make(\"Example\", filename=filepath, project=project)\n\n\ndef make_example_state(example, user):\n    return mommy.make(\"ExampleState\", example=example, confirmed_by=user)\n\n\ndef make_assignment(project, example, user):\n    return mommy.make(\"Assignment\", project=project, example=example, assignee=user)\n",
                                    "summary": "Functions for creating various model instances, including Comment, Example, ExampleState, and Assignment, using the `mommy` library, each associated with specific documents, projects, or users.",
                                    "code_element_summaries": [
                                        "Function `make_comment`: Creates a new Comment instance associated with a given document and user using the `mommy` library.",
                                        "Function `make_doc`: Creates an instance of the \"Example\" model with specified text and associated project using the `mommy` library.",
                                        "Function `make_image`: A utility function that creates an instance of the \"Example\" model with a specified filename and associated project.",
                                        "Function `make_example_state`: Creates an instance of the `ExampleState` model, associating it with a given example and user who confirmed it.",
                                        "Function `make_assignment`: A utility function that creates and returns a new Assignment instance associated with a specified project, example, and user."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views.assignment import (\n    AssignmentDetail,\n    AssignmentList,\n    BulkAssignment,\n    ResetAssignment,\n)\nfrom .views.comment import CommentDetail, CommentList\nfrom .views.example import ExampleDetail, ExampleList\nfrom .views.example_state import ExampleStateList\n\nurlpatterns = [\n    path(route=\"assignments\", view=AssignmentList.as_view(), name=\"assignment_list\"),\n    path(route=\"assignments/<uuid:assignment_id>\", view=AssignmentDetail.as_view(), name=\"assignment_detail\"),\n    path(route=\"assignments/reset\", view=ResetAssignment.as_view(), name=\"assignment_reset\"),\n    path(route=\"assignments/bulk_assign\", view=BulkAssignment.as_view(), name=\"bulk_assignment\"),\n    path(route=\"examples\", view=ExampleList.as_view(), name=\"example_list\"),\n    path(route=\"examples/<int:example_id>\", view=ExampleDetail.as_view(), name=\"example_detail\"),\n    path(route=\"comments\", view=CommentList.as_view(), name=\"comment_list\"),\n    path(route=\"comments/<int:comment_id>\", view=CommentDetail.as_view(), name=\"comment_detail\"),\n    path(route=\"examples/<int:example_id>/states\", view=ExampleStateList.as_view(), name=\"example_state_list\"),\n]\n",
                            "summary": "URL patterns for an API that manage assignments, examples, comments, and their respective details using Django views.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Classes and functions for managing assignments and comments in a Django REST framework, providing authenticated users with capabilities to list, create, update, and delete assignments and comments, while also supporting filtering, searching, and specific permissions for project members and example instances.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "assignment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views\\assignment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `AssignmentList`\nCode:\nclass AssignmentList(generics.ListCreateAPIView):\n    serializer_class = AssignmentSerializer\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    filter_backends = (DjangoFilterBackend, filters.OrderingFilter)\n    ordering_fields = (\"created_at\", \"updated_at\")\n    model = Assignment\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        queryset = self.model.objects.filter(project=self.project, assignee=self.request.user)\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)",
                                        "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        queryset = self.model.objects.filter(project=self.project, assignee=self.request.user)\n        return queryset",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)",
                                        "Class `AssignmentDetail`\nCode:\nclass AssignmentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Assignment.objects.all()\n    serializer_class = AssignmentSerializer\n    lookup_url_kwarg = \"assignment_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]",
                                        "Class `ResetAssignment`\nCode:\nclass ResetAssignment(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def delete(self, *args, **kwargs):\n        Assignment.objects.filter(project=self.project).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                        "Function `delete`\nCode:\n    def delete(self, *args, **kwargs):\n        Assignment.objects.filter(project=self.project).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Class `BulkAssignment`\nCode:\nclass BulkAssignment(APIView):\n    serializer_class = AssignmentSerializer\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        try:\n            strategy_name = StrategyName[self.request.data[\"strategy_name\"]]\n        except KeyError:\n            return Response(\n                {\"detail\": \"Invalid strategy name\"},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            workload_allocation = WorkloadAllocation(workloads=self.request.data[\"workloads\"])\n        except ValidationError as e:\n            return Response(\n                {\"detail\": e.errors()},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            bulk_assign(\n                project_id=self.kwargs[\"project_id\"],\n                strategy_name=strategy_name,\n                member_ids=workload_allocation.member_ids,\n                weights=workload_allocation.weights,\n            )\n        except ValueError as e:\n            return Response(\n                {\"detail\": str(e)},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n        return Response(status=status.HTTP_201_CREATED)",
                                        "Function `post`\nCode:\n    def post(self, *args, **kwargs):\n        try:\n            strategy_name = StrategyName[self.request.data[\"strategy_name\"]]\n        except KeyError:\n            return Response(\n                {\"detail\": \"Invalid strategy name\"},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            workload_allocation = WorkloadAllocation(workloads=self.request.data[\"workloads\"])\n        except ValidationError as e:\n            return Response(\n                {\"detail\": e.errors()},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            bulk_assign(\n                project_id=self.kwargs[\"project_id\"],\n                strategy_name=strategy_name,\n                member_ids=workload_allocation.member_ids,\n                weights=workload_allocation.weights,\n            )\n        except ValueError as e:\n            return Response(\n                {\"detail\": str(e)},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n        return Response(status=status.HTTP_201_CREATED)"
                                    ],
                                    "code": "from django.shortcuts import get_object_or_404\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom pydantic import ValidationError\nfrom rest_framework import filters, generics, status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.views import APIView, Response\n\nfrom examples.assignment.strategies import StrategyName\nfrom examples.assignment.usecase import bulk_assign\nfrom examples.assignment.workload import WorkloadAllocation\nfrom examples.models import Assignment\nfrom examples.serializers import AssignmentSerializer\nfrom projects.models import Project\nfrom projects.permissions import IsProjectAdmin, IsProjectStaffAndReadOnly\n\n\nclass AssignmentList(generics.ListCreateAPIView):\n    serializer_class = AssignmentSerializer\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    filter_backends = (DjangoFilterBackend, filters.OrderingFilter)\n    ordering_fields = (\"created_at\", \"updated_at\")\n    model = Assignment\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        queryset = self.model.objects.filter(project=self.project, assignee=self.request.user)\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)\n\n\nclass AssignmentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Assignment.objects.all()\n    serializer_class = AssignmentSerializer\n    lookup_url_kwarg = \"assignment_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n\nclass ResetAssignment(APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def delete(self, *args, **kwargs):\n        Assignment.objects.filter(project=self.project).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass BulkAssignment(APIView):\n    serializer_class = AssignmentSerializer\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def post(self, *args, **kwargs):\n        try:\n            strategy_name = StrategyName[self.request.data[\"strategy_name\"]]\n        except KeyError:\n            return Response(\n                {\"detail\": \"Invalid strategy name\"},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            workload_allocation = WorkloadAllocation(workloads=self.request.data[\"workloads\"])\n        except ValidationError as e:\n            return Response(\n                {\"detail\": e.errors()},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n\n        try:\n            bulk_assign(\n                project_id=self.kwargs[\"project_id\"],\n                strategy_name=strategy_name,\n                member_ids=workload_allocation.member_ids,\n                weights=workload_allocation.weights,\n            )\n        except ValueError as e:\n            return Response(\n                {\"detail\": str(e)},\n                status=status.HTTP_400_BAD_REQUEST,\n            )\n        return Response(status=status.HTTP_201_CREATED)\n",
                                    "summary": "Classes and functions for managing assignments in a Django REST framework, including listing, creating, updating, and deleting assignments, with specific permissions and handling bulk allocations for project members.",
                                    "code_element_summaries": [
                                        "Class `AssignmentList`: A Django REST framework view that allows authenticated users to list and create assignments associated with a specific project, enforcing permissions and filtering options.",
                                        "Function `project`: Retrieves a Project object based on the provided project ID, returning a 404 error if not found.",
                                        "Function `get_queryset`: Retrieves a filtered queryset of model instances based on the current project and the user assigned to it.",
                                        "Function `perform_create`: A method that saves a serializer instance while associating it with a specific project.",
                                        "Class `AssignmentDetail`: A view that allows retrieving, updating, and destroying assignment objects, with specific permissions and a lookup parameter for assignment identification.",
                                        "Class ResetAssignment: An API view that allows project administrators to delete all assignments associated with a specific project.",
                                        "Function `project`: Retrieves a Project object based on the provided project ID, returning a 404 error if not found.",
                                        "Function `delete`: Deletes all assignments associated with a specific project and returns a 204 No Content response.",
                                        "Class `BulkAssignment`: An API view that handles bulk assignment of workloads to project members, validating input data and managing errors related to strategy names and workload allocations.",
                                        "Function `post`: A method that processes incoming requests to allocate workloads based on a specified strategy, handling errors for invalid strategy names, validation issues, and assignment failures, and returns appropriate HTTP responses."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "comment.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views\\comment.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `CommentList`\nCode:\nclass CommentList(generics.ListCreateAPIView):\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    serializer_class = CommentSerializer\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    filterset_fields = [\"example\"]\n    search_fields = (\"text\",)\n    ordering_fields = (\"created_at\", \"example\")\n\n    def get_queryset(self):\n        queryset = Comment.objects.filter(example__project_id=self.kwargs[\"project_id\"])\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.request.query_params.get(\"example\"), user=self.request.user)\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        Comment.objects.filter(user=request.user, pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        queryset = Comment.objects.filter(example__project_id=self.kwargs[\"project_id\"])\n        return queryset",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.request.query_params.get(\"example\"), user=self.request.user)",
                                        "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        Comment.objects.filter(user=request.user, pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Class `CommentDetail`\nCode:\nclass CommentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Comment.objects.all()\n    serializer_class = CommentSerializer\n    lookup_url_kwarg = \"comment_id\"\n    permission_classes = [IsAuthenticated & IsProjectMember & IsOwnComment]"
                                    ],
                                    "code": "from django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import filters, generics, status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom examples.models import Comment\nfrom examples.permissions import IsOwnComment\nfrom examples.serializers import CommentSerializer\nfrom projects.permissions import IsProjectMember\n\n\nclass CommentList(generics.ListCreateAPIView):\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    serializer_class = CommentSerializer\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    filterset_fields = [\"example\"]\n    search_fields = (\"text\",)\n    ordering_fields = (\"created_at\", \"example\")\n\n    def get_queryset(self):\n        queryset = Comment.objects.filter(example__project_id=self.kwargs[\"project_id\"])\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.request.query_params.get(\"example\"), user=self.request.user)\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        Comment.objects.filter(user=request.user, pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass CommentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Comment.objects.all()\n    serializer_class = CommentSerializer\n    lookup_url_kwarg = \"comment_id\"\n    permission_classes = [IsAuthenticated & IsProjectMember & IsOwnComment]\n",
                                    "summary": "Class CommentList: A view that enables authenticated users to manage comments for a specific project with capabilities for listing, creating, and deleting, while offering filtering, searching, and ordering options; along with the CommentDetail class that manages individual comment operations while ensuring authentication and permission checks.",
                                    "code_element_summaries": [
                                        "Class `CommentList`: A view that provides authenticated users with the ability to list, create, and delete comments associated with a specific project, utilizing filtering, searching, and ordering functionalities.",
                                        "Function `get_queryset`: Retrieves a queryset of Comment objects filtered by the project ID provided in the URL parameters.",
                                        "Function `perform_create`: Saves a serializer with additional parameters for example ID and user extracted from the request.",
                                        "Function `delete`: A method that removes comments associated with the current user based on a list of provided IDs and returns a 204 No Content response.",
                                        "Class `CommentDetail`: A view that handles retrieving, updating, and deleting comments, enforcing authentication and specific permission checks."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "example.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views\\example.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ExampleList`\nCode:\nclass ExampleList(generics.ListCreateAPIView):\n    serializer_class = ExampleSerializer\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    ordering_fields = (\"created_at\", \"updated_at\", \"score\")\n    search_fields = (\"text\", \"filename\")\n    model = Example\n    filterset_class = ExampleFilter\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        member = get_object_or_404(Member, project=self.project, user=self.request.user)\n        if member.is_admin():\n            return self.model.objects.filter(project=self.project)\n\n        queryset = self.model.objects.filter(project=self.project, assignments__assignee=self.request.user)\n        if self.project.random_order:\n            queryset = queryset.order_by(\"assignments__id\")\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)\n\n    def delete(self, request, *args, **kwargs):\n        queryset = self.project.examples\n        delete_ids = request.data[\"ids\"]\n        if delete_ids:\n            queryset.filter(pk__in=delete_ids).delete()\n        else:\n            queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        member = get_object_or_404(Member, project=self.project, user=self.request.user)\n        if member.is_admin():\n            return self.model.objects.filter(project=self.project)\n\n        queryset = self.model.objects.filter(project=self.project, assignments__assignee=self.request.user)\n        if self.project.random_order:\n            queryset = queryset.order_by(\"assignments__id\")\n        return queryset",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)",
                                        "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        queryset = self.project.examples\n        delete_ids = request.data[\"ids\"]\n        if delete_ids:\n            queryset.filter(pk__in=delete_ids).delete()\n        else:\n            queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Class `ExampleDetail`\nCode:\nclass ExampleDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Example.objects.all()\n    serializer_class = ExampleSerializer\n    lookup_url_kwarg = \"example_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]"
                                    ],
                                    "code": "from django.shortcuts import get_object_or_404\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import filters, generics, status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom examples.filters import ExampleFilter\nfrom examples.models import Example\nfrom examples.serializers import ExampleSerializer\nfrom projects.models import Member, Project\nfrom projects.permissions import IsProjectAdmin, IsProjectStaffAndReadOnly\n\n\nclass ExampleList(generics.ListCreateAPIView):\n    serializer_class = ExampleSerializer\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    ordering_fields = (\"created_at\", \"updated_at\", \"score\")\n    search_fields = (\"text\", \"filename\")\n    model = Example\n    filterset_class = ExampleFilter\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        member = get_object_or_404(Member, project=self.project, user=self.request.user)\n        if member.is_admin():\n            return self.model.objects.filter(project=self.project)\n\n        queryset = self.model.objects.filter(project=self.project, assignments__assignee=self.request.user)\n        if self.project.random_order:\n            queryset = queryset.order_by(\"assignments__id\")\n        return queryset\n\n    def perform_create(self, serializer):\n        serializer.save(project=self.project)\n\n    def delete(self, request, *args, **kwargs):\n        queryset = self.project.examples\n        delete_ids = request.data[\"ids\"]\n        if delete_ids:\n            queryset.filter(pk__in=delete_ids).delete()\n        else:\n            queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass ExampleDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Example.objects.all()\n    serializer_class = ExampleSerializer\n    lookup_url_kwarg = \"example_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n",
                                    "summary": "Class `ExampleList`: A view that manages Example instances with authentication, project-specific permissions, and functionalities for filtering, searching, creating, and deleting examples; alongside class `ExampleDetail`, which handles the retrieval, update, and deletion of individual Example instances based on user roles.",
                                    "code_element_summaries": [
                                        "Class `ExampleList`: A view that manages the listing and creation of Example instances, enforcing authentication and project-specific permissions while providing filtering, searching, and deletion functionalities.",
                                        "Function `project`: Retrieves a Project object based on the provided project ID, returning a 404 error if not found.",
                                        "Function `get_queryset`: Retrieves a filtered queryset of model objects based on the user's membership status and project settings, allowing admins to see all objects while regular users see only their assigned objects, optionally ordered randomly.",
                                        "Function `perform_create`: A method that saves a serializer instance with an associated project.",
                                        "Function `delete`: A method that removes specified examples from a project based on provided IDs or deletes all examples if no IDs are given, returning a 204 No Content response.",
                                        "Class ExampleDetail: A Django REST framework view that handles retrieval, update, and deletion of Example instances with specific permissions based on user roles."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "example_state.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views\\example_state.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ExampleStateList`\nCode:\nclass ExampleStateList(generics.ListCreateAPIView):\n    serializer_class = ExampleStateSerializer\n    permission_classes = [IsAuthenticated & IsProjectMember]\n\n    @property\n    def can_confirm_per_user(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        return not project.collaborative_annotation\n\n    def get_queryset(self):\n        queryset = ExampleState.objects.filter(example=self.kwargs[\"example_id\"])\n        if self.can_confirm_per_user:\n            queryset = queryset.filter(confirmed_by=self.request.user)\n        return queryset\n\n    def perform_create(self, serializer):\n        queryset = self.get_queryset()\n        if queryset.exists():\n            queryset.delete()\n        else:\n            example = get_object_or_404(Example, pk=self.kwargs[\"example_id\"])\n            serializer.save(example=example, confirmed_by=self.request.user)",
                                        "Function `can_confirm_per_user`\nCode:\n    def can_confirm_per_user(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        return not project.collaborative_annotation",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        queryset = ExampleState.objects.filter(example=self.kwargs[\"example_id\"])\n        if self.can_confirm_per_user:\n            queryset = queryset.filter(confirmed_by=self.request.user)\n        return queryset",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        queryset = self.get_queryset()\n        if queryset.exists():\n            queryset.delete()\n        else:\n            example = get_object_or_404(Example, pk=self.kwargs[\"example_id\"])\n            serializer.save(example=example, confirmed_by=self.request.user)"
                                    ],
                                    "code": "from django.shortcuts import get_object_or_404\nfrom rest_framework import generics\nfrom rest_framework.permissions import IsAuthenticated\n\nfrom examples.models import Example, ExampleState\nfrom examples.serializers import ExampleStateSerializer\nfrom projects.models import Project\nfrom projects.permissions import IsProjectMember\n\n\nclass ExampleStateList(generics.ListCreateAPIView):\n    serializer_class = ExampleStateSerializer\n    permission_classes = [IsAuthenticated & IsProjectMember]\n\n    @property\n    def can_confirm_per_user(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        return not project.collaborative_annotation\n\n    def get_queryset(self):\n        queryset = ExampleState.objects.filter(example=self.kwargs[\"example_id\"])\n        if self.can_confirm_per_user:\n            queryset = queryset.filter(confirmed_by=self.request.user)\n        return queryset\n\n    def perform_create(self, serializer):\n        queryset = self.get_queryset()\n        if queryset.exists():\n            queryset.delete()\n        else:\n            example = get_object_or_404(Example, pk=self.kwargs[\"example_id\"])\n            serializer.save(example=example, confirmed_by=self.request.user)\n",
                                    "summary": "Class ExampleStateList: A ListCreateAPIView that facilitates the retrieval and creation of ExampleState objects while managing user permissions and confirmation status, along with methods for checking project settings, retrieving filtered querysets, and handling object creation.",
                                    "code_element_summaries": [
                                        "Class `ExampleStateList`: A ListCreateAPIView that manages the retrieval and creation of ExampleState objects, ensuring user permissions and handling the confirmation status based on project settings.",
                                        "Function `can_confirm_per_user`: Checks if a project allows confirmation by verifying if it is not set for collaborative annotation.",
                                        "Function `get_queryset`: Retrieves a filtered queryset of ExampleState objects based on the example ID and user confirmation status.",
                                        "Function `perform_create`: A method that deletes existing objects in a queryset if they exist; otherwise, it saves a new object associated with a specific example and the user making the request."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\views\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\examples\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "labels",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content details a comprehensive set of Django classes and configurations for managing annotations, including admin interfaces, application settings, label management, migration processes, permission checks, serializers, testing frameworks, and API endpoints, all aimed at ensuring data integrity, functionality, and access control in collaborative annotation projects.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `SpanAdmin`\nCode:\nclass SpanAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"start_offset\", \"user\")\n    ordering = (\"example\",)",
                                "Class `CategoryAdmin`\nCode:\nclass CategoryAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\")\n    ordering = (\"example\",)",
                                "Class `TextLabelAdmin`\nCode:\nclass TextLabelAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"text\", \"user\")\n    ordering = (\"example\",)",
                                "Class `BoundingBoxAdmin`\nCode:\nclass BoundingBoxAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\", \"x\", \"y\", \"width\", \"height\")\n    ordering = (\"example\",)",
                                "Class `SegmentationAdmin`\nCode:\nclass SegmentationAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\", \"points\")\n    ordering = (\"example\",)"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import BoundingBox, Category, Segmentation, Span, TextLabel\n\n\nclass SpanAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"start_offset\", \"user\")\n    ordering = (\"example\",)\n\n\nclass CategoryAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\")\n    ordering = (\"example\",)\n\n\nclass TextLabelAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"text\", \"user\")\n    ordering = (\"example\",)\n\n\nclass BoundingBoxAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\", \"x\", \"y\", \"width\", \"height\")\n    ordering = (\"example\",)\n\n\nclass SegmentationAdmin(admin.ModelAdmin):\n    list_display = (\"example\", \"label\", \"user\", \"points\")\n    ordering = (\"example\",)\n\n\nadmin.site.register(Category, CategoryAdmin)\nadmin.site.register(Span, SpanAdmin)\nadmin.site.register(TextLabel, TextLabelAdmin)\nadmin.site.register(BoundingBox, BoundingBoxAdmin)\nadmin.site.register(Segmentation, SegmentationAdmin)\n",
                            "summary": "Classes SpanAdmin, CategoryAdmin, TextLabelAdmin, BoundingBoxAdmin, and SegmentationAdmin: Django admin model configurations that customize the display fields and ordering for their respective objects in the admin interface.",
                            "code_element_summaries": [
                                "Class SpanAdmin: A Django admin model configuration that specifies the display fields and ordering for Span objects in the admin interface.",
                                "Class CategoryAdmin: A Django admin model that customizes the display and ordering of category objects in the admin interface.",
                                "Class `TextLabelAdmin`: A Django admin model that manages the display and ordering of text label entries in the admin interface.",
                                "Class BoundingBoxAdmin: A Django admin model that customizes the display and ordering of bounding box annotations in the admin interface.",
                                "Class SegmentationAdmin: A Django admin model that manages the display and ordering of segmentation annotations in the admin interface."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelsConfig`\nCode:\nclass LabelsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"labels\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass LabelsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"labels\"\n",
                            "summary": "Class LabelsConfig: A Django application configuration class for the \"labels\" app that specifies the default auto field type as BigAutoField.",
                            "code_element_summaries": [
                                "Class LabelsConfig: A Django application configuration class for the \"labels\" app, setting the default auto field type to BigAutoField."
                            ],
                            "children": []
                        },
                        {
                            "name": "managers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\managers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelManager`\nCode:\nclass LabelManager(Manager):\n    label_type_field = \"label\"\n\n    def calc_label_distribution(self, examples, members, labels):\n        \"\"\"Calculate label distribution.\n\n        Args:\n            examples: example queryset.\n            members: user queryset.\n            labels: label queryset.\n\n        Returns:\n            label distribution per user.\n\n        Examples:\n            >>> self.calc_label_distribution(examples, members, labels)\n            {'admin': {'positive': 10, 'negative': 5}}\n        \"\"\"\n        distribution = {member.username: {label.text: 0 for label in labels} for member in members}\n        items = (\n            self.filter(example_id__in=examples)\n            .values(\"user__username\", f\"{self.label_type_field}__text\")\n            .annotate(count=Count(f\"{self.label_type_field}__text\"))\n        )\n        for item in items:\n            username = item[\"user__username\"]\n            label = item[f\"{self.label_type_field}__text\"]\n            count = item[\"count\"]\n            distribution[username][label] = count\n        return distribution\n\n    def get_labels(self, label, project):\n        if project.collaborative_annotation:\n            return self.filter(example=label.example)\n        else:\n            return self.filter(example=label.example, user=label.user)\n\n    def can_annotate(self, label, project) -> bool:\n        raise NotImplementedError(\"Please implement this method in the subclass\")\n\n    def filter_annotatable_labels(self, labels, project):\n        return [label for label in labels if self.can_annotate(label, project)]",
                                "Function `calc_label_distribution`: Calculate label distribution.\nCode:\n    def calc_label_distribution(self, examples, members, labels):\n        \"\"\"Calculate label distribution.\n\n        Args:\n            examples: example queryset.\n            members: user queryset.\n            labels: label queryset.\n\n        Returns:\n            label distribution per user.\n\n        Examples:\n            >>> self.calc_label_distribution(examples, members, labels)\n            {'admin': {'positive': 10, 'negative': 5}}\n        \"\"\"\n        distribution = {member.username: {label.text: 0 for label in labels} for member in members}\n        items = (\n            self.filter(example_id__in=examples)\n            .values(\"user__username\", f\"{self.label_type_field}__text\")\n            .annotate(count=Count(f\"{self.label_type_field}__text\"))\n        )\n        for item in items:\n            username = item[\"user__username\"]\n            label = item[f\"{self.label_type_field}__text\"]\n            count = item[\"count\"]\n            distribution[username][label] = count\n        return distribution",
                                "Function `get_labels`\nCode:\n    def get_labels(self, label, project):\n        if project.collaborative_annotation:\n            return self.filter(example=label.example)\n        else:\n            return self.filter(example=label.example, user=label.user)",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        raise NotImplementedError(\"Please implement this method in the subclass\")",
                                "Function `filter_annotatable_labels`\nCode:\n    def filter_annotatable_labels(self, labels, project):\n        return [label for label in labels if self.can_annotate(label, project)]",
                                "Class `CategoryManager`\nCode:\nclass CategoryManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        is_exclusive = project.single_class_classification\n        categories = self.get_labels(label, project)\n        if is_exclusive:\n            return not categories.exists()\n        else:\n            return not categories.filter(label=label.label).exists()",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        is_exclusive = project.single_class_classification\n        categories = self.get_labels(label, project)\n        if is_exclusive:\n            return not categories.exists()\n        else:\n            return not categories.filter(label=label.label).exists()",
                                "Class `SpanManager`\nCode:\nclass SpanManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        overlapping = getattr(project, \"allow_overlapping\", False)\n        spans = self.get_labels(label, project)\n        if overlapping:\n            return True\n        for span in spans:\n            if span.is_overlapping(label):\n                return False\n        return True",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        overlapping = getattr(project, \"allow_overlapping\", False)\n        spans = self.get_labels(label, project)\n        if overlapping:\n            return True\n        for span in spans:\n            if span.is_overlapping(label):\n                return False\n        return True",
                                "Class `TextLabelManager`\nCode:\nclass TextLabelManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        texts = self.get_labels(label, project)\n        for text in texts:\n            if text.is_same_text(label):\n                return False\n        return True",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        texts = self.get_labels(label, project)\n        for text in texts:\n            if text.is_same_text(label):\n                return False\n        return True",
                                "Class `RelationManager`\nCode:\nclass RelationManager(LabelManager):\n    label_type_field = \"type\"\n\n    def can_annotate(self, label, project) -> bool:\n        return True",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        return True",
                                "Class `BoundingBoxManager`\nCode:\nclass BoundingBoxManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        return True",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        return True",
                                "Class `SegmentationManager`\nCode:\nclass SegmentationManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        return True",
                                "Function `can_annotate`\nCode:\n    def can_annotate(self, label, project) -> bool:\n        return True"
                            ],
                            "code": "from django.db.models import Count, Manager\n\n\nclass LabelManager(Manager):\n    label_type_field = \"label\"\n\n    def calc_label_distribution(self, examples, members, labels):\n        \"\"\"Calculate label distribution.\n\n        Args:\n            examples: example queryset.\n            members: user queryset.\n            labels: label queryset.\n\n        Returns:\n            label distribution per user.\n\n        Examples:\n            >>> self.calc_label_distribution(examples, members, labels)\n            {'admin': {'positive': 10, 'negative': 5}}\n        \"\"\"\n        distribution = {member.username: {label.text: 0 for label in labels} for member in members}\n        items = (\n            self.filter(example_id__in=examples)\n            .values(\"user__username\", f\"{self.label_type_field}__text\")\n            .annotate(count=Count(f\"{self.label_type_field}__text\"))\n        )\n        for item in items:\n            username = item[\"user__username\"]\n            label = item[f\"{self.label_type_field}__text\"]\n            count = item[\"count\"]\n            distribution[username][label] = count\n        return distribution\n\n    def get_labels(self, label, project):\n        if project.collaborative_annotation:\n            return self.filter(example=label.example)\n        else:\n            return self.filter(example=label.example, user=label.user)\n\n    def can_annotate(self, label, project) -> bool:\n        raise NotImplementedError(\"Please implement this method in the subclass\")\n\n    def filter_annotatable_labels(self, labels, project):\n        return [label for label in labels if self.can_annotate(label, project)]\n\n\nclass CategoryManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        is_exclusive = project.single_class_classification\n        categories = self.get_labels(label, project)\n        if is_exclusive:\n            return not categories.exists()\n        else:\n            return not categories.filter(label=label.label).exists()\n\n\nclass SpanManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        overlapping = getattr(project, \"allow_overlapping\", False)\n        spans = self.get_labels(label, project)\n        if overlapping:\n            return True\n        for span in spans:\n            if span.is_overlapping(label):\n                return False\n        return True\n\n\nclass TextLabelManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        texts = self.get_labels(label, project)\n        for text in texts:\n            if text.is_same_text(label):\n                return False\n        return True\n\n\nclass RelationManager(LabelManager):\n    label_type_field = \"type\"\n\n    def can_annotate(self, label, project) -> bool:\n        return True\n\n\nclass BoundingBoxManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        return True\n\n\nclass SegmentationManager(LabelManager):\n    def can_annotate(self, label, project) -> bool:\n        return True\n",
                            "summary": "Class LabelManager and its subclasses provide custom management for label distribution and annotation permissions in collaborative projects, implementing various methods to calculate label distribution, retrieve labels, and determine annotatability based on project settings and classification rules.",
                            "code_element_summaries": [
                                "Class LabelManager: A custom manager for handling label distribution calculations, retrieving labels based on project settings, and filtering annotatable labels for users in a collaborative annotation context.",
                                "Function `calc_label_distribution`: Computes the distribution of labels assigned by users over a set of examples, returning a dictionary that maps each user to their respective label counts.",
                                "Function `get_labels`: Retrieves labels based on the collaborative annotation status of the project, filtering by example and optionally by user.",
                                "Function `can_annotate`: An abstract method that raises a NotImplementedError, indicating that subclasses must provide their own implementation to determine if annotation is possible for a given label and project.",
                                "Function `filter_annotatable_labels`: Filters a list of labels to return only those that can be annotated in a specified project.",
                                "Class CategoryManager: A specialized manager for handling label annotations that determines if a label can be annotated based on project classification rules.",
                                "Function `can_annotate`: Determines if a label can be annotated in a project based on whether the project allows exclusive classification and the existence of categories associated with the label.",
                                "Class SpanManager: A subclass of LabelManager that determines if a label can be annotated based on overlapping constraints within a project.",
                                "Function `can_annotate`: Determines if a label can be annotated in a project based on overlapping settings and existing label spans.",
                                "Class TextLabelManager: A specialized manager that determines if a label can be annotated by checking for existing identical text labels within a project.",
                                "Function `can_annotate`: Checks if a given label can be annotated in a project by verifying if it matches any existing labels.",
                                "Class RelationManager: A subclass of LabelManager that defines a label type field and provides a method to determine if annotation is possible for a given label and project.",
                                "Function `can_annotate`: A method that always returns `True`, indicating that annotation is permitted regardless of the label or project.",
                                "Class BoundingBoxManager: A subclass of LabelManager that provides a method to determine if a label can be annotated for a given project, always returning true.",
                                "Function `can_annotate`: A method that always returns `True`, indicating that annotation is permitted for a given label and project.",
                                "Class SegmentationManager: A subclass of LabelManager that allows for annotation by always returning True in the can_annotate method.",
                                "Function `can_annotate`: A method that always returns `True`, indicating that annotation is permitted for a given label and project."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A series of Django migration classes that define, modify, and manage various models such as Span, Category, AnnotationRelations, and TextLabel, including their fields, relationships, and constraints, while ensuring data integrity and schema updates throughout the migration process.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0031_auto_20220127_0032\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Span\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"start_offset\", models.IntegerField()),\n                        (\"end_offset\", models.IntegerField()),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"api.example\"\n                            ),\n                        ),\n                        (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.spantype\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"Category\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"api.example\"\n                            ),\n                        ),\n                        (\n                            \"label\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.categorytype\"),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"AnnotationRelations\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"annotation_id_1\", models.IntegerField()),\n                        (\"annotation_id_2\", models.IntegerField()),\n                        (\"timestamp\", models.DateTimeField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\n                            \"type\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=\"api.relationtypes\",\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"TextLabel\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"text\", models.TextField()),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"api.example\"\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"example\", \"user\", \"text\")},\n                    },\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(\n                        check=models.Q((\"start_offset__gte\", 0)), name=\"startOffset >= 0\"\n                    ),\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(check=models.Q((\"end_offset__gte\", 0)), name=\"endOffset >= 0\"),\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(\n                        check=models.Q((\"start_offset__lt\", django.db.models.expressions.F(\"end_offset\"))),\n                        name=\"start < end\",\n                    ),\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"category\",\n                    unique_together={(\"example\", \"user\", \"label\")},\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"annotationrelations\",\n                    unique_together={(\"annotation_id_1\", \"annotation_id_2\", \"type\", \"project\")},\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 00:32\n\nfrom django.conf import settings\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport django.db.models.expressions\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0031_auto_20220127_0032\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Span\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"start_offset\", models.IntegerField()),\n                        (\"end_offset\", models.IntegerField()),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"api.example\"\n                            ),\n                        ),\n                        (\"label\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.spantype\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"Category\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"api.example\"\n                            ),\n                        ),\n                        (\n                            \"label\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.categorytype\"),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"AnnotationRelations\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"annotation_id_1\", models.IntegerField()),\n                        (\"annotation_id_2\", models.IntegerField()),\n                        (\"timestamp\", models.DateTimeField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\n                            \"type\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=\"api.relationtypes\",\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"annotation_relations\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"TextLabel\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"prob\", models.FloatField(default=0.0)),\n                        (\"manual\", models.BooleanField(default=False)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"text\", models.TextField()),\n                        (\n                            \"example\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"api.example\"\n                            ),\n                        ),\n                        (\n                            \"user\",\n                            models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"example\", \"user\", \"text\")},\n                    },\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(\n                        check=models.Q((\"start_offset__gte\", 0)), name=\"startOffset >= 0\"\n                    ),\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(check=models.Q((\"end_offset__gte\", 0)), name=\"endOffset >= 0\"),\n                ),\n                migrations.AddConstraint(\n                    model_name=\"span\",\n                    constraint=models.CheckConstraint(\n                        check=models.Q((\"start_offset__lt\", django.db.models.expressions.F(\"end_offset\"))),\n                        name=\"start < end\",\n                    ),\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"category\",\n                    unique_together={(\"example\", \"user\", \"label\")},\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"annotationrelations\",\n                    unique_together={(\"annotation_id_1\", \"annotation_id_2\", \"type\", \"project\")},\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that defines and creates several models such as Span, Category, AnnotationRelations, and TextLabel, including their fields, constraints, and dependencies on existing models.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates multiple models including Span, Category, AnnotationRelations, and TextLabel, along with their respective fields and constraints, while establishing dependencies on existing models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_rename_annotationrelations_relation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0002_rename_annotationrelations_relation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0031_auto_20220127_0032\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"AnnotationRelations\",\n            new_name=\"Relation\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 02:39\n\nfrom django.conf import settings\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"api\", \"0031_auto_20220127_0032\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"AnnotationRelations\",\n            new_name=\"Relation\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration class that renames the model \"AnnotationRelations\" to \"Relation\" while specifying its dependencies.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration class that renames the model \"AnnotationRelations\" to \"Relation\" and defines its dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_auto_20220127_0654.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0003_auto_20220127_0654.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0001_initial\"),\n        (\"labels\", \"0002_rename_annotationrelations_relation\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"category\",\n                    name=\"label\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                migrations.AlterField(\n                    model_name=\"relation\",\n                    name=\"type\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"label_types.relationtypes\",\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"span\",\n                    name=\"label\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.spantype\"),\n                ),\n            ]\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 06:54\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0001_initial\"),\n        (\"labels\", \"0002_rename_annotationrelations_relation\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"category\",\n                    name=\"label\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                migrations.AlterField(\n                    model_name=\"relation\",\n                    name=\"type\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"label_types.relationtypes\",\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"span\",\n                    name=\"label\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.spantype\"),\n                ),\n            ]\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration class that updates the database schema by changing foreign key fields in the `category`, `relation`, and `span` models.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration class that modifies the database schema by altering foreign key fields in the `category`, `relation`, and `span` models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_auto_20220128_0246.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0004_auto_20220128_0246.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0001_initial\"),\n        (\"labels\", \"0003_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"category\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"examples.example\"\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"span\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"examples.example\"\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"textlabel\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"examples.example\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-28 02:46\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0001_initial\"),\n        (\"labels\", \"0003_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"category\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"categories\", to=\"examples.example\"\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"span\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"spans\", to=\"examples.example\"\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"textlabel\",\n                    name=\"example\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"texts\", to=\"examples.example\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that updates ForeignKey relationships in the \"category,\" \"span,\" and \"textlabel\" models to point to the \"example\" model within the \"examples\" app.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that modifies the ForeignKey relationships of the \"category,\" \"span,\" and \"textlabel\" models to reference the \"example\" model in the \"examples\" app."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_alter_relation_project.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0005_alter_relation_project.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"labels\", \"0004_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"relation\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"labels\", \"0004_auto_20220128_0246\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"relation\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"annotation_relations\",\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the \"project\" field in the \"relation\" model to create a foreign key relationship with the \"projects.project\" model.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the \"project\" field in the \"relation\" model to establish a foreign key relationship with the \"projects.project\" model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0006_rename_relation_relationold.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0006_rename_relation_relationold.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0005_alter_relation_project\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"Relation\",\n            new_name=\"RelationOld\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 05:29\n\nfrom django.conf import settings\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0005_alter_relation_project\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"Relation\",\n            new_name=\"RelationOld\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that renames the \"Relation\" model to \"RelationOld\" and defines its dependencies.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that renames the model \"Relation\" to \"RelationOld\" while specifying its dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0007_relationnew.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0007_relationnew.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0006_rename_relation_relationold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"RelationNew\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"direction\",\n                    models.CharField(\n                        choices=[(\"left\", \"left\"), (\"right\", \"right\"), (\"undirected\", \"undirected\")],\n                        default=\"undirected\",\n                        max_length=10,\n                    ),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"relations\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"from_id\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"from_relations\", to=\"labels.span\"\n                    ),\n                ),\n                (\n                    \"to_id\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"to_relations\", to=\"labels.span\"\n                    ),\n                ),\n                (\"type\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.relationtype\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"abstract\": False,\n            },\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 06:15\n\nfrom django.conf import settings\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0006_rename_relation_relationold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"RelationNew\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\n                    \"direction\",\n                    models.CharField(\n                        choices=[(\"left\", \"left\"), (\"right\", \"right\"), (\"undirected\", \"undirected\")],\n                        default=\"undirected\",\n                        max_length=10,\n                    ),\n                ),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"relations\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"from_id\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"from_relations\", to=\"labels.span\"\n                    ),\n                ),\n                (\n                    \"to_id\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"to_relations\", to=\"labels.span\"\n                    ),\n                ),\n                (\"type\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.relationtype\")),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"abstract\": False,\n            },\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes a new model named RelationNew, incorporating multiple fields and dependencies on pre-existing models.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates a new model called RelationNew with various fields and dependencies on existing models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0008_auto_20220222_0630.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0008_auto_20220222_0630.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `copy_relation`\nCode:\ndef copy_relation(apps, schema_editor):\n    RelationTypeNew = apps.get_model(\"label_types\", \"RelationType\")\n    RelationOld = apps.get_model(\"labels\", \"RelationOld\")\n    RelationNew = apps.get_model(\"labels\", \"RelationNew\")\n    Span = apps.get_model(\"labels\", \"Span\")\n    for relation_old in RelationOld.objects.all():\n        from_id = Span.objects.get(id=relation_old.annotation_id_1)\n        to_id = Span.objects.get(id=relation_old.annotation_id_2)\n        relation_type = RelationTypeNew.objects.get(project=relation_old.type.project, text=relation_old.type.name)\n        RelationNew(\n            from_id=from_id, to_id=to_id, user=relation_old.user, type=relation_type, example=from_id.example\n        ).save()",
                                        "Function `delete_new_relation`\nCode:\ndef delete_new_relation(apps, schema_editor):\n    RelationNew = apps.get_model(\"labels\", \"RelationNew\")\n    RelationOld = apps.get_model(\"labels\", \"RelationOld\")\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    for relation in RelationNew.objects.all():\n        relation_type, _ = RelationTypeOld.objects.get_or_create(\n            project=relation.type.project, name=relation.type.text, color=relation.type.background_color\n        )\n        RelationOld(\n            annotation_id_1=relation.from_id.id,\n            annotation_id_2=relation.to_id.id,\n            timestamp=relation.created_at,\n            user=relation.user,\n            project=relation.example.project,\n            type=relation_type,\n        ).save()\n        relation.delete()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0007_relationnew\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_relation, reverse_code=delete_new_relation),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 06:30\n\nfrom django.db import migrations\n\n\ndef copy_relation(apps, schema_editor):\n    RelationTypeNew = apps.get_model(\"label_types\", \"RelationType\")\n    RelationOld = apps.get_model(\"labels\", \"RelationOld\")\n    RelationNew = apps.get_model(\"labels\", \"RelationNew\")\n    Span = apps.get_model(\"labels\", \"Span\")\n    for relation_old in RelationOld.objects.all():\n        from_id = Span.objects.get(id=relation_old.annotation_id_1)\n        to_id = Span.objects.get(id=relation_old.annotation_id_2)\n        relation_type = RelationTypeNew.objects.get(project=relation_old.type.project, text=relation_old.type.name)\n        RelationNew(\n            from_id=from_id, to_id=to_id, user=relation_old.user, type=relation_type, example=from_id.example\n        ).save()\n\n\ndef delete_new_relation(apps, schema_editor):\n    RelationNew = apps.get_model(\"labels\", \"RelationNew\")\n    RelationOld = apps.get_model(\"labels\", \"RelationOld\")\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    for relation in RelationNew.objects.all():\n        relation_type, _ = RelationTypeOld.objects.get_or_create(\n            project=relation.type.project, name=relation.type.text, color=relation.type.background_color\n        )\n        RelationOld(\n            annotation_id_1=relation.from_id.id,\n            annotation_id_2=relation.to_id.id,\n            timestamp=relation.created_at,\n            user=relation.user,\n            project=relation.example.project,\n            type=relation_type,\n        ).save()\n        relation.delete()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0007_relationnew\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_relation, reverse_code=delete_new_relation),\n    ]\n",
                                    "summary": "Class Migration: A Django migration class that facilitates the copying of relationships between old and new models while managing database schema changes and ensuring data integrity.",
                                    "code_element_summaries": [
                                        "Function `copy_relation`: A migration function that copies relationships from an old model to a new model by retrieving and transferring relevant data between them.",
                                        "Function `delete_new_relation`: A migration function that transfers data from the RelationNew model to the RelationOld model while creating corresponding RelationTypeOld entries, and subsequently deletes the original RelationNew records.",
                                        "Class Migration: A Django migration class that defines dependencies and operations for database schema changes, specifically executing a Python function to copy relations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0009_delete_relationold.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0009_delete_relationold.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0008_auto_20220222_0630\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"RelationOld\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 06:46\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0008_auto_20220222_0630\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"RelationOld\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that removes the \"RelationOld\" model while depending on an earlier migration from the \"labels\" app.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that deletes the model \"RelationOld\" and has a dependency on a previous migration in the \"labels\" app."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0010_rename_relationnew_relation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0010_rename_relationnew_relation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0009_delete_relationold\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationNew\",\n            new_name=\"Relation\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 07:04\n\nfrom django.conf import settings\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        (\"examples\", \"0002_alter_example_project\"),\n        (\"labels\", \"0009_delete_relationold\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationNew\",\n            new_name=\"Relation\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that renames the model \"RelationNew\" to \"Relation\" while defining dependencies on other migrations and the user model.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that renames the model \"RelationNew\" to \"Relation\" and specifies dependencies on other migrations and the user model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0011_remove_relation_direction.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0011_remove_relation_direction.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0010_rename_relationnew_relation\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"relation\",\n            name=\"direction\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-03-02 01:30\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0010_rename_relationnew_relation\"),\n    ]\n\n    operations = [\n        migrations.RemoveField(\n            model_name=\"relation\",\n            name=\"direction\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that deletes the \"direction\" field from the \"relation\" model, relying on a prior migration for its execution.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that removes the \"direction\" field from the \"relation\" model, with a dependency on a previous migration."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0012_add_uuid_field.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0012_add_uuid_field.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0011_remove_relation_direction\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"relation\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"span\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"textlabel\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-05-12 02:27\n\nfrom django.db import migrations, models\nimport uuid\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0011_remove_relation_direction\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"category\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"relation\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"span\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n        migrations.AddField(\n            model_name=\"textlabel\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, null=True),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that introduces a UUID field to the Category, Relation, Span, and TextLabel models, with default values generated by uuid.uuid4.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that adds a UUID field to the models Category, Relation, Span, and TextLabel, with a default value generated by uuid.uuid4."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0013_populate_uuid_values.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0013_populate_uuid_values.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `gen_uuid`\nCode:\ndef gen_uuid(apps, schema_editor):\n    Category = apps.get_model(\"labels\", \"Category\")\n    Span = apps.get_model(\"labels\", \"Span\")\n    Relation = apps.get_model(\"labels\", \"Relation\")\n    TextLabel = apps.get_model(\"labels\", \"TextLabel\")\n    for label in [Category, Span, Relation, TextLabel]:\n        for row in label.objects.all():\n            row.uuid = uuid.uuid4()\n            row.save(update_fields=[\"uuid\"])",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0012_add_uuid_field\"),\n    ]\n\n    operations = [\n        migrations.RunPython(gen_uuid, reverse_code=migrations.RunPython.noop),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-05-12 02:28\n\nfrom django.db import migrations\n\nimport uuid\n\n\ndef gen_uuid(apps, schema_editor):\n    Category = apps.get_model(\"labels\", \"Category\")\n    Span = apps.get_model(\"labels\", \"Span\")\n    Relation = apps.get_model(\"labels\", \"Relation\")\n    TextLabel = apps.get_model(\"labels\", \"TextLabel\")\n    for label in [Category, Span, Relation, TextLabel]:\n        for row in label.objects.all():\n            row.uuid = uuid.uuid4()\n            row.save(update_fields=[\"uuid\"])\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0012_add_uuid_field\"),\n    ]\n\n    operations = [\n        migrations.RunPython(gen_uuid, reverse_code=migrations.RunPython.noop),\n    ]\n",
                                    "summary": "Function `gen_uuid` and Class `Migration`: A database migration function that assigns UUIDs to Category, Span, Relation, and TextLabel instances while adding a UUID field to the labels model through a Django migration.",
                                    "code_element_summaries": [
                                        "Function `gen_uuid`: A database migration function that assigns a new UUID to each instance of the Category, Span, Relation, and TextLabel models.",
                                        "Class `Migration`: A Django migration that adds a UUID field to the labels model by running a Python function during the migration process."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0014_remove_uuid_null.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0014_remove_uuid_null.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0013_populate_uuid_values\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"relation\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"textlabel\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n    ]"
                                    ],
                                    "code": "import uuid\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0013_populate_uuid_values\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"category\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"relation\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"span\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        migrations.AlterField(\n            model_name=\"textlabel\",\n            name=\"uuid\",\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that alters the `uuid` field in the `category`, `relation`, `span`, and `textlabel` models to guarantee uniqueness and set a default UUID for each.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that modifies the `uuid` field of the `category`, `relation`, `span`, and `textlabel` models to ensure they are unique and generated with a default UUID."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0015_create_boundingbox_table.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0015_create_boundingbox_table.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"labels\", \"0014_remove_uuid_null\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"BoundingBox\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"uuid\", models.UUIDField(default=uuid.uuid4, unique=True)),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"x\", models.FloatField()),\n                (\"y\", models.FloatField()),\n                (\"width\", models.FloatField()),\n                (\"height\", models.FloatField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"bboxes\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"label\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"x__gte\", 0)), name=\"x >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"y__gte\", 0)), name=\"y >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"width__gte\", 0)), name=\"width >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"height__gte\", 0)), name=\"height >= 0\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-29 06:19\n\nfrom django.conf import settings\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport uuid\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"labels\", \"0014_remove_uuid_null\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"BoundingBox\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"uuid\", models.UUIDField(default=uuid.uuid4, unique=True)),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"x\", models.FloatField()),\n                (\"y\", models.FloatField()),\n                (\"width\", models.FloatField()),\n                (\"height\", models.FloatField()),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"bboxes\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"label\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"x__gte\", 0)), name=\"x >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"y__gte\", 0)), name=\"y >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"width__gte\", 0)), name=\"width >= 0\"),\n        ),\n        migrations.AddConstraint(\n            model_name=\"boundingbox\",\n            constraint=models.CheckConstraint(check=models.Q((\"height__gte\", 0)), name=\"height >= 0\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that defines the BoundingBox model with specific fields, constraints, and relationships, ensuring that dimensions are non-negative.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates the BoundingBox model with various fields and constraints, establishing relationships with other models and ensuring non-negative dimensions."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0016_segmentation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\0016_segmentation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0015_create_boundingbox_table\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Segmentation\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"uuid\", models.UUIDField(default=uuid.uuid4, unique=True)),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"points\", models.JSONField(default=list)),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"segmentations\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"label\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"abstract\": False,\n            },\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 05:24\n\nimport uuid\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"examples\", \"0006_alter_example_upload_name\"),\n        (\"label_types\", \"0007_delete_relationtypeold\"),\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"labels\", \"0015_create_boundingbox_table\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Segmentation\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"uuid\", models.UUIDField(default=uuid.uuid4, unique=True)),\n                (\"prob\", models.FloatField(default=0.0)),\n                (\"manual\", models.BooleanField(default=False)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"points\", models.JSONField(default=list)),\n                (\n                    \"example\",\n                    models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"segmentations\", to=\"examples.example\"\n                    ),\n                ),\n                (\n                    \"label\",\n                    models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"label_types.categorytype\"),\n                ),\n                (\"user\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),\n            ],\n            options={\n                \"abstract\": False,\n            },\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes the Segmentation model with various fields and relationships for managing segmentation data.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates the Segmentation model with fields for UUID, probability, manual annotation status, timestamps, points, and foreign key relationships to examples, label types, and users."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Label`\nCode:\nclass Label(models.Model):\n    objects = LabelManager()\n\n    uuid = models.UUIDField(default=uuid.uuid4, unique=True)\n    prob = models.FloatField(default=0.0)\n    manual = models.BooleanField(default=False)\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        abstract = True",
                                "Class `Meta`\nCode:\n    class Meta:\n        abstract = True",
                                "Class `Category`\nCode:\nclass Category(Label):\n    objects = CategoryManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"categories\")\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = (\"example\", \"user\", \"label\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        unique_together = (\"example\", \"user\", \"label\")",
                                "Class `Span`\nCode:\nclass Span(Label):\n    objects = SpanManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"spans\")\n    label = models.ForeignKey(to=SpanType, on_delete=models.CASCADE)\n    start_offset = models.IntegerField()\n    end_offset = models.IntegerField()\n\n    def __str__(self):\n        text = self.example.text[self.start_offset : self.end_offset]\n        return f\"({text}, {self.start_offset}, {self.end_offset}, {self.label.text})\"\n\n    def validate_unique(self, exclude=None):\n        allow_overlapping = getattr(self.example.project, \"allow_overlapping\", False)\n        is_collaborative = self.example.project.collaborative_annotation\n        if allow_overlapping:\n            super().validate_unique(exclude=exclude)\n            return\n\n        overlapping_span = (\n            Span.objects.exclude(id=self.id)\n            .filter(example=self.example)\n            .filter(\n                models.Q(start_offset__gte=self.start_offset, start_offset__lt=self.end_offset)\n                | models.Q(end_offset__gt=self.start_offset, end_offset__lte=self.end_offset)\n                | models.Q(start_offset__lte=self.start_offset, end_offset__gte=self.end_offset)\n            )\n        )\n        if is_collaborative:\n            if overlapping_span.exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")\n        else:\n            if overlapping_span.filter(user=self.user).exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")\n\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)\n\n    def is_overlapping(self, other: \"Span\"):\n        return (\n            (other.start_offset <= self.start_offset < other.end_offset)\n            or (other.start_offset < self.end_offset <= other.end_offset)\n            or (self.start_offset < other.start_offset and other.end_offset < self.end_offset)\n        )\n\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(start_offset__gte=0), name=\"startOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(end_offset__gte=0), name=\"endOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(start_offset__lt=models.F(\"end_offset\")), name=\"start < end\"),\n        ]",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        text = self.example.text[self.start_offset : self.end_offset]\n        return f\"({text}, {self.start_offset}, {self.end_offset}, {self.label.text})\"",
                                "Function `validate_unique`\nCode:\n    def validate_unique(self, exclude=None):\n        allow_overlapping = getattr(self.example.project, \"allow_overlapping\", False)\n        is_collaborative = self.example.project.collaborative_annotation\n        if allow_overlapping:\n            super().validate_unique(exclude=exclude)\n            return\n\n        overlapping_span = (\n            Span.objects.exclude(id=self.id)\n            .filter(example=self.example)\n            .filter(\n                models.Q(start_offset__gte=self.start_offset, start_offset__lt=self.end_offset)\n                | models.Q(end_offset__gt=self.start_offset, end_offset__lte=self.end_offset)\n                | models.Q(start_offset__lte=self.start_offset, end_offset__gte=self.end_offset)\n            )\n        )\n        if is_collaborative:\n            if overlapping_span.exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")\n        else:\n            if overlapping_span.filter(user=self.user).exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")",
                                "Function `save`\nCode:\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)",
                                "Function `is_overlapping`\nCode:\n    def is_overlapping(self, other: \"Span\"):\n        return (\n            (other.start_offset <= self.start_offset < other.end_offset)\n            or (other.start_offset < self.end_offset <= other.end_offset)\n            or (self.start_offset < other.start_offset and other.end_offset < self.end_offset)\n        )",
                                "Class `Meta`\nCode:\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(start_offset__gte=0), name=\"startOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(end_offset__gte=0), name=\"endOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(start_offset__lt=models.F(\"end_offset\")), name=\"start < end\"),\n        ]",
                                "Class `TextLabel`\nCode:\nclass TextLabel(Label):\n    objects = TextLabelManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"texts\")\n    text = models.TextField()\n\n    def is_same_text(self, other: \"TextLabel\"):\n        return self.text == other.text\n\n    class Meta:\n        unique_together = (\"example\", \"user\", \"text\")",
                                "Function `is_same_text`\nCode:\n    def is_same_text(self, other: \"TextLabel\"):\n        return self.text == other.text",
                                "Class `Meta`\nCode:\n    class Meta:\n        unique_together = (\"example\", \"user\", \"text\")",
                                "Class `Relation`\nCode:\nclass Relation(Label):\n    objects = RelationManager()\n    from_id = models.ForeignKey(Span, on_delete=models.CASCADE, related_name=\"from_relations\")\n    to_id = models.ForeignKey(Span, on_delete=models.CASCADE, related_name=\"to_relations\")\n    type = models.ForeignKey(RelationType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"relations\")\n\n    def __str__(self):\n        text = self.example.text\n        from_span = text[self.from_id.start_offset : self.from_id.end_offset]\n        to_span = text[self.to_id.start_offset : self.to_id.end_offset]\n        type_text = self.type.text\n        return f\"{from_span} - ({type_text}) -> {to_span}\"\n\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)\n\n    def clean(self):\n        same_example = self.from_id.example == self.to_id.example == self.example\n        if not same_example:\n            raise ValidationError(\"You need to label the same example.\")\n        return super().clean()",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        text = self.example.text\n        from_span = text[self.from_id.start_offset : self.from_id.end_offset]\n        to_span = text[self.to_id.start_offset : self.to_id.end_offset]\n        type_text = self.type.text\n        return f\"{from_span} - ({type_text}) -> {to_span}\"",
                                "Function `save`\nCode:\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)",
                                "Function `clean`\nCode:\n    def clean(self):\n        same_example = self.from_id.example == self.to_id.example == self.example\n        if not same_example:\n            raise ValidationError(\"You need to label the same example.\")\n        return super().clean()",
                                "Class `BoundingBox`\nCode:\nclass BoundingBox(Label):\n    objects = BoundingBoxManager()\n    x = models.FloatField()\n    y = models.FloatField()\n    width = models.FloatField()\n    height = models.FloatField()\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"bboxes\")\n\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(x__gte=0), name=\"x >= 0\"),\n            models.CheckConstraint(check=models.Q(y__gte=0), name=\"y >= 0\"),\n            models.CheckConstraint(check=models.Q(width__gte=0), name=\"width >= 0\"),\n            models.CheckConstraint(check=models.Q(height__gte=0), name=\"height >= 0\"),\n        ]",
                                "Class `Meta`\nCode:\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(x__gte=0), name=\"x >= 0\"),\n            models.CheckConstraint(check=models.Q(y__gte=0), name=\"y >= 0\"),\n            models.CheckConstraint(check=models.Q(width__gte=0), name=\"width >= 0\"),\n            models.CheckConstraint(check=models.Q(height__gte=0), name=\"height >= 0\"),\n        ]",
                                "Class `Segmentation`\nCode:\nclass Segmentation(Label):\n    objects = SegmentationManager()\n    points = models.JSONField(default=list)\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"segmentations\")"
                            ],
                            "code": "import uuid\n\nfrom django.contrib.auth.models import User\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\n\nfrom .managers import (\n    BoundingBoxManager,\n    CategoryManager,\n    LabelManager,\n    RelationManager,\n    SegmentationManager,\n    SpanManager,\n    TextLabelManager,\n)\nfrom examples.models import Example\nfrom label_types.models import CategoryType, RelationType, SpanType\n\n\nclass Label(models.Model):\n    objects = LabelManager()\n\n    uuid = models.UUIDField(default=uuid.uuid4, unique=True)\n    prob = models.FloatField(default=0.0)\n    manual = models.BooleanField(default=False)\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        abstract = True\n\n\nclass Category(Label):\n    objects = CategoryManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"categories\")\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = (\"example\", \"user\", \"label\")\n\n\nclass Span(Label):\n    objects = SpanManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"spans\")\n    label = models.ForeignKey(to=SpanType, on_delete=models.CASCADE)\n    start_offset = models.IntegerField()\n    end_offset = models.IntegerField()\n\n    def __str__(self):\n        text = self.example.text[self.start_offset : self.end_offset]\n        return f\"({text}, {self.start_offset}, {self.end_offset}, {self.label.text})\"\n\n    def validate_unique(self, exclude=None):\n        allow_overlapping = getattr(self.example.project, \"allow_overlapping\", False)\n        is_collaborative = self.example.project.collaborative_annotation\n        if allow_overlapping:\n            super().validate_unique(exclude=exclude)\n            return\n\n        overlapping_span = (\n            Span.objects.exclude(id=self.id)\n            .filter(example=self.example)\n            .filter(\n                models.Q(start_offset__gte=self.start_offset, start_offset__lt=self.end_offset)\n                | models.Q(end_offset__gt=self.start_offset, end_offset__lte=self.end_offset)\n                | models.Q(start_offset__lte=self.start_offset, end_offset__gte=self.end_offset)\n            )\n        )\n        if is_collaborative:\n            if overlapping_span.exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")\n        else:\n            if overlapping_span.filter(user=self.user).exists():\n                raise ValidationError(\"This overlapping is not allowed in this project.\")\n\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)\n\n    def is_overlapping(self, other: \"Span\"):\n        return (\n            (other.start_offset <= self.start_offset < other.end_offset)\n            or (other.start_offset < self.end_offset <= other.end_offset)\n            or (self.start_offset < other.start_offset and other.end_offset < self.end_offset)\n        )\n\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(start_offset__gte=0), name=\"startOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(end_offset__gte=0), name=\"endOffset >= 0\"),\n            models.CheckConstraint(check=models.Q(start_offset__lt=models.F(\"end_offset\")), name=\"start < end\"),\n        ]\n\n\nclass TextLabel(Label):\n    objects = TextLabelManager()\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"texts\")\n    text = models.TextField()\n\n    def is_same_text(self, other: \"TextLabel\"):\n        return self.text == other.text\n\n    class Meta:\n        unique_together = (\"example\", \"user\", \"text\")\n\n\nclass Relation(Label):\n    objects = RelationManager()\n    from_id = models.ForeignKey(Span, on_delete=models.CASCADE, related_name=\"from_relations\")\n    to_id = models.ForeignKey(Span, on_delete=models.CASCADE, related_name=\"to_relations\")\n    type = models.ForeignKey(RelationType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"relations\")\n\n    def __str__(self):\n        text = self.example.text\n        from_span = text[self.from_id.start_offset : self.from_id.end_offset]\n        to_span = text[self.to_id.start_offset : self.to_id.end_offset]\n        type_text = self.type.text\n        return f\"{from_span} - ({type_text}) -> {to_span}\"\n\n    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):\n        self.full_clean()\n        super().save(force_insert, force_update, using, update_fields)\n\n    def clean(self):\n        same_example = self.from_id.example == self.to_id.example == self.example\n        if not same_example:\n            raise ValidationError(\"You need to label the same example.\")\n        return super().clean()\n\n\nclass BoundingBox(Label):\n    objects = BoundingBoxManager()\n    x = models.FloatField()\n    y = models.FloatField()\n    width = models.FloatField()\n    height = models.FloatField()\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"bboxes\")\n\n    class Meta:\n        constraints = [\n            models.CheckConstraint(check=models.Q(x__gte=0), name=\"x >= 0\"),\n            models.CheckConstraint(check=models.Q(y__gte=0), name=\"y >= 0\"),\n            models.CheckConstraint(check=models.Q(width__gte=0), name=\"width >= 0\"),\n            models.CheckConstraint(check=models.Q(height__gte=0), name=\"height >= 0\"),\n        ]\n\n\nclass Segmentation(Label):\n    objects = SegmentationManager()\n    points = models.JSONField(default=list)\n    label = models.ForeignKey(to=CategoryType, on_delete=models.CASCADE)\n    example = models.ForeignKey(to=Example, on_delete=models.CASCADE, related_name=\"segmentations\")\n",
                            "summary": "Summary: The content describes several models related to annotations, including `Label`, `Category`, `Span`, `TextLabel`, `Relation`, `BoundingBox`, and `Segmentation`, each with specific attributes, validation methods, and constraints to ensure data integrity and uniqueness across various relationships and properties.",
                            "code_element_summaries": [
                                "Class `Label`: An abstract model representing a label with attributes for unique identification, probability, manual assignment, user association, and timestamps for creation and updates.",
                                "Class Meta: An abstract base class that serves as a blueprint for other models without being instantiated directly.",
                                "Class `Category`: A model that associates categories with examples and category types, ensuring uniqueness across example, user, and label combinations.",
                                "Class Meta: Defines a unique constraint ensuring that the combination of \"example\", \"user\", and \"label\" is unique within the database.",
                                "Class `Span`: A model representing annotated text spans with validation for overlapping spans and methods for string representation and saving.",
                                "Function `__str__`: Returns a string representation of the object, including a substring of example text along with its start and end offsets and the associated label.",
                                "Function `validate_unique`: Checks for overlapping spans in a collaborative or non-collaborative project context, raising a validation error if overlaps are detected and not permitted.",
                                "Function `save`: A method that validates the instance before saving it to the database, allowing for options to force insert or update.",
                                "Function `is_overlapping`: Determines if the current span overlaps with another span based on their start and end offsets.",
                                "Class Meta: Defines database constraints to ensure that start and end offsets are non-negative and that the start offset is less than the end offset.",
                                "Class `TextLabel`: A model representing labeled text associated with an example, featuring a method to compare text equality and enforcing uniqueness constraints.",
                                "Function `is_same_text`: Compares the text of the current TextLabel instance with that of another TextLabel instance to determine if they are the same.",
                                "Class Meta: Defines a unique constraint for the combination of \"example,\" \"user,\" and \"text\" fields in a model.",
                                "Class `Relation`: A model representing relationships between spans in a text example, ensuring that both spans belong to the same example and providing a string representation of the relationship.",
                                "Function `__str__`: Returns a string representation of a span of text, formatted to show the source and target segments along with their associated type.",
                                "Function `save`: A method that validates the instance before saving it to the database, ensuring data integrity.",
                                "Function `clean`: Validates that the `from_id`, `to_id`, and `example` attributes all refer to the same example before proceeding with the cleaning process.",
                                "Class BoundingBox: A model that represents bounding box annotations with properties for position, dimensions, and associated labels, enforced by constraints to ensure non-negative values.",
                                "Class `Meta`: Defines constraints for a model ensuring that the values of x, y, width, and height are all non-negative.",
                                "Class Segmentation: A model that represents segmentation annotations with associated points, a label, and a relationship to example instances."
                            ],
                            "children": []
                        },
                        {
                            "name": "permissions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\permissions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `CanEditLabel`\nCode:\nclass CanEditLabel(BasePermission):\n    def __init__(self, queryset):\n        super().__init__()\n        self.queryset = queryset\n\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        annotation_id = view.kwargs.get(\"annotation_id\")\n        return self.queryset.filter(id=annotation_id, user=request.user).exists()",
                                "Function `__init__`\nCode:\n    def __init__(self, queryset):\n        super().__init__()\n        self.queryset = queryset",
                                "Function `has_permission`\nCode:\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        annotation_id = view.kwargs.get(\"annotation_id\")\n        return self.queryset.filter(id=annotation_id, user=request.user).exists()"
                            ],
                            "code": "from rest_framework.permissions import BasePermission\n\n\nclass CanEditLabel(BasePermission):\n    def __init__(self, queryset):\n        super().__init__()\n        self.queryset = queryset\n\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        annotation_id = view.kwargs.get(\"annotation_id\")\n        return self.queryset.filter(id=annotation_id, user=request.user).exists()\n",
                            "summary": "Class CanEditLabel: A permission class that verifies user access to edit labels based on annotation ownership, granting unrestricted access to superusers while checking ownership for regular users.",
                            "code_element_summaries": [
                                "Class `CanEditLabel`: A permission class that allows users to edit labels based on their ownership of the specified annotation, with superusers granted unrestricted access.",
                                "Function `__init__`: Initializes an instance by calling the superclass constructor and setting a queryset attribute.",
                                "Function `has_permission`: Checks if the user has permission to access a specific annotation, allowing superusers unrestricted access and verifying ownership for regular users."
                            ],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `CategorySerializer`\nCode:\nclass CategorySerializer(serializers.ModelSerializer):\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = Category\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Category\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `SpanSerializer`\nCode:\nclass SpanSerializer(serializers.ModelSerializer):\n    label = serializers.PrimaryKeyRelatedField(queryset=SpanType.objects.all())\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = Span\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"start_offset\",\n            \"end_offset\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Span\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"start_offset\",\n            \"end_offset\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `TextLabelSerializer`\nCode:\nclass TextLabelSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = TextLabel\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"text\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = TextLabel\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"text\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `RelationSerializer`\nCode:\nclass RelationSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    type = serializers.PrimaryKeyRelatedField(queryset=RelationType.objects.all())\n\n    class Meta:\n        model = Relation\n        fields = (\"id\", \"prob\", \"user\", \"example\", \"created_at\", \"updated_at\", \"from_id\", \"to_id\", \"type\")\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Relation\n        fields = (\"id\", \"prob\", \"user\", \"example\", \"created_at\", \"updated_at\", \"from_id\", \"to_id\", \"type\")\n        read_only_fields = (\"user\",)",
                                "Class `BoundingBoxSerializer`\nCode:\nclass BoundingBoxSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n\n    class Meta:\n        model = BoundingBox\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"x\",\n            \"y\",\n            \"width\",\n            \"height\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = BoundingBox\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"x\",\n            \"y\",\n            \"width\",\n            \"height\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `SegmentationSerializer`\nCode:\nclass SegmentationSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n\n    class Meta:\n        model = Segmentation\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"points\",\n        )\n        read_only_fields = (\"user\",)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Segmentation\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"points\",\n        )\n        read_only_fields = (\"user\",)"
                            ],
                            "code": "from rest_framework import serializers\n\nfrom .models import BoundingBox, Category, Relation, Segmentation, Span, TextLabel\nfrom examples.models import Example\nfrom label_types.models import CategoryType, RelationType, SpanType\n\n\nclass CategorySerializer(serializers.ModelSerializer):\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = Category\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n        )\n        read_only_fields = (\"user\",)\n\n\nclass SpanSerializer(serializers.ModelSerializer):\n    label = serializers.PrimaryKeyRelatedField(queryset=SpanType.objects.all())\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = Span\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"start_offset\",\n            \"end_offset\",\n        )\n        read_only_fields = (\"user\",)\n\n\nclass TextLabelSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n\n    class Meta:\n        model = TextLabel\n        fields = (\n            \"id\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"text\",\n        )\n        read_only_fields = (\"user\",)\n\n\nclass RelationSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    type = serializers.PrimaryKeyRelatedField(queryset=RelationType.objects.all())\n\n    class Meta:\n        model = Relation\n        fields = (\"id\", \"prob\", \"user\", \"example\", \"created_at\", \"updated_at\", \"from_id\", \"to_id\", \"type\")\n        read_only_fields = (\"user\",)\n\n\nclass BoundingBoxSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n\n    class Meta:\n        model = BoundingBox\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"x\",\n            \"y\",\n            \"width\",\n            \"height\",\n        )\n        read_only_fields = (\"user\",)\n\n\nclass SegmentationSerializer(serializers.ModelSerializer):\n    example = serializers.PrimaryKeyRelatedField(queryset=Example.objects.all())\n    label = serializers.PrimaryKeyRelatedField(queryset=CategoryType.objects.all())\n\n    class Meta:\n        model = Segmentation\n        fields = (\n            \"id\",\n            \"uuid\",\n            \"prob\",\n            \"user\",\n            \"example\",\n            \"created_at\",\n            \"updated_at\",\n            \"label\",\n            \"points\",\n        )\n        read_only_fields = (\"user\",)\n",
                            "summary": "Multiple serializer classes for various models (Category, Span, TextLabel, Relation, BoundingBox, and Segmentation) are defined, each including specific fields with user fields set as read-only, along with corresponding configuration classes that specify their models and field settings for serialization.",
                            "code_element_summaries": [
                                "Class `CategorySerializer`: A serializer for the Category model that includes fields for id, probability, user, example, creation and update timestamps, and label, with the user field set as read-only.",
                                "Class Meta: A configuration class that defines the model and fields for the Category, specifying which fields are read-only.",
                                "Class `SpanSerializer`: A serializer for the Span model that includes fields for id, probability, user, example, timestamps, label, and offsets, with the user field set as read-only.",
                                "Class Meta: A configuration class for the Span model that specifies the fields to be included, with \"user\" designated as a read-only field.",
                                "Class `TextLabelSerializer`: A serializer for the TextLabel model that includes fields for ID, probability, user, example, timestamps, and text, with the user field set as read-only.",
                                "Class Meta: A configuration class that specifies the model TextLabel and defines the fields to be included, along with read-only fields for serialization.",
                                "Class RelationSerializer: A Django REST framework serializer for the Relation model that includes fields for its attributes and specifies read-only fields for user information.",
                                "Class Meta: A configuration class that specifies the model Relation, its fields, and read-only fields for serialization.",
                                "Class BoundingBoxSerializer: A serializer for the BoundingBox model that includes fields for various attributes and establishes relationships with Example and CategoryType models.",
                                "Class Meta: A configuration class that defines the model and fields for the BoundingBox, specifying read-only fields for user-related data.",
                                "Class SegmentationSerializer: A serializer for the Segmentation model that includes fields for id, uuid, probability, user, example, timestamps, label, and points, with the user field set as read-only.",
                                "Class Meta: A configuration class that specifies the model Segmentation and defines its fields, including read-only fields for serialization."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "The content outlines a comprehensive suite of test classes and functions designed to validate and manage annotations in document classification and sequence labeling projects, ensuring integrity constraints, functionality, and access restrictions for users while providing utilities for generating tailored annotation instances.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_bbox.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_bbox.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestBoundingBox`\nCode:\nclass TestBoundingBox(TestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin\n\n    def test_cannot_create_label_if_x_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=-1, y=0, width=0, height=0)\n\n    def test_cannot_create_label_if_y_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=-1, width=0, height=0)\n\n    def test_cannot_create_label_if_width_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=-1, height=0)\n\n    def test_cannot_create_label_if_height_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=0, height=-1)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin",
                                        "Function `test_cannot_create_label_if_x_is_less_than_zero`\nCode:\n    def test_cannot_create_label_if_x_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=-1, y=0, width=0, height=0)",
                                        "Function `test_cannot_create_label_if_y_is_less_than_zero`\nCode:\n    def test_cannot_create_label_if_y_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=-1, width=0, height=0)",
                                        "Function `test_cannot_create_label_if_width_is_less_than_zero`\nCode:\n    def test_cannot_create_label_if_width_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=-1, height=0)",
                                        "Function `test_cannot_create_label_if_height_is_less_than_zero`\nCode:\n    def test_cannot_create_label_if_height_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=0, height=-1)"
                                    ],
                                    "code": "from django.db import IntegrityError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom projects.tests.utils import prepare_project\n\n\nclass TestBoundingBox(TestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin\n\n    def test_cannot_create_label_if_x_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=-1, y=0, width=0, height=0)\n\n    def test_cannot_create_label_if_y_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=-1, width=0, height=0)\n\n    def test_cannot_create_label_if_width_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=-1, height=0)\n\n    def test_cannot_create_label_if_height_is_less_than_zero(self):\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"BoundingBox\", example=self.example, x=0, y=0, width=0, height=-1)\n",
                                    "summary": "Class TestBoundingBox: A test suite that validates the integrity constraints for creating bounding boxes by ensuring that the x, y, width, and height values are non-negative, with individual test cases for each constraint.",
                                    "code_element_summaries": [
                                        "Class TestBoundingBox: A test case that verifies the integrity constraints for creating bounding boxes, ensuring that the x, y, width, and height values are not less than zero.",
                                        "Function `setUpTestData`: A class method that initializes test data by preparing a project, creating an example instance associated with that project, and assigning the project's admin user.",
                                        "Function `test_cannot_create_label_if_x_is_less_than_zero`: A test case that verifies an IntegrityError is raised when attempting to create a BoundingBox with a negative x-coordinate.",
                                        "Function `test_cannot_create_label_if_y_is_less_than_zero`: A unit test that verifies an `IntegrityError` is raised when attempting to create a BoundingBox with a negative y-coordinate.",
                                        "Function `test_cannot_create_label_if_width_is_less_than_zero`: A test case that verifies an IntegrityError is raised when attempting to create a BoundingBox with a negative width.",
                                        "Function `test_cannot_create_label_if_height_is_less_than_zero`: A test case that verifies an `IntegrityError` is raised when attempting to create a BoundingBox with a height less than zero."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_category.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_category.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestCategoryLabeling`\nCode:\nclass TestCategoryLabeling(abc.ABC, TestCase):\n    exclusive = True\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION,\n            single_class_classification=cls.exclusive,\n            collaborative_annotation=cls.collaborative,\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"CategoryType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.category = Category(example=cls.example, label=cls.label_type, user=cls.user)\n\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION,\n            single_class_classification=cls.exclusive,\n            collaborative_annotation=cls.collaborative,\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"CategoryType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.category = Category(example=cls.example, label=cls.label_type, user=cls.user)",
                                        "Function `test_can_annotate_category_to_unannotated_data`\nCode:\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `NonCollaborativeMixin`\nCode:\nclass NonCollaborativeMixin:\n    def test_cannot_annotate_same_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_allow_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_cannot_annotate_same_category_to_annotated_data`\nCode:\n    def test_cannot_annotate_same_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_same_category`\nCode:\n    def test_allow_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestExclusiveCategoryLabeling`\nCode:\nclass TestExclusiveCategoryLabeling(TestCategoryLabeling, NonCollaborativeMixin):\n    exclusive = True\n    collaborative = False\n\n    def test_cannot_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_cannot_annotate_different_category_to_annotated_data`\nCode:\n    def test_cannot_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Class `TestNonExclusiveCategoryLabeling`\nCode:\nclass TestNonExclusiveCategoryLabeling(TestCategoryLabeling, NonCollaborativeMixin):\n    exclusive = False\n    collaborative = False\n\n    def test_can_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_can_annotate_different_category_to_annotated_data`\nCode:\n    def test_can_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `CollaborativeMixin`\nCode:\nclass CollaborativeMixin:\n    def test_deny_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_deny_another_user_to_annotate_same_category`\nCode:\n    def test_deny_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Class `TestCollaborativeExclusiveCategoryLabeling`\nCode:\nclass TestCollaborativeExclusiveCategoryLabeling(TestCategoryLabeling, CollaborativeMixin):\n    exclusive = True\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_deny_another_user_to_annotate_different_category`\nCode:\n    def test_deny_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Class `TestCollaborativeNonExclusiveCategoryLabeling`\nCode:\nclass TestCollaborativeNonExclusiveCategoryLabeling(TestCategoryLabeling, CollaborativeMixin):\n    exclusive = False\n    collaborative = True\n\n    def test_allow_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_different_category`\nCode:\n    def test_allow_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestCategory`\nCode:\nclass TestCategory(TestCase):\n    def test_uniqueness(self):\n        a = mommy.make(\"Category\")\n        with self.assertRaises(IntegrityError):\n            Category(example=a.example, user=a.user, label=a.label).save()",
                                        "Function `test_uniqueness`\nCode:\n    def test_uniqueness(self):\n        a = mommy.make(\"Category\")\n        with self.assertRaises(IntegrityError):\n            Category(example=a.example, user=a.user, label=a.label).save()"
                                    ],
                                    "code": "import abc\n\nfrom django.db import IntegrityError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom labels.models import Category\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestCategoryLabeling(abc.ABC, TestCase):\n    exclusive = True\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION,\n            single_class_classification=cls.exclusive,\n            collaborative_annotation=cls.collaborative,\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"CategoryType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.category = Category(example=cls.example, label=cls.label_type, user=cls.user)\n\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass NonCollaborativeMixin:\n    def test_cannot_annotate_same_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_allow_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestExclusiveCategoryLabeling(TestCategoryLabeling, NonCollaborativeMixin):\n    exclusive = True\n    collaborative = False\n\n    def test_cannot_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)\n\n\nclass TestNonExclusiveCategoryLabeling(TestCategoryLabeling, NonCollaborativeMixin):\n    exclusive = False\n    collaborative = False\n\n    def test_can_annotate_different_category_to_annotated_data(self):\n        mommy.make(\"Category\", example=self.example, user=self.user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass CollaborativeMixin:\n    def test_deny_another_user_to_annotate_same_category(self):\n        mommy.make(\"Category\", example=self.example, label=self.label_type, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)\n\n\nclass TestCollaborativeExclusiveCategoryLabeling(TestCategoryLabeling, CollaborativeMixin):\n    exclusive = True\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertFalse(can_annotate)\n\n\nclass TestCollaborativeNonExclusiveCategoryLabeling(TestCategoryLabeling, CollaborativeMixin):\n    exclusive = False\n    collaborative = True\n\n    def test_allow_another_user_to_annotate_different_category(self):\n        mommy.make(\"Category\", example=self.example, user=self.another_user)\n        can_annotate = Category.objects.can_annotate(self.category, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestCategory(TestCase):\n    def test_uniqueness(self):\n        a = mommy.make(\"Category\")\n        with self.assertRaises(IntegrityError):\n            Category(example=a.example, user=a.user, label=a.label).save()\n",
                                    "summary": "Class TestCategoryLabeling and its related classes and functions provide a comprehensive framework for testing category labeling functionality in a document classification project, covering scenarios for annotating unannotated data, enforcing exclusivity and collaboration rules, and ensuring the uniqueness of category entries.",
                                    "code_element_summaries": [
                                        "Class TestCategoryLabeling: An abstract test case for verifying category labeling functionality in a document classification project, ensuring that annotations can be applied to unannotated data.",
                                        "Function `setUpTestData`: A class method that initializes test data by preparing a project, creating an example, a label type, and setting up users and a category for testing purposes.",
                                        "Function `test_can_annotate_category_to_unannotated_data`: A test that verifies whether a specific category can be annotated to unannotated data within a project.",
                                        "Class `NonCollaborativeMixin`: A mixin that provides tests to ensure that only different users can annotate the same category for annotated data.",
                                        "Function `test_cannot_annotate_same_category_to_annotated_data`: A test case that verifies that a category cannot be annotated to data that has already been annotated with the same category.",
                                        "Function `test_allow_another_user_to_annotate_same_category`: A test case that verifies if another user can annotate a category associated with a specific project item.",
                                        "Class TestExclusiveCategoryLabeling: A test case for ensuring that data annotated with a specific category cannot be annotated with a different category in an exclusive labeling scenario.",
                                        "Function `test_cannot_annotate_different_category_to_annotated_data`: A test case that verifies that a user cannot annotate data with a different category than that which has already been annotated.",
                                        "Class TestNonExclusiveCategoryLabeling: A test case that verifies the ability to annotate data with different categories in a non-exclusive and non-collaborative context.",
                                        "Function `test_can_annotate_different_category_to_annotated_data`: A test case that verifies whether a user can annotate data with a different category in a specific project.",
                                        "Class CollaborativeMixin: A mixin that provides a test method to ensure that another user cannot annotate the same category in a collaborative environment.",
                                        "Function `test_deny_another_user_to_annotate_same_category`: A test case that verifies that another user is not allowed to annotate a category that is already associated with a specific user.",
                                        "Class TestCollaborativeExclusiveCategoryLabeling: A test case that ensures that a user is denied the ability to annotate a different category when exclusive and collaborative settings are enabled.",
                                        "Function `test_deny_another_user_to_annotate_different_category`: A test case that verifies that a user cannot annotate a category that belongs to another user.",
                                        "Class TestCollaborativeNonExclusiveCategoryLabeling: A test case that verifies the ability for multiple users to annotate different categories collaboratively without exclusivity.",
                                        "Function `test_allow_another_user_to_annotate_different_category`: A test that verifies if another user can annotate a different category within a specified project.",
                                        "Class TestCategory: A test case that verifies the uniqueness constraint of the Category model by attempting to save a duplicate entry and expecting an IntegrityError.",
                                        "Function `test_uniqueness`: A test case that checks for an `IntegrityError` when attempting to save a duplicate `Category` instance with the same example, user, and label as an existing one."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_relation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_relation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestRelationLabeling`\nCode:\nclass TestRelationLabeling(TestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"RelationType\", project=cls.project.item)\n        cls.user = cls.project.admin\n\n    def test_can_annotate_relation(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)\n\n    def test_cannot_annotate_relation_if_span_example_is_different(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)\n\n    def test_cannot_annotate_relation_if_relation_example_is_different_from_span_example(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", from_id=from_id, to_id=to_id)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"RelationType\", project=cls.project.item)\n        cls.user = cls.project.admin",
                                        "Function `test_can_annotate_relation`\nCode:\n    def test_can_annotate_relation(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)",
                                        "Function `test_cannot_annotate_relation_if_span_example_is_different`\nCode:\n    def test_cannot_annotate_relation_if_span_example_is_different(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)",
                                        "Function `test_cannot_annotate_relation_if_relation_example_is_different_from_span_example`\nCode:\n    def test_cannot_annotate_relation_if_relation_example_is_different_from_span_example(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", from_id=from_id, to_id=to_id)"
                                    ],
                                    "code": "from django.core.exceptions import ValidationError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestRelationLabeling(TestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQUENCE_LABELING)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"RelationType\", project=cls.project.item)\n        cls.user = cls.project.admin\n\n    def test_can_annotate_relation(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)\n\n    def test_cannot_annotate_relation_if_span_example_is_different(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", example=self.example, from_id=from_id, to_id=to_id)\n\n    def test_cannot_annotate_relation_if_relation_example_is_different_from_span_example(self):\n        from_id = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.example, start_offset=1, end_offset=2)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Relation\", from_id=from_id, to_id=to_id)\n",
                                    "summary": "Class TestRelationLabeling: A test case that ensures the correct functionality and validation of annotating relations between spans in different examples, including appropriate error handling for invalid cases.",
                                    "code_element_summaries": [
                                        "Class TestRelationLabeling: A test case that verifies the functionality of annotating relations between spans, ensuring proper validation when spans belong to different examples.",
                                        "Function `setUpTestData`: A class method that initializes test data for a sequence labeling project, including creating a project, an example, a label type, and assigning a user.",
                                        "Function `test_can_annotate_relation`: A test function that creates two Span objects and establishes a Relation between them within a given example.",
                                        "Function `test_cannot_annotate_relation_if_span_example_is_different`: A unit test that verifies a `ValidationError` is raised when attempting to create a `Relation` between two `Span` instances with different examples.",
                                        "Function `test_cannot_annotate_relation_if_relation_example_is_different_from_span_example`: A test that verifies a `ValidationError` is raised when attempting to create a `Relation` with spans that have different examples."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_span.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_span.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestSpanLabeling`\nCode:\nclass TestSpanLabeling(abc.ABC, TestCase):\n    overlapping = False\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, allow_overlapping=cls.overlapping, collaborative_annotation=cls.collaborative\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"SpanType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.span = Span(example=cls.example, label=cls.label_type, user=cls.user, start_offset=0, end_offset=5)\n\n    def test_can_annotate_span_to_unannotated_data(self):\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, allow_overlapping=cls.overlapping, collaborative_annotation=cls.collaborative\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"SpanType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.span = Span(example=cls.example, label=cls.label_type, user=cls.user, start_offset=0, end_offset=5)",
                                        "Function `test_can_annotate_span_to_unannotated_data`\nCode:\n    def test_can_annotate_span_to_unannotated_data(self):\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `NonCollaborativeMixin`\nCode:\nclass NonCollaborativeMixin:\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_same_span`\nCode:\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestNonOverlappingSpanLabeling`\nCode:\nclass TestNonOverlappingSpanLabeling(TestSpanLabeling, NonCollaborativeMixin):\n    overlapping = False\n    collaborative = False\n\n    def test_cannot_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_cannot_annotate_different_span_type_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_cannot_annotate_same_span_to_annotated_data`\nCode:\n    def test_cannot_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_cannot_annotate_different_span_type_to_annotated_data`\nCode:\n    def test_cannot_annotate_different_span_type_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Class `TestOverlappingSpanLabeling`\nCode:\nclass TestOverlappingSpanLabeling(TestSpanLabeling, NonCollaborativeMixin):\n    overlapping = True\n    collaborative = False\n\n    def test_can_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_can_annotate_same_span_to_annotated_data`\nCode:\n    def test_can_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestCollaborativeNonOverlappingSpanLabeling`\nCode:\nclass TestCollaborativeNonOverlappingSpanLabeling(TestSpanLabeling):\n    overlapping = False\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_same_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_deny_another_user_to_annotate_different_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_deny_another_user_to_annotate_same_span_type`\nCode:\n    def test_deny_another_user_to_annotate_same_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_deny_another_user_to_annotate_different_span_type`\nCode:\n    def test_deny_another_user_to_annotate_different_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Class `TestCollaborativeOverlappingSpanLabeling`\nCode:\nclass TestCollaborativeOverlappingSpanLabeling(TestSpanLabeling):\n    overlapping = True\n    collaborative = True\n\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_same_span`\nCode:\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestSpan`\nCode:\nclass TestSpan(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin\n\n    def test_start_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-1, end_offset=0)\n\n    def test_end_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-2, end_offset=-1)\n\n    def test_start_offset_is_less_than_end_offset(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=0, end_offset=0)\n\n    def test_unique_constraint(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user)\n\n    def test_unique_constraint_violated(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            with self.assertRaises(ValidationError):\n                mommy.make(\n                    \"Span\", example=self.example, start_offset=start_offset, end_offset=end_offset, user=self.user\n                )\n\n    def test_unique_constraint_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        user = project.admin\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            mommy.make(\"Span\", example=example, start_offset=start_offset, end_offset=end_offset, user=user)\n\n    def test_update(self):\n        span = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5)\n        span.end_offset = 6\n        span.save()",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin",
                                        "Function `test_start_offset_is_not_negative`\nCode:\n    def test_start_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-1, end_offset=0)",
                                        "Function `test_end_offset_is_not_negative`\nCode:\n    def test_end_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-2, end_offset=-1)",
                                        "Function `test_start_offset_is_less_than_end_offset`\nCode:\n    def test_start_offset_is_less_than_end_offset(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=0, end_offset=0)",
                                        "Function `test_unique_constraint`\nCode:\n    def test_unique_constraint(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user)",
                                        "Function `test_unique_constraint_violated`\nCode:\n    def test_unique_constraint_violated(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            with self.assertRaises(ValidationError):\n                mommy.make(\n                    \"Span\", example=self.example, start_offset=start_offset, end_offset=end_offset, user=self.user\n                )",
                                        "Function `test_unique_constraint_if_overlapping_is_allowed`\nCode:\n    def test_unique_constraint_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        user = project.admin\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            mommy.make(\"Span\", example=example, start_offset=start_offset, end_offset=end_offset, user=user)",
                                        "Function `test_update`\nCode:\n    def test_update(self):\n        span = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5)\n        span.end_offset = 6\n        span.save()",
                                        "Class `TestSpanWithoutCollaborativeMode`\nCode:\nclass TestSpanWithoutCollaborativeMode(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, False, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_allow_users_to_create_same_spans(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.admin)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.approver)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, False, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)",
                                        "Function `test_allow_users_to_create_same_spans`\nCode:\n    def test_allow_users_to_create_same_spans(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.admin)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.approver)",
                                        "Class `TestSpanWithCollaborativeMode`\nCode:\nclass TestSpanWithCollaborativeMode(TestCase):\n    def test_deny_users_to_create_same_spans(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=False)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)\n\n    def test_allow_users_to_create_same_spans_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)",
                                        "Function `test_deny_users_to_create_same_spans`\nCode:\n    def test_deny_users_to_create_same_spans(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=False)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)",
                                        "Function `test_allow_users_to_create_same_spans_if_overlapping_is_allowed`\nCode:\n    def test_allow_users_to_create_same_spans_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)",
                                        "Class `TestLabelDistribution`\nCode:\nclass TestLabelDistribution(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin\n\n    def test_calc_label_distribution(self):\n        label_a = mommy.make(\"SpanType\", text=\"labelA\", project=self.project.item)\n        label_b = mommy.make(\"SpanType\", text=\"labelB\", project=self.project.item)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user, label=label_a)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user, label=label_b)\n        distribution = Span.objects.calc_label_distribution(\n            examples=self.project.item.examples.all(), members=self.project.members, labels=SpanType.objects.all()\n        )\n        expected = {user.username: {label.text: 0 for label in SpanType.objects.all()} for user in self.project.members}\n        expected[self.user.username][label_a.text] = 1\n        expected[self.user.username][label_b.text] = 1\n        self.assertEqual(distribution, expected)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin",
                                        "Function `test_calc_label_distribution`\nCode:\n    def test_calc_label_distribution(self):\n        label_a = mommy.make(\"SpanType\", text=\"labelA\", project=self.project.item)\n        label_b = mommy.make(\"SpanType\", text=\"labelB\", project=self.project.item)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user, label=label_a)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user, label=label_b)\n        distribution = Span.objects.calc_label_distribution(\n            examples=self.project.item.examples.all(), members=self.project.members, labels=SpanType.objects.all()\n        )\n        expected = {user.username: {label.text: 0 for label in SpanType.objects.all()} for user in self.project.members}\n        expected[self.user.username][label_a.text] = 1\n        expected[self.user.username][label_b.text] = 1\n        self.assertEqual(distribution, expected)"
                                    ],
                                    "code": "import abc\n\nfrom django.core.exceptions import ValidationError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom label_types.models import SpanType\nfrom labels.models import Span\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestSpanLabeling(abc.ABC, TestCase):\n    overlapping = False\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\n            ProjectType.SEQUENCE_LABELING, allow_overlapping=cls.overlapping, collaborative_annotation=cls.collaborative\n        )\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.label_type = mommy.make(\"SpanType\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.span = Span(example=cls.example, label=cls.label_type, user=cls.user, start_offset=0, end_offset=5)\n\n    def test_can_annotate_span_to_unannotated_data(self):\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass NonCollaborativeMixin:\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestNonOverlappingSpanLabeling(TestSpanLabeling, NonCollaborativeMixin):\n    overlapping = False\n    collaborative = False\n\n    def test_cannot_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_cannot_annotate_different_span_type_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n\nclass TestOverlappingSpanLabeling(TestSpanLabeling, NonCollaborativeMixin):\n    overlapping = True\n    collaborative = False\n\n    def test_can_annotate_same_span_to_annotated_data(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestCollaborativeNonOverlappingSpanLabeling(TestSpanLabeling):\n    overlapping = False\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_same_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_deny_another_user_to_annotate_different_span_type(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertFalse(can_annotate)\n\n\nclass TestCollaborativeOverlappingSpanLabeling(TestSpanLabeling):\n    overlapping = True\n    collaborative = True\n\n    def test_allow_another_user_to_annotate_same_span(self):\n        mommy.make(\n            \"Span\",\n            example=self.example,\n            label=self.label_type,\n            user=self.another_user,\n            start_offset=self.span.start_offset,\n            end_offset=self.span.end_offset,\n        )\n        can_annotate = Span.objects.can_annotate(self.span, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestSpan(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin\n\n    def test_start_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-1, end_offset=0)\n\n    def test_end_offset_is_not_negative(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=-2, end_offset=-1)\n\n    def test_start_offset_is_less_than_end_offset(self):\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", start_offset=0, end_offset=0)\n\n    def test_unique_constraint(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5, user=self.user)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user)\n\n    def test_unique_constraint_violated(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            with self.assertRaises(ValidationError):\n                mommy.make(\n                    \"Span\", example=self.example, start_offset=start_offset, end_offset=end_offset, user=self.user\n                )\n\n    def test_unique_constraint_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        user = project.admin\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=user)\n        spans = [(5, 10), (5, 11), (4, 10), (6, 9), (9, 15), (0, 6)]\n        for start_offset, end_offset in spans:\n            mommy.make(\"Span\", example=example, start_offset=start_offset, end_offset=end_offset, user=user)\n\n    def test_update(self):\n        span = mommy.make(\"Span\", example=self.example, start_offset=0, end_offset=5)\n        span.end_offset = 6\n        span.save()\n\n\nclass TestSpanWithoutCollaborativeMode(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, False, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n\n    def test_allow_users_to_create_same_spans(self):\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.admin)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.project.approver)\n\n\nclass TestSpanWithCollaborativeMode(TestCase):\n    def test_deny_users_to_create_same_spans(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=False)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        with self.assertRaises(ValidationError):\n            mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)\n\n    def test_allow_users_to_create_same_spans_if_overlapping_is_allowed(self):\n        project = prepare_project(ProjectType.SEQUENCE_LABELING, True, allow_overlapping=True)\n        example = mommy.make(\"Example\", project=project.item)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.admin)\n        mommy.make(\"Span\", example=example, start_offset=5, end_offset=10, user=project.approver)\n\n\nclass TestLabelDistribution(TestCase):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.SEQUENCE_LABELING, allow_overlapping=False)\n        self.example = mommy.make(\"Example\", project=self.project.item)\n        self.user = self.project.admin\n\n    def test_calc_label_distribution(self):\n        label_a = mommy.make(\"SpanType\", text=\"labelA\", project=self.project.item)\n        label_b = mommy.make(\"SpanType\", text=\"labelB\", project=self.project.item)\n        mommy.make(\"Span\", example=self.example, start_offset=5, end_offset=10, user=self.user, label=label_a)\n        mommy.make(\"Span\", example=self.example, start_offset=10, end_offset=15, user=self.user, label=label_b)\n        distribution = Span.objects.calc_label_distribution(\n            examples=self.project.item.examples.all(), members=self.project.members, labels=SpanType.objects.all()\n        )\n        expected = {user.username: {label.text: 0 for label in SpanType.objects.all()} for user in self.project.members}\n        expected[self.user.username][label_a.text] = 1\n        expected[self.user.username][label_b.text] = 1\n        self.assertEqual(distribution, expected)\n",
                                    "summary": "Class TestSpanLabeling: An abstract test case framework designed to validate span annotation functionality, including collaborative and non-collaborative constraints, as well as the integrity of span annotations within sequence labeling projects.",
                                    "code_element_summaries": [
                                        "Class TestSpanLabeling: An abstract test case for validating span annotation functionality in sequence labeling projects, including setup for test data and a test method to check annotation permissions.",
                                        "Function `setUpTestData`: A class method that initializes test data by preparing a project, creating an example, generating a label type, and setting up user roles and a span instance for testing purposes.",
                                        "Function `test_can_annotate_span_to_unannotated_data`: A test case that verifies if a span can be annotated to unannotated data within a specific project item.",
                                        "Class `NonCollaborativeMixin`: A mixin that tests whether another user can annotate the same span in a project, ensuring collaborative constraints are respected.",
                                        "Function `test_allow_another_user_to_annotate_same_span`: A test case that verifies whether another user can annotate a span that has already been annotated by a different user.",
                                        "Class `TestNonOverlappingSpanLabeling`: A test case that ensures spans cannot be annotated multiple times or with different types in a non-overlapping and non-collaborative context.",
                                        "Function `test_cannot_annotate_same_span_to_annotated_data`: A test case that verifies that an attempt to annotate a span that has already been annotated fails, ensuring the integrity of annotations in the system.",
                                        "Function `test_cannot_annotate_different_span_type_to_annotated_data`: A test case that verifies that a specific span cannot be annotated to the annotated data when the span type differs, asserting that the annotation is not permitted.",
                                        "Class TestOverlappingSpanLabeling: A test case for verifying the ability to annotate overlapping spans in non-collaborative settings.",
                                        "Function `test_can_annotate_same_span_to_annotated_data`: A test that verifies if the same span can be annotated to annotated data by checking the annotation capability and asserting its truthiness.",
                                        "Class `TestCollaborativeNonOverlappingSpanLabeling`: A test case that verifies that users cannot annotate the same or different span types collaboratively within a non-overlapping span labeling context.",
                                        "Function `test_deny_another_user_to_annotate_same_span_type`: A test case that verifies that another user cannot annotate a span of the same type within the specified offsets.",
                                        "Function `test_deny_another_user_to_annotate_different_span_type`: A test case that verifies that a different user cannot annotate a span of a different type within the same project.",
                                        "Class `TestCollaborativeOverlappingSpanLabeling`: A test case for verifying that multiple users can collaboratively annotate overlapping spans in a labeling system.",
                                        "Function `test_allow_another_user_to_annotate_same_span`: A test case that verifies whether a different user can annotate a span that has already been annotated, asserting that the annotation is allowed.",
                                        "Class TestSpan: A test case for validating the constraints and behaviors of the Span model, including checks for negative offsets, uniqueness, and updates within a sequence labeling project.",
                                        "Function `setUp`: A setup method that initializes a sequence labeling project, creates an example associated with the project, and assigns the project administrator to a user variable.",
                                        "Function `test_start_offset_is_not_negative`: A test that verifies a `ValidationError` is raised when attempting to create a `Span` object with a negative `start_offset`.",
                                        "Function `test_end_offset_is_not_negative`: A unit test that verifies a `ValidationError` is raised when attempting to create a `Span` object with a negative `start_offset`.",
                                        "Function `test_start_offset_is_less_than_end_offset`: A unit test that verifies a `ValidationError` is raised when a `Span` object is created with equal start and end offsets.",
                                        "Function `test_unique_constraint`: A test function that creates multiple `Span` instances with specified offsets for a given example and user, ensuring unique constraints are respected.",
                                        "Function `test_unique_constraint_violated`: A test that verifies a unique constraint violation by attempting to create overlapping Span instances and expecting a ValidationError for each.",
                                        "Function `test_unique_constraint_if_overlapping_is_allowed`: A test function that verifies the creation of overlapping spans in a sequence labeling project where overlapping is permitted.",
                                        "Function `test_update`: A test function that creates a Span object, modifies its end_offset, and saves the updated object.",
                                        "Class TestSpanWithoutCollaborativeMode: A test case that verifies the ability of different users to create overlapping spans in a sequence labeling project.",
                                        "Function `setUp`: Initializes a test environment by preparing a sequence labeling project and creating an example associated with that project.",
                                        "Function `test_allow_users_to_create_same_spans`: A test function that verifies that multiple users can create overlapping span annotations with the same start and end offsets for a given example.",
                                        "Class TestSpanWithCollaborativeMode: A test case that verifies the behavior of span creation permissions based on overlapping settings in a collaborative environment.",
                                        "Function `test_deny_users_to_create_same_spans`: A test case that verifies users are prevented from creating overlapping spans in a sequence labeling project, raising a ValidationError when attempting to do so.",
                                        "Function `test_allow_users_to_create_same_spans_if_overlapping_is_allowed`: A test function that verifies users can create overlapping spans in a sequence labeling project when overlapping is permitted.",
                                        "Class TestLabelDistribution: A unit test that verifies the correct calculation of label distribution for span annotations in a sequence labeling project.",
                                        "Function `setUp`: Initializes a test environment by preparing a sequence labeling project, creating an example associated with that project, and assigning the project admin as the user.",
                                        "Function `test_calc_label_distribution`: A unit test that verifies the label distribution calculation for spans associated with specific labels and users within a project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_text_label.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_text_label.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestTextLabeling`\nCode:\nclass TestTextLabeling(abc.ABC, TestCase):\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=cls.collaborative)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.text_label = TextLabel(example=cls.example, user=cls.user, text=\"foo\")\n\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n\n    def test_uniqueness(self):\n        a = mommy.make(\"TextLabel\")\n        with self.assertRaises(IntegrityError):\n            TextLabel(example=a.example, user=a.user, text=a.text).save()",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=cls.collaborative)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.text_label = TextLabel(example=cls.example, user=cls.user, text=\"foo\")",
                                        "Function `test_can_annotate_category_to_unannotated_data`\nCode:\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_uniqueness`\nCode:\n    def test_uniqueness(self):\n        a = mommy.make(\"TextLabel\")\n        with self.assertRaises(IntegrityError):\n            TextLabel(example=a.example, user=a.user, text=a.text).save()",
                                        "Class `TestNonCollaborativeTextLabeling`\nCode:\nclass TestNonCollaborativeTextLabeling(TestTextLabeling):\n    collaborative = False\n\n    def test_cannot_annotate_same_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_can_annotate_different_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n\n    def test_allow_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_cannot_annotate_same_text_to_annotated_data`\nCode:\n    def test_cannot_annotate_same_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_can_annotate_different_text_to_annotated_data`\nCode:\n    def test_can_annotate_different_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_same_text`\nCode:\n    def test_allow_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Class `TestCollaborativeTextLabeling`\nCode:\nclass TestCollaborativeTextLabeling(TestTextLabeling):\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_allow_another_user_to_annotate_different_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)",
                                        "Function `test_deny_another_user_to_annotate_same_text`\nCode:\n    def test_deny_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)",
                                        "Function `test_allow_another_user_to_annotate_different_text`\nCode:\n    def test_allow_another_user_to_annotate_different_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)"
                                    ],
                                    "code": "import abc\n\nfrom django.db import IntegrityError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom labels.models import TextLabel\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestTextLabeling(abc.ABC, TestCase):\n    collaborative = False\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.SEQ2SEQ, collaborative_annotation=cls.collaborative)\n        cls.example = mommy.make(\"Example\", project=cls.project.item)\n        cls.user = cls.project.admin\n        cls.another_user = cls.project.approver\n        cls.text_label = TextLabel(example=cls.example, user=cls.user, text=\"foo\")\n\n    def test_can_annotate_category_to_unannotated_data(self):\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n\n    def test_uniqueness(self):\n        a = mommy.make(\"TextLabel\")\n        with self.assertRaises(IntegrityError):\n            TextLabel(example=a.example, user=a.user, text=a.text).save()\n\n\nclass TestNonCollaborativeTextLabeling(TestTextLabeling):\n    collaborative = False\n\n    def test_cannot_annotate_same_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_can_annotate_different_text_to_annotated_data(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n\n    def test_allow_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n\n\nclass TestCollaborativeTextLabeling(TestTextLabeling):\n    collaborative = True\n\n    def test_deny_another_user_to_annotate_same_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user, text=self.text_label.text)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertFalse(can_annotate)\n\n    def test_allow_another_user_to_annotate_different_text(self):\n        mommy.make(\"TextLabel\", example=self.example, user=self.another_user)\n        can_annotate = TextLabel.objects.can_annotate(self.text_label, self.project.item)\n        self.assertTrue(can_annotate)\n",
                                    "summary": "Class `TestTextLabeling` and its associated methods provide a framework for testing the functionality and constraints of the `TextLabel` model, focusing on annotation capabilities, uniqueness, and collaborative versus non-collaborative behaviors in text labeling scenarios.",
                                    "code_element_summaries": [
                                        "Class `TestTextLabeling`: An abstract test case for verifying the functionality and constraints of the `TextLabel` model, including annotation capabilities and uniqueness of entries.",
                                        "Function `setUpTestData`: A class method that initializes test data by preparing a project, creating an example, and setting up user and label instances for testing purposes.",
                                        "Function `test_can_annotate_category_to_unannotated_data`: A test case that verifies whether a specific text label can be annotated to unannotated data within a project.",
                                        "Function `test_uniqueness`: A test that verifies an IntegrityError is raised when attempting to save a duplicate TextLabel instance with the same example, user, and text.",
                                        "Class TestNonCollaborativeTextLabeling: A test suite for verifying non-collaborative text labeling behavior, ensuring that the same text cannot be annotated by the same user while allowing different texts and annotations by different users.",
                                        "Function `test_cannot_annotate_same_text_to_annotated_data`: A test case that verifies that the same text label cannot be annotated multiple times to the same annotated data.",
                                        "Function `test_can_annotate_different_text_to_annotated_data`: A test case that verifies if a user can annotate a text label to a specific project item.",
                                        "Function `test_allow_another_user_to_annotate_same_text`: A test case that verifies if another user can annotate the same text label in a given project.",
                                        "Class `TestCollaborativeTextLabeling`: A test case that verifies collaborative text labeling functionality by ensuring that users cannot annotate the same text while allowing annotations on different texts.",
                                        "Function `test_deny_another_user_to_annotate_same_text`: A test case that verifies that another user cannot annotate the same text label in a specific project.",
                                        "Function `test_allow_another_user_to_annotate_different_text`: A test case that verifies whether a different user can annotate a text label associated with a specific project item."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestLabelList`\nCode:\nclass TestLabelList:\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task)\n        cls.non_member = make_user()\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)\n\n    def test_allows_project_member_to_fetch_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)  # fetch only own annotation\n\n    def test_denies_non_project_member_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 2)  # delete only own annotation",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task)\n        cls.non_member = make_user()\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)",
                                        "Function `test_allows_project_member_to_fetch_annotation`\nCode:\n    def test_allows_project_member_to_fetch_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)  # fetch only own annotation",
                                        "Function `test_denies_non_project_member_to_fetch_annotation`\nCode:\n    def test_denies_non_project_member_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_fetch_annotation`\nCode:\n    def test_denies_unauthenticated_user_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_member_to_bulk_delete_annotation`\nCode:\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 2)  # delete only own annotation",
                                        "Class `TestCategoryList`\nCode:\nclass TestCategoryList(TestLabelList, CRUDMixin):\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_list\"",
                                        "Class `TestSpanList`\nCode:\nclass TestSpanList(TestLabelList, CRUDMixin):\n    model = Span\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=0, end_offset=1)",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=0, end_offset=1)",
                                        "Class `TestBBoxList`\nCode:\nclass TestBBoxList(TestLabelList, CRUDMixin):\n    model = BoundingBox\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        mommy.make(\"BoundingBox\", example=doc, user=member, x=0, y=0, width=0, height=0)",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        mommy.make(\"BoundingBox\", example=doc, user=member, x=0, y=0, width=0, height=0)",
                                        "Class `TestSegmentationList`\nCode:\nclass TestSegmentationList(TestLabelList, CRUDMixin):\n    model = Segmentation\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        mommy.make(\"Segmentation\", example=doc, user=member, points=[0, 1])",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        mommy.make(\"Segmentation\", example=doc, user=member, points=[0, 1])",
                                        "Class `TestTextList`\nCode:\nclass TestTextList(TestLabelList, CRUDMixin):\n    model = TextLabel\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"",
                                        "Class `TestSharedLabelList`\nCode:\nclass TestSharedLabelList:\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task, collaborative_annotation=True)\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)\n\n    def test_allows_project_member_to_fetch_all_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 3)\n\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 0)  # delete all annotation in the doc",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task, collaborative_annotation=True)\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)",
                                        "Function `test_allows_project_member_to_fetch_all_annotation`\nCode:\n    def test_allows_project_member_to_fetch_all_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 3)",
                                        "Function `test_allows_project_member_to_bulk_delete_annotation`\nCode:\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 0)  # delete all annotation in the doc",
                                        "Class `TestSharedCategoryList`\nCode:\nclass TestSharedCategoryList(TestSharedLabelList, CRUDMixin):\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_list\"",
                                        "Class `TestSharedSpanList`\nCode:\nclass TestSharedSpanList(TestSharedLabelList, CRUDMixin):\n    model = Span\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n    start_offset = 0\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=cls.start_offset, end_offset=cls.start_offset + 1)\n        cls.start_offset += 1",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=cls.start_offset, end_offset=cls.start_offset + 1)\n        cls.start_offset += 1",
                                        "Class `TestSharedTextList`\nCode:\nclass TestSharedTextList(TestSharedLabelList, CRUDMixin):\n    model = TextLabel\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"",
                                        "Class `TestDataLabeling`\nCode:\nclass TestDataLabeling:\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        self.data = self.create_data()\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, self.doc.id])\n\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_non_project_member_to_annotate(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_annotate(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        self.data = self.create_data()\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, self.doc.id])",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id}",
                                        "Function `test_allows_project_member_to_annotate`\nCode:\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Function `test_denies_non_project_member_to_annotate`\nCode:\n    def test_denies_non_project_member_to_annotate(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_annotate`\nCode:\n    def test_denies_unauthenticated_user_to_annotate(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestCategoryCreation`\nCode:\nclass TestCategoryCreation(TestDataLabeling, CRUDMixin):\n    view_name = \"category_list\"",
                                        "Class `TestSpanCreation`\nCode:\nclass TestSpanCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id, \"start_offset\": 0, \"end_offset\": 1}",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id, \"start_offset\": 0, \"end_offset\": 1}",
                                        "Class `TestRelationCreation`\nCode:\nclass TestRelationCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"relation_list\"\n\n    def create_data(self):\n        relation_type = mommy.make(\"RelationType\", project=self.project.item)\n        from_id = mommy.make(\"Span\", example=self.doc, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.doc, start_offset=1, end_offset=2)\n        return {\"type\": relation_type.id, \"from_id\": from_id.id, \"to_id\": to_id.id}",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        relation_type = mommy.make(\"RelationType\", project=self.project.item)\n        from_id = mommy.make(\"Span\", example=self.doc, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.doc, start_offset=1, end_offset=2)\n        return {\"type\": relation_type.id, \"from_id\": from_id.id, \"to_id\": to_id.id}",
                                        "Class `TestTextLabelCreation`\nCode:\nclass TestTextLabelCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"\n\n    def create_data(self):\n        return {\"text\": \"example\"}",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        return {\"text\": \"example\"}",
                                        "Class `TestBoundingBoxCreation`\nCode:\nclass TestBoundingBoxCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_list\"\n\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"x\": 0, \"y\": 0, \"width\": 0, \"height\": 0, \"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"x\": 0, \"y\": 0, \"width\": 0, \"height\": 0, \"label\": label.id}",
                                        "Function `test_allows_project_member_to_annotate`\nCode:\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Class `TestSegmentationCreation`\nCode:\nclass TestSegmentationCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_list\"\n\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"points\": [1, 2], \"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Function `create_data`\nCode:\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"points\": [1, 2], \"label\": label.id}",
                                        "Function `test_allows_project_member_to_annotate`\nCode:\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Class `TestLabelDetail`\nCode:\nclass TestLabelDetail:\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"annotation_detail\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        label = make_label(self.project.item)\n        annotation = self.create_annotation_data(doc=doc)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin, start_offset=0, end_offset=1)\n\n    def test_allows_owner_to_get_annotation(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_owner_to_get_annotation(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_get_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_annotation(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_owner_to_update_annotation(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_owner_to_update_annotation(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_annotation(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_owner_to_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_owner_to_delete_annotation(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_annotation(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        label = make_label(self.project.item)\n        annotation = self.create_annotation_data(doc=doc)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])",
                                        "Function `create_annotation_data`\nCode:\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin, start_offset=0, end_offset=1)",
                                        "Function `test_allows_owner_to_get_annotation`\nCode:\n    def test_allows_owner_to_get_annotation(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_non_owner_to_get_annotation`\nCode:\n    def test_denies_non_owner_to_get_annotation(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_get_annotation`\nCode:\n    def test_denies_non_project_member_to_get_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_get_annotation`\nCode:\n    def test_denies_unauthenticated_user_to_get_annotation(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_owner_to_update_annotation`\nCode:\n    def test_allows_owner_to_update_annotation(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_non_owner_to_update_annotation`\nCode:\n    def test_denies_non_owner_to_update_annotation(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_update_annotation`\nCode:\n    def test_denies_non_project_member_to_update_annotation(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_owner_to_delete_annotation`\nCode:\n    def test_allows_owner_to_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_non_owner_to_delete_annotation`\nCode:\n    def test_denies_non_owner_to_delete_annotation(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_delete_annotation`\nCode:\n    def test_denies_non_project_member_to_delete_annotation(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Class `TestCategoryDetail`\nCode:\nclass TestCategoryDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_detail\"\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)",
                                        "Function `create_annotation_data`\nCode:\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)",
                                        "Class `TestSpanDetail`\nCode:\nclass TestSpanDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_detail\"",
                                        "Class `TestTextDetail`\nCode:\nclass TestTextDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_detail\"\n\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}",
                                        "Function `create_annotation_data`\nCode:\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)",
                                        "Class `TestBBoxDetail`\nCode:\nclass TestBBoxDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_detail\"\n\n    def create_annotation_data(self, doc):\n        return mommy.make(\"BoundingBox\", example=doc, user=self.project.admin, x=0, y=0, width=0, height=0)",
                                        "Function `create_annotation_data`\nCode:\n    def create_annotation_data(self, doc):\n        return mommy.make(\"BoundingBox\", example=doc, user=self.project.admin, x=0, y=0, width=0, height=0)",
                                        "Class `TestSegmentationDetail`\nCode:\nclass TestSegmentationDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_detail\"\n\n    def create_annotation_data(self, doc):\n        return mommy.make(\"Segmentation\", example=doc, user=self.project.admin, points=[1, 2])",
                                        "Function `create_annotation_data`\nCode:\n    def create_annotation_data(self, doc):\n        return mommy.make(\"Segmentation\", example=doc, user=self.project.admin, points=[1, 2])",
                                        "Class `TestSharedLabelDetail`\nCode:\nclass TestSharedLabelDetail:\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_detail\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task, collaborative_annotation=True)\n        doc = make_doc(self.project.item)\n        annotation = self.make_annotation(doc, self.project.admin)\n        label = make_label(self.project.item)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])\n\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member)\n\n    def test_allows_any_member_to_get_annotation(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_allows_any_member_to_update_annotation(self):\n        for member in self.project.members:\n            self.assert_update(member, status.HTTP_200_OK)\n\n    def test_allows_any_member_to_delete_annotation(self):\n        self.assert_delete(self.project.approver, status.HTTP_204_NO_CONTENT)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(task=self.task, collaborative_annotation=True)\n        doc = make_doc(self.project.item)\n        annotation = self.make_annotation(doc, self.project.admin)\n        label = make_label(self.project.item)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member)",
                                        "Function `test_allows_any_member_to_get_annotation`\nCode:\n    def test_allows_any_member_to_get_annotation(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)",
                                        "Function `test_allows_any_member_to_update_annotation`\nCode:\n    def test_allows_any_member_to_update_annotation(self):\n        for member in self.project.members:\n            self.assert_update(member, status.HTTP_200_OK)",
                                        "Function `test_allows_any_member_to_delete_annotation`\nCode:\n    def test_allows_any_member_to_delete_annotation(self):\n        self.assert_delete(self.project.approver, status.HTTP_204_NO_CONTENT)",
                                        "Class `TestSharedCategoryDetail`\nCode:\nclass TestSharedCategoryDetail(TestSharedLabelDetail, CRUDMixin):\n    view_name = \"category_detail\"",
                                        "Class `TestSharedSpanDetail`\nCode:\nclass TestSharedSpanDetail(TestSharedLabelDetail, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_detail\"\n\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member, start_offset=0, end_offset=1)",
                                        "Function `make_annotation`\nCode:\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member, start_offset=0, end_offset=1)",
                                        "Class `TestSharedTextDetail`\nCode:\nclass TestSharedTextDetail(TestSharedLabelDetail, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_detail\"\n\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}"
                                    ],
                                    "code": "import uuid\n\nfrom model_mommy import mommy\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import make_annotation\nfrom api.tests.utils import CRUDMixin\nfrom examples.tests.utils import make_doc\nfrom label_types.tests.utils import make_label\nfrom labels.models import BoundingBox, Category, Segmentation, Span, TextLabel\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestLabelList:\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task)\n        cls.non_member = make_user()\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)\n\n    def test_allows_project_member_to_fetch_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)  # fetch only own annotation\n\n    def test_denies_non_project_member_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_fetch_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 2)  # delete only own annotation\n\n\nclass TestCategoryList(TestLabelList, CRUDMixin):\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_list\"\n\n\nclass TestSpanList(TestLabelList, CRUDMixin):\n    model = Span\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=0, end_offset=1)\n\n\nclass TestBBoxList(TestLabelList, CRUDMixin):\n    model = BoundingBox\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        mommy.make(\"BoundingBox\", example=doc, user=member, x=0, y=0, width=0, height=0)\n\n\nclass TestSegmentationList(TestLabelList, CRUDMixin):\n    model = Segmentation\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_list\"\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        mommy.make(\"Segmentation\", example=doc, user=member, points=[0, 1])\n\n\nclass TestTextList(TestLabelList, CRUDMixin):\n    model = TextLabel\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"\n\n\nclass TestSharedLabelList:\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(task=cls.task, collaborative_annotation=True)\n        doc = make_doc(cls.project.item)\n        for member in cls.project.members:\n            cls.make_annotation(doc, member)\n        cls.url = reverse(viewname=cls.view_name, args=[cls.project.item.id, doc.id])\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member)\n\n    def test_allows_project_member_to_fetch_all_annotation(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 3)\n\n    def test_allows_project_member_to_bulk_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        count = self.model.objects.count()\n        self.assertEqual(count, 0)  # delete all annotation in the doc\n\n\nclass TestSharedCategoryList(TestSharedLabelList, CRUDMixin):\n    model = Category\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_list\"\n\n\nclass TestSharedSpanList(TestSharedLabelList, CRUDMixin):\n    model = Span\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n    start_offset = 0\n\n    @classmethod\n    def make_annotation(cls, doc, member):\n        make_annotation(cls.task, doc=doc, user=member, start_offset=cls.start_offset, end_offset=cls.start_offset + 1)\n        cls.start_offset += 1\n\n\nclass TestSharedTextList(TestSharedLabelList, CRUDMixin):\n    model = TextLabel\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"\n\n\nclass TestDataLabeling:\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_list\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        self.doc = make_doc(self.project.item)\n        self.data = self.create_data()\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, self.doc.id])\n\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_non_project_member_to_annotate(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_annotate(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestCategoryCreation(TestDataLabeling, CRUDMixin):\n    view_name = \"category_list\"\n\n\nclass TestSpanCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_list\"\n\n    def create_data(self):\n        label = make_label(self.project.item)\n        return {\"label\": label.id, \"start_offset\": 0, \"end_offset\": 1}\n\n\nclass TestRelationCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"relation_list\"\n\n    def create_data(self):\n        relation_type = mommy.make(\"RelationType\", project=self.project.item)\n        from_id = mommy.make(\"Span\", example=self.doc, start_offset=0, end_offset=1)\n        to_id = mommy.make(\"Span\", example=self.doc, start_offset=1, end_offset=2)\n        return {\"type\": relation_type.id, \"from_id\": from_id.id, \"to_id\": to_id.id}\n\n\nclass TestTextLabelCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_list\"\n\n    def create_data(self):\n        return {\"text\": \"example\"}\n\n\nclass TestBoundingBoxCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_list\"\n\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"x\": 0, \"y\": 0, \"width\": 0, \"height\": 0, \"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n\nclass TestSegmentationCreation(TestDataLabeling, CRUDMixin):\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_list\"\n\n    def create_data(self):\n        label = mommy.make(\"CategoryType\", project=self.project.item)\n        return {\"points\": [1, 2], \"label\": label.id}\n\n    def test_allows_project_member_to_annotate(self):\n        for member in self.project.members:\n            self.data[\"uuid\"] = str(uuid.uuid4())\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n\nclass TestLabelDetail:\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"annotation_detail\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task)\n        self.non_member = make_user()\n        doc = make_doc(self.project.item)\n        label = make_label(self.project.item)\n        annotation = self.create_annotation_data(doc=doc)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin, start_offset=0, end_offset=1)\n\n    def test_allows_owner_to_get_annotation(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_owner_to_get_annotation(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_get_annotation(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_get_annotation(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_owner_to_update_annotation(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_non_owner_to_update_annotation(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_annotation(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_owner_to_delete_annotation(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_non_owner_to_delete_annotation(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_annotation(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n\nclass TestCategoryDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"category_detail\"\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)\n\n\nclass TestSpanDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_detail\"\n\n\nclass TestTextDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_detail\"\n\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}\n\n    def create_annotation_data(self, doc):\n        return make_annotation(task=self.task, doc=doc, user=self.project.admin)\n\n\nclass TestBBoxDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.BOUNDING_BOX\n    view_name = \"bbox_detail\"\n\n    def create_annotation_data(self, doc):\n        return mommy.make(\"BoundingBox\", example=doc, user=self.project.admin, x=0, y=0, width=0, height=0)\n\n\nclass TestSegmentationDetail(TestLabelDetail, CRUDMixin):\n    task = ProjectType.SEGMENTATION\n    view_name = \"segmentation_detail\"\n\n    def create_annotation_data(self, doc):\n        return mommy.make(\"Segmentation\", example=doc, user=self.project.admin, points=[1, 2])\n\n\nclass TestSharedLabelDetail:\n    task = ProjectType.DOCUMENT_CLASSIFICATION\n    view_name = \"annotation_detail\"\n\n    def setUp(self):\n        self.project = prepare_project(task=self.task, collaborative_annotation=True)\n        doc = make_doc(self.project.item)\n        annotation = self.make_annotation(doc, self.project.admin)\n        label = make_label(self.project.item)\n        self.data = {\"label\": label.id}\n        self.url = reverse(viewname=self.view_name, args=[self.project.item.id, doc.id, annotation.id])\n\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member)\n\n    def test_allows_any_member_to_get_annotation(self):\n        for member in self.project.members:\n            self.assert_fetch(member, status.HTTP_200_OK)\n\n    def test_allows_any_member_to_update_annotation(self):\n        for member in self.project.members:\n            self.assert_update(member, status.HTTP_200_OK)\n\n    def test_allows_any_member_to_delete_annotation(self):\n        self.assert_delete(self.project.approver, status.HTTP_204_NO_CONTENT)\n\n\nclass TestSharedCategoryDetail(TestSharedLabelDetail, CRUDMixin):\n    view_name = \"category_detail\"\n\n\nclass TestSharedSpanDetail(TestSharedLabelDetail, CRUDMixin):\n    task = ProjectType.SEQUENCE_LABELING\n    view_name = \"span_detail\"\n\n    def make_annotation(self, doc, member):\n        return make_annotation(self.task, doc=doc, user=member, start_offset=0, end_offset=1)\n\n\nclass TestSharedTextDetail(TestSharedLabelDetail, CRUDMixin):\n    task = ProjectType.SEQ2SEQ\n    view_name = \"text_detail\"\n\n    def setUp(self):\n        super().setUp()\n        self.data = {\"text\": \"changed\"}\n",
                                    "summary": "The content describes a comprehensive suite of test cases and classes for managing annotations in a document classification and sequence labeling project, ensuring that project members can create, retrieve, update, and delete their annotations while enforcing access restrictions for non-members and unauthenticated users.",
                                    "code_element_summaries": [
                                        "Class `TestLabelList`: A test case for managing annotations in a document classification project, ensuring that project members can fetch and bulk delete their annotations while non-members and unauthenticated users are denied access.",
                                        "Function `setUpTestData`: A class method that prepares test data by creating a project, a non-member user, a document, and annotations for project members, as well as generating a URL for accessing the document.",
                                        "Function `make_annotation`: A class method that generates an annotation by calling the `make_annotation` function with the task of the class, a document, and a user member.",
                                        "Function `test_allows_project_member_to_fetch_annotation`: A test case that verifies each project member can successfully fetch their own annotation, expecting a 200 OK response and a single annotation in the response data.",
                                        "Function `test_denies_non_project_member_to_fetch_annotation`: A test case that verifies a non-project member receives a 403 Forbidden status when attempting to fetch an annotation.",
                                        "Function `test_denies_unauthenticated_user_to_fetch_annotation`: A test that verifies an unauthenticated user receives a 403 Forbidden status when attempting to fetch an annotation.",
                                        "Function `test_allows_project_member_to_bulk_delete_annotation`: A test that verifies a project member can successfully bulk delete their own annotations, expecting a 204 NO CONTENT response and confirming the count of remaining annotations.",
                                        "Class TestCategoryList: A subclass of TestLabelList and CRUDMixin that manages a list of categories for document classification tasks.",
                                        "Class `TestSpanList`: A subclass of TestLabelList and CRUDMixin that facilitates the creation of span annotations for sequence labeling tasks.",
                                        "Function `make_annotation`: A class method that creates an annotation by invoking another `make_annotation` function with specified parameters including task, document, user, and offsets.",
                                        "Class TestBBoxList: A subclass of TestLabelList and CRUDMixin that defines a model for managing bounding box annotations in a specified project type and view.",
                                        "Function `make_annotation`: A class method that creates a `BoundingBox` instance with specified parameters using the `mommy` library.",
                                        "Class TestSegmentationList: A subclass of TestLabelList and CRUDMixin that manages segmentation annotations, specifying the model, task type, and providing a method to create annotations.",
                                        "Function `make_annotation`: A class method that creates a \"Segmentation\" instance associated with a document and a user, using specified points.",
                                        "Class TestTextList: A model that extends TestLabelList and CRUDMixin for managing a list of text labels in a sequence-to-sequence project.",
                                        "Class TestSharedLabelList: A test case for ensuring that project members can fetch and bulk delete annotations in a document classification project.",
                                        "Function `setUpTestData`: A class method that prepares test data by creating a project with collaborative annotation, generating a document, and making annotations for each project member, while also setting the URL for accessing the document.",
                                        "Function `make_annotation`: A class method that creates an annotation by invoking the `make_annotation` function with the task of the class, along with a document and a user member.",
                                        "Function `test_allows_project_member_to_fetch_all_annotation`: A test that verifies each member of a project can successfully fetch all annotations, expecting a response with three annotation items.",
                                        "Function `test_allows_project_member_to_bulk_delete_annotation`: A test that verifies a project member can successfully bulk delete annotations, resulting in a count of zero annotations remaining.",
                                        "Class TestSharedCategoryList: A test class for managing shared categories in document classification, inheriting from TestSharedLabelList and CRUDMixin.",
                                        "Class TestSharedSpanList: A subclass of TestSharedLabelList that manages span annotations for sequence labeling tasks, providing a method to create annotations with an incrementing start offset.",
                                        "Function `make_annotation`: A class method that creates an annotation for a document by invoking another `make_annotation` function, while incrementally updating a start offset.",
                                        "Class TestSharedTextList: A subclass of TestSharedLabelList and CRUDMixin that defines a model for text labels in a sequence-to-sequence project context.",
                                        "Class `TestDataLabeling`: A test case that verifies annotation permissions for project members, non-members, and unauthenticated users in a document classification project.",
                                        "Function `setUp`: A setup method that initializes a project, creates a non-member user, generates a document, prepares data, and constructs a URL for testing purposes.",
                                        "Function `create_data`: Generates a dictionary containing the ID of a label created from the project's item.",
                                        "Function `test_allows_project_member_to_annotate`: A test that verifies all members of a project are allowed to create annotations, expecting a successful creation status.",
                                        "Function `test_denies_non_project_member_to_annotate`: A test case that verifies non-project members receive a 403 Forbidden status when attempting to create annotations.",
                                        "Function `test_denies_unauthenticated_user_to_annotate`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to create an annotation.",
                                        "Class TestCategoryCreation: A test case for creating categories, inheriting from TestDataLabeling and CRUDMixin, with a specified view name for the category list.",
                                        "Class `TestSpanCreation`: A test class for creating span annotations in a sequence labeling project, integrating data labeling and CRUD operations.",
                                        "Function `create_data`: Generates a dictionary containing a label ID and offset values for a project item.",
                                        "Class `TestRelationCreation`: A test class for creating relation data in a sequence labeling project using specified relation types and span identifiers.",
                                        "Function `create_data`: Generates a dictionary containing a relation type ID and the IDs of two spans created in a document.",
                                        "Class TestTextLabelCreation: A test case for creating text labels in a sequence-to-sequence project, inheriting from TestDataLabeling and CRUDMixin.",
                                        "Function `create_data`: A method that returns a dictionary containing a single key-value pair with the key \"text\" and the value \"example\".",
                                        "Class TestBoundingBoxCreation: A test case that verifies if project members can create bounding box annotations by generating sample data and asserting successful creation.",
                                        "Function `create_data`: Generates a dictionary containing default bounding box coordinates and a label ID for a specific project category.",
                                        "Function `test_allows_project_member_to_annotate`: A test that verifies if each member of a project can successfully create annotations with a generated UUID.",
                                        "Class TestSegmentationCreation: A test case that verifies project members can create segmentation annotations by generating data and asserting successful creation.",
                                        "Function `create_data`: Generates a dictionary containing a list of points and the ID of a newly created CategoryType associated with the current project.",
                                        "Function `test_allows_project_member_to_annotate`: A test function that verifies that each member of a project can successfully create annotations, asserting a successful creation status for each member.",
                                        "Class TestLabelDetail: A test suite that verifies the permissions for creating, retrieving, updating, and deleting annotations in a sequence labeling project, ensuring that only the owner can perform these actions while denying access to non-owners and unauthorized users.",
                                        "Function `setUp`: Initializes test data by preparing a project, creating a user, document, label, and annotation, and sets up a URL for accessing a specific view related to the project item and annotation.",
                                        "Function `create_annotation_data`: A method that generates annotation data by utilizing the `make_annotation` function with specified parameters including task, document, user, and offset values.",
                                        "Function `test_allows_owner_to_get_annotation`: A test that verifies the project owner can successfully retrieve an annotation with a status code of 200 OK.",
                                        "Function `test_denies_non_owner_to_get_annotation`: A test case that verifies non-owner project staff members receive a 403 Forbidden status when attempting to access an annotation.",
                                        "Function `test_denies_non_project_member_to_get_annotation`: A test that verifies a non-project member receives a forbidden status when attempting to access an annotation.",
                                        "Function `test_denies_unauthenticated_user_to_get_annotation`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to fetch an annotation.",
                                        "Function `test_allows_owner_to_update_annotation`: A test case that verifies the project owner can successfully update an annotation, expecting a HTTP 200 OK status.",
                                        "Function `test_denies_non_owner_to_update_annotation`: A test case that verifies that non-owners of an annotation receive a forbidden status when attempting to update it.",
                                        "Function `test_denies_non_project_member_to_update_annotation`: A test case that verifies a non-project member receives a 403 Forbidden status when attempting to update an annotation.",
                                        "Function `test_allows_owner_to_delete_annotation`: A test case that verifies the project owner can successfully delete an annotation, expecting a 204 No Content status.",
                                        "Function `test_denies_non_owner_to_delete_annotation`: A test that verifies non-owners of an annotation receive a forbidden status when attempting to delete it.",
                                        "Function `test_denies_non_project_member_to_delete_annotation`: A test case that verifies a non-project member receives a 403 Forbidden status when attempting to delete an annotation.",
                                        "Class TestCategoryDetail: A subclass of TestLabelDetail and CRUDMixin that handles the creation of annotation data for document classification tasks.",
                                        "Function `create_annotation_data`: A method that generates annotation data by invoking the `make_annotation` function with specified task, document, and user parameters.",
                                        "Class TestSpanDetail: A subclass of TestLabelDetail and CRUDMixin that is designed for handling span detail views within a sequence labeling task.",
                                        "Class TestTextDetail: A test case for managing text detail annotations in a sequence-to-sequence project context, with setup for annotation data creation.",
                                        "Function `setUp`: A setup method that initializes the `data` attribute with a dictionary containing a modified text value.",
                                        "Function `create_annotation_data`: A method that generates annotation data by invoking the `make_annotation` function with specified task, document, and user parameters.",
                                        "Class TestBBoxDetail: A view for handling bounding box annotations that extends TestLabelDetail and includes functionality for creating annotation data.",
                                        "Function `create_annotation_data`: Generates a new BoundingBox instance with specified parameters, using the `mommy` library to create a mock object based on the provided document and user.",
                                        "Class `TestSegmentationDetail`: A subclass of TestLabelDetail and CRUDMixin that handles segmentation tasks and creates annotation data for segmentation projects.",
                                        "Function `create_annotation_data`: Creates a segmentation annotation using the provided document, associating it with the project admin and specifying points.",
                                        "Class TestSharedLabelDetail: A test suite that verifies that all members of a collaborative document classification project can retrieve, update, and delete annotations.",
                                        "Function `setUp`: Prepares the test environment by creating a project, document, annotation, and label, and sets up the URL for accessing the project's item.",
                                        "Function `make_annotation`: A method that creates an annotation by invoking the `make_annotation` function with the current task, a document, and a user as parameters.",
                                        "Function `test_allows_any_member_to_get_annotation`: A test that verifies all members of a project can successfully retrieve annotations with a 200 OK status.",
                                        "Function `test_allows_any_member_to_update_annotation`: A test that verifies all members of a project can successfully update an annotation with a 200 OK status.",
                                        "Function `test_allows_any_member_to_delete_annotation`: A test case that verifies an approver member can successfully delete an annotation with a 204 No Content status response.",
                                        "Class TestSharedCategoryDetail: A test case that extends TestSharedLabelDetail and implements CRUD operations for category details.",
                                        "Class TestSharedSpanDetail: A subclass of TestSharedLabelDetail and CRUDMixin that defines a task for sequence labeling and provides a method to create annotations for documents.",
                                        "Function `make_annotation`: A method that creates an annotation for a document using a specified task and a user, with default start and end offsets.",
                                        "Class TestSharedTextDetail: A test case that extends TestSharedLabelDetail and implements CRUDMixin for handling shared text details in a sequence-to-sequence project context.",
                                        "Function `setUp`: A method that initializes test data by calling the parent class's `setUp` method and modifying the `data` attribute."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `make_annotation`\nCode:\ndef make_annotation(task, doc, user, **kwargs):\n    annotation_model = {\n        ProjectType.DOCUMENT_CLASSIFICATION: \"Category\",\n        ProjectType.SEQUENCE_LABELING: \"Span\",\n        ProjectType.SEQ2SEQ: \"TextLabel\",\n        ProjectType.SPEECH2TEXT: \"TextLabel\",\n    }.get(task)\n    return mommy.make(annotation_model, example=doc, user=user, **kwargs)"
                                    ],
                                    "code": "from model_mommy import mommy\n\nfrom projects.models import ProjectType\n\n\ndef make_annotation(task, doc, user, **kwargs):\n    annotation_model = {\n        ProjectType.DOCUMENT_CLASSIFICATION: \"Category\",\n        ProjectType.SEQUENCE_LABELING: \"Span\",\n        ProjectType.SEQ2SEQ: \"TextLabel\",\n        ProjectType.SPEECH2TEXT: \"TextLabel\",\n    }.get(task)\n    return mommy.make(annotation_model, example=doc, user=user, **kwargs)\n",
                                    "summary": "Function `make_annotation`: A utility function that generates an annotation instance tailored to the specified task type, document, and user by leveraging a mapping of project types to their respective annotation models.",
                                    "code_element_summaries": [
                                        "Function `make_annotation`: A utility function that creates an annotation instance based on the specified task type, document, and user, utilizing a mapping of project types to their corresponding annotation models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import (\n    BoundingBoxDetailAPI,\n    BoundingBoxListAPI,\n    CategoryDetailAPI,\n    CategoryListAPI,\n    RelationDetail,\n    RelationList,\n    SegmentationDetailAPI,\n    SegmentationListAPI,\n    SpanDetailAPI,\n    SpanListAPI,\n    TextLabelDetailAPI,\n    TextLabelListAPI,\n)\n\nurlpatterns = [\n    path(route=\"examples/<int:example_id>/relations\", view=RelationList.as_view(), name=\"relation_list\"),\n    path(\n        route=\"examples/<int:example_id>/relations/<int:annotation_id>\",\n        view=RelationDetail.as_view(),\n        name=\"relation_detail\",\n    ),\n    path(route=\"examples/<int:example_id>/categories\", view=CategoryListAPI.as_view(), name=\"category_list\"),\n    path(\n        route=\"examples/<int:example_id>/categories/<int:annotation_id>\",\n        view=CategoryDetailAPI.as_view(),\n        name=\"category_detail\",\n    ),\n    path(route=\"examples/<int:example_id>/spans\", view=SpanListAPI.as_view(), name=\"span_list\"),\n    path(route=\"examples/<int:example_id>/spans/<int:annotation_id>\", view=SpanDetailAPI.as_view(), name=\"span_detail\"),\n    path(route=\"examples/<int:example_id>/texts\", view=TextLabelListAPI.as_view(), name=\"text_list\"),\n    path(\n        route=\"examples/<int:example_id>/texts/<int:annotation_id>\",\n        view=TextLabelDetailAPI.as_view(),\n        name=\"text_detail\",\n    ),\n    path(route=\"examples/<int:example_id>/bboxes\", view=BoundingBoxListAPI.as_view(), name=\"bbox_list\"),\n    path(\n        route=\"examples/<int:example_id>/bboxes/<int:annotation_id>\",\n        view=BoundingBoxDetailAPI.as_view(),\n        name=\"bbox_detail\",\n    ),\n    path(route=\"examples/<int:example_id>/segments\", view=SegmentationListAPI.as_view(), name=\"segmentation_list\"),\n    path(\n        route=\"examples/<int:example_id>/segments/<int:annotation_id>\",\n        view=SegmentationDetailAPI.as_view(),\n        name=\"segmentation_detail\",\n    ),\n]\n",
                            "summary": "URL patterns for a Django application that define API endpoints for managing relations, categories, spans, text labels, bounding boxes, and segmentation annotations associated with specific examples.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `BaseListAPI`\nCode:\nclass BaseListAPI(generics.ListCreateAPIView):\n    label_class: Type[Label]\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    swagger_schema = None\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        queryset = self.label_class.objects.filter(example=self.kwargs[\"example_id\"])\n        if not self.project.collaborative_annotation:\n            queryset = queryset.filter(user=self.request.user)\n        return queryset\n\n    def create(self, request, *args, **kwargs):\n        request.data[\"example\"] = self.kwargs[\"example_id\"]\n        try:\n            response = super().create(request, args, kwargs)\n        except ValidationError as err:\n            response = Response({\"detail\": err.messages}, status=status.HTTP_400_BAD_REQUEST)\n        return response\n\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.kwargs[\"example_id\"], user=self.request.user)\n\n    def delete(self, request, *args, **kwargs):\n        queryset = self.get_queryset()\n        queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        queryset = self.label_class.objects.filter(example=self.kwargs[\"example_id\"])\n        if not self.project.collaborative_annotation:\n            queryset = queryset.filter(user=self.request.user)\n        return queryset",
                                "Function `create`\nCode:\n    def create(self, request, *args, **kwargs):\n        request.data[\"example\"] = self.kwargs[\"example_id\"]\n        try:\n            response = super().create(request, args, kwargs)\n        except ValidationError as err:\n            response = Response({\"detail\": err.messages}, status=status.HTTP_400_BAD_REQUEST)\n        return response",
                                "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.kwargs[\"example_id\"], user=self.request.user)",
                                "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        queryset = self.get_queryset()\n        queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                "Class `BaseDetailAPI`\nCode:\nclass BaseDetailAPI(generics.RetrieveUpdateDestroyAPIView):\n    lookup_url_kwarg = \"annotation_id\"\n    swagger_schema = None\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_permissions(self):\n        if self.project.collaborative_annotation:\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & IsProjectMember & partial(CanEditLabel, self.queryset)]\n        return super().get_permissions()",
                                "Function `project`\nCode:\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])",
                                "Function `get_permissions`\nCode:\n    def get_permissions(self):\n        if self.project.collaborative_annotation:\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & IsProjectMember & partial(CanEditLabel, self.queryset)]\n        return super().get_permissions()",
                                "Class `CategoryListAPI`\nCode:\nclass CategoryListAPI(BaseListAPI):\n    label_class = Category\n    serializer_class = CategorySerializer\n\n    def create(self, request, *args, **kwargs):\n        if self.project.single_class_classification:\n            self.get_queryset().delete()\n        return super().create(request, args, kwargs)",
                                "Function `create`\nCode:\n    def create(self, request, *args, **kwargs):\n        if self.project.single_class_classification:\n            self.get_queryset().delete()\n        return super().create(request, args, kwargs)",
                                "Class `CategoryDetailAPI`\nCode:\nclass CategoryDetailAPI(BaseDetailAPI):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer",
                                "Class `SpanListAPI`\nCode:\nclass SpanListAPI(BaseListAPI):\n    label_class = Span\n    serializer_class = SpanSerializer",
                                "Class `SpanDetailAPI`\nCode:\nclass SpanDetailAPI(BaseDetailAPI):\n    queryset = Span.objects.all()\n    serializer_class = SpanSerializer",
                                "Class `TextLabelListAPI`\nCode:\nclass TextLabelListAPI(BaseListAPI):\n    label_class = TextLabel\n    serializer_class = TextLabelSerializer",
                                "Class `TextLabelDetailAPI`\nCode:\nclass TextLabelDetailAPI(BaseDetailAPI):\n    queryset = TextLabel.objects.all()\n    serializer_class = TextLabelSerializer",
                                "Class `RelationList`\nCode:\nclass RelationList(BaseListAPI):\n    label_class = Relation\n    serializer_class = RelationSerializer",
                                "Class `RelationDetail`\nCode:\nclass RelationDetail(BaseDetailAPI):\n    queryset = Relation.objects.all()\n    serializer_class = RelationSerializer",
                                "Class `BoundingBoxListAPI`\nCode:\nclass BoundingBoxListAPI(BaseListAPI):\n    label_class = BoundingBox\n    serializer_class = BoundingBoxSerializer",
                                "Class `BoundingBoxDetailAPI`\nCode:\nclass BoundingBoxDetailAPI(BaseDetailAPI):\n    queryset = BoundingBox.objects.all()\n    serializer_class = BoundingBoxSerializer",
                                "Class `SegmentationListAPI`\nCode:\nclass SegmentationListAPI(BaseListAPI):\n    label_class = Segmentation\n    serializer_class = SegmentationSerializer",
                                "Class `SegmentationDetailAPI`\nCode:\nclass SegmentationDetailAPI(BaseDetailAPI):\n    queryset = Segmentation.objects.all()\n    serializer_class = SegmentationSerializer"
                            ],
                            "code": "from functools import partial\nfrom typing import Type\n\nfrom django.core.exceptions import ValidationError\nfrom django.shortcuts import get_object_or_404\nfrom rest_framework import generics, status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom .permissions import CanEditLabel\nfrom .serializers import (\n    BoundingBoxSerializer,\n    CategorySerializer,\n    RelationSerializer,\n    SegmentationSerializer,\n    SpanSerializer,\n    TextLabelSerializer,\n)\nfrom labels.models import (\n    BoundingBox,\n    Category,\n    Label,\n    Relation,\n    Segmentation,\n    Span,\n    TextLabel,\n)\nfrom projects.models import Project\nfrom projects.permissions import IsProjectMember\n\n\nclass BaseListAPI(generics.ListCreateAPIView):\n    label_class: Type[Label]\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectMember]\n    swagger_schema = None\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_queryset(self):\n        queryset = self.label_class.objects.filter(example=self.kwargs[\"example_id\"])\n        if not self.project.collaborative_annotation:\n            queryset = queryset.filter(user=self.request.user)\n        return queryset\n\n    def create(self, request, *args, **kwargs):\n        request.data[\"example\"] = self.kwargs[\"example_id\"]\n        try:\n            response = super().create(request, args, kwargs)\n        except ValidationError as err:\n            response = Response({\"detail\": err.messages}, status=status.HTTP_400_BAD_REQUEST)\n        return response\n\n    def perform_create(self, serializer):\n        serializer.save(example_id=self.kwargs[\"example_id\"], user=self.request.user)\n\n    def delete(self, request, *args, **kwargs):\n        queryset = self.get_queryset()\n        queryset.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass BaseDetailAPI(generics.RetrieveUpdateDestroyAPIView):\n    lookup_url_kwarg = \"annotation_id\"\n    swagger_schema = None\n\n    @property\n    def project(self):\n        return get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n\n    def get_permissions(self):\n        if self.project.collaborative_annotation:\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & IsProjectMember & partial(CanEditLabel, self.queryset)]\n        return super().get_permissions()\n\n\nclass CategoryListAPI(BaseListAPI):\n    label_class = Category\n    serializer_class = CategorySerializer\n\n    def create(self, request, *args, **kwargs):\n        if self.project.single_class_classification:\n            self.get_queryset().delete()\n        return super().create(request, args, kwargs)\n\n\nclass CategoryDetailAPI(BaseDetailAPI):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer\n\n\nclass SpanListAPI(BaseListAPI):\n    label_class = Span\n    serializer_class = SpanSerializer\n\n\nclass SpanDetailAPI(BaseDetailAPI):\n    queryset = Span.objects.all()\n    serializer_class = SpanSerializer\n\n\nclass TextLabelListAPI(BaseListAPI):\n    label_class = TextLabel\n    serializer_class = TextLabelSerializer\n\n\nclass TextLabelDetailAPI(BaseDetailAPI):\n    queryset = TextLabel.objects.all()\n    serializer_class = TextLabelSerializer\n\n\nclass RelationList(BaseListAPI):\n    label_class = Relation\n    serializer_class = RelationSerializer\n\n\nclass RelationDetail(BaseDetailAPI):\n    queryset = Relation.objects.all()\n    serializer_class = RelationSerializer\n\n\nclass BoundingBoxListAPI(BaseListAPI):\n    label_class = BoundingBox\n    serializer_class = BoundingBoxSerializer\n\n\nclass BoundingBoxDetailAPI(BaseDetailAPI):\n    queryset = BoundingBox.objects.all()\n    serializer_class = BoundingBoxSerializer\n\n\nclass SegmentationListAPI(BaseListAPI):\n    label_class = Segmentation\n    serializer_class = SegmentationSerializer\n\n\nclass SegmentationDetailAPI(BaseDetailAPI):\n    queryset = Segmentation.objects.all()\n    serializer_class = SegmentationSerializer\n",
                            "summary": "The provided content describes a series of Django API classes and methods for managing various annotation types and categories, including listing, creating, retrieving, updating, and deleting label objects, while enforcing permissions based on project membership and collaboration settings.",
                            "code_element_summaries": [
                                "Class `BaseListAPI`: A Django API view for listing and creating label objects associated with a specific project and example, enforcing authentication and project membership permissions.",
                                "Function `project`: Retrieves a Project object based on the provided project ID, or raises a 404 error if not found.",
                                "Function `get_queryset`: Retrieves a filtered queryset of label objects based on the example ID and the user's permissions in a non-collaborative annotation project.",
                                "Function `create`: A method that modifies the request data by adding an example ID and handles potential validation errors during the creation process, returning an appropriate response.",
                                "Function `perform_create`: Saves a serializer instance with an example ID and the current user as additional parameters.",
                                "Function `delete`: A method that deletes all objects from the queryset and returns a 204 No Content response.",
                                "Class `BaseDetailAPI`: A Django REST framework view that handles retrieving, updating, and deleting resources while enforcing permissions based on project collaboration settings.",
                                "Function `project`: Retrieves a Project object based on the provided project ID, returning a 404 error if not found.",
                                "Function `get_permissions`: Determines permission classes based on whether the project allows collaborative annotation, ensuring that only authenticated project members can access or edit labels.",
                                "Class CategoryListAPI: A specialized API for managing categories that overrides the create method to handle single class classification by deleting existing entries before creating new ones.",
                                "Function `create`: A method that deletes existing entries in the queryset if the project is set for single-class classification before calling the superclass's create method.",
                                "Class CategoryDetailAPI: An API endpoint for retrieving detailed information about categories using a specified serializer.",
                                "Class SpanListAPI: A subclass of BaseListAPI that manages a list of Span objects using the SpanSerializer for serialization.",
                                "Class SpanDetailAPI: A detail API for Span objects that utilizes a queryset and a serializer for data representation.",
                                "Class TextLabelListAPI: A subclass of BaseListAPI that manages a list of TextLabel instances using the TextLabelSerializer for serialization.",
                                "Class TextLabelDetailAPI: A detail API for managing TextLabel instances using a specified queryset and serializer.",
                                "Class RelationList: An API list class for managing relations, utilizing the Relation model and its corresponding serializer.",
                                "Class RelationDetail: An API view that handles the retrieval of relation objects using a specified queryset and serializer.",
                                "Class BoundingBoxListAPI: An API endpoint for listing bounding box annotations, utilizing a specified serializer and label class.",
                                "Class BoundingBoxDetailAPI: An API endpoint for retrieving details of bounding box objects using a specified serializer.",
                                "Class SegmentationListAPI: An API endpoint for listing segmentation objects, utilizing the Segmentation model and its corresponding serializer.",
                                "Class SegmentationDetailAPI: A detail API for managing segmentation objects, utilizing a queryset of all Segmentation instances and a specified serializer class."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\labels\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "label_types",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "Classes and functions for managing label types in a Django application, including admin configurations, serializers, migrations, validation, utility functions, and unit tests, aimed at ensuring data integrity and enhancing label management functionality.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelAdmin`\nCode:\nclass LabelAdmin(admin.ModelAdmin):\n    list_display = (\"text\", \"project\", \"text_color\", \"background_color\")\n    ordering = (\"project\",)\n    search_fields = (\"text\",)",
                                "Class `CategoryTypeAdmin`\nCode:\nclass CategoryTypeAdmin(LabelAdmin):\n    pass",
                                "Class `SpanTypeAdmin`\nCode:\nclass SpanTypeAdmin(LabelAdmin):\n    pass"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import CategoryType, SpanType\n\n\nclass LabelAdmin(admin.ModelAdmin):\n    list_display = (\"text\", \"project\", \"text_color\", \"background_color\")\n    ordering = (\"project\",)\n    search_fields = (\"text\",)\n\n\nclass CategoryTypeAdmin(LabelAdmin):\n    pass\n\n\nclass SpanTypeAdmin(LabelAdmin):\n    pass\n\n\nadmin.site.register(CategoryType, CategoryTypeAdmin)\nadmin.site.register(SpanType, SpanTypeAdmin)\n",
                            "summary": "Class LabelAdmin: A Django admin model configuration for Label objects, with CategoryTypeAdmin and SpanTypeAdmin serving as subclasses that inherit its functionality without adding any new features.",
                            "code_element_summaries": [
                                "Class LabelAdmin: A Django admin model configuration that customizes the display, ordering, and search functionality for Label objects in the admin interface.",
                                "Class CategoryTypeAdmin: A subclass of LabelAdmin with no additional functionality or properties defined.",
                                "Class SpanTypeAdmin: A subclass of LabelAdmin that currently does not add any additional functionality or attributes."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelTypesConfig`\nCode:\nclass LabelTypesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"label_types\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass LabelTypesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"label_types\"\n",
                            "summary": "Class LabelTypesConfig: A Django application configuration class that defines the default auto field type and names the application \"label_types\".",
                            "code_element_summaries": [
                                "Class LabelTypesConfig: A Django application configuration class that sets the default auto field type and specifies the application name as \"label_types\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "exceptions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\exceptions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelValidationError`\nCode:\nclass LabelValidationError(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"You cannot create a label with same name or shortcut key.\""
                            ],
                            "code": "from rest_framework import status\nfrom rest_framework.exceptions import APIException\n\n\nclass LabelValidationError(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"You cannot create a label with same name or shortcut key.\"\n",
                            "summary": "Class `LabelValidationError`: An exception that signifies a validation error due to duplicate label names or shortcut keys, resulting in a 400 Bad Request status.",
                            "code_element_summaries": [
                                "Class `LabelValidationError`: An exception class that indicates a validation error when attempting to create a label with a duplicate name or shortcut key, returning a 400 Bad Request status."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A series of Django migrations that define, rename, and modify models related to relation types and project associations, while ensuring data integrity through unique constraints and foreign key relationships.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"api\", \"0032_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"SpanType\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.CharField(db_index=True, max_length=100)),\n                        (\n                            \"prefix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                                max_length=10,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"suffix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[\n                                    (\"0\", \"0\"),\n                                    (\"1\", \"1\"),\n                                    (\"2\", \"2\"),\n                                    (\"3\", \"3\"),\n                                    (\"4\", \"4\"),\n                                    (\"5\", \"5\"),\n                                    (\"6\", \"6\"),\n                                    (\"7\", \"7\"),\n                                    (\"8\", \"8\"),\n                                    (\"9\", \"9\"),\n                                    (\"a\", \"a\"),\n                                    (\"b\", \"b\"),\n                                    (\"c\", \"c\"),\n                                    (\"d\", \"d\"),\n                                    (\"e\", \"e\"),\n                                    (\"f\", \"f\"),\n                                    (\"g\", \"g\"),\n                                    (\"h\", \"h\"),\n                                    (\"i\", \"i\"),\n                                    (\"j\", \"j\"),\n                                    (\"k\", \"k\"),\n                                    (\"l\", \"l\"),\n                                    (\"m\", \"m\"),\n                                    (\"n\", \"n\"),\n                                    (\"o\", \"o\"),\n                                    (\"p\", \"p\"),\n                                    (\"q\", \"q\"),\n                                    (\"r\", \"r\"),\n                                    (\"s\", \"s\"),\n                                    (\"t\", \"t\"),\n                                    (\"u\", \"u\"),\n                                    (\"v\", \"v\"),\n                                    (\"w\", \"w\"),\n                                    (\"x\", \"x\"),\n                                    (\"y\", \"y\"),\n                                    (\"z\", \"z\"),\n                                ],\n                                max_length=1,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"background_color\",\n                            models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                        ),\n                        (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\")),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                        \"abstract\": False,\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"RelationTypes\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"color\", models.TextField()),\n                        (\"name\", models.TextField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"relation_types\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"CategoryType\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.CharField(db_index=True, max_length=100)),\n                        (\n                            \"prefix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                                max_length=10,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"suffix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[\n                                    (\"0\", \"0\"),\n                                    (\"1\", \"1\"),\n                                    (\"2\", \"2\"),\n                                    (\"3\", \"3\"),\n                                    (\"4\", \"4\"),\n                                    (\"5\", \"5\"),\n                                    (\"6\", \"6\"),\n                                    (\"7\", \"7\"),\n                                    (\"8\", \"8\"),\n                                    (\"9\", \"9\"),\n                                    (\"a\", \"a\"),\n                                    (\"b\", \"b\"),\n                                    (\"c\", \"c\"),\n                                    (\"d\", \"d\"),\n                                    (\"e\", \"e\"),\n                                    (\"f\", \"f\"),\n                                    (\"g\", \"g\"),\n                                    (\"h\", \"h\"),\n                                    (\"i\", \"i\"),\n                                    (\"j\", \"j\"),\n                                    (\"k\", \"k\"),\n                                    (\"l\", \"l\"),\n                                    (\"m\", \"m\"),\n                                    (\"n\", \"n\"),\n                                    (\"o\", \"o\"),\n                                    (\"p\", \"p\"),\n                                    (\"q\", \"q\"),\n                                    (\"r\", \"r\"),\n                                    (\"s\", \"s\"),\n                                    (\"t\", \"t\"),\n                                    (\"u\", \"u\"),\n                                    (\"v\", \"v\"),\n                                    (\"w\", \"w\"),\n                                    (\"x\", \"x\"),\n                                    (\"y\", \"y\"),\n                                    (\"z\", \"z\"),\n                                ],\n                                max_length=1,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"background_color\",\n                            models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                        ),\n                        (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\")),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                        \"abstract\": False,\n                    },\n                ),\n                migrations.AddConstraint(\n                    model_name=\"spantype\",\n                    constraint=models.UniqueConstraint(\n                        fields=(\"project\", \"text\"), name=\"label_types_spantype_is_unique\"\n                    ),\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"relationtypes\",\n                    unique_together={(\"color\", \"name\")},\n                ),\n                migrations.AddConstraint(\n                    model_name=\"categorytype\",\n                    constraint=models.UniqueConstraint(\n                        fields=(\"project\", \"text\"), name=\"label_types_categorytype_is_unique\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 06:54\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport label_types.models\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        (\"api\", \"0032_auto_20220127_0654\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"SpanType\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.CharField(db_index=True, max_length=100)),\n                        (\n                            \"prefix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                                max_length=10,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"suffix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[\n                                    (\"0\", \"0\"),\n                                    (\"1\", \"1\"),\n                                    (\"2\", \"2\"),\n                                    (\"3\", \"3\"),\n                                    (\"4\", \"4\"),\n                                    (\"5\", \"5\"),\n                                    (\"6\", \"6\"),\n                                    (\"7\", \"7\"),\n                                    (\"8\", \"8\"),\n                                    (\"9\", \"9\"),\n                                    (\"a\", \"a\"),\n                                    (\"b\", \"b\"),\n                                    (\"c\", \"c\"),\n                                    (\"d\", \"d\"),\n                                    (\"e\", \"e\"),\n                                    (\"f\", \"f\"),\n                                    (\"g\", \"g\"),\n                                    (\"h\", \"h\"),\n                                    (\"i\", \"i\"),\n                                    (\"j\", \"j\"),\n                                    (\"k\", \"k\"),\n                                    (\"l\", \"l\"),\n                                    (\"m\", \"m\"),\n                                    (\"n\", \"n\"),\n                                    (\"o\", \"o\"),\n                                    (\"p\", \"p\"),\n                                    (\"q\", \"q\"),\n                                    (\"r\", \"r\"),\n                                    (\"s\", \"s\"),\n                                    (\"t\", \"t\"),\n                                    (\"u\", \"u\"),\n                                    (\"v\", \"v\"),\n                                    (\"w\", \"w\"),\n                                    (\"x\", \"x\"),\n                                    (\"y\", \"y\"),\n                                    (\"z\", \"z\"),\n                                ],\n                                max_length=1,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"background_color\",\n                            models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                        ),\n                        (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\")),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                        \"abstract\": False,\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"RelationTypes\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"color\", models.TextField()),\n                        (\"name\", models.TextField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"relation_types\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"CategoryType\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.CharField(db_index=True, max_length=100)),\n                        (\n                            \"prefix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                                max_length=10,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"suffix_key\",\n                            models.CharField(\n                                blank=True,\n                                choices=[\n                                    (\"0\", \"0\"),\n                                    (\"1\", \"1\"),\n                                    (\"2\", \"2\"),\n                                    (\"3\", \"3\"),\n                                    (\"4\", \"4\"),\n                                    (\"5\", \"5\"),\n                                    (\"6\", \"6\"),\n                                    (\"7\", \"7\"),\n                                    (\"8\", \"8\"),\n                                    (\"9\", \"9\"),\n                                    (\"a\", \"a\"),\n                                    (\"b\", \"b\"),\n                                    (\"c\", \"c\"),\n                                    (\"d\", \"d\"),\n                                    (\"e\", \"e\"),\n                                    (\"f\", \"f\"),\n                                    (\"g\", \"g\"),\n                                    (\"h\", \"h\"),\n                                    (\"i\", \"i\"),\n                                    (\"j\", \"j\"),\n                                    (\"k\", \"k\"),\n                                    (\"l\", \"l\"),\n                                    (\"m\", \"m\"),\n                                    (\"n\", \"n\"),\n                                    (\"o\", \"o\"),\n                                    (\"p\", \"p\"),\n                                    (\"q\", \"q\"),\n                                    (\"r\", \"r\"),\n                                    (\"s\", \"s\"),\n                                    (\"t\", \"t\"),\n                                    (\"u\", \"u\"),\n                                    (\"v\", \"v\"),\n                                    (\"w\", \"w\"),\n                                    (\"x\", \"x\"),\n                                    (\"y\", \"y\"),\n                                    (\"z\", \"z\"),\n                                ],\n                                max_length=1,\n                                null=True,\n                            ),\n                        ),\n                        (\n                            \"background_color\",\n                            models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                        ),\n                        (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"api.project\")),\n                    ],\n                    options={\n                        \"ordering\": [\"created_at\"],\n                        \"abstract\": False,\n                    },\n                ),\n                migrations.AddConstraint(\n                    model_name=\"spantype\",\n                    constraint=models.UniqueConstraint(\n                        fields=(\"project\", \"text\"), name=\"label_types_spantype_is_unique\"\n                    ),\n                ),\n                migrations.AlterUniqueTogether(\n                    name=\"relationtypes\",\n                    unique_together={(\"color\", \"name\")},\n                ),\n                migrations.AddConstraint(\n                    model_name=\"categorytype\",\n                    constraint=models.UniqueConstraint(\n                        fields=(\"project\", \"text\"), name=\"label_types_categorytype_is_unique\"\n                    ),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that defines three models—SpanType, RelationTypes, and CategoryType—with their respective fields, constraints, and relationships to the Project model, including unique constraints for specific fields.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates three models—SpanType, RelationTypes, and CategoryType—along with their fields, constraints, and relationships to the Project model, while ensuring unique constraints for certain fields."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_rename_relationtypes_relationtype.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0002_rename_relationtypes_relationtype.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0003_auto_20220127_0654\"),\n        (\"api\", \"0033_auto_20220127_0654\"),\n        (\"label_types\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationTypes\",\n            new_name=\"RelationType\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-01-27 07:27\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0003_auto_20220127_0654\"),\n        (\"api\", \"0033_auto_20220127_0654\"),\n        (\"label_types\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationTypes\",\n            new_name=\"RelationType\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that renames the model `RelationTypes` to `RelationType` while defining its dependencies on other migrations.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that renames the model `RelationTypes` to `RelationType` and specifies its dependencies on other migrations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_auto_20220204_0201.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0003_auto_20220204_0201.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"label_types\", \"0002_rename_relationtypes_relationtype\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"categorytype\",\n                    name=\"project\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\"),\n                ),\n                migrations.AlterField(\n                    model_name=\"relationtype\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"relation_types\",\n                        to=\"projects.project\",\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"spantype\",\n                    name=\"project\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\"),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0002_auto_20220204_0201\"),\n        (\"label_types\", \"0002_rename_relationtypes_relationtype\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.AlterField(\n                    model_name=\"categorytype\",\n                    name=\"project\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\"),\n                ),\n                migrations.AlterField(\n                    model_name=\"relationtype\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE,\n                        related_name=\"relation_types\",\n                        to=\"projects.project\",\n                    ),\n                ),\n                migrations.AlterField(\n                    model_name=\"spantype\",\n                    name=\"project\",\n                    field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\"),\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the `project` field in various models to create foreign key relationships with the `projects` app, while handling database and state operations independently.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the `project` field in multiple models to establish foreign key relationships with the `projects` app while managing database and state operations separately."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_rename_relationtype_relationtypeold.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0004_rename_relationtype_relationtypeold.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        (\"labels\", \"0005_alter_relation_project\"),\n        (\"label_types\", \"0003_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationType\",\n            new_name=\"RelationTypeOld\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 05:05\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        (\"labels\", \"0005_alter_relation_project\"),\n        (\"label_types\", \"0003_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RelationType\",\n            new_name=\"RelationTypeOld\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A database migration that renames the model \"RelationType\" to \"RelationTypeOld\" and establishes dependencies on other migrations.",
                                    "code_element_summaries": [
                                        "Class Migration: A database migration that renames the model \"RelationType\" to \"RelationTypeOld\" while specifying dependencies on other migrations."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_relationtype_and_more.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0005_relationtype_and_more.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        (\"label_types\", \"0004_rename_relationtype_relationtypeold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"RelationType\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"background_color\",\n                    models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                ),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\")),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.AddConstraint(\n            model_name=\"relationtype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"label_types_relationtype_is_unique\"),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 05:11\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport label_types.models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n        (\"label_types\", \"0004_rename_relationtype_relationtypeold\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"RelationType\",\n            fields=[\n                (\"id\", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\")),\n                (\"text\", models.CharField(db_index=True, max_length=100)),\n                (\n                    \"prefix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[(\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")],\n                        max_length=10,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"suffix_key\",\n                    models.CharField(\n                        blank=True,\n                        choices=[\n                            (\"0\", \"0\"),\n                            (\"1\", \"1\"),\n                            (\"2\", \"2\"),\n                            (\"3\", \"3\"),\n                            (\"4\", \"4\"),\n                            (\"5\", \"5\"),\n                            (\"6\", \"6\"),\n                            (\"7\", \"7\"),\n                            (\"8\", \"8\"),\n                            (\"9\", \"9\"),\n                            (\"a\", \"a\"),\n                            (\"b\", \"b\"),\n                            (\"c\", \"c\"),\n                            (\"d\", \"d\"),\n                            (\"e\", \"e\"),\n                            (\"f\", \"f\"),\n                            (\"g\", \"g\"),\n                            (\"h\", \"h\"),\n                            (\"i\", \"i\"),\n                            (\"j\", \"j\"),\n                            (\"k\", \"k\"),\n                            (\"l\", \"l\"),\n                            (\"m\", \"m\"),\n                            (\"n\", \"n\"),\n                            (\"o\", \"o\"),\n                            (\"p\", \"p\"),\n                            (\"q\", \"q\"),\n                            (\"r\", \"r\"),\n                            (\"s\", \"s\"),\n                            (\"t\", \"t\"),\n                            (\"u\", \"u\"),\n                            (\"v\", \"v\"),\n                            (\"w\", \"w\"),\n                            (\"x\", \"x\"),\n                            (\"y\", \"y\"),\n                            (\"z\", \"z\"),\n                        ],\n                        max_length=1,\n                        null=True,\n                    ),\n                ),\n                (\n                    \"background_color\",\n                    models.CharField(default=label_types.models.generate_random_hex_color, max_length=7),\n                ),\n                (\"text_color\", models.CharField(default=\"#ffffff\", max_length=7)),\n                (\"created_at\", models.DateTimeField(auto_now_add=True, db_index=True)),\n                (\"updated_at\", models.DateTimeField(auto_now=True)),\n                (\"project\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"projects.project\")),\n            ],\n            options={\n                \"ordering\": [\"created_at\"],\n                \"abstract\": False,\n            },\n        ),\n        migrations.AddConstraint(\n            model_name=\"relationtype\",\n            constraint=models.UniqueConstraint(fields=(\"project\", \"text\"), name=\"label_types_relationtype_is_unique\"),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes the `RelationType` model with multiple fields and enforces uniqueness constraints within a project.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A Django migration that creates the `RelationType` model with various fields, including constraints for uniqueness within a project."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0006_auto_20220222_0512.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0006_auto_20220222_0512.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `copy_relation_type`\nCode:\ndef copy_relation_type(apps, schema_editor):\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    RelationType = apps.get_model(\"label_types\", \"RelationType\")\n    for relation_type in RelationTypeOld.objects.all():\n        RelationType(\n            background_color=relation_type.color, text=relation_type.name, project=relation_type.project\n        ).save()\n        relation_type.delete()",
                                        "Function `delete_new_relation_type`\nCode:\ndef delete_new_relation_type(apps, schema_editor):\n    RelationTypeNew = apps.get_model(\"label_types\", \"RelationType\")\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    for relation_type in RelationTypeNew.objects.all():\n        RelationTypeOld.objects.get_or_create(\n            color=relation_type.background_color, name=relation_type.text, project=relation_type.project\n        )\n        relation_type.delete()",
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0005_relationtype_and_more\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_relation_type, reverse_code=delete_new_relation_type),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 05:12\n\nfrom django.db import migrations\n\n\ndef copy_relation_type(apps, schema_editor):\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    RelationType = apps.get_model(\"label_types\", \"RelationType\")\n    for relation_type in RelationTypeOld.objects.all():\n        RelationType(\n            background_color=relation_type.color, text=relation_type.name, project=relation_type.project\n        ).save()\n        relation_type.delete()\n\n\ndef delete_new_relation_type(apps, schema_editor):\n    RelationTypeNew = apps.get_model(\"label_types\", \"RelationType\")\n    RelationTypeOld = apps.get_model(\"label_types\", \"RelationTypeOld\")\n    for relation_type in RelationTypeNew.objects.all():\n        RelationTypeOld.objects.get_or_create(\n            color=relation_type.background_color, name=relation_type.text, project=relation_type.project\n        )\n        relation_type.delete()\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"label_types\", \"0005_relationtype_and_more\"),\n    ]\n\n    operations = [\n        migrations.RunPython(code=copy_relation_type, reverse_code=delete_new_relation_type),\n    ]\n",
                                    "summary": "Functions `copy_relation_type` and `delete_new_relation_type`, along with the class `Migration`, collectively manage the migration of relation types between old and new models in a Django database.",
                                    "code_element_summaries": [
                                        "Function `copy_relation_type`: A database migration function that copies data from the old `RelationTypeOld` model to the new `RelationType` model and deletes the old entries.",
                                        "Function `delete_new_relation_type`: A database migration function that transfers existing relation types from a new model to an old model and then deletes the new relation types.",
                                        "Class Migration: A Django migration that defines dependencies and operations to copy and delete relation types in the database."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0007_delete_relationtypeold.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\0007_delete_relationtypeold.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0009_delete_relationold\"),\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"RelationTypeOld\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-22 06:46\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"labels\", \"0009_delete_relationold\"),\n        (\"label_types\", \"0006_auto_20220222_0512\"),\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name=\"RelationTypeOld\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that removes the \"RelationTypeOld\" model and relies on two prior migrations from the \"labels\" and \"label_types\" applications.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that deletes the model \"RelationTypeOld\" and has dependencies on two previous migrations from the \"labels\" and \"label_types\" apps."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Function `generate_random_hex_color`\nCode:\ndef generate_random_hex_color():\n    return f\"#{random.randint(0, 0xFFFFFF):06x}\"",
                                "Class `LabelType`\nCode:\nclass LabelType(models.Model):\n    text = models.CharField(max_length=100, db_index=True)\n    prefix_key = models.CharField(\n        max_length=10,\n        blank=True,\n        null=True,\n        choices=((\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")),\n    )\n    suffix_key = models.CharField(\n        max_length=1, blank=True, null=True, choices=tuple((c, c) for c in string.digits + string.ascii_lowercase)\n    )\n    project = models.ForeignKey(\n        to=Project,\n        on_delete=models.CASCADE,\n        # related_name='labels'\n    )\n    background_color = models.CharField(max_length=7, default=generate_random_hex_color)\n    text_color = models.CharField(max_length=7, default=\"#ffffff\")\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.text\n\n    @property\n    def labels(self):\n        raise NotImplementedError()\n\n    def clean(self):\n        # Don't allow shortcut key not to have a suffix key.\n        if self.prefix_key and not self.suffix_key:\n            message = \"Shortcut key may not have a suffix key.\"\n            raise ValidationError(message)\n\n        # each shortcut (prefix key + suffix key) can only be assigned to one label\n        if self.suffix_key or self.prefix_key:\n            other_labels = self.labels.exclude(id=self.id)\n            if other_labels.filter(suffix_key=self.suffix_key, prefix_key=self.prefix_key).exists():\n                message = \"A label with the shortcut already exists in the project.\"\n                raise ValidationError(message)\n\n        super().clean()\n\n    class Meta:\n        abstract = True\n        constraints = [models.UniqueConstraint(fields=[\"project\", \"text\"], name=\"%(app_label)s_%(class)s_is_unique\")]\n        ordering = [\"created_at\"]",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        return self.text",
                                "Function `labels`\nCode:\n    def labels(self):\n        raise NotImplementedError()",
                                "Function `clean`\nCode:\n    def clean(self):\n        # Don't allow shortcut key not to have a suffix key.\n        if self.prefix_key and not self.suffix_key:\n            message = \"Shortcut key may not have a suffix key.\"\n            raise ValidationError(message)\n\n        # each shortcut (prefix key + suffix key) can only be assigned to one label\n        if self.suffix_key or self.prefix_key:\n            other_labels = self.labels.exclude(id=self.id)\n            if other_labels.filter(suffix_key=self.suffix_key, prefix_key=self.prefix_key).exists():\n                message = \"A label with the shortcut already exists in the project.\"\n                raise ValidationError(message)\n\n        super().clean()",
                                "Class `Meta`\nCode:\n    class Meta:\n        abstract = True\n        constraints = [models.UniqueConstraint(fields=[\"project\", \"text\"], name=\"%(app_label)s_%(class)s_is_unique\")]\n        ordering = [\"created_at\"]",
                                "Class `CategoryType`\nCode:\nclass CategoryType(LabelType):\n    @property\n    def labels(self):\n        return CategoryType.objects.filter(project=self.project)",
                                "Function `labels`\nCode:\n    def labels(self):\n        return CategoryType.objects.filter(project=self.project)",
                                "Class `SpanType`\nCode:\nclass SpanType(LabelType):\n    @property\n    def labels(self):\n        return SpanType.objects.filter(project=self.project)",
                                "Function `labels`\nCode:\n    def labels(self):\n        return SpanType.objects.filter(project=self.project)",
                                "Class `RelationType`\nCode:\nclass RelationType(LabelType):\n    @property\n    def labels(self):\n        return RelationType.objects.filter(project=self.project)",
                                "Function `labels`\nCode:\n    def labels(self):\n        return RelationType.objects.filter(project=self.project)"
                            ],
                            "code": "import random\nimport string\n\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\n\nfrom projects.models import Project\n\n\ndef generate_random_hex_color():\n    return f\"#{random.randint(0, 0xFFFFFF):06x}\"\n\n\nclass LabelType(models.Model):\n    text = models.CharField(max_length=100, db_index=True)\n    prefix_key = models.CharField(\n        max_length=10,\n        blank=True,\n        null=True,\n        choices=((\"ctrl\", \"ctrl\"), (\"shift\", \"shift\"), (\"ctrl shift\", \"ctrl shift\")),\n    )\n    suffix_key = models.CharField(\n        max_length=1, blank=True, null=True, choices=tuple((c, c) for c in string.digits + string.ascii_lowercase)\n    )\n    project = models.ForeignKey(\n        to=Project,\n        on_delete=models.CASCADE,\n        # related_name='labels'\n    )\n    background_color = models.CharField(max_length=7, default=generate_random_hex_color)\n    text_color = models.CharField(max_length=7, default=\"#ffffff\")\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.text\n\n    @property\n    def labels(self):\n        raise NotImplementedError()\n\n    def clean(self):\n        # Don't allow shortcut key not to have a suffix key.\n        if self.prefix_key and not self.suffix_key:\n            message = \"Shortcut key may not have a suffix key.\"\n            raise ValidationError(message)\n\n        # each shortcut (prefix key + suffix key) can only be assigned to one label\n        if self.suffix_key or self.prefix_key:\n            other_labels = self.labels.exclude(id=self.id)\n            if other_labels.filter(suffix_key=self.suffix_key, prefix_key=self.prefix_key).exists():\n                message = \"A label with the shortcut already exists in the project.\"\n                raise ValidationError(message)\n\n        super().clean()\n\n    class Meta:\n        abstract = True\n        constraints = [models.UniqueConstraint(fields=[\"project\", \"text\"], name=\"%(app_label)s_%(class)s_is_unique\")]\n        ordering = [\"created_at\"]\n\n\nclass CategoryType(LabelType):\n    @property\n    def labels(self):\n        return CategoryType.objects.filter(project=self.project)\n\n\nclass SpanType(LabelType):\n    @property\n    def labels(self):\n        return SpanType.objects.filter(project=self.project)\n\n\nclass RelationType(LabelType):\n    @property\n    def labels(self):\n        return RelationType.objects.filter(project=self.project)\n",
                            "summary": "Functions and classes for managing label types in a Django application, including generating random hex colors, defining abstract models with validation for label attributes, and implementing subclasses that retrieve associated labels for specific projects.",
                            "code_element_summaries": [
                                "Function `generate_random_hex_color`: Generates a random hexadecimal color code in the format of a string.",
                                "Class `LabelType`: An abstract Django model that defines label attributes, including text, shortcut keys, and colors, with validation to ensure uniqueness within a project.",
                                "Function `__str__`: Returns the string representation of the object by returning its text attribute.",
                                "Function `labels`: An abstract method that raises a NotImplementedError, indicating that it must be implemented in a subclass.",
                                "Function `clean`: Validates that a shortcut key has a suffix key and ensures that each combination of prefix and suffix keys is unique within the project, raising validation errors if these conditions are not met.",
                                "Class Meta: An abstract base class that enforces unique constraints on the combination of project and text fields while defining ordering by creation date.",
                                "Class CategoryType: A subclass of LabelType that provides a property to retrieve labels associated with a specific project.",
                                "Function `labels`: Retrieves a queryset of CategoryType objects filtered by the associated project.",
                                "Class SpanType: A subclass of LabelType that provides a property to retrieve labels associated with a specific project.",
                                "Function `labels`: Retrieves a queryset of `SpanType` objects filtered by the associated project.",
                                "Class RelationType: A subclass of LabelType that provides a property to retrieve labels associated with a specific project.",
                                "Function `labels`: Retrieves a queryset of RelationType objects filtered by the associated project."
                            ],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `LabelSerializer`\nCode:\nclass LabelSerializer(serializers.ModelSerializer):\n    def validate(self, attrs):\n        prefix_key = attrs.get(\"prefix_key\")\n        suffix_key = attrs.get(\"suffix_key\")\n\n        # In the case of user don't set any shortcut key.\n        if prefix_key is None and suffix_key is None:\n            return super().validate(attrs)\n\n        # Don't allow shortcut key not to have a suffix key.\n        if prefix_key and not suffix_key:\n            raise ValidationError(\"Shortcut key may not have a suffix key.\")\n\n        # Don't allow to save same shortcut key when prefix_key is null.\n        try:\n            context = self.context[\"request\"].parser_context\n            project_id = context[\"kwargs\"][\"project_id\"]\n            label_id = context[\"kwargs\"].get(\"label_id\")\n        except (AttributeError, KeyError):\n            pass  # unit tests don't always have the correct context set up\n        else:\n            conflicting_labels = self.Meta.model.objects.filter(\n                suffix_key=suffix_key,\n                prefix_key=prefix_key,\n                project=project_id,\n            )\n\n            if label_id is not None:\n                conflicting_labels = conflicting_labels.exclude(id=label_id)\n\n            if conflicting_labels.exists():\n                raise ValidationError(\"Duplicate shortcut key.\")\n\n        return super().validate(attrs)\n\n    class Meta:\n        model = LabelType\n        fields = (\n            \"id\",\n            \"text\",\n            \"prefix_key\",\n            \"suffix_key\",\n            \"background_color\",\n            \"text_color\",\n        )",
                                "Function `validate`\nCode:\n    def validate(self, attrs):\n        prefix_key = attrs.get(\"prefix_key\")\n        suffix_key = attrs.get(\"suffix_key\")\n\n        # In the case of user don't set any shortcut key.\n        if prefix_key is None and suffix_key is None:\n            return super().validate(attrs)\n\n        # Don't allow shortcut key not to have a suffix key.\n        if prefix_key and not suffix_key:\n            raise ValidationError(\"Shortcut key may not have a suffix key.\")\n\n        # Don't allow to save same shortcut key when prefix_key is null.\n        try:\n            context = self.context[\"request\"].parser_context\n            project_id = context[\"kwargs\"][\"project_id\"]\n            label_id = context[\"kwargs\"].get(\"label_id\")\n        except (AttributeError, KeyError):\n            pass  # unit tests don't always have the correct context set up\n        else:\n            conflicting_labels = self.Meta.model.objects.filter(\n                suffix_key=suffix_key,\n                prefix_key=prefix_key,\n                project=project_id,\n            )\n\n            if label_id is not None:\n                conflicting_labels = conflicting_labels.exclude(id=label_id)\n\n            if conflicting_labels.exists():\n                raise ValidationError(\"Duplicate shortcut key.\")\n\n        return super().validate(attrs)",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = LabelType\n        fields = (\n            \"id\",\n            \"text\",\n            \"prefix_key\",\n            \"suffix_key\",\n            \"background_color\",\n            \"text_color\",\n        )",
                                "Class `CategoryTypeSerializer`\nCode:\nclass CategoryTypeSerializer(LabelSerializer):\n    class Meta:\n        model = CategoryType\n        fields = LabelSerializer.Meta.fields",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = CategoryType\n        fields = LabelSerializer.Meta.fields",
                                "Class `SpanTypeSerializer`\nCode:\nclass SpanTypeSerializer(LabelSerializer):\n    class Meta:\n        model = SpanType\n        fields = LabelSerializer.Meta.fields",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = SpanType\n        fields = LabelSerializer.Meta.fields",
                                "Class `RelationTypeSerializer`\nCode:\nclass RelationTypeSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = RelationType\n        fields = LabelSerializer.Meta.fields",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = RelationType\n        fields = LabelSerializer.Meta.fields"
                            ],
                            "code": "from rest_framework import serializers\nfrom rest_framework.exceptions import ValidationError\n\nfrom .models import CategoryType, LabelType, RelationType, SpanType\n\n\nclass LabelSerializer(serializers.ModelSerializer):\n    def validate(self, attrs):\n        prefix_key = attrs.get(\"prefix_key\")\n        suffix_key = attrs.get(\"suffix_key\")\n\n        # In the case of user don't set any shortcut key.\n        if prefix_key is None and suffix_key is None:\n            return super().validate(attrs)\n\n        # Don't allow shortcut key not to have a suffix key.\n        if prefix_key and not suffix_key:\n            raise ValidationError(\"Shortcut key may not have a suffix key.\")\n\n        # Don't allow to save same shortcut key when prefix_key is null.\n        try:\n            context = self.context[\"request\"].parser_context\n            project_id = context[\"kwargs\"][\"project_id\"]\n            label_id = context[\"kwargs\"].get(\"label_id\")\n        except (AttributeError, KeyError):\n            pass  # unit tests don't always have the correct context set up\n        else:\n            conflicting_labels = self.Meta.model.objects.filter(\n                suffix_key=suffix_key,\n                prefix_key=prefix_key,\n                project=project_id,\n            )\n\n            if label_id is not None:\n                conflicting_labels = conflicting_labels.exclude(id=label_id)\n\n            if conflicting_labels.exists():\n                raise ValidationError(\"Duplicate shortcut key.\")\n\n        return super().validate(attrs)\n\n    class Meta:\n        model = LabelType\n        fields = (\n            \"id\",\n            \"text\",\n            \"prefix_key\",\n            \"suffix_key\",\n            \"background_color\",\n            \"text_color\",\n        )\n\n\nclass CategoryTypeSerializer(LabelSerializer):\n    class Meta:\n        model = CategoryType\n        fields = LabelSerializer.Meta.fields\n\n\nclass SpanTypeSerializer(LabelSerializer):\n    class Meta:\n        model = SpanType\n        fields = LabelSerializer.Meta.fields\n\n\nclass RelationTypeSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = RelationType\n        fields = LabelSerializer.Meta.fields\n",
                            "summary": "Class LabelSerializer: A serializer for the LabelType model that enforces validation rules for unique shortcut keys, while CategoryTypeSerializer, SpanTypeSerializer, and RelationTypeSerializer extend its functionality for their respective models, each with their own Meta configurations.",
                            "code_element_summaries": [
                                "Class `LabelSerializer`: A serializer for the `LabelType` model that includes validation rules for ensuring unique shortcut keys and proper key usage.",
                                "Function `validate`: A method that checks the validity of shortcut key attributes, ensuring that suffix keys are provided when prefix keys are present and preventing duplicate shortcut keys for the same project.",
                                "Class Meta: A configuration class that specifies the model LabelType and the fields to be included in its serialization.",
                                "Class CategoryTypeSerializer: A serializer for the CategoryType model that inherits fields from LabelSerializer.",
                                "Class Meta: A configuration class that specifies the model as CategoryType and inherits fields from LabelSerializer's Meta class.",
                                "Class SpanTypeSerializer: A serializer for the SpanType model that inherits fields from the LabelSerializer.",
                                "Class Meta: A configuration class that specifies the model as SpanType and inherits fields from LabelSerializer's Meta class.",
                                "Class RelationTypeSerializer: A serializer for the RelationType model that inherits fields from the LabelSerializer.",
                                "Class Meta: A nested class that specifies the model as RelationType and inherits fields from LabelSerializer's Meta class."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class TestLabel and TestGeneratedColor: Unit test suites that validate the integrity of the CategoryType model and ensure the consistency of generated hex color strings, while Class TestLabelList verifies label management permissions based on user roles, and the function make_label generates instances of CategoryType or SpanType based on project specifications.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_models.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\tests\\test_models.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestLabel`\nCode:\nclass TestLabel(TestCase):\n    def test_deny_creating_same_text(self):\n        label = mommy.make(\"CategoryType\")\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"CategoryType\", project=label.project, text=label.text)\n\n    def test_keys_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()\n\n    def test_suffix_key_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=None, suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()\n\n    def test_cannot_add_label_only_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\")\n        with self.assertRaises(ValidationError):\n            label.clean()\n\n    def test_can_add_label_only_suffix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)\n\n    def test_can_add_label_suffix_key_with_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)",
                                        "Function `test_deny_creating_same_text`\nCode:\n    def test_deny_creating_same_text(self):\n        label = mommy.make(\"CategoryType\")\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"CategoryType\", project=label.project, text=label.text)",
                                        "Function `test_keys_uniqueness`\nCode:\n    def test_keys_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()",
                                        "Function `test_suffix_key_uniqueness`\nCode:\n    def test_suffix_key_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=None, suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()",
                                        "Function `test_cannot_add_label_only_prefix_key`\nCode:\n    def test_cannot_add_label_only_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\")\n        with self.assertRaises(ValidationError):\n            label.clean()",
                                        "Function `test_can_add_label_only_suffix_key`\nCode:\n    def test_can_add_label_only_suffix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)",
                                        "Function `test_can_add_label_suffix_key_with_prefix_key`\nCode:\n    def test_can_add_label_suffix_key_with_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)",
                                        "Class `TestGeneratedColor`\nCode:\nclass TestGeneratedColor(TestCase):\n    def test_length(self):\n        for _ in range(100):\n            color = generate_random_hex_color()\n            self.assertEqual(len(color), 7)",
                                        "Function `test_length`\nCode:\n    def test_length(self):\n        for _ in range(100):\n            color = generate_random_hex_color()\n            self.assertEqual(len(color), 7)"
                                    ],
                                    "code": "from django.core.exceptions import ValidationError\nfrom django.db import IntegrityError\nfrom django.test import TestCase\nfrom model_mommy import mommy\n\nfrom label_types.models import CategoryType, generate_random_hex_color\n\n\nclass TestLabel(TestCase):\n    def test_deny_creating_same_text(self):\n        label = mommy.make(\"CategoryType\")\n        with self.assertRaises(IntegrityError):\n            mommy.make(\"CategoryType\", project=label.project, text=label.text)\n\n    def test_keys_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()\n\n    def test_suffix_key_uniqueness(self):\n        label = mommy.make(\"CategoryType\", prefix_key=None, suffix_key=\"a\")\n        with self.assertRaises(ValidationError):\n            CategoryType(\n                project=label.project, text=\"example\", prefix_key=label.prefix_key, suffix_key=label.suffix_key\n            ).full_clean()\n\n    def test_cannot_add_label_only_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\")\n        with self.assertRaises(ValidationError):\n            label.clean()\n\n    def test_can_add_label_only_suffix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)\n\n    def test_can_add_label_suffix_key_with_prefix_key(self):\n        project = mommy.make(\"Project\")\n        label = CategoryType(project=project, text=\"example\", prefix_key=\"ctrl\", suffix_key=\"a\")\n        try:\n            label.full_clean()\n        except ValidationError:\n            self.fail(msg=ValidationError)\n\n\nclass TestGeneratedColor(TestCase):\n    def test_length(self):\n        for _ in range(100):\n            color = generate_random_hex_color()\n            self.assertEqual(len(color), 7)\n",
                                    "summary": "Class `TestLabel`: A unit test suite that ensures the integrity and uniqueness constraints of the `CategoryType` model through various test cases, while class `TestGeneratedColor` verifies the consistent length of randomly generated hex color strings.",
                                    "code_element_summaries": [
                                        "Class `TestLabel`: A unit test suite that verifies the integrity and uniqueness constraints of the `CategoryType` model, ensuring proper validation for label creation and key uniqueness.",
                                        "Function `test_deny_creating_same_text`: A test case that verifies an IntegrityError is raised when attempting to create a duplicate CategoryType with the same project and text as an existing one.",
                                        "Function `test_keys_uniqueness`: A test function that verifies a `ValidationError` is raised when attempting to create a `CategoryType` with duplicate key combinations.",
                                        "Function `test_suffix_key_uniqueness`: A test that verifies a `ValidationError` is raised when attempting to create a `CategoryType` with a non-unique suffix key.",
                                        "Function `test_cannot_add_label_only_prefix_key`: A test case that verifies a `ValidationError` is raised when attempting to create a label with only a prefix key and no text.",
                                        "Function `test_can_add_label_only_suffix_key`: A test case that verifies the successful creation of a label with a suffix key in a project without raising a validation error.",
                                        "Function `test_can_add_label_suffix_key_with_prefix_key`: A test case that verifies the successful creation of a `CategoryType` label with specified prefix and suffix keys, ensuring it passes validation without errors.",
                                        "Class `TestGeneratedColor`: A test case that verifies the length of randomly generated hex color strings is consistently 7 characters.",
                                        "Function `test_length`: A test function that verifies that the length of a randomly generated hex color string is always 7 characters."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestLabelList`\nCode:\nclass TestLabelList(CRUDMixin):\n    def setUp(self):\n        self.non_member = make_user()\n        self.project_a = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.label = make_label(self.project_a.item)\n        self.url = reverse(viewname=\"category_types\", args=[self.project_a.item.id])\n\n        # Ensure that the API does not return the labels of the other project.\n        self.project_b = make_project(task=\"Any\", users=[\"admin\"], roles=[settings.ROLE_PROJECT_ADMIN])\n        make_label(self.project_b.item)\n\n        # for label creation\n        self.data = {\"text\": \"example\"}\n\n    def test_returns_labels_to_project_member(self):\n        for member in self.project_a.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)\n            self.assertEqual(response.data[0][\"id\"], self.label.id)\n\n    def test_does_not_return_labels_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_labels_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_create_label(self):\n        self.assert_create(self.project_a.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_create_label(self):\n        for member in self.project_a.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_create_label(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_label(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_bulk_delete_label(self):\n        self.assert_delete(self.project_a.admin, status.HTTP_204_NO_CONTENT, data={\"ids\": [self.label.id]})\n\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project_a.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.non_member = make_user()\n        self.project_a = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.label = make_label(self.project_a.item)\n        self.url = reverse(viewname=\"category_types\", args=[self.project_a.item.id])\n\n        # Ensure that the API does not return the labels of the other project.\n        self.project_b = make_project(task=\"Any\", users=[\"admin\"], roles=[settings.ROLE_PROJECT_ADMIN])\n        make_label(self.project_b.item)\n\n        # for label creation\n        self.data = {\"text\": \"example\"}",
                                        "Function `test_returns_labels_to_project_member`\nCode:\n    def test_returns_labels_to_project_member(self):\n        for member in self.project_a.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)\n            self.assertEqual(response.data[0][\"id\"], self.label.id)",
                                        "Function `test_does_not_return_labels_to_non_project_member`\nCode:\n    def test_does_not_return_labels_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_does_not_return_labels_to_unauthenticated_user`\nCode:\n    def test_does_not_return_labels_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_create_label`\nCode:\n    def test_allows_admin_to_create_label(self):\n        self.assert_create(self.project_a.admin, status.HTTP_201_CREATED)",
                                        "Function `test_denies_project_staff_to_create_label`\nCode:\n    def test_denies_project_staff_to_create_label(self):\n        for member in self.project_a.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_create_label`\nCode:\n    def test_denies_non_project_member_to_create_label(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_create_label`\nCode:\n    def test_denies_unauthenticated_user_to_create_label(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_bulk_delete_label`\nCode:\n    def test_allows_admin_to_bulk_delete_label(self):\n        self.assert_delete(self.project_a.admin, status.HTTP_204_NO_CONTENT, data={\"ids\": [self.label.id]})",
                                        "Function `test_denies_project_staff_to_bulk_delete_label`\nCode:\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project_a.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})",
                                        "Class `TestAllowMemberToCreateLabelType`\nCode:\nclass TestAllowMemberToCreateLabelType(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, allow_member_to_create_label_type=True)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_types\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_allows_member_to_create_label_type(self):\n        for member in self.project.members:\n            self.data[\"text\"] = member.username\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, allow_member_to_create_label_type=True)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_types\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}",
                                        "Function `test_allows_member_to_create_label_type`\nCode:\n    def test_allows_member_to_create_label_type(self):\n        for member in self.project.members:\n            self.data[\"text\"] = member.username\n            self.assert_create(member, status.HTTP_201_CREATED)",
                                        "Function `test_denies_project_staff_to_bulk_delete_label`\nCode:\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})",
                                        "Class `TestLabelDetailAPI`\nCode:\nclass TestLabelDetailAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_type\", args=[cls.project.item.id, cls.label.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_returns_label_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.label.id)\n\n    def test_does_not_return_label_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_label_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_update_label(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_project_staff_to_update_label(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_label(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_update_label(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_delete_label(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_label(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_label(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_label(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_type\", args=[cls.project.item.id, cls.label.id])\n        cls.data = {\"text\": \"example\"}",
                                        "Function `test_returns_label_to_project_member`\nCode:\n    def test_returns_label_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.label.id)",
                                        "Function `test_does_not_return_label_to_non_project_member`\nCode:\n    def test_does_not_return_label_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_does_not_return_label_to_unauthenticated_user`\nCode:\n    def test_does_not_return_label_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_update_label`\nCode:\n    def test_allows_admin_to_update_label(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])",
                                        "Function `test_denies_project_staff_to_update_label`\nCode:\n    def test_denies_project_staff_to_update_label(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_update_label`\nCode:\n    def test_denies_non_project_member_to_update_label(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_update_label`\nCode:\n    def test_denies_unauthenticated_user_to_update_label(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_delete_label`\nCode:\n    def test_allows_admin_to_delete_label(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_project_staff_to_delete_label`\nCode:\n    def test_denies_project_staff_to_delete_label(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_delete_label`\nCode:\n    def test_denies_non_project_member_to_delete_label(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_delete_label`\nCode:\n    def test_denies_unauthenticated_user_to_delete_label(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestLabelUploadAPI`\nCode:\nclass TestLabelUploadAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.url = reverse(viewname=\"category_type_upload\", args=[cls.project.item.id])\n\n    def assert_upload_file(self, filename, user=None, expected_status=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        with open(os.path.join(DATA_DIR, filename), \"rb\") as f:\n            response = self.client.post(self.url, data={\"file\": f})\n        self.assertEqual(response.status_code, expected_status)\n\n    def test_allows_project_admin_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.project.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_member_to_upload_label(self):\n        for member in self.project.staffs:\n            self.assert_upload_file(\"valid_labels.json\", member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", expected_status=status.HTTP_403_FORBIDDEN)\n\n    def test_try_to_upload_invalid_file(self):\n        self.assert_upload_file(\"invalid_labels.json\", self.project.admin, status.HTTP_400_BAD_REQUEST)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.url = reverse(viewname=\"category_type_upload\", args=[cls.project.item.id])",
                                        "Function `assert_upload_file`\nCode:\n    def assert_upload_file(self, filename, user=None, expected_status=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        with open(os.path.join(DATA_DIR, filename), \"rb\") as f:\n            response = self.client.post(self.url, data={\"file\": f})\n        self.assertEqual(response.status_code, expected_status)",
                                        "Function `test_allows_project_admin_to_upload_label`\nCode:\n    def test_allows_project_admin_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.project.admin, status.HTTP_201_CREATED)",
                                        "Function `test_denies_project_member_to_upload_label`\nCode:\n    def test_denies_project_member_to_upload_label(self):\n        for member in self.project.staffs:\n            self.assert_upload_file(\"valid_labels.json\", member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_upload_label`\nCode:\n    def test_denies_non_project_member_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_upload_label`\nCode:\n    def test_denies_unauthenticated_user_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", expected_status=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_try_to_upload_invalid_file`\nCode:\n    def test_try_to_upload_invalid_file(self):\n        self.assert_upload_file(\"invalid_labels.json\", self.project.admin, status.HTTP_400_BAD_REQUEST)"
                                    ],
                                    "code": "import os\n\nfrom django.conf import settings\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\nfrom rest_framework.test import APITestCase\n\nfrom .utils import make_label\nfrom api.tests.utils import CRUDMixin\nfrom projects.models import ProjectType\nfrom projects.tests.utils import make_project, prepare_project\nfrom users.tests.utils import make_user\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"data\")\n\n\nclass TestLabelList(CRUDMixin):\n    def setUp(self):\n        self.non_member = make_user()\n        self.project_a = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.label = make_label(self.project_a.item)\n        self.url = reverse(viewname=\"category_types\", args=[self.project_a.item.id])\n\n        # Ensure that the API does not return the labels of the other project.\n        self.project_b = make_project(task=\"Any\", users=[\"admin\"], roles=[settings.ROLE_PROJECT_ADMIN])\n        make_label(self.project_b.item)\n\n        # for label creation\n        self.data = {\"text\": \"example\"}\n\n    def test_returns_labels_to_project_member(self):\n        for member in self.project_a.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)\n            self.assertEqual(response.data[0][\"id\"], self.label.id)\n\n    def test_does_not_return_labels_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_labels_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_create_label(self):\n        self.assert_create(self.project_a.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_create_label(self):\n        for member in self.project_a.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_create_label(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_label(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_bulk_delete_label(self):\n        self.assert_delete(self.project_a.admin, status.HTTP_204_NO_CONTENT, data={\"ids\": [self.label.id]})\n\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project_a.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})\n\n\nclass TestAllowMemberToCreateLabelType(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION, allow_member_to_create_label_type=True)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_types\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_allows_member_to_create_label_type(self):\n        for member in self.project.members:\n            self.data[\"text\"] = member.username\n            self.assert_create(member, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_bulk_delete_label(self):\n        member = self.project.staffs[0]\n        self.assert_delete(member, status.HTTP_403_FORBIDDEN, data={\"ids\": [self.label.id]})\n\n\nclass TestLabelDetailAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.label = make_label(cls.project.item)\n        cls.url = reverse(viewname=\"category_type\", args=[cls.project.item.id, cls.label.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_returns_label_to_project_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.label.id)\n\n    def test_does_not_return_label_to_non_project_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_label_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_update_label(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_project_staff_to_update_label(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_update_label(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_update_label(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_delete_label(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_label(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_delete_label(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_label(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestLabelUploadAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.non_member = make_user()\n        cls.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.url = reverse(viewname=\"category_type_upload\", args=[cls.project.item.id])\n\n    def assert_upload_file(self, filename, user=None, expected_status=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        with open(os.path.join(DATA_DIR, filename), \"rb\") as f:\n            response = self.client.post(self.url, data={\"file\": f})\n        self.assertEqual(response.status_code, expected_status)\n\n    def test_allows_project_admin_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.project.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_member_to_upload_label(self):\n        for member in self.project.staffs:\n            self.assert_upload_file(\"valid_labels.json\", member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_upload_label(self):\n        self.assert_upload_file(\"valid_labels.json\", expected_status=status.HTTP_403_FORBIDDEN)\n\n    def test_try_to_upload_invalid_file(self):\n        self.assert_upload_file(\"invalid_labels.json\", self.project.admin, status.HTTP_400_BAD_REQUEST)\n",
                                    "summary": "Class TestLabelList: A comprehensive test suite that verifies label access and management permissions within a project, ensuring only authorized users can fetch, create, update, delete, or upload labels while handling various user roles and authentication statuses.",
                                    "code_element_summaries": [
                                        "Class TestLabelList: A test suite for verifying label access and management permissions within a project, ensuring that only authorized users can fetch, create, or delete labels.",
                                        "Function `setUp`: A setup method that initializes test data, including user, project, label, and URL, while ensuring that labels from unrelated projects are not returned.",
                                        "Function `test_returns_labels_to_project_member`: A test function that verifies that each member of a project receives the correct label data with a successful HTTP response.",
                                        "Function `test_does_not_return_labels_to_non_project_member`: A test case that verifies a non-project member receives a forbidden status when attempting to fetch labels.",
                                        "Function `test_does_not_return_labels_to_unauthenticated_user`: A test case that asserts an unauthenticated user receives a 403 Forbidden status when attempting to fetch labels.",
                                        "Function `test_allows_admin_to_create_label`: A test case that verifies an admin user can successfully create a label, expecting a 201 Created status.",
                                        "Function `test_denies_project_staff_to_create_label`: A test function that verifies project staff members are forbidden from creating labels, expecting a 403 Forbidden status for each staff member in the project.",
                                        "Function `test_denies_non_project_member_to_create_label`: A test that verifies a non-project member receives a 403 Forbidden status when attempting to create a label.",
                                        "Function `test_denies_unauthenticated_user_to_create_label`: A test case that asserts an unauthenticated user receives a forbidden status when attempting to create a label.",
                                        "Function `test_allows_admin_to_bulk_delete_label`: A test that verifies if an admin can successfully perform a bulk delete operation on labels, expecting a 204 No Content response status.",
                                        "Function `test_denies_project_staff_to_bulk_delete_label`: A test case that verifies project staff members are forbidden from bulk deleting labels, expecting a 403 Forbidden status.",
                                        "Class TestAllowMemberToCreateLabelType: A test case that verifies members can create label types while ensuring project staff cannot bulk delete labels in a document classification project.",
                                        "Function `setUpTestData`: A class method that prepares test data by creating a project, a label associated with the project, and defining a URL and sample data for testing purposes.",
                                        "Function `test_allows_member_to_create_label_type`: A test that verifies each member of a project can successfully create a label type with their username.",
                                        "Function `test_denies_project_staff_to_bulk_delete_label`: A test case that verifies project staff members receive a 403 Forbidden status when attempting to bulk delete a label.",
                                        "Class TestLabelDetailAPI: A test suite that verifies label access and modification permissions for project members, non-members, and unauthenticated users in a document classification project.",
                                        "Function `setUpTestData`: A class method that initializes test data, including a user, a project, a label, a URL for a category type view, and a sample data dictionary.",
                                        "Function `test_returns_label_to_project_member`: A test function that verifies each project member can successfully fetch the label's ID with a 200 OK status.",
                                        "Function test_does_not_return_label_to_non_project_member: A test case that asserts a non-project member receives a 403 Forbidden status when attempting to fetch a label.",
                                        "Function `test_does_not_return_label_to_unauthenticated_user`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to fetch a label.",
                                        "Function `test_allows_admin_to_update_label`: A test that verifies an admin user can successfully update a label and checks that the updated label text matches the expected data.",
                                        "Function `test_denies_project_staff_to_update_label`: A test that verifies project staff members are forbidden from updating labels, asserting a 403 Forbidden status for each staff member.",
                                        "Function `test_denies_non_project_member_to_update_label`: A test case that verifies a non-project member receives a 403 Forbidden status when attempting to update a label.",
                                        "Function `test_denies_unauthenticated_user_to_update_label`: A test case that verifies an unauthenticated user receives a forbidden status when attempting to update a label.",
                                        "Function `test_allows_admin_to_delete_label`: A test function that verifies an admin user can successfully delete a label, expecting a 204 No Content status response.",
                                        "Function `test_denies_project_staff_to_delete_label`: A test that asserts project staff members receive a 403 Forbidden status when attempting to delete a label.",
                                        "Function `test_denies_non_project_member_to_delete_label`: A test case that verifies a non-project member receives a 403 Forbidden status when attempting to delete a label.",
                                        "Function `test_denies_unauthenticated_user_to_delete_label`: A test case that verifies an unauthenticated user receives a forbidden status when attempting to delete a label.",
                                        "Class `TestLabelUploadAPI`: A test case for verifying the label upload functionality, ensuring that only project admins can successfully upload valid label files while denying access to project members, non-members, unauthenticated users, and invalid files.",
                                        "Function `setUpTestData`: A class method that initializes test data by creating a non-member user, preparing a document classification project, and generating a URL for category type upload.",
                                        "Function `assert_upload_file`: A method that uploads a file and checks if the response status matches the expected status, optionally logging in a user before the upload.",
                                        "Function `test_allows_project_admin_to_upload_label`: A test case that verifies if a project admin can successfully upload a valid label file, expecting a 201 Created status.",
                                        "Function `test_denies_project_member_to_upload_label`: A test case that verifies project members are forbidden from uploading label files, expecting a 403 Forbidden status.",
                                        "Function `test_denies_non_project_member_to_upload_label`: A test case that verifies non-project members receive a 403 Forbidden status when attempting to upload label files.",
                                        "Function `test_denies_unauthenticated_user_to_upload_label`: A test case that verifies an unauthenticated user receives a forbidden status when attempting to upload a label file.",
                                        "Function `test_try_to_upload_invalid_file`: A test function that asserts the uploading of an invalid file results in a 400 Bad Request status."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `make_label`\nCode:\ndef make_label(project, **kwargs):\n    if project.project_type.endswith(\"Classification\") or project.project_type in {\n        ProjectType.BOUNDING_BOX,\n        ProjectType.SEGMENTATION,\n    }:\n        return mommy.make(\"CategoryType\", project=project, **kwargs)\n    else:\n        return mommy.make(\"SpanType\", project=project, **kwargs)"
                                    ],
                                    "code": "from model_mommy import mommy\n\nfrom projects.models import ProjectType\n\n\ndef make_label(project, **kwargs):\n    if project.project_type.endswith(\"Classification\") or project.project_type in {\n        ProjectType.BOUNDING_BOX,\n        ProjectType.SEGMENTATION,\n    }:\n        return mommy.make(\"CategoryType\", project=project, **kwargs)\n    else:\n        return mommy.make(\"SpanType\", project=project, **kwargs)\n",
                                    "summary": "Function `make_label`: A utility function that generates a CategoryType or SpanType instance depending on the project's classification, bounding box, or segmentation type.",
                                    "code_element_summaries": [
                                        "Function `make_label`: A utility function that creates either a CategoryType or SpanType instance based on the project's type for classification, bounding box, or segmentation projects."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import (\n    CategoryTypeDetail,\n    CategoryTypeList,\n    CategoryTypeUploadAPI,\n    RelationTypeDetail,\n    RelationTypeList,\n    RelationTypeUploadAPI,\n    SpanTypeDetail,\n    SpanTypeList,\n    SpanTypeUploadAPI,\n)\n\nurlpatterns = [\n    path(route=\"category-types\", view=CategoryTypeList.as_view(), name=\"category_types\"),\n    path(route=\"category-types/<int:label_id>\", view=CategoryTypeDetail.as_view(), name=\"category_type\"),\n    path(route=\"span-types\", view=SpanTypeList.as_view(), name=\"span_types\"),\n    path(route=\"span-types/<int:label_id>\", view=SpanTypeDetail.as_view(), name=\"span_type\"),\n    path(route=\"category-type-upload\", view=CategoryTypeUploadAPI.as_view(), name=\"category_type_upload\"),\n    path(route=\"span-type-upload\", view=SpanTypeUploadAPI.as_view(), name=\"span_type_upload\"),\n    path(route=\"relation-type-upload\", view=RelationTypeUploadAPI.as_view(), name=\"relation_type-upload\"),\n    path(route=\"relation-types\", view=RelationTypeList.as_view(), name=\"relation_types_list\"),\n    path(route=\"relation-types/<int:label_id>\", view=RelationTypeDetail.as_view(), name=\"relation_type_detail\"),\n]\n",
                            "summary": "URL patterns for category types, span types, and relation types in a Django application, defining routes for listing, detail views, and upload APIs.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Function `camel_to_snake`\nCode:\ndef camel_to_snake(name):\n    name = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", name).lower()",
                                "Function `camel_to_snake_dict`\nCode:\ndef camel_to_snake_dict(d):\n    return {camel_to_snake(k): v for k, v in d.items()}",
                                "Class `LabelList`\nCode:\nclass LabelList(generics.ListCreateAPIView):\n    model = LabelType\n    filter_backends = [DjangoFilterBackend]\n    serializer_class = LabelSerializer\n    pagination_class = None\n\n    def get_permissions(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.allow_member_to_create_label_type and self.request.method == \"POST\":\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n        return super().get_permissions()\n\n    def get_queryset(self):\n        return self.model.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        self.model.objects.filter(pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                "Function `get_permissions`\nCode:\n    def get_permissions(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.allow_member_to_create_label_type and self.request.method == \"POST\":\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n        return super().get_permissions()",
                                "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        return self.model.objects.filter(project=self.kwargs[\"project_id\"])",
                                "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])",
                                "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        self.model.objects.filter(pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                "Class `CategoryTypeList`\nCode:\nclass CategoryTypeList(LabelList):\n    model = CategoryType\n    serializer_class = CategoryTypeSerializer",
                                "Class `CategoryTypeDetail`\nCode:\nclass CategoryTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = CategoryType.objects.all()\n    serializer_class = CategoryTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]",
                                "Class `SpanTypeList`\nCode:\nclass SpanTypeList(LabelList):\n    model = SpanType\n    serializer_class = SpanTypeSerializer",
                                "Class `SpanTypeDetail`\nCode:\nclass SpanTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = SpanType.objects.all()\n    serializer_class = SpanTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]",
                                "Class `RelationTypeList`\nCode:\nclass RelationTypeList(LabelList):\n    model = RelationType\n    serializer_class = RelationTypeSerializer",
                                "Class `RelationTypeDetail`\nCode:\nclass RelationTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = RelationType.objects.all()\n    serializer_class = RelationTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]",
                                "Class `LabelUploadAPI`\nCode:\nclass LabelUploadAPI(APIView):\n    parser_classes = (MultiPartParser,)\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n    serializer_class = LabelSerializer\n\n    @transaction.atomic\n    def post(self, request, *args, **kwargs):\n        if \"file\" not in request.data:\n            raise ParseError(\"Empty content\")\n        try:\n            labels = json.load(request.data[\"file\"])\n            labels = list(map(camel_to_snake_dict, labels))\n            serializer = self.serializer_class(data=labels, many=True)\n            serializer.is_valid(raise_exception=True)\n            serializer.save(project_id=kwargs[\"project_id\"])\n            return Response(status=status.HTTP_201_CREATED)\n        except json.decoder.JSONDecodeError:\n            raise ParseError(\"The file format is invalid.\")\n        except IntegrityError:\n            raise LabelValidationError",
                                "Function `post`\nCode:\n    def post(self, request, *args, **kwargs):\n        if \"file\" not in request.data:\n            raise ParseError(\"Empty content\")\n        try:\n            labels = json.load(request.data[\"file\"])\n            labels = list(map(camel_to_snake_dict, labels))\n            serializer = self.serializer_class(data=labels, many=True)\n            serializer.is_valid(raise_exception=True)\n            serializer.save(project_id=kwargs[\"project_id\"])\n            return Response(status=status.HTTP_201_CREATED)\n        except json.decoder.JSONDecodeError:\n            raise ParseError(\"The file format is invalid.\")\n        except IntegrityError:\n            raise LabelValidationError",
                                "Class `CategoryTypeUploadAPI`\nCode:\nclass CategoryTypeUploadAPI(LabelUploadAPI):\n    serializer_class = CategoryTypeSerializer",
                                "Class `SpanTypeUploadAPI`\nCode:\nclass SpanTypeUploadAPI(LabelUploadAPI):\n    serializer_class = SpanTypeSerializer",
                                "Class `RelationTypeUploadAPI`\nCode:\nclass RelationTypeUploadAPI(LabelUploadAPI):\n    serializer_class = RelationTypeSerializer"
                            ],
                            "code": "import json\nimport re\n\nfrom django.db import IntegrityError, transaction\nfrom django.shortcuts import get_object_or_404\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import generics, status\nfrom rest_framework.exceptions import ParseError\nfrom rest_framework.parsers import MultiPartParser\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom .exceptions import LabelValidationError\nfrom .models import CategoryType, LabelType, RelationType, SpanType\nfrom .serializers import (\n    CategoryTypeSerializer,\n    LabelSerializer,\n    RelationTypeSerializer,\n    SpanTypeSerializer,\n)\nfrom projects.models import Project\nfrom projects.permissions import (\n    IsProjectAdmin,\n    IsProjectMember,\n    IsProjectStaffAndReadOnly,\n)\n\n\ndef camel_to_snake(name):\n    name = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", name).lower()\n\n\ndef camel_to_snake_dict(d):\n    return {camel_to_snake(k): v for k, v in d.items()}\n\n\nclass LabelList(generics.ListCreateAPIView):\n    model = LabelType\n    filter_backends = [DjangoFilterBackend]\n    serializer_class = LabelSerializer\n    pagination_class = None\n\n    def get_permissions(self):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.allow_member_to_create_label_type and self.request.method == \"POST\":\n            self.permission_classes = [IsAuthenticated & IsProjectMember]\n        else:\n            self.permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n        return super().get_permissions()\n\n    def get_queryset(self):\n        return self.model.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        self.model.objects.filter(pk__in=delete_ids).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass CategoryTypeList(LabelList):\n    model = CategoryType\n    serializer_class = CategoryTypeSerializer\n\n\nclass CategoryTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = CategoryType.objects.all()\n    serializer_class = CategoryTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n\nclass SpanTypeList(LabelList):\n    model = SpanType\n    serializer_class = SpanTypeSerializer\n\n\nclass SpanTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = SpanType.objects.all()\n    serializer_class = SpanTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n\nclass RelationTypeList(LabelList):\n    model = RelationType\n    serializer_class = RelationTypeSerializer\n\n\nclass RelationTypeDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = RelationType.objects.all()\n    serializer_class = RelationTypeSerializer\n    lookup_url_kwarg = \"label_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n\nclass LabelUploadAPI(APIView):\n    parser_classes = (MultiPartParser,)\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n    serializer_class = LabelSerializer\n\n    @transaction.atomic\n    def post(self, request, *args, **kwargs):\n        if \"file\" not in request.data:\n            raise ParseError(\"Empty content\")\n        try:\n            labels = json.load(request.data[\"file\"])\n            labels = list(map(camel_to_snake_dict, labels))\n            serializer = self.serializer_class(data=labels, many=True)\n            serializer.is_valid(raise_exception=True)\n            serializer.save(project_id=kwargs[\"project_id\"])\n            return Response(status=status.HTTP_201_CREATED)\n        except json.decoder.JSONDecodeError:\n            raise ParseError(\"The file format is invalid.\")\n        except IntegrityError:\n            raise LabelValidationError\n\n\nclass CategoryTypeUploadAPI(LabelUploadAPI):\n    serializer_class = CategoryTypeSerializer\n\n\nclass SpanTypeUploadAPI(LabelUploadAPI):\n    serializer_class = SpanTypeSerializer\n\n\nclass RelationTypeUploadAPI(LabelUploadAPI):\n    serializer_class = RelationTypeSerializer\n",
                            "summary": "Utility functions and Django REST framework views for converting camelCase to snake_case, managing label types, category types, span types, and relation types, along with handling permissions, filtering, and uploads in a project-specific context.",
                            "code_element_summaries": [
                                "Function `camel_to_snake`: A utility function that converts a camelCase string into a snake_case format by inserting underscores before uppercase letters and transforming the entire string to lowercase.",
                                "Function `camel_to_snake_dict`: Converts a dictionary with camelCase keys into a dictionary with snake_case keys by applying the `camel_to_snake` transformation to each key.",
                                "Class `LabelList`: A Django REST framework view that handles the listing and creation of label types for a specific project, with permissions and filtering based on project membership.",
                                "Function `get_permissions`: Determines the permissions for a request based on the project's settings and the request method, allowing members to create label types if permitted.",
                                "Function `get_queryset`: Retrieves a filtered queryset of model objects associated with a specific project identified by `project_id`.",
                                "Function `perform_create`: Saves the serializer with the project ID extracted from the URL parameters.",
                                "Function `delete`: A method that deletes objects from the model based on a list of IDs provided in the request data and returns a 204 No Content response.",
                                "Class CategoryTypeList: A list representation of CategoryType objects that uses CategoryTypeSerializer for serialization.",
                                "Class `CategoryTypeDetail`: A view for retrieving, updating, and deleting category types, with specific permissions and URL lookup for label IDs.",
                                "Class SpanTypeList: A list representation of SpanType objects, utilizing the SpanType model and SpanTypeSerializer for data handling.",
                                "Class SpanTypeDetail: A view for retrieving, updating, and deleting SpanType instances, with authentication and permission checks based on user roles.",
                                "Class RelationTypeList: A specialized label list that manages RelationType instances using the specified serializer.",
                                "Class `RelationTypeDetail`: A view for retrieving, updating, and deleting relation types, requiring authentication and specific project permissions.",
                                "Class `LabelUploadAPI`: An API view that handles the upload of label data in JSON format, ensuring the file is valid and saving the labels to a specified project while enforcing authentication and project admin permissions.",
                                "Function `post`: Handles file uploads by validating and saving label data, returning a success response or raising errors for empty content, invalid file format, or integrity issues.",
                                "Class CategoryTypeUploadAPI: A specialized API for uploading category types, utilizing the CategoryTypeSerializer for data serialization.",
                                "Class SpanTypeUploadAPI: An extension of LabelUploadAPI that specifies the serializer class for handling span type uploads.",
                                "Class RelationTypeUploadAPI: A specialized API for uploading relation types, utilizing the RelationTypeSerializer for data serialization."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\label_types\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "manage.py",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\manage.py",
                    "is_dir": false,
                    "code_elements": [],
                    "code": "#!/usr/bin/env python\nimport os\nimport sys\n\nif __name__ == \"__main__\":\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings.development\")\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)\n",
                    "summary": "Script to set up the Django environment and execute command-line management tasks while handling potential import errors.",
                    "code_element_summaries": [],
                    "children": []
                },
                {
                    "name": "metrics",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "Summary: The content includes a proxy model ExportedBoundingBox for converting bounding box data, a MetricsConfig class for Django application configuration, a comprehensive test suite for document classification project progress and category distribution, URL patterns for API endpoints, and classes and functions for managing project example counts and member progress with strict authentication and permissions.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\admin.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class ExportedBoundingBox: A proxy model of BoundingBox that provides methods to convert bounding box data into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `MetricsConfig`\nCode:\nclass MetricsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"metrics\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass MetricsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"metrics\"\n",
                            "summary": "Class MetricsConfig: A Django application configuration class that defines the default auto field type and names the application \"metrics.\"",
                            "code_element_summaries": [
                                "Class MetricsConfig: A Django application configuration class that sets the default auto field type and specifies the application name as \"metrics.\""
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\models.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class ExportedBoundingBox: A subclass of BoundingBox that provides methods to convert bounding box attributes into dictionary and tuple formats while serving as a proxy model.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "tests.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\tests.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `TestMemberProgress`\nCode:\nclass TestMemberProgress(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"member_progress\", args=[self.project.item.id])\n\n    def test_fetch_initial_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})\n\n    def test_fetch_progress(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})",
                                "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"member_progress\", args=[self.project.item.id])",
                                "Function `test_fetch_initial_progress`\nCode:\n    def test_fetch_initial_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})",
                                "Function `test_fetch_progress`\nCode:\n    def test_fetch_progress(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})",
                                "Class `TestProgressHelper`\nCode:\nclass TestProgressHelper(CRUDMixin):\n    collaborative_annotation = False\n\n    def setUp(self):\n        self.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=self.collaborative_annotation\n        )\n        self.example = make_doc(self.project.item)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        self.url = reverse(viewname=\"progress\", args=[self.project.item.id])",
                                "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=self.collaborative_annotation\n        )\n        self.example = make_doc(self.project.item)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        self.url = reverse(viewname=\"progress\", args=[self.project.item.id])",
                                "Class `TestProgress`\nCode:\nclass TestProgress(TestProgressHelper):\n    collaborative_annotation = False\n\n    def test_fetch_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n        self.assertEqual(response.data, expected)\n\n    def test_cannot_affect_others_progress(self):\n        for member in self.project.staffs:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 1, \"complete\": 0}\n            self.assertEqual(response.data, expected)",
                                "Function `test_fetch_progress`\nCode:\n    def test_fetch_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n        self.assertEqual(response.data, expected)",
                                "Function `test_cannot_affect_others_progress`\nCode:\n    def test_cannot_affect_others_progress(self):\n        for member in self.project.staffs:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 1, \"complete\": 0}\n            self.assertEqual(response.data, expected)",
                                "Class `TestProgressOnCollaborativeAnnotation`\nCode:\nclass TestProgressOnCollaborativeAnnotation(TestProgressHelper):\n    collaborative_annotation = True\n\n    def test_fetch_progress(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n            self.assertEqual(response.data, expected)",
                                "Function `test_fetch_progress`\nCode:\n    def test_fetch_progress(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n            self.assertEqual(response.data, expected)",
                                "Class `TestCategoryDistribution`\nCode:\nclass TestCategoryDistribution(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.label = make_label(self.project.item, text=\"label\")\n        mommy.make(\"Category\", example=self.example, label=self.label, user=self.project.admin)\n        self.url = reverse(viewname=\"category_distribution\", args=[self.project.item.id])\n\n    def test_fetch_distribution(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {member.username: {self.label.text: 0} for member in self.project.members}\n        expected[self.project.admin.username][self.label.text] = 1\n        self.assertEqual(response.data, expected)",
                                "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.label = make_label(self.project.item, text=\"label\")\n        mommy.make(\"Category\", example=self.example, label=self.label, user=self.project.admin)\n        self.url = reverse(viewname=\"category_distribution\", args=[self.project.item.id])",
                                "Function `test_fetch_distribution`\nCode:\n    def test_fetch_distribution(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {member.username: {self.label.text: 0} for member in self.project.members}\n        expected[self.project.admin.username][self.label.text] = 1\n        self.assertEqual(response.data, expected)"
                            ],
                            "code": "from model_mommy import mommy\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom examples.tests.utils import make_doc\nfrom label_types.tests.utils import make_label\nfrom projects.models import ProjectType\nfrom projects.tests.utils import prepare_project\n\n\nclass TestMemberProgress(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.url = reverse(viewname=\"member_progress\", args=[self.project.item.id])\n\n    def test_fetch_initial_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})\n\n    def test_fetch_progress(self):\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected_progress = [{\"user\": member.username, \"done\": 0} for member in self.project.members]\n        expected_progress[0][\"done\"] = 1\n        self.assertEqual(response.data, {\"total\": 1, \"progress\": expected_progress})\n\n\nclass TestProgressHelper(CRUDMixin):\n    collaborative_annotation = False\n\n    def setUp(self):\n        self.project = prepare_project(\n            ProjectType.DOCUMENT_CLASSIFICATION, collaborative_annotation=self.collaborative_annotation\n        )\n        self.example = make_doc(self.project.item)\n        mommy.make(\"ExampleState\", example=self.example, confirmed_by=self.project.admin)\n        self.url = reverse(viewname=\"progress\", args=[self.project.item.id])\n\n\nclass TestProgress(TestProgressHelper):\n    collaborative_annotation = False\n\n    def test_fetch_progress(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n        self.assertEqual(response.data, expected)\n\n    def test_cannot_affect_others_progress(self):\n        for member in self.project.staffs:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 1, \"complete\": 0}\n            self.assertEqual(response.data, expected)\n\n\nclass TestProgressOnCollaborativeAnnotation(TestProgressHelper):\n    collaborative_annotation = True\n\n    def test_fetch_progress(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            expected = {\"total\": 1, \"remaining\": 0, \"complete\": 1}\n            self.assertEqual(response.data, expected)\n\n\nclass TestCategoryDistribution(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project(ProjectType.DOCUMENT_CLASSIFICATION)\n        self.example = make_doc(self.project.item)\n        self.label = make_label(self.project.item, text=\"label\")\n        mommy.make(\"Category\", example=self.example, label=self.label, user=self.project.admin)\n        self.url = reverse(viewname=\"category_distribution\", args=[self.project.item.id])\n\n    def test_fetch_distribution(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        expected = {member.username: {self.label.text: 0} for member in self.project.members}\n        expected[self.project.admin.username][self.label.text] = 1\n        self.assertEqual(response.data, expected)\n",
                            "summary": "A comprehensive test suite for verifying member progress and category distribution in a document classification project, ensuring accurate fetching of initial and updated progress data, individual progress integrity, and correct category counts across project members.",
                            "code_element_summaries": [
                                "Class `TestMemberProgress`: A test case for verifying the progress of members in a document classification project, ensuring accurate initial and updated progress data is fetched correctly.",
                                "Function `setUp`: Prepares a document classification project, creates an example document, and sets the URL for the member progress view.",
                                "Function `test_fetch_initial_progress`: A test that verifies the initial progress of project members is fetched correctly, asserting a successful response and matching expected progress data.",
                                "Function `test_fetch_progress`: A test case that verifies the progress fetching functionality for project members, ensuring the response matches the expected format and values.",
                                "Class TestProgressHelper: A helper class for setting up test environments related to project progress in document classification, including project preparation and example state creation.",
                                "Function `setUp`: Initializes a test environment by preparing a project for document classification, creating an example document, and setting up a URL for progress tracking.",
                                "Class TestProgress: A test suite that verifies the progress fetching functionality and ensures that users cannot affect each other's progress in a collaborative annotation project.",
                                "Function `test_fetch_progress`: A test that verifies the fetch progress function returns the expected total, remaining, and complete values for a project.",
                                "Function `test_cannot_affect_others_progress`: A test function that verifies that the progress of each staff member in a project remains unaffected, ensuring that their individual progress data returns the expected values.",
                                "Class TestProgressOnCollaborativeAnnotation: A test case that verifies the progress of collaborative annotations for project members, ensuring the correct status is returned.",
                                "Function `test_fetch_progress`: A test that verifies the fetch progress of project members, ensuring the response data matches the expected total, remaining, and complete counts.",
                                "Class TestCategoryDistribution: A test case for verifying the distribution of categories in a document classification project, ensuring that category counts are correctly fetched for project members.",
                                "Function `setUp`: Prepares a test environment by creating a project for document classification, an example document, a label, and a category, while also defining the URL for category distribution based on the project item ID.",
                                "Function `test_fetch_distribution`: A test case that verifies the distribution of label assignments among project members, ensuring the response matches the expected structure and values."
                            ],
                            "children": []
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import (\n    CategoryTypeDistribution,\n    MemberProgressAPI,\n    ProgressAPI,\n    RelationTypeDistribution,\n    SpanTypeDistribution,\n)\n\nurlpatterns = [\n    path(route=\"progress\", view=ProgressAPI.as_view(), name=\"progress\"),\n    path(route=\"member-progress\", view=MemberProgressAPI.as_view(), name=\"member_progress\"),\n    path(route=\"category-distribution\", view=CategoryTypeDistribution.as_view(), name=\"category_distribution\"),\n    path(route=\"relation-distribution\", view=RelationTypeDistribution.as_view(), name=\"relation_distribution\"),\n    path(route=\"span-distribution\", view=SpanTypeDistribution.as_view(), name=\"span_distribution\"),\n]\n",
                            "summary": "URL patterns for various API endpoints related to progress and distribution types in a Django application.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ProgressAPI`\nCode:\nclass ProgressAPI(APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        total = examples.count()\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.collaborative_annotation:\n            complete = ExampleState.objects.count_done(examples)\n        else:\n            complete = ExampleState.objects.count_done(examples, user=self.request.user)\n        data = {\"total\": total, \"remaining\": total - complete, \"complete\": complete}\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        total = examples.count()\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.collaborative_annotation:\n            complete = ExampleState.objects.count_done(examples)\n        else:\n            complete = ExampleState.objects.count_done(examples, user=self.request.user)\n        data = {\"total\": total, \"remaining\": total - complete, \"complete\": complete}\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Class `MemberProgressAPI`\nCode:\nclass MemberProgressAPI(APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = ExampleState.objects.measure_member_progress(examples, members)\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = ExampleState.objects.measure_member_progress(examples, members)\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Class `LabelDistribution`\nCode:\nclass LabelDistribution(abc.ABC, APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    model = Label\n    label_type = LabelType\n\n    def get(self, request, *args, **kwargs):\n        labels = self.label_type.objects.filter(project=self.kwargs[\"project_id\"])\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = self.model.objects.calc_label_distribution(examples, members, labels)\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        labels = self.label_type.objects.filter(project=self.kwargs[\"project_id\"])\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = self.model.objects.calc_label_distribution(examples, members, labels)\n        return Response(data=data, status=status.HTTP_200_OK)",
                                "Class `CategoryTypeDistribution`\nCode:\nclass CategoryTypeDistribution(LabelDistribution):\n    model = Category\n    label_type = CategoryType",
                                "Class `SpanTypeDistribution`\nCode:\nclass SpanTypeDistribution(LabelDistribution):\n    model = Span\n    label_type = SpanType",
                                "Class `RelationTypeDistribution`\nCode:\nclass RelationTypeDistribution(LabelDistribution):\n    model = Relation\n    label_type = RelationType"
                            ],
                            "code": "import abc\n\nfrom django.shortcuts import get_object_or_404\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom examples.models import Example, ExampleState\nfrom label_types.models import CategoryType, LabelType, RelationType, SpanType\nfrom labels.models import Category, Label, Relation, Span\nfrom projects.models import Member, Project\nfrom projects.permissions import IsProjectAdmin, IsProjectStaffAndReadOnly\n\n\nclass ProgressAPI(APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        total = examples.count()\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        if project.collaborative_annotation:\n            complete = ExampleState.objects.count_done(examples)\n        else:\n            complete = ExampleState.objects.count_done(examples, user=self.request.user)\n        data = {\"total\": total, \"remaining\": total - complete, \"complete\": complete}\n        return Response(data=data, status=status.HTTP_200_OK)\n\n\nclass MemberProgressAPI(APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get(self, request, *args, **kwargs):\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = ExampleState.objects.measure_member_progress(examples, members)\n        return Response(data=data, status=status.HTTP_200_OK)\n\n\nclass LabelDistribution(abc.ABC, APIView):\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n    model = Label\n    label_type = LabelType\n\n    def get(self, request, *args, **kwargs):\n        labels = self.label_type.objects.filter(project=self.kwargs[\"project_id\"])\n        examples = Example.objects.filter(project=self.kwargs[\"project_id\"]).values(\"id\")\n        members = Member.objects.filter(project=self.kwargs[\"project_id\"])\n        data = self.model.objects.calc_label_distribution(examples, members, labels)\n        return Response(data=data, status=status.HTTP_200_OK)\n\n\nclass CategoryTypeDistribution(LabelDistribution):\n    model = Category\n    label_type = CategoryType\n\n\nclass SpanTypeDistribution(LabelDistribution):\n    model = Span\n    label_type = SpanType\n\n\nclass RelationTypeDistribution(LabelDistribution):\n    model = Relation\n    label_type = RelationType\n",
                            "summary": "Classes and functions for an API that manage and analyze project example counts, member progress, and label distributions, with strict authentication and permission requirements for project-specific access.",
                            "code_element_summaries": [
                                "Class ProgressAPI: An API view that retrieves and returns the total, remaining, and completed example counts for a specific project, enforcing authentication and project-specific permissions.",
                                "Function `get`: Retrieves and returns a JSON response containing the total number of examples and their completion status for a specified project, considering user-specific access if collaborative annotation is disabled.",
                                "Class MemberProgressAPI: An API view that retrieves and measures the progress of members within a specified project, requiring authentication and appropriate permissions.",
                                "Function `get`: Retrieves the progress of members associated with a specific project by filtering examples and returning the measured data in a response.",
                                "Class LabelDistribution: An abstract view that calculates and returns the distribution of labels for a specific project, ensuring access is restricted to authenticated project administrators and staff.",
                                "Function `get`: Retrieves label distribution data for a specific project by filtering labels, examples, and members, and returns the data in a response with a 200 OK status.",
                                "Class CategoryTypeDistribution: A model that represents the distribution of labels categorized by type, inheriting from LabelDistribution and associated with the Category model.",
                                "Class SpanTypeDistribution: A model that extends LabelDistribution to represent the distribution of span types associated with the Span model.",
                                "Class RelationTypeDistribution: A model for distributing labels based on relation types, inheriting from LabelDistribution."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\metrics\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "projects",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content describes a Django application for project management, featuring customized admin models for managing members, projects, and tags; application configuration; custom exceptions for role constraints; a management command for member creation; migration scripts for project models; role-based permission controls; serializers for member and project data; a comprehensive test suite; URL routing for project-related functionalities; and views for handling project members, projects, and tags with authentication and access control.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `MemberAdmin`\nCode:\nclass MemberAdmin(admin.ModelAdmin):\n    list_display = (\n        \"user\",\n        \"role\",\n        \"project\",\n    )\n    ordering = (\"user\",)\n    search_fields = (\"user__username\",)",
                                "Class `ProjectAdmin`\nCode:\nclass ProjectAdmin(admin.ModelAdmin):\n    list_display = (\"name\", \"description\", \"project_type\", \"random_order\", \"collaborative_annotation\")\n    ordering = (\"project_type\",)\n    search_fields = (\"name\",)",
                                "Class `TagAdmin`\nCode:\nclass TagAdmin(admin.ModelAdmin):\n    list_display = (\n        \"project\",\n        \"text\",\n    )\n    ordering = (\n        \"project\",\n        \"text\",\n    )\n    search_fields = (\"text\",)"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import (\n    BoundingBoxProject,\n    ImageCaptioningProject,\n    ImageClassificationProject,\n    Member,\n    Project,\n    SegmentationProject,\n    Seq2seqProject,\n    SequenceLabelingProject,\n    Tag,\n    TextClassificationProject,\n)\n\n\nclass MemberAdmin(admin.ModelAdmin):\n    list_display = (\n        \"user\",\n        \"role\",\n        \"project\",\n    )\n    ordering = (\"user\",)\n    search_fields = (\"user__username\",)\n\n\nclass ProjectAdmin(admin.ModelAdmin):\n    list_display = (\"name\", \"description\", \"project_type\", \"random_order\", \"collaborative_annotation\")\n    ordering = (\"project_type\",)\n    search_fields = (\"name\",)\n\n\nclass TagAdmin(admin.ModelAdmin):\n    list_display = (\n        \"project\",\n        \"text\",\n    )\n    ordering = (\n        \"project\",\n        \"text\",\n    )\n    search_fields = (\"text\",)\n\n\nadmin.site.register(Member, MemberAdmin)\nadmin.site.register(Project, ProjectAdmin)\nadmin.site.register(TextClassificationProject, ProjectAdmin)\nadmin.site.register(SequenceLabelingProject, ProjectAdmin)\nadmin.site.register(Seq2seqProject, ProjectAdmin)\nadmin.site.register(BoundingBoxProject, ProjectAdmin)\nadmin.site.register(SegmentationProject, ProjectAdmin)\nadmin.site.register(ImageCaptioningProject, ProjectAdmin)\nadmin.site.register(ImageClassificationProject, ProjectAdmin)\nadmin.site.register(Tag, TagAdmin)\n",
                            "summary": "Classes MemberAdmin, ProjectAdmin, and TagAdmin: Django admin models that customize the display, ordering, and search functionality for member records, project entries, and tags associated with projects, respectively, in the admin interface.",
                            "code_element_summaries": [
                                "Class MemberAdmin: A Django admin model that customizes the display, ordering, and search functionality for member records in the admin interface.",
                                "Class ProjectAdmin: A Django admin model that customizes the display, ordering, and search functionality for project entries in the admin interface.",
                                "Class TagAdmin: A Django admin model that manages the display, ordering, and search functionality for tags associated with projects."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ProjectsConfig`\nCode:\nclass ProjectsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"projects\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass ProjectsConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"projects\"\n",
                            "summary": "Class ProjectsConfig: A Django application configuration class that defines the default auto field type and names the application \"projects.\"",
                            "code_element_summaries": [
                                "Class ProjectsConfig: A Django application configuration class that sets the default auto field type and specifies the application name as \"projects.\""
                            ],
                            "children": []
                        },
                        {
                            "name": "exceptions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\exceptions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RoleConstraintException`\nCode:\nclass RoleConstraintException(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"The project needs at least one administrator.\"",
                                "Class `RoleAlreadyAssignedException`\nCode:\nclass RoleAlreadyAssignedException(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"This user is already assigned to a role in this project.\""
                            ],
                            "code": "from rest_framework import status\nfrom rest_framework.exceptions import APIException\n\n\nclass RoleConstraintException(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"The project needs at least one administrator.\"\n\n\nclass RoleAlreadyAssignedException(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = \"This user is already assigned to a role in this project.\"\n",
                            "summary": "Class RoleConstraintException and Class RoleAlreadyAssignedException: Custom API exceptions that handle project role constraints and user role assignments, both with a default status code of 400 Bad Request.",
                            "code_element_summaries": [
                                "Class RoleConstraintException: An API exception that indicates a project must have at least one administrator, with a default status code of 400 Bad Request.",
                                "Class RoleAlreadyAssignedException: A custom API exception that indicates a user is already assigned to a role in a project, with a status code of 400 Bad Request."
                            ],
                            "children": []
                        },
                        {
                            "name": "management",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\management",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Command: A management command designed for the non-interactive creation of a member by processing inputs for role name, username, and project name, with built-in error handling and feedback delivery.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "commands",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\management\\commands",
                                    "is_dir": true,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "Class Command: A management command that enables the non-interactive creation of a member by processing role name, username, and project name inputs, while handling errors and delivering feedback.",
                                    "code_element_summaries": [],
                                    "children": [
                                        {
                                            "name": "create_member.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\management\\commands\\create_member.py",
                                            "is_dir": false,
                                            "code_elements": [
                                                "Class `Command`\nCode:\nclass Command(BaseCommand):\n    help = \"Non-interactively create a member\"\n\n    @classmethod\n    def add_arguments(self, parser):\n        parser.add_argument(\"--rolename\", default=None, help=\"The name of the role.\")\n        parser.add_argument(\"--username\", default=None, help=\"The name of the user.\")\n        parser.add_argument(\"--projectname\", default=None, help=\"The name of the project.\")\n\n    def handle(self, *args, **options):\n        rolename = options.get(\"rolename\")\n        username = options.get(\"username\")\n        projectname = options.get(\"projectname\")\n\n        if not rolename or not username or not projectname:\n            raise CommandError(\"--rolename  --projectname  --username are required for the member\")\n\n        if rolename and projectname and username:\n            try:\n                role = Role.objects.get(name=rolename)\n                user = User.objects.get(username=username)\n                project = Project.objects.get(name=projectname)\n                member = Member.objects.create(role_id=role.id, user_id=user.id, project_id=project.id)\n            except Exception as ex:\n                self.stderr.write(self.style.ERROR('Error occurred while creating member \"%s\"' % ex))\n            else:\n                self.stdout.write(self.style.SUCCESS('Member created successfully \"%s\"' % member.id))",
                                                "Function `add_arguments`\nCode:\n    def add_arguments(self, parser):\n        parser.add_argument(\"--rolename\", default=None, help=\"The name of the role.\")\n        parser.add_argument(\"--username\", default=None, help=\"The name of the user.\")\n        parser.add_argument(\"--projectname\", default=None, help=\"The name of the project.\")",
                                                "Function `handle`\nCode:\n    def handle(self, *args, **options):\n        rolename = options.get(\"rolename\")\n        username = options.get(\"username\")\n        projectname = options.get(\"projectname\")\n\n        if not rolename or not username or not projectname:\n            raise CommandError(\"--rolename  --projectname  --username are required for the member\")\n\n        if rolename and projectname and username:\n            try:\n                role = Role.objects.get(name=rolename)\n                user = User.objects.get(username=username)\n                project = Project.objects.get(name=projectname)\n                member = Member.objects.create(role_id=role.id, user_id=user.id, project_id=project.id)\n            except Exception as ex:\n                self.stderr.write(self.style.ERROR('Error occurred while creating member \"%s\"' % ex))\n            else:\n                self.stdout.write(self.style.SUCCESS('Member created successfully \"%s\"' % member.id))"
                                            ],
                                            "code": "from django.contrib.auth.models import User\nfrom django.core.management.base import BaseCommand, CommandError\nfrom models import Project\n\nfrom ...models import Member\nfrom roles.models import Role\n\n\nclass Command(BaseCommand):\n    help = \"Non-interactively create a member\"\n\n    @classmethod\n    def add_arguments(self, parser):\n        parser.add_argument(\"--rolename\", default=None, help=\"The name of the role.\")\n        parser.add_argument(\"--username\", default=None, help=\"The name of the user.\")\n        parser.add_argument(\"--projectname\", default=None, help=\"The name of the project.\")\n\n    def handle(self, *args, **options):\n        rolename = options.get(\"rolename\")\n        username = options.get(\"username\")\n        projectname = options.get(\"projectname\")\n\n        if not rolename or not username or not projectname:\n            raise CommandError(\"--rolename  --projectname  --username are required for the member\")\n\n        if rolename and projectname and username:\n            try:\n                role = Role.objects.get(name=rolename)\n                user = User.objects.get(username=username)\n                project = Project.objects.get(name=projectname)\n                member = Member.objects.create(role_id=role.id, user_id=user.id, project_id=project.id)\n            except Exception as ex:\n                self.stderr.write(self.style.ERROR('Error occurred while creating member \"%s\"' % ex))\n            else:\n                self.stdout.write(self.style.SUCCESS('Member created successfully \"%s\"' % member.id))\n",
                                            "summary": "Class Command: A management command that facilitates the non-interactive creation of a member by accepting role name, username, and project name as arguments, while managing potential errors and providing feedback.",
                                            "code_element_summaries": [
                                                "Class Command: A management command that non-interactively creates a member by requiring a role name, username, and project name, and handles potential errors during the process.",
                                                "Function `add_arguments`: A method that adds command-line argument options for role name, user name, and project name to a parser.",
                                                "Function `handle`: A method that processes command options to create a new member associated with a specified role, user, and project, while handling errors and providing success or error messages."
                                            ],
                                            "children": []
                                        },
                                        {
                                            "name": "__init__.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\management\\commands\\__init__.py",
                                            "is_dir": false,
                                            "code_elements": [],
                                            "code": "",
                                            "summary": "",
                                            "code_element_summaries": [],
                                            "children": []
                                        }
                                    ]
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\management\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A series of Django migrations that create and modify various project models and their fields, ensuring compatibility and dependencies with existing models and migrations.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"roles\", \"0003_delete_member\"),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Member\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\"role\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"roles.role\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"user\", \"project\")},\n                    },\n                ),\n            ],\n            database_operations=[],\n        ),\n        migrations.RunSQL(\n            sql=\"ALTER TABLE members_member RENAME TO projects_member\",\n            reverse_sql=\"ALTER TABLE projects_member RENAME TO members_member\",\n        ),\n        migrations.RunSQL(\n            sql=\"UPDATE django_content_type SET app_label='projects' WHERE app_label='members'\",\n            reverse_sql=\"UPDATE django_content_type SET app_label='members' WHERE app_label='projects'\",\n        ),\n        migrations.RunSQL(\n            sql=\"UPDATE django_migrations SET app='projects' WHERE app='members'\",\n            reverse_sql=\"UPDATE django_migrations SET app='members' WHERE app='projects'\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-13 01:54\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"roles\", \"0003_delete_member\"),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Member\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\"role\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"roles.role\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"user\", \"project\")},\n                    },\n                ),\n            ],\n            database_operations=[],\n        ),\n        migrations.RunSQL(\n            sql=\"ALTER TABLE members_member RENAME TO projects_member\",\n            reverse_sql=\"ALTER TABLE projects_member RENAME TO members_member\",\n        ),\n        migrations.RunSQL(\n            sql=\"UPDATE django_content_type SET app_label='projects' WHERE app_label='members'\",\n            reverse_sql=\"UPDATE django_content_type SET app_label='members' WHERE app_label='projects'\",\n        ),\n        migrations.RunSQL(\n            sql=\"UPDATE django_migrations SET app='projects' WHERE app='members'\",\n            reverse_sql=\"UPDATE django_migrations SET app='members' WHERE app='projects'\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that defines a new \"Member\" model, modifies database table names and app labels, and sets dependencies on other migrations and the user model.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates a new \"Member\" model, updates database table names and app labels, and establishes dependencies on other migrations and the user model."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_auto_20220204_0201.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0002_auto_20220204_0201.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n        (\"projects\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Project\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"name\", models.CharField(max_length=100)),\n                        (\"description\", models.TextField(default=\"\")),\n                        (\"guideline\", models.TextField(blank=True, default=\"\")),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project_type\",\n                            models.CharField(\n                                choices=[\n                                    (\"DocumentClassification\", \"document classification\"),\n                                    (\"SequenceLabeling\", \"sequence labeling\"),\n                                    (\"Seq2seq\", \"sequence to sequence\"),\n                                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                                    (\"Speech2text\", \"speech to text\"),\n                                    (\"ImageClassification\", \"image classification\"),\n                                ],\n                                max_length=30,\n                            ),\n                        ),\n                        (\"random_order\", models.BooleanField(default=False)),\n                        (\"collaborative_annotation\", models.BooleanField(default=False)),\n                        (\"single_class_classification\", models.BooleanField(default=False)),\n                        (\n                            \"created_by\",\n                            models.ForeignKey(\n                                null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                            ),\n                        ),\n                        (\n                            \"polymorphic_ctype\",\n                            models.ForeignKey(\n                                editable=False,\n                                null=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"polymorphic_projects.project_set+\",\n                                to=\"contenttypes.contenttype\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"ImageClassificationProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"IntentDetectionAndSlotFillingProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Seq2seqProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"SequenceLabelingProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                        (\"allow_overlapping\", models.BooleanField(default=False)),\n                        (\"grapheme_mode\", models.BooleanField(default=False)),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Speech2textProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"TextClassificationProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Tag\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.TextField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"tags\", to=\"projects.project\"\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.AlterField(\n                    model_name=\"member\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            database_operations=[\n                migrations.RunSQL(\n                    sql=\"\"\"\n                    UPDATE django_content_type\n                    SET app_label = 'projects'\n                    WHERE app_label = 'api' AND model LIKE '%project'\n                    \"\"\",\n                    reverse_sql=\"\"\"\n                    UPDATE django_content_type\n                    SET app_label = 'api'\n                    WHERE app_label = 'projects' AND model LIKE '%project'\n                    \"\"\",\n                )\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.11 on 2022-02-04 02:01\n\nimport django.db.models.deletion\nfrom django.conf import settings\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n        (\"projects\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Project\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"name\", models.CharField(max_length=100)),\n                        (\"description\", models.TextField(default=\"\")),\n                        (\"guideline\", models.TextField(blank=True, default=\"\")),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project_type\",\n                            models.CharField(\n                                choices=[\n                                    (\"DocumentClassification\", \"document classification\"),\n                                    (\"SequenceLabeling\", \"sequence labeling\"),\n                                    (\"Seq2seq\", \"sequence to sequence\"),\n                                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                                    (\"Speech2text\", \"speech to text\"),\n                                    (\"ImageClassification\", \"image classification\"),\n                                ],\n                                max_length=30,\n                            ),\n                        ),\n                        (\"random_order\", models.BooleanField(default=False)),\n                        (\"collaborative_annotation\", models.BooleanField(default=False)),\n                        (\"single_class_classification\", models.BooleanField(default=False)),\n                        (\n                            \"created_by\",\n                            models.ForeignKey(\n                                null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL\n                            ),\n                        ),\n                        (\n                            \"polymorphic_ctype\",\n                            models.ForeignKey(\n                                editable=False,\n                                null=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"polymorphic_projects.project_set+\",\n                                to=\"contenttypes.contenttype\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                ),\n                migrations.CreateModel(\n                    name=\"ImageClassificationProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"IntentDetectionAndSlotFillingProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Seq2seqProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"SequenceLabelingProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                        (\"allow_overlapping\", models.BooleanField(default=False)),\n                        (\"grapheme_mode\", models.BooleanField(default=False)),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Speech2textProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"TextClassificationProject\",\n                    fields=[\n                        (\n                            \"project_ptr\",\n                            models.OneToOneField(\n                                auto_created=True,\n                                on_delete=django.db.models.deletion.CASCADE,\n                                parent_link=True,\n                                primary_key=True,\n                                serialize=False,\n                                to=\"projects.project\",\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"abstract\": False,\n                        \"base_manager_name\": \"objects\",\n                    },\n                    bases=(\"projects.project\",),\n                ),\n                migrations.CreateModel(\n                    name=\"Tag\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"text\", models.TextField()),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE, related_name=\"tags\", to=\"projects.project\"\n                            ),\n                        ),\n                    ],\n                ),\n                migrations.AlterField(\n                    model_name=\"member\",\n                    name=\"project\",\n                    field=models.ForeignKey(\n                        on_delete=django.db.models.deletion.CASCADE, related_name=\"role_mappings\", to=\"projects.project\"\n                    ),\n                ),\n            ],\n            database_operations=[\n                migrations.RunSQL(\n                    sql=\"\"\"\n                    UPDATE django_content_type\n                    SET app_label = 'projects'\n                    WHERE app_label = 'api' AND model LIKE '%project'\n                    \"\"\",\n                    reverse_sql=\"\"\"\n                    UPDATE django_content_type\n                    SET app_label = 'api'\n                    WHERE app_label = 'projects' AND model LIKE '%project'\n                    \"\"\",\n                )\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that facilitates the creation of multiple project models, including Project and its specialized types, while handling database operations and dependencies.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates various project models, including Project and its specialized types, while managing database operations and dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_alter_project_polymorphic_ctype.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0003_alter_project_polymorphic_ctype.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n        (\"projects\", \"0002_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"polymorphic_ctype\",\n            field=models.ForeignKey(\n                editable=False,\n                null=True,\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"polymorphic_%(app_label)s.%(class)s_set+\",\n                to=\"contenttypes.contenttype\",\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-21 00:01\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"contenttypes\", \"0002_remove_content_type_name\"),\n        (\"projects\", \"0002_auto_20220204_0201\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"polymorphic_ctype\",\n            field=models.ForeignKey(\n                editable=False,\n                null=True,\n                on_delete=django.db.models.deletion.CASCADE,\n                related_name=\"polymorphic_%(app_label)s.%(class)s_set+\",\n                to=\"contenttypes.contenttype\",\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the `polymorphic_ctype` field of the `project` model to maintain compatibility with defined content type dependencies.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that alters the `polymorphic_ctype` field of the `project` model to ensure its compatibility with the specified content type dependencies."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0004_sequencelabelingproject_use_relation.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0004_sequencelabelingproject_use_relation.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"use_relation\",\n            field=models.BooleanField(default=False),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.2 on 2022-02-23 22:59\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0003_alter_project_polymorphic_ctype\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"sequencelabelingproject\",\n            name=\"use_relation\",\n            field=models.BooleanField(default=False),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A migration script that introduces a boolean field \"use_relation\" (defaulting to False) to the \"sequencelabelingproject\" model, while maintaining dependencies on a prior migration.",
                                    "code_element_summaries": [
                                        "Class Migration: A migration script that adds a boolean field named \"use_relation\" with a default value of False to the \"sequencelabelingproject\" model, with dependencies on a previous migration."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0005_boundingboxproject_alter_project_project_type.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0005_boundingboxproject_alter_project_project_type.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0004_sequencelabelingproject_use_relation\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"BoundingBoxProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 00:20\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0004_sequencelabelingproject_use_relation\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"BoundingBoxProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes the BoundingBoxProject model and modifies the project_type field in the Project model to accommodate multiple project types.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates the BoundingBoxProject model and alters the project_type field in the Project model to include various project types."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0006_segmentationproject_alter_project_project_type.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0006_segmentationproject_alter_project_project_type.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0005_boundingboxproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"SegmentationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                    (\"Segmentation\", \"segmentation\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 04:43\n\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0005_boundingboxproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"SegmentationProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                    (\"Segmentation\", \"segmentation\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes the SegmentationProject model and updates the project_type field in the Project model to incorporate segmentation options.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates the SegmentationProject model and modifies the project_type field in the existing Project model to include segmentation options."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0007_imagecaptioningproject_alter_project_project_type.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0007_imagecaptioningproject_alter_project_project_type.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0006_segmentationproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ImageCaptioningProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                    (\"Segmentation\", \"segmentation\"),\n                    (\"ImageCaptioning\", \"image captioning\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.0.4 on 2022-06-30 23:07\n\nimport django.db.models.deletion\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0006_segmentationproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"ImageCaptioningProject\",\n            fields=[\n                (\n                    \"project_ptr\",\n                    models.OneToOneField(\n                        auto_created=True,\n                        on_delete=django.db.models.deletion.CASCADE,\n                        parent_link=True,\n                        primary_key=True,\n                        serialize=False,\n                        to=\"projects.project\",\n                    ),\n                ),\n            ],\n            options={\n                \"abstract\": False,\n                \"base_manager_name\": \"objects\",\n            },\n            bases=(\"projects.project\",),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"document classification\"),\n                    (\"SequenceLabeling\", \"sequence labeling\"),\n                    (\"Seq2seq\", \"sequence to sequence\"),\n                    (\"IntentDetectionAndSlotFilling\", \"intent detection and slot filling\"),\n                    (\"Speech2text\", \"speech to text\"),\n                    (\"ImageClassification\", \"image classification\"),\n                    (\"BoundingBox\", \"bounding box\"),\n                    (\"Segmentation\", \"segmentation\"),\n                    (\"ImageCaptioning\", \"image captioning\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that establishes the ImageCaptioningProject model and modifies the project_type field in the Project model to incorporate multiple project types, including image captioning.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates the ImageCaptioningProject model and alters the project_type field in the Project model to include various project types, including image captioning."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0008_project_allow_member_to_create_label_type_and_more.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\0008_project_allow_member_to_create_label_type_and_more.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0007_imagecaptioningproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"allow_member_to_create_label_type\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"Document Classification\"),\n                    (\"SequenceLabeling\", \"Sequence Labeling\"),\n                    (\"Seq2seq\", \"Seq2Seq\"),\n                    (\"IntentDetectionAndSlotFilling\", \"Intent Detection And Slot Filling\"),\n                    (\"Speech2text\", \"Speech2Text\"),\n                    (\"ImageClassification\", \"Image Classification\"),\n                    (\"BoundingBox\", \"Bounding Box\"),\n                    (\"Segmentation\", \"Segmentation\"),\n                    (\"ImageCaptioning\", \"Image Captioning\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 4.1.7 on 2023-06-07 04:57\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"projects\", \"0007_imagecaptioningproject_alter_project_project_type\"),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name=\"project\",\n            name=\"allow_member_to_create_label_type\",\n            field=models.BooleanField(default=False),\n        ),\n        migrations.AlterField(\n            model_name=\"project\",\n            name=\"project_type\",\n            field=models.CharField(\n                choices=[\n                    (\"DocumentClassification\", \"Document Classification\"),\n                    (\"SequenceLabeling\", \"Sequence Labeling\"),\n                    (\"Seq2seq\", \"Seq2Seq\"),\n                    (\"IntentDetectionAndSlotFilling\", \"Intent Detection And Slot Filling\"),\n                    (\"Speech2text\", \"Speech2Text\"),\n                    (\"ImageClassification\", \"Image Classification\"),\n                    (\"BoundingBox\", \"Bounding Box\"),\n                    (\"Segmentation\", \"Segmentation\"),\n                    (\"ImageCaptioning\", \"Image Captioning\"),\n                ],\n                max_length=30,\n            ),\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that modifies the Project model by adding a boolean field and updating the project_type field to support multiple classification options.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that adds a boolean field to the Project model and alters the project_type field to include various classification choices."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `ProjectType`\nCode:\nclass ProjectType(models.TextChoices):\n    DOCUMENT_CLASSIFICATION = \"DocumentClassification\"\n    SEQUENCE_LABELING = \"SequenceLabeling\"\n    SEQ2SEQ = \"Seq2seq\"\n    INTENT_DETECTION_AND_SLOT_FILLING = \"IntentDetectionAndSlotFilling\"\n    SPEECH2TEXT = \"Speech2text\"\n    IMAGE_CLASSIFICATION = \"ImageClassification\"\n    BOUNDING_BOX = \"BoundingBox\"\n    SEGMENTATION = \"Segmentation\"\n    IMAGE_CAPTIONING = \"ImageCaptioning\"",
                                "Class `Project`\nCode:\nclass Project(PolymorphicModel):\n    name = models.CharField(max_length=100)\n    description = models.TextField(default=\"\")\n    guideline = models.TextField(default=\"\", blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    created_by = models.ForeignKey(\n        User,\n        on_delete=models.SET_NULL,\n        null=True,\n    )\n    project_type = models.CharField(max_length=30, choices=ProjectType.choices)\n    random_order = models.BooleanField(default=False)\n    collaborative_annotation = models.BooleanField(default=False)\n    single_class_classification = models.BooleanField(default=False)\n    allow_member_to_create_label_type = models.BooleanField(default=False)\n\n    def add_admin(self):\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        Member.objects.create(\n            project=self,\n            user=self.created_by,\n            role=admin_role,\n        )\n\n    @property\n    @abc.abstractmethod\n    def is_text_project(self) -> bool:\n        return False\n\n    def clone(self) -> \"Project\":\n        \"\"\"Clone the project.\n        See https://docs.djangoproject.com/en/4.2/topics/db/queries/#copying-model-instances\n\n        Returns:\n            The cloned project.\n        \"\"\"\n        project = Project.objects.get(pk=self.pk)\n        project.pk = None\n        project.id = None\n        project._state.adding = True\n        project.save()\n\n        def bulk_clone(queryset: models.QuerySet, field_initializers: Optional[Dict[Any, Any]] = None):\n            \"\"\"Clone the queryset.\n\n            Args:\n                queryset: The queryset to clone.\n                field_initializers: The field initializers.\n            \"\"\"\n            if field_initializers is None:\n                field_initializers = {}\n            items = []\n            for item in queryset:\n                item.id = None\n                item.pk = None\n                for field, value_or_callable in field_initializers.items():\n                    if callable(value_or_callable):\n                        value_or_callable = value_or_callable()\n                    setattr(item, field, value_or_callable)\n                item.project = project\n                item._state.adding = True\n                items.append(item)\n            queryset.model.objects.bulk_create(items)\n\n        bulk_clone(self.role_mappings.all())\n        bulk_clone(self.tags.all())\n\n        # clone examples\n        bulk_clone(self.examples.all(), field_initializers={\"uuid\": uuid.uuid4})\n\n        # clone label types\n        bulk_clone(self.categorytype_set.all())\n        bulk_clone(self.spantype_set.all())\n        bulk_clone(self.relationtype_set.all())\n\n        return project\n\n    def __str__(self):\n        return self.name",
                                "Function `add_admin`\nCode:\n    def add_admin(self):\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        Member.objects.create(\n            project=self,\n            user=self.created_by,\n            role=admin_role,\n        )",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `clone`: Clone the project.\nCode:\n    def clone(self) -> \"Project\":\n        \"\"\"Clone the project.\n        See https://docs.djangoproject.com/en/4.2/topics/db/queries/#copying-model-instances\n\n        Returns:\n            The cloned project.\n        \"\"\"\n        project = Project.objects.get(pk=self.pk)\n        project.pk = None\n        project.id = None\n        project._state.adding = True\n        project.save()\n\n        def bulk_clone(queryset: models.QuerySet, field_initializers: Optional[Dict[Any, Any]] = None):\n            \"\"\"Clone the queryset.\n\n            Args:\n                queryset: The queryset to clone.\n                field_initializers: The field initializers.\n            \"\"\"\n            if field_initializers is None:\n                field_initializers = {}\n            items = []\n            for item in queryset:\n                item.id = None\n                item.pk = None\n                for field, value_or_callable in field_initializers.items():\n                    if callable(value_or_callable):\n                        value_or_callable = value_or_callable()\n                    setattr(item, field, value_or_callable)\n                item.project = project\n                item._state.adding = True\n                items.append(item)\n            queryset.model.objects.bulk_create(items)\n\n        bulk_clone(self.role_mappings.all())\n        bulk_clone(self.tags.all())\n\n        # clone examples\n        bulk_clone(self.examples.all(), field_initializers={\"uuid\": uuid.uuid4})\n\n        # clone label types\n        bulk_clone(self.categorytype_set.all())\n        bulk_clone(self.spantype_set.all())\n        bulk_clone(self.relationtype_set.all())\n\n        return project",
                                "Function `bulk_clone`: Clone the queryset.\nCode:\n        def bulk_clone(queryset: models.QuerySet, field_initializers: Optional[Dict[Any, Any]] = None):\n            \"\"\"Clone the queryset.\n\n            Args:\n                queryset: The queryset to clone.\n                field_initializers: The field initializers.\n            \"\"\"\n            if field_initializers is None:\n                field_initializers = {}\n            items = []\n            for item in queryset:\n                item.id = None\n                item.pk = None\n                for field, value_or_callable in field_initializers.items():\n                    if callable(value_or_callable):\n                        value_or_callable = value_or_callable()\n                    setattr(item, field, value_or_callable)\n                item.project = project\n                item._state.adding = True\n                items.append(item)\n            queryset.model.objects.bulk_create(items)",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        return self.name",
                                "Class `TextClassificationProject`\nCode:\nclass TextClassificationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return True",
                                "Class `SequenceLabelingProject`\nCode:\nclass SequenceLabelingProject(Project):\n    allow_overlapping = models.BooleanField(default=False)\n    grapheme_mode = models.BooleanField(default=False)\n    use_relation = models.BooleanField(default=False)\n\n    @property\n    def is_text_project(self) -> bool:\n        return True",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return True",
                                "Class `Seq2seqProject`\nCode:\nclass Seq2seqProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return True",
                                "Class `IntentDetectionAndSlotFillingProject`\nCode:\nclass IntentDetectionAndSlotFillingProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return True",
                                "Class `Speech2textProject`\nCode:\nclass Speech2textProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Class `ImageClassificationProject`\nCode:\nclass ImageClassificationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Class `BoundingBoxProject`\nCode:\nclass BoundingBoxProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Class `SegmentationProject`\nCode:\nclass SegmentationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Class `ImageCaptioningProject`\nCode:\nclass ImageCaptioningProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False",
                                "Function `is_text_project`\nCode:\n    def is_text_project(self) -> bool:\n        return False",
                                "Class `Tag`\nCode:\nclass Tag(models.Model):\n    text = models.TextField()\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"tags\")\n\n    def __str__(self):\n        return self.text",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        return self.text",
                                "Class `MemberManager`\nCode:\nclass MemberManager(Manager):\n    def can_update(self, project: int, member_id: int, new_role: str) -> bool:\n        \"\"\"The project needs at least 1 admin.\n\n        Args:\n            project: The project id.\n            member_id: The member id.\n            new_role: The new role name.\n\n        Returns:\n            Whether the mapping can be updated or not.\n        \"\"\"\n        queryset = self.filter(project=project, role__name=settings.ROLE_PROJECT_ADMIN)\n        if queryset.count() > 1:\n            return True\n        else:\n            admin = queryset.first()\n            # we can change the role except for the only admin.\n            return admin.id != member_id or new_role == settings.ROLE_PROJECT_ADMIN\n\n    def has_role(self, project_id: int, user: User, role_name: str):\n        return self.filter(project=project_id, user=user, role__name=role_name).exists()",
                                "Function `can_update`: The project needs at least 1 admin.\nCode:\n    def can_update(self, project: int, member_id: int, new_role: str) -> bool:\n        \"\"\"The project needs at least 1 admin.\n\n        Args:\n            project: The project id.\n            member_id: The member id.\n            new_role: The new role name.\n\n        Returns:\n            Whether the mapping can be updated or not.\n        \"\"\"\n        queryset = self.filter(project=project, role__name=settings.ROLE_PROJECT_ADMIN)\n        if queryset.count() > 1:\n            return True\n        else:\n            admin = queryset.first()\n            # we can change the role except for the only admin.\n            return admin.id != member_id or new_role == settings.ROLE_PROJECT_ADMIN",
                                "Function `has_role`\nCode:\n    def has_role(self, project_id: int, user: User, role_name: str):\n        return self.filter(project=project_id, user=user, role__name=role_name).exists()",
                                "Class `Member`\nCode:\nclass Member(models.Model):\n    user = models.ForeignKey(to=User, on_delete=models.CASCADE, related_name=\"role_mappings\")\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"role_mappings\")\n    role = models.ForeignKey(to=Role, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    objects = MemberManager()\n\n    def clean(self):\n        members = self.__class__.objects.exclude(id=self.id)\n        if members.filter(user=self.user, project=self.project).exists():\n            message = \"This user is already assigned to a role in this project.\"\n            raise ValidationError(message)\n\n    def is_admin(self):\n        return self.role.name == settings.ROLE_PROJECT_ADMIN\n\n    @property\n    def username(self):\n        return self.user.username\n\n    class Meta:\n        unique_together = (\"user\", \"project\")",
                                "Function `clean`\nCode:\n    def clean(self):\n        members = self.__class__.objects.exclude(id=self.id)\n        if members.filter(user=self.user, project=self.project).exists():\n            message = \"This user is already assigned to a role in this project.\"\n            raise ValidationError(message)",
                                "Function `is_admin`\nCode:\n    def is_admin(self):\n        return self.role.name == settings.ROLE_PROJECT_ADMIN",
                                "Function `username`\nCode:\n    def username(self):\n        return self.user.username",
                                "Class `Meta`\nCode:\n    class Meta:\n        unique_together = (\"user\", \"project\")"
                            ],
                            "code": "import abc\nimport uuid\nfrom typing import Any, Dict, Optional\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import User\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.db.models import Manager\nfrom polymorphic.models import PolymorphicModel\n\nfrom roles.models import Role\n\n\nclass ProjectType(models.TextChoices):\n    DOCUMENT_CLASSIFICATION = \"DocumentClassification\"\n    SEQUENCE_LABELING = \"SequenceLabeling\"\n    SEQ2SEQ = \"Seq2seq\"\n    INTENT_DETECTION_AND_SLOT_FILLING = \"IntentDetectionAndSlotFilling\"\n    SPEECH2TEXT = \"Speech2text\"\n    IMAGE_CLASSIFICATION = \"ImageClassification\"\n    BOUNDING_BOX = \"BoundingBox\"\n    SEGMENTATION = \"Segmentation\"\n    IMAGE_CAPTIONING = \"ImageCaptioning\"\n\n\nclass Project(PolymorphicModel):\n    name = models.CharField(max_length=100)\n    description = models.TextField(default=\"\")\n    guideline = models.TextField(default=\"\", blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    created_by = models.ForeignKey(\n        User,\n        on_delete=models.SET_NULL,\n        null=True,\n    )\n    project_type = models.CharField(max_length=30, choices=ProjectType.choices)\n    random_order = models.BooleanField(default=False)\n    collaborative_annotation = models.BooleanField(default=False)\n    single_class_classification = models.BooleanField(default=False)\n    allow_member_to_create_label_type = models.BooleanField(default=False)\n\n    def add_admin(self):\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        Member.objects.create(\n            project=self,\n            user=self.created_by,\n            role=admin_role,\n        )\n\n    @property\n    @abc.abstractmethod\n    def is_text_project(self) -> bool:\n        return False\n\n    def clone(self) -> \"Project\":\n        \"\"\"Clone the project.\n        See https://docs.djangoproject.com/en/4.2/topics/db/queries/#copying-model-instances\n\n        Returns:\n            The cloned project.\n        \"\"\"\n        project = Project.objects.get(pk=self.pk)\n        project.pk = None\n        project.id = None\n        project._state.adding = True\n        project.save()\n\n        def bulk_clone(queryset: models.QuerySet, field_initializers: Optional[Dict[Any, Any]] = None):\n            \"\"\"Clone the queryset.\n\n            Args:\n                queryset: The queryset to clone.\n                field_initializers: The field initializers.\n            \"\"\"\n            if field_initializers is None:\n                field_initializers = {}\n            items = []\n            for item in queryset:\n                item.id = None\n                item.pk = None\n                for field, value_or_callable in field_initializers.items():\n                    if callable(value_or_callable):\n                        value_or_callable = value_or_callable()\n                    setattr(item, field, value_or_callable)\n                item.project = project\n                item._state.adding = True\n                items.append(item)\n            queryset.model.objects.bulk_create(items)\n\n        bulk_clone(self.role_mappings.all())\n        bulk_clone(self.tags.all())\n\n        # clone examples\n        bulk_clone(self.examples.all(), field_initializers={\"uuid\": uuid.uuid4})\n\n        # clone label types\n        bulk_clone(self.categorytype_set.all())\n        bulk_clone(self.spantype_set.all())\n        bulk_clone(self.relationtype_set.all())\n\n        return project\n\n    def __str__(self):\n        return self.name\n\n\nclass TextClassificationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True\n\n\nclass SequenceLabelingProject(Project):\n    allow_overlapping = models.BooleanField(default=False)\n    grapheme_mode = models.BooleanField(default=False)\n    use_relation = models.BooleanField(default=False)\n\n    @property\n    def is_text_project(self) -> bool:\n        return True\n\n\nclass Seq2seqProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True\n\n\nclass IntentDetectionAndSlotFillingProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return True\n\n\nclass Speech2textProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False\n\n\nclass ImageClassificationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False\n\n\nclass BoundingBoxProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False\n\n\nclass SegmentationProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False\n\n\nclass ImageCaptioningProject(Project):\n    @property\n    def is_text_project(self) -> bool:\n        return False\n\n\nclass Tag(models.Model):\n    text = models.TextField()\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"tags\")\n\n    def __str__(self):\n        return self.text\n\n\nclass MemberManager(Manager):\n    def can_update(self, project: int, member_id: int, new_role: str) -> bool:\n        \"\"\"The project needs at least 1 admin.\n\n        Args:\n            project: The project id.\n            member_id: The member id.\n            new_role: The new role name.\n\n        Returns:\n            Whether the mapping can be updated or not.\n        \"\"\"\n        queryset = self.filter(project=project, role__name=settings.ROLE_PROJECT_ADMIN)\n        if queryset.count() > 1:\n            return True\n        else:\n            admin = queryset.first()\n            # we can change the role except for the only admin.\n            return admin.id != member_id or new_role == settings.ROLE_PROJECT_ADMIN\n\n    def has_role(self, project_id: int, user: User, role_name: str):\n        return self.filter(project=project_id, user=user, role__name=role_name).exists()\n\n\nclass Member(models.Model):\n    user = models.ForeignKey(to=User, on_delete=models.CASCADE, related_name=\"role_mappings\")\n    project = models.ForeignKey(to=Project, on_delete=models.CASCADE, related_name=\"role_mappings\")\n    role = models.ForeignKey(to=Role, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    objects = MemberManager()\n\n    def clean(self):\n        members = self.__class__.objects.exclude(id=self.id)\n        if members.filter(user=self.user, project=self.project).exists():\n            message = \"This user is already assigned to a role in this project.\"\n            raise ValidationError(message)\n\n    def is_admin(self):\n        return self.role.name == settings.ROLE_PROJECT_ADMIN\n\n    @property\n    def username(self):\n        return self.user.username\n\n    class Meta:\n        unique_together = (\"user\", \"project\")\n",
                            "summary": "Classes and functions related to project management in machine learning, including various project types, role management, and methods for cloning and validating project members, with specific implementations for text-based and non-text-based projects.",
                            "code_element_summaries": [
                                "Class ProjectType: An enumeration of various project types for machine learning tasks, represented as text choices.",
                                "Class `Project`: A polymorphic model that encapsulates project details, including attributes like name, description, and settings for collaboration and classification, along with methods for adding an admin and cloning the project.",
                                "Function `add_admin`: A method that assigns the project creator as an admin member of the project by creating a new Member instance with the admin role.",
                                "Function `is_text_project`: A method that always returns `False`, indicating that the project is not a text project.",
                                "Function `clone`: Creates a duplicate of the project along with its associated role mappings, tags, examples, and label types by resetting primary keys and utilizing bulk creation for efficiency.",
                                "Function `bulk_clone`: Clones a given queryset by resetting the IDs and applying specified field initializers before bulk creating the new items.",
                                "Function `__str__`: A method that returns the string representation of an object by providing its name.",
                                "Class `TextClassificationProject`: A subclass of Project that indicates it is specifically designed for text classification tasks.",
                                "Function `is_text_project`: A function that always returns `True`, indicating the project is a text project.",
                                "Class SequenceLabelingProject: A specialized project model that includes settings for overlapping annotations and grapheme modes, with a property indicating it is a text-based project.",
                                "Function `is_text_project`: A simple function that always returns `True`, indicating the project is a text project.",
                                "Class Seq2seqProject: A subclass of Project that indicates it is specifically a text project through a boolean property.",
                                "Function `is_text_project`: A function that always returns `True`, indicating that the project is a text project.",
                                "Class IntentDetectionAndSlotFillingProject: A specialized project class that indicates it is specifically designed for text-based intent detection and slot filling.",
                                "Function `is_text_project`: A function that always returns `True`, indicating a text project.",
                                "Class `Speech2textProject`: A subclass of Project that defines a property indicating that it is not a text project.",
                                "Function `is_text_project`: A function that always returns `False`, indicating that the current project is not a text project.",
                                "Class `ImageClassificationProject`: A subclass of Project that indicates it is not a text-based project through the `is_text_project` property.",
                                "Function `is_text_project`: A method that always returns `False`, indicating that the project is not a text project.",
                                "Class BoundingBoxProject: A subclass of Project that indicates it is not a text project through the is_text_project property.",
                                "Function `is_text_project`: A method that always returns `False`, indicating that the current context is not a text project.",
                                "Class SegmentationProject: A subclass of Project that indicates it is not a text project through the `is_text_project` property.",
                                "Function `is_text_project`: A method that always returns `False`, indicating that the project is not a text project.",
                                "Class ImageCaptioningProject: A subclass of Project that indicates it is not a text-based project through the is_text_project property.",
                                "Function `is_text_project`: A function that always returns `False`, indicating that the project is not a text project.",
                                "Class Tag: A Django model representing tags with associated text and a foreign key relationship to a project.",
                                "Function `__str__`: Returns the string representation of the object by returning its `text` attribute.",
                                "Class `MemberManager`: A custom manager that provides methods to determine if a project member's role can be updated and to check if a user has a specific role within a project.",
                                "Function `can_update`: Determines if a project's member role can be updated, ensuring that at least one admin remains in the project.",
                                "Function `has_role`: Checks if a specified user has a particular role in a given project by querying the database for the existence of such a relationship.",
                                "Class Member: A Django model that manages user-role assignments within projects, ensuring unique user-project combinations and providing methods to check administrative roles and retrieve usernames.",
                                "Function `clean`: Validates that a user is not assigned to multiple roles within the same project, raising a `ValidationError` if such an assignment exists.",
                                "Function `is_admin`: Checks if the user's role is that of a project administrator by comparing it to the defined settings.",
                                "Function `username`: Returns the username of the associated user object.",
                                "Class Meta: Defines a unique constraint that ensures the combination of \"user\" and \"project\" fields is unique in the database."
                            ],
                            "children": []
                        },
                        {
                            "name": "permissions.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\permissions.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RolePermission`\nCode:\nclass RolePermission(BasePermission):\n    UNSAFE_METHODS = (\"POST\", \"PATCH\", \"DELETE\")\n    unsafe_methods_check = True\n    role_name = \"\"\n\n    @classmethod\n    def get_project_id(cls, request, view):\n        return view.kwargs.get(\"project_id\") or request.query_params.get(\"project_id\")\n\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        if self.unsafe_methods_check and request.method in self.UNSAFE_METHODS:\n            return request.user.is_superuser\n\n        project_id = self.get_project_id(request, view)\n        if not project_id and request.method in SAFE_METHODS:\n            return True\n\n        return Member.objects.has_role(project_id, request.user, self.role_name)",
                                "Function `get_project_id`\nCode:\n    def get_project_id(cls, request, view):\n        return view.kwargs.get(\"project_id\") or request.query_params.get(\"project_id\")",
                                "Function `has_permission`\nCode:\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        if self.unsafe_methods_check and request.method in self.UNSAFE_METHODS:\n            return request.user.is_superuser\n\n        project_id = self.get_project_id(request, view)\n        if not project_id and request.method in SAFE_METHODS:\n            return True\n\n        return Member.objects.has_role(project_id, request.user, self.role_name)",
                                "Class `IsProjectAdmin`\nCode:\nclass IsProjectAdmin(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_PROJECT_ADMIN",
                                "Class `IsAnnotatorAndReadOnly`\nCode:\nclass IsAnnotatorAndReadOnly(RolePermission):\n    role_name = settings.ROLE_ANNOTATOR",
                                "Class `IsAnnotator`\nCode:\nclass IsAnnotator(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_ANNOTATOR",
                                "Class `IsAnnotationApproverAndReadOnly`\nCode:\nclass IsAnnotationApproverAndReadOnly(RolePermission):\n    role_name = settings.ROLE_ANNOTATION_APPROVER",
                                "Class `IsAnnotationApprover`\nCode:\nclass IsAnnotationApprover(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_ANNOTATION_APPROVER"
                            ],
                            "code": "from django.conf import settings\nfrom rest_framework.permissions import SAFE_METHODS, BasePermission\n\nfrom .models import Member\n\n\nclass RolePermission(BasePermission):\n    UNSAFE_METHODS = (\"POST\", \"PATCH\", \"DELETE\")\n    unsafe_methods_check = True\n    role_name = \"\"\n\n    @classmethod\n    def get_project_id(cls, request, view):\n        return view.kwargs.get(\"project_id\") or request.query_params.get(\"project_id\")\n\n    def has_permission(self, request, view):\n        if request.user.is_superuser:\n            return True\n\n        if self.unsafe_methods_check and request.method in self.UNSAFE_METHODS:\n            return request.user.is_superuser\n\n        project_id = self.get_project_id(request, view)\n        if not project_id and request.method in SAFE_METHODS:\n            return True\n\n        return Member.objects.has_role(project_id, request.user, self.role_name)\n\n\nclass IsProjectAdmin(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_PROJECT_ADMIN\n\n\nclass IsAnnotatorAndReadOnly(RolePermission):\n    role_name = settings.ROLE_ANNOTATOR\n\n\nclass IsAnnotator(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_ANNOTATOR\n\n\nclass IsAnnotationApproverAndReadOnly(RolePermission):\n    role_name = settings.ROLE_ANNOTATION_APPROVER\n\n\nclass IsAnnotationApprover(RolePermission):\n    unsafe_methods_check = False\n    role_name = settings.ROLE_ANNOTATION_APPROVER\n\n\nIsProjectMember = IsAnnotator | IsAnnotationApprover | IsProjectAdmin  # type: ignore\nIsProjectStaffAndReadOnly = IsAnnotatorAndReadOnly | IsAnnotationApproverAndReadOnly  # type: ignore\n",
                            "summary": "Class RolePermission and its subclasses define various permission controls based on user roles and project IDs, with specific methods for retrieving project IDs and determining access permissions, including distinctions for superusers and different user roles such as project admins, annotators, and annotation approvers.",
                            "code_element_summaries": [
                                "Class `RolePermission`: A permission class that controls access based on user roles and project IDs, allowing superusers unrestricted access and validating permissions for unsafe methods.",
                                "Function `get_project_id`: Retrieves the project ID from the view's URL parameters or the request's query parameters.",
                                "Function `has_permission`: A method that determines if a user has permission to access a view based on their role, superuser status, and the request method.",
                                "Class IsProjectAdmin: A role permission class that defines the project admin role with unsafe methods check disabled.",
                                "Class IsAnnotatorAndReadOnly: A role permission class that defines the annotator role for read-only access.",
                                "Class IsAnnotator: A role permission class that defines the annotator role with unsafe methods check disabled.",
                                "Class IsAnnotationApproverAndReadOnly: A role permission class that defines the role of an annotation approver based on the specified role name in the settings.",
                                "Class IsAnnotationApprover: A role permission class that defines the permissions for users designated as annotation approvers, with unsafe methods check disabled."
                            ],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `MemberSerializer`\nCode:\nclass MemberSerializer(serializers.ModelSerializer):\n    username = serializers.SerializerMethodField()\n    rolename = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_username(cls, instance):\n        user = instance.user\n        return user.username if user else None\n\n    @classmethod\n    def get_rolename(cls, instance):\n        role = instance.role\n        return role.name if role else None\n\n    class Meta:\n        model = Member\n        fields = (\"id\", \"user\", \"role\", \"username\", \"rolename\")",
                                "Function `get_username`\nCode:\n    def get_username(cls, instance):\n        user = instance.user\n        return user.username if user else None",
                                "Function `get_rolename`\nCode:\n    def get_rolename(cls, instance):\n        role = instance.role\n        return role.name if role else None",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Member\n        fields = (\"id\", \"user\", \"role\", \"username\", \"rolename\")",
                                "Class `TagSerializer`\nCode:\nclass TagSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Tag\n        fields = (\n            \"id\",\n            \"project\",\n            \"text\",\n        )\n        read_only_fields = (\"id\", \"project\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Tag\n        fields = (\n            \"id\",\n            \"project\",\n            \"text\",\n        )\n        read_only_fields = (\"id\", \"project\")",
                                "Class `ProjectSerializer`\nCode:\nclass ProjectSerializer(serializers.ModelSerializer):\n    tags = TagSerializer(many=True, required=False)\n    author = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_author(cls, instance):\n        if instance.created_by:\n            return instance.created_by.username\n        return \"\"\n\n    class Meta:\n        model = Project\n        fields = [\n            \"id\",\n            \"name\",\n            \"description\",\n            \"guideline\",\n            \"project_type\",\n            \"created_at\",\n            \"updated_at\",\n            \"random_order\",\n            \"author\",\n            \"collaborative_annotation\",\n            \"single_class_classification\",\n            \"allow_member_to_create_label_type\",\n            \"is_text_project\",\n            \"tags\",\n        ]\n        read_only_fields = (\n            \"created_at\",\n            \"updated_at\",\n            \"author\",\n            \"is_text_project\",\n        )\n\n    def create(self, validated_data):\n        tags = TagSerializer(data=validated_data.pop(\"tags\", []), many=True)\n        project = self.Meta.model.objects.create(**validated_data)\n        tags.is_valid()\n        tags.save(project=project)\n        return project\n\n    def update(self, instance, validated_data):\n        # Don't update tags. Please use TagAPI.\n        validated_data.pop(\"tags\", None)\n        return super().update(instance, validated_data)",
                                "Function `get_author`\nCode:\n    def get_author(cls, instance):\n        if instance.created_by:\n            return instance.created_by.username\n        return \"\"",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Project\n        fields = [\n            \"id\",\n            \"name\",\n            \"description\",\n            \"guideline\",\n            \"project_type\",\n            \"created_at\",\n            \"updated_at\",\n            \"random_order\",\n            \"author\",\n            \"collaborative_annotation\",\n            \"single_class_classification\",\n            \"allow_member_to_create_label_type\",\n            \"is_text_project\",\n            \"tags\",\n        ]\n        read_only_fields = (\n            \"created_at\",\n            \"updated_at\",\n            \"author\",\n            \"is_text_project\",\n        )",
                                "Function `create`\nCode:\n    def create(self, validated_data):\n        tags = TagSerializer(data=validated_data.pop(\"tags\", []), many=True)\n        project = self.Meta.model.objects.create(**validated_data)\n        tags.is_valid()\n        tags.save(project=project)\n        return project",
                                "Function `update`\nCode:\n    def update(self, instance, validated_data):\n        # Don't update tags. Please use TagAPI.\n        validated_data.pop(\"tags\", None)\n        return super().update(instance, validated_data)",
                                "Class `TextClassificationProjectSerializer`\nCode:\nclass TextClassificationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = TextClassificationProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = TextClassificationProject",
                                "Class `SequenceLabelingProjectSerializer`\nCode:\nclass SequenceLabelingProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = SequenceLabelingProject\n        fields = ProjectSerializer.Meta.fields + [\"allow_overlapping\", \"grapheme_mode\", \"use_relation\"]",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = SequenceLabelingProject\n        fields = ProjectSerializer.Meta.fields + [\"allow_overlapping\", \"grapheme_mode\", \"use_relation\"]",
                                "Class `Seq2seqProjectSerializer`\nCode:\nclass Seq2seqProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = Seq2seqProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = Seq2seqProject",
                                "Class `IntentDetectionAndSlotFillingProjectSerializer`\nCode:\nclass IntentDetectionAndSlotFillingProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = IntentDetectionAndSlotFillingProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = IntentDetectionAndSlotFillingProject",
                                "Class `Speech2textProjectSerializer`\nCode:\nclass Speech2textProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = Speech2textProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = Speech2textProject",
                                "Class `ImageClassificationProjectSerializer`\nCode:\nclass ImageClassificationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = ImageClassificationProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = ImageClassificationProject",
                                "Class `BoundingBoxProjectSerializer`\nCode:\nclass BoundingBoxProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = BoundingBoxProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = BoundingBoxProject",
                                "Class `SegmentationProjectSerializer`\nCode:\nclass SegmentationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = SegmentationProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = SegmentationProject",
                                "Class `ImageCaptioningProjectSerializer`\nCode:\nclass ImageCaptioningProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = ImageCaptioningProject",
                                "Class `Meta`\nCode:\n    class Meta(ProjectSerializer.Meta):\n        model = ImageCaptioningProject",
                                "Class `ProjectPolymorphicSerializer`\nCode:\nclass ProjectPolymorphicSerializer(PolymorphicSerializer):\n    model_serializer_mapping = {\n        Project: ProjectSerializer,\n        **{cls.Meta.model: cls for cls in ProjectSerializer.__subclasses__()},\n    }"
                            ],
                            "code": "from rest_framework import serializers\nfrom rest_polymorphic.serializers import PolymorphicSerializer\n\nfrom .models import (\n    BoundingBoxProject,\n    ImageCaptioningProject,\n    ImageClassificationProject,\n    IntentDetectionAndSlotFillingProject,\n    Member,\n    Project,\n    SegmentationProject,\n    Seq2seqProject,\n    SequenceLabelingProject,\n    Speech2textProject,\n    Tag,\n    TextClassificationProject,\n)\n\n\nclass MemberSerializer(serializers.ModelSerializer):\n    username = serializers.SerializerMethodField()\n    rolename = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_username(cls, instance):\n        user = instance.user\n        return user.username if user else None\n\n    @classmethod\n    def get_rolename(cls, instance):\n        role = instance.role\n        return role.name if role else None\n\n    class Meta:\n        model = Member\n        fields = (\"id\", \"user\", \"role\", \"username\", \"rolename\")\n\n\nclass TagSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Tag\n        fields = (\n            \"id\",\n            \"project\",\n            \"text\",\n        )\n        read_only_fields = (\"id\", \"project\")\n\n\nclass ProjectSerializer(serializers.ModelSerializer):\n    tags = TagSerializer(many=True, required=False)\n    author = serializers.SerializerMethodField()\n\n    @classmethod\n    def get_author(cls, instance):\n        if instance.created_by:\n            return instance.created_by.username\n        return \"\"\n\n    class Meta:\n        model = Project\n        fields = [\n            \"id\",\n            \"name\",\n            \"description\",\n            \"guideline\",\n            \"project_type\",\n            \"created_at\",\n            \"updated_at\",\n            \"random_order\",\n            \"author\",\n            \"collaborative_annotation\",\n            \"single_class_classification\",\n            \"allow_member_to_create_label_type\",\n            \"is_text_project\",\n            \"tags\",\n        ]\n        read_only_fields = (\n            \"created_at\",\n            \"updated_at\",\n            \"author\",\n            \"is_text_project\",\n        )\n\n    def create(self, validated_data):\n        tags = TagSerializer(data=validated_data.pop(\"tags\", []), many=True)\n        project = self.Meta.model.objects.create(**validated_data)\n        tags.is_valid()\n        tags.save(project=project)\n        return project\n\n    def update(self, instance, validated_data):\n        # Don't update tags. Please use TagAPI.\n        validated_data.pop(\"tags\", None)\n        return super().update(instance, validated_data)\n\n\nclass TextClassificationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = TextClassificationProject\n\n\nclass SequenceLabelingProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = SequenceLabelingProject\n        fields = ProjectSerializer.Meta.fields + [\"allow_overlapping\", \"grapheme_mode\", \"use_relation\"]\n\n\nclass Seq2seqProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = Seq2seqProject\n\n\nclass IntentDetectionAndSlotFillingProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = IntentDetectionAndSlotFillingProject\n\n\nclass Speech2textProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = Speech2textProject\n\n\nclass ImageClassificationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = ImageClassificationProject\n\n\nclass BoundingBoxProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = BoundingBoxProject\n\n\nclass SegmentationProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = SegmentationProject\n\n\nclass ImageCaptioningProjectSerializer(ProjectSerializer):\n    class Meta(ProjectSerializer.Meta):\n        model = ImageCaptioningProject\n\n\nclass ProjectPolymorphicSerializer(PolymorphicSerializer):\n    model_serializer_mapping = {\n        Project: ProjectSerializer,\n        **{cls.Meta.model: cls for cls in ProjectSerializer.__subclasses__()},\n    }\n",
                            "summary": "Class MemberSerializer: A serializer for the Member model that includes custom fields for username and rolename, while ProjectSerializer and its subclasses manage serialization for various project models, each with specific configurations and methods for handling associated data and relationships.",
                            "code_element_summaries": [
                                "Class MemberSerializer: A serializer for the Member model that includes custom fields for username and rolename derived from related user and role instances.",
                                "Function `get_username`: A class method that retrieves the username of a user associated with a given instance, returning None if no user is present.",
                                "Function `get_rolename`: A class method that retrieves the name of the role associated with a given instance, returning None if no role is present.",
                                "Class Meta: Defines the configuration for the Member model, specifying the associated model and the fields to be included.",
                                "Class TagSerializer: A serializer for the Tag model that defines which fields are included and specifies certain fields as read-only.",
                                "Class Meta: Defines the configuration for the Tag model, specifying fields to include and marking certain fields as read-only.",
                                "Class `ProjectSerializer`: A serializer for the Project model that handles the serialization of project data, including tags and author information, while providing custom create and update methods.",
                                "Function `get_author`: Retrieves the username of the author who created the instance, returning an empty string if no author is associated.",
                                "Class Meta: A configuration class for the Project model that defines the fields to be included, specifies read-only fields, and outlines the structure for serialization.",
                                "Function `create`: A method that creates a project instance using validated data and associates it with tags through serialization.",
                                "Function `update`: A method that updates an instance while excluding the \"tags\" field, which should be handled separately using TagAPI.",
                                "Class TextClassificationProjectSerializer: A serializer for the TextClassificationProject model, extending the functionality of the ProjectSerializer.",
                                "Class Meta: A subclass of ProjectSerializer.Meta that specifies the model as TextClassificationProject for serialization purposes.",
                                "Class SequenceLabelingProjectSerializer: A serializer for the SequenceLabelingProject model that extends ProjectSerializer to include additional fields related to project settings.",
                                "Class Meta: A subclass of ProjectSerializer.Meta that specifies the model as SequenceLabelingProject and extends the fields to include additional attributes related to project settings.",
                                "Class Seq2seqProjectSerializer: A serializer for the Seq2seqProject model that extends the functionality of the ProjectSerializer.",
                                "Class Meta: A subclass of ProjectSerializer.Meta that specifies the model as Seq2seqProject for serialization purposes.",
                                "Class IntentDetectionAndSlotFillingProjectSerializer: A serializer that extends ProjectSerializer for the IntentDetectionAndSlotFillingProject model.",
                                "Class Meta: A subclass of ProjectSerializer.Meta that specifies the model to be IntentDetectionAndSlotFillingProject for serialization purposes.",
                                "Class Speech2textProjectSerializer: A serializer that extends ProjectSerializer to handle the Speech2textProject model.",
                                "Class Meta: A subclass of ProjectSerializer.Meta that specifies Speech2textProject as the model for serialization.",
                                "Class ImageClassificationProjectSerializer: A serializer for the ImageClassificationProject model, inheriting from ProjectSerializer.",
                                "Class Meta: A subclass of ProjectSerializer.Meta that specifies ImageClassificationProject as the model for serialization.",
                                "Class BoundingBoxProjectSerializer: A serializer for the BoundingBoxProject model that inherits metadata from ProjectSerializer.",
                                "Class Meta: A subclass of ProjectSerializer.Meta that specifies BoundingBoxProject as the model for serialization.",
                                "Class SegmentationProjectSerializer: A serializer for the SegmentationProject model that inherits metadata from the ProjectSerializer.",
                                "Class `Meta`: A subclass of ProjectSerializer.Meta that specifies SegmentationProject as the associated model.",
                                "Class ImageCaptioningProjectSerializer: A serializer for the ImageCaptioningProject model, extending the functionality of ProjectSerializer.",
                                "Class Meta: A subclass of ProjectSerializer.Meta that specifies the model as ImageCaptioningProject.",
                                "Class ProjectPolymorphicSerializer: A serializer that maps project models to their respective serializers, including subclasses of ProjectSerializer."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Comprehensive test suite for project management functionality, including access control and CRUD operations for project members and tags, along with a class representing project data that manages user roles and assignments.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_member.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests\\test_member.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestMemberListAPI`\nCode:\nclass TestMemberListAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        self.data = {\"user\": self.non_member.id, \"role\": admin_role.id, \"project\": self.project.item.id}\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_know_members(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_know_members(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_know_members(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_known_members(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_add_member(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_add_member(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_add_member(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_add_member(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        ids = [item.id for item in self.project.item.role_mappings.all()]\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n\n    def test_allows_project_admin_to_remove_members(self):\n        self.assert_bulk_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        response = self.client.get(self.url)\n        self.assertEqual(len(response.data), 1)\n\n    def test_denies_project_staff_to_remove_members(self):\n        for member in self.project.staffs:\n            self.assert_bulk_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_remove_members(self):\n        self.assert_bulk_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_remove_members(self):\n        self.assert_bulk_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        self.data = {\"user\": self.non_member.id, \"role\": admin_role.id, \"project\": self.project.item.id}\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])",
                                        "Function `test_allows_project_admin_to_know_members`\nCode:\n    def test_allows_project_admin_to_know_members(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_project_staff_to_know_members`\nCode:\n    def test_denies_project_staff_to_know_members(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_know_members`\nCode:\n    def test_denies_non_project_member_to_know_members(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_known_members`\nCode:\n    def test_denies_unauthenticated_user_to_known_members(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_add_member`\nCode:\n    def test_allows_project_admin_to_add_member(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)",
                                        "Function `test_denies_project_staff_to_add_member`\nCode:\n    def test_denies_project_staff_to_add_member(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_add_member`\nCode:\n    def test_denies_non_project_member_to_add_member(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_add_member`\nCode:\n    def test_denies_unauthenticated_user_to_add_member(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `assert_bulk_delete`\nCode:\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        ids = [item.id for item in self.project.item.role_mappings.all()]\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)",
                                        "Function `test_allows_project_admin_to_remove_members`\nCode:\n    def test_allows_project_admin_to_remove_members(self):\n        self.assert_bulk_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        response = self.client.get(self.url)\n        self.assertEqual(len(response.data), 1)",
                                        "Function `test_denies_project_staff_to_remove_members`\nCode:\n    def test_denies_project_staff_to_remove_members(self):\n        for member in self.project.staffs:\n            self.assert_bulk_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_remove_members`\nCode:\n    def test_denies_non_project_member_to_remove_members(self):\n        self.assert_bulk_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_remove_members`\nCode:\n    def test_denies_unauthenticated_user_to_remove_members(self):\n        self.assert_bulk_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestMemberRoleDetailAPI`\nCode:\nclass TestMemberRoleDetailAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        member = Member.objects.get(user=self.project.approver)\n        self.url = reverse(viewname=\"member_detail\", args=[self.project.item.id, member.id])\n        self.data = {\"role\": admin_role.id}\n\n    def test_allows_project_admin_to_known_member(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_know_member(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_know_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_know_member(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_change_member_role(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_change_member_role(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_change_member_role(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_change_member_role(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        member = Member.objects.get(user=self.project.approver)\n        self.url = reverse(viewname=\"member_detail\", args=[self.project.item.id, member.id])\n        self.data = {\"role\": admin_role.id}",
                                        "Function `test_allows_project_admin_to_known_member`\nCode:\n    def test_allows_project_admin_to_known_member(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_project_staff_to_know_member`\nCode:\n    def test_denies_project_staff_to_know_member(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_know_member`\nCode:\n    def test_denies_non_project_member_to_know_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_know_member`\nCode:\n    def test_denies_unauthenticated_user_to_know_member(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_project_admin_to_change_member_role`\nCode:\n    def test_allows_project_admin_to_change_member_role(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)",
                                        "Function `test_denies_project_staff_to_change_member_role`\nCode:\n    def test_denies_project_staff_to_change_member_role(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_project_member_to_change_member_role`\nCode:\n    def test_denies_non_project_member_to_change_member_role(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_change_member_role`\nCode:\n    def test_denies_unauthenticated_user_to_change_member_role(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestMemberFilter`\nCode:\nclass TestMemberFilter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])\n        self.url += f\"?user={self.project.admin.id}\"\n\n    def test_filter_role_by_user_id(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])\n        self.url += f\"?user={self.project.admin.id}\"",
                                        "Function `test_filter_role_by_user_id`\nCode:\n    def test_filter_role_by_user_id(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)",
                                        "Class `TestMyRole`\nCode:\nclass TestMyRole(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"my_role\", args=[self.project.item.id])\n\n    def test_admin(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_PROJECT_ADMIN)\n\n    def test_approver(self):\n        response = self.assert_fetch(self.project.approver, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATION_APPROVER)\n\n    def test_annotator(self):\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATOR)",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"my_role\", args=[self.project.item.id])",
                                        "Function `test_admin`\nCode:\n    def test_admin(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_PROJECT_ADMIN)",
                                        "Function `test_approver`\nCode:\n    def test_approver(self):\n        response = self.assert_fetch(self.project.approver, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATION_APPROVER)",
                                        "Function `test_annotator`\nCode:\n    def test_annotator(self):\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATOR)",
                                        "Class `TestMemberManager`\nCode:\nclass TestMemberManager(CRUDMixin):\n    def test_has_role(self):\n        project = prepare_project()\n        admin = project.admin\n        expected = [\n            (settings.ROLE_PROJECT_ADMIN, True),\n            (settings.ROLE_ANNOTATION_APPROVER, False),\n            (settings.ROLE_ANNOTATOR, False),\n        ]\n        for role, expect in expected:\n            self.assertEqual(Member.objects.has_role(project.item, admin, role), expect)",
                                        "Function `test_has_role`\nCode:\n    def test_has_role(self):\n        project = prepare_project()\n        admin = project.admin\n        expected = [\n            (settings.ROLE_PROJECT_ADMIN, True),\n            (settings.ROLE_ANNOTATION_APPROVER, False),\n            (settings.ROLE_ANNOTATOR, False),\n        ]\n        for role, expect in expected:\n            self.assertEqual(Member.objects.has_role(project.item, admin, role), expect)",
                                        "Class `TestMember`\nCode:\nclass TestMember(TestCase):\n    def test_clean(self):\n        member = mommy.make(\"Member\")\n        same_user = Member(project=member.project, user=member.user, role=member.role)\n        with self.assertRaises(ValidationError):\n            same_user.clean()",
                                        "Function `test_clean`\nCode:\n    def test_clean(self):\n        member = mommy.make(\"Member\")\n        same_user = Member(project=member.project, user=member.user, role=member.role)\n        with self.assertRaises(ValidationError):\n            same_user.clean()"
                                    ],
                                    "code": "from django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.test import TestCase\nfrom model_mommy import mommy\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom projects.models import Member\nfrom projects.tests.utils import prepare_project\nfrom roles.models import Role\nfrom users.tests.utils import make_user\n\n\nclass TestMemberListAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        self.data = {\"user\": self.non_member.id, \"role\": admin_role.id, \"project\": self.project.item.id}\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])\n\n    def test_allows_project_admin_to_know_members(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_know_members(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_know_members(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_known_members(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_add_member(self):\n        self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n\n    def test_denies_project_staff_to_add_member(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_add_member(self):\n        self.assert_create(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_add_member(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n    def assert_bulk_delete(self, user=None, expected=status.HTTP_403_FORBIDDEN):\n        if user:\n            self.client.force_login(user)\n        ids = [item.id for item in self.project.item.role_mappings.all()]\n        response = self.client.delete(self.url, data={\"ids\": ids}, format=\"json\")\n        self.assertEqual(response.status_code, expected)\n\n    def test_allows_project_admin_to_remove_members(self):\n        self.assert_bulk_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n        response = self.client.get(self.url)\n        self.assertEqual(len(response.data), 1)\n\n    def test_denies_project_staff_to_remove_members(self):\n        for member in self.project.staffs:\n            self.assert_bulk_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_remove_members(self):\n        self.assert_bulk_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_remove_members(self):\n        self.assert_bulk_delete(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestMemberRoleDetailAPI(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.non_member = make_user()\n        admin_role = Role.objects.get(name=settings.ROLE_PROJECT_ADMIN)\n        member = Member.objects.get(user=self.project.approver)\n        self.url = reverse(viewname=\"member_detail\", args=[self.project.item.id, member.id])\n        self.data = {\"role\": admin_role.id}\n\n    def test_allows_project_admin_to_known_member(self):\n        self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_know_member(self):\n        for member in self.project.staffs:\n            self.assert_fetch(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_know_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_know_member(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n    def test_allows_project_admin_to_change_member_role(self):\n        self.assert_update(self.project.admin, status.HTTP_200_OK)\n\n    def test_denies_project_staff_to_change_member_role(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_project_member_to_change_member_role(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_change_member_role(self):\n        self.assert_update(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestMemberFilter(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"member_list\", args=[self.project.item.id])\n        self.url += f\"?user={self.project.admin.id}\"\n\n    def test_filter_role_by_user_id(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n\n\nclass TestMyRole(CRUDMixin):\n    def setUp(self):\n        self.project = prepare_project()\n        self.url = reverse(viewname=\"my_role\", args=[self.project.item.id])\n\n    def test_admin(self):\n        response = self.assert_fetch(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_PROJECT_ADMIN)\n\n    def test_approver(self):\n        response = self.assert_fetch(self.project.approver, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATION_APPROVER)\n\n    def test_annotator(self):\n        response = self.assert_fetch(self.project.annotator, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"rolename\"], settings.ROLE_ANNOTATOR)\n\n\nclass TestMemberManager(CRUDMixin):\n    def test_has_role(self):\n        project = prepare_project()\n        admin = project.admin\n        expected = [\n            (settings.ROLE_PROJECT_ADMIN, True),\n            (settings.ROLE_ANNOTATION_APPROVER, False),\n            (settings.ROLE_ANNOTATOR, False),\n        ]\n        for role, expect in expected:\n            self.assertEqual(Member.objects.has_role(project.item, admin, role), expect)\n\n\nclass TestMember(TestCase):\n    def test_clean(self):\n        member = mommy.make(\"Member\")\n        same_user = Member(project=member.project, user=member.user, role=member.role)\n        with self.assertRaises(ValidationError):\n            same_user.clean()\n",
                                    "summary": "Class TestMemberListAPI: A test suite that ensures proper access control for project members, verifying that only project administrators can view, add, or remove members while denying access to staff, non-members, and unauthenticated users; Class TestMemberRoleDetailAPI: A test suite focused on access permissions and role management for project members; Class TestMemberFilter: A test case for filtering project members by user ID; Class TestMyRole: A test case that verifies role assignments for different user types; Class TestMemberManager: A test case that confirms role assignments for a project admin; Class TestMember: A unit test that checks for validation errors when creating duplicate members.",
                                    "code_element_summaries": [
                                        "Class TestMemberListAPI: A test suite that verifies access control for project members, ensuring only project administrators can view, add, or remove members, while denying access to staff, non-members, and unauthenticated users.",
                                        "Function `setUp`: Prepares the test environment by creating a project, a non-member user, and setting up role and URL data for testing the member list view.",
                                        "Function `test_allows_project_admin_to_know_members`: A test that verifies if the project admin can successfully fetch the list of members with a 200 OK status.",
                                        "Function `test_denies_project_staff_to_know_members`: A test that verifies project staff members receive a forbidden status when attempting to access information about other members.",
                                        "Function `test_denies_non_project_member_to_know_members`: A test case that verifies a non-project member receives a forbidden status when attempting to access member information.",
                                        "Function test_denies_unauthenticated_user_to_known_members: A test case that verifies that unauthenticated users are denied access to known members by asserting a forbidden HTTP status response.",
                                        "Function `test_allows_project_admin_to_add_member`: A test case that verifies if a project administrator can successfully add a member, expecting a 201 Created status.",
                                        "Function `test_denies_project_staff_to_add_member`: A test that verifies project staff members are forbidden from adding new members, expecting a 403 Forbidden status.",
                                        "Function `test_denies_non_project_member_to_add_member`: A test that asserts a non-project member receives a 403 Forbidden status when attempting to add a member.",
                                        "Function `test_denies_unauthenticated_user_to_add_member`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to add a member.",
                                        "Function `assert_bulk_delete`: A test function that verifies the response status of a bulk delete operation for role mappings, optionally logging in a user before making the request.",
                                        "Function `test_allows_project_admin_to_remove_members`: A test case that verifies a project admin can successfully remove members, resulting in a 204 No Content response and a reduced member count in the project.",
                                        "Function `test_denies_project_staff_to_remove_members`: A test case that verifies project staff are forbidden from removing members by asserting a 403 Forbidden status for each staff member.",
                                        "Function `test_denies_non_project_member_to_remove_members`: A test case that verifies a non-project member receives a forbidden status when attempting to remove members.",
                                        "Function `test_denies_unauthenticated_user_to_remove_members`: A test case that asserts an unauthenticated user receives a forbidden status when attempting to remove members.",
                                        "Class `TestMemberRoleDetailAPI`: A test suite for verifying access permissions and role management for project members, ensuring only authorized users can view and modify member roles.",
                                        "Function `setUp`: Prepares the test environment by initializing a project, creating a non-member user, retrieving an admin role, and setting up the URL and data for a member detail view.",
                                        "Function `test_allows_project_admin_to_known_member`: A test case that verifies if a known project admin can successfully fetch project data with a 200 OK status.",
                                        "Function `test_denies_project_staff_to_know_member`: A test that asserts project staff members are forbidden from accessing member information, expecting a 403 Forbidden status for each staff member.",
                                        "Function `test_denies_non_project_member_to_know_member`: A test case that verifies a non-project member receives a 403 Forbidden status when attempting to access member information.",
                                        "Function `test_denies_unauthenticated_user_to_know_member`: A test function that asserts an unauthenticated user receives a 403 Forbidden status when attempting to access member information.",
                                        "Function `test_allows_project_admin_to_change_member_role`: A test case that verifies a project admin's ability to successfully change a member's role with an HTTP 200 OK response.",
                                        "Function `test_denies_project_staff_to_change_member_role`: A test case that verifies project staff members are forbidden from changing the roles of other members, expecting a 403 Forbidden status.",
                                        "Function `test_denies_non_project_member_to_change_member_role`: A test case that asserts a non-project member receives a 403 Forbidden response when attempting to change a member's role.",
                                        "Function `test_denies_unauthenticated_user_to_change_member_role`: A test case that asserts an unauthenticated user receives a 403 Forbidden status when attempting to change a member's role.",
                                        "Class TestMemberFilter: A test case for filtering project members by user ID, ensuring that the correct number of members is returned based on the specified role.",
                                        "Function `setUp`: Initializes a test environment by preparing a project and constructing a URL for the member list view with the project's item ID and admin user ID as parameters.",
                                        "Function `test_filter_role_by_user_id`: A test case that verifies the filtering of roles by user ID, ensuring a successful response with exactly one role returned.",
                                        "Class TestMyRole: A test case that verifies the role assignments for different user types within a project, ensuring that each user receives the correct role name upon fetching their information.",
                                        "Function `setUp`: Prepares a project and constructs a URL for accessing a specific view associated with that project.",
                                        "Function `test_admin`: A test function that verifies if the project admin fetch request returns a successful response with the correct role name for the project admin.",
                                        "Function `test_approver`: A test function that verifies the response of the project approver endpoint returns a status of 200 OK and checks that the role name matches the expected annotation approver role.",
                                        "Function `test_annotator`: A test method that verifies the annotator's response status and checks if the role name matches the expected annotator role.",
                                        "Class `TestMemberManager`: A test case that verifies the role assignments for a project admin using assertions to compare expected outcomes with actual results.",
                                        "Function `test_has_role`: A unit test that verifies the role assignments for a project admin against expected boolean values for various roles.",
                                        "Class TestMember: A unit test that verifies the validation logic for creating a duplicate member within the same project, user, and role, ensuring that a ValidationError is raised.",
                                        "Function `test_clean`: A test case that verifies a `ValidationError` is raised when attempting to clean a duplicate member instance with the same project, user, and role."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_project.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests\\test_project.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestProjectList`\nCode:\nclass TestProjectList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n\n    def test_return_projects_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            project = response.data[\"results\"][0]\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertEqual(project[\"id\"], self.project.item.id)\n\n    def test_does_not_return_project_to_non_member(self):\n        response = self.assert_fetch(self.non_member, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], 0)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_list\")",
                                        "Function `test_return_projects_to_member`\nCode:\n    def test_return_projects_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            project = response.data[\"results\"][0]\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertEqual(project[\"id\"], self.project.item.id)",
                                        "Function `test_does_not_return_project_to_non_member`\nCode:\n    def test_does_not_return_project_to_non_member(self):\n        response = self.assert_fetch(self.non_member, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], 0)",
                                        "Class `TestProjectCreate`\nCode:\nclass TestProjectCreate(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"DocumentClassification\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"resourcetype\": \"TextClassificationProject\",\n        }\n\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"name\"], self.data[\"name\"])\n\n    def test_exists_project_administrator(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        members = Member.objects.filter(project=response.data[\"id\"])\n        self.assertEqual(members.count(), 1)\n        member = members.first()\n        self.assertEqual(member.role.name, settings.ROLE_PROJECT_ADMIN)\n\n    def test_denies_non_staff_user_to_create_project(self):\n        self.assert_create(self.user, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_project(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"DocumentClassification\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"resourcetype\": \"TextClassificationProject\",\n        }",
                                        "Function `test_allows_staff_user_to_create_project`\nCode:\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"name\"], self.data[\"name\"])",
                                        "Function `test_exists_project_administrator`\nCode:\n    def test_exists_project_administrator(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        members = Member.objects.filter(project=response.data[\"id\"])\n        self.assertEqual(members.count(), 1)\n        member = members.first()\n        self.assertEqual(member.role.name, settings.ROLE_PROJECT_ADMIN)",
                                        "Function `test_denies_non_staff_user_to_create_project`\nCode:\n    def test_denies_non_staff_user_to_create_project(self):\n        self.assert_create(self.user, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_create_project`\nCode:\n    def test_denies_unauthenticated_user_to_create_project(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestSequenceLabelingProjectCreation`\nCode:\nclass TestSequenceLabelingProjectCreation(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"SequenceLabeling\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"allow_overlapping\": True,\n            \"grapheme_mode\": True,\n            \"resourcetype\": \"SequenceLabelingProject\",\n        }\n\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"allow_overlapping\"], self.data[\"allow_overlapping\"])\n        self.assertEqual(response.data[\"grapheme_mode\"], self.data[\"grapheme_mode\"])",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"SequenceLabeling\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"allow_overlapping\": True,\n            \"grapheme_mode\": True,\n            \"resourcetype\": \"SequenceLabelingProject\",\n        }",
                                        "Function `test_allows_staff_user_to_create_project`\nCode:\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"allow_overlapping\"], self.data[\"allow_overlapping\"])\n        self.assertEqual(response.data[\"grapheme_mode\"], self.data[\"grapheme_mode\"])",
                                        "Class `TestProjectDetailAPI`\nCode:\nclass TestProjectDetailAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\"SequenceLabeling\")\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_detail\", args=[cls.project.item.id])\n        cls.data = {\"description\": \"lorem\", \"resourcetype\": \"SequenceLabelingProject\"}\n\n    def test_return_project_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.project.item.id)\n\n    def test_does_not_return_project_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_update_project(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"description\"], self.data[\"description\"])\n\n    def test_denies_project_staff_to_update_project(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_member_to_update_project(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_delete_project(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_project(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_member_to_delete_project(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project(\"SequenceLabeling\")\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_detail\", args=[cls.project.item.id])\n        cls.data = {\"description\": \"lorem\", \"resourcetype\": \"SequenceLabelingProject\"}",
                                        "Function `test_return_project_to_member`\nCode:\n    def test_return_project_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.project.item.id)",
                                        "Function `test_does_not_return_project_to_non_member`\nCode:\n    def test_does_not_return_project_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_update_project`\nCode:\n    def test_allows_admin_to_update_project(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"description\"], self.data[\"description\"])",
                                        "Function `test_denies_project_staff_to_update_project`\nCode:\n    def test_denies_project_staff_to_update_project(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_member_to_update_project`\nCode:\n    def test_denies_non_member_to_update_project(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_allows_admin_to_delete_project`\nCode:\n    def test_allows_admin_to_delete_project(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_project_staff_to_delete_project`\nCode:\n    def test_denies_project_staff_to_delete_project(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_non_member_to_delete_project`\nCode:\n    def test_denies_non_member_to_delete_project(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Class `TestProjectModel`\nCode:\nclass TestProjectModel(TestCase):\n    def setUp(self):\n        self.project = prepare_project().item\n\n    def test_clone_project(self):\n        project = self.project.clone()\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n        self.assertEqual(project.role_mappings.count(), self.project.role_mappings.count())",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        self.project = prepare_project().item",
                                        "Function `test_clone_project`\nCode:\n    def test_clone_project(self):\n        project = self.project.clone()\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n        self.assertEqual(project.role_mappings.count(), self.project.role_mappings.count())",
                                        "Class `TestCloneProject`\nCode:\nclass TestCloneProject(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.project = project.item\n        cls.user = project.admin\n        make_doc(cls.project)\n        cls.category_type = make_label(cls.project)\n        cls.url = reverse(viewname=\"clone_project\", args=[cls.project.id])\n\n    def test_clone_project(self):\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n\n        project = Project.objects.get(id=response.data[\"id\"])\n\n        # assert project\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n\n        # assert category type\n        category_type = project.categorytype_set.first()\n        self.assertEqual(category_type.text, self.category_type.text)\n\n        # assert example\n        example = self.project.examples.first()\n        cloned_example = project.examples.first()\n        self.assertEqual(example.text, cloned_example.text)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.project = project.item\n        cls.user = project.admin\n        make_doc(cls.project)\n        cls.category_type = make_label(cls.project)\n        cls.url = reverse(viewname=\"clone_project\", args=[cls.project.id])",
                                        "Function `test_clone_project`\nCode:\n    def test_clone_project(self):\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n\n        project = Project.objects.get(id=response.data[\"id\"])\n\n        # assert project\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n\n        # assert category type\n        category_type = project.categorytype_set.first()\n        self.assertEqual(category_type.text, self.category_type.text)\n\n        # assert example\n        example = self.project.examples.first()\n        cloned_example = project.examples.first()\n        self.assertEqual(example.text, cloned_example.text)"
                                    ],
                                    "code": "from django.conf import settings\nfrom django.test import TestCase\nfrom rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom examples.tests.utils import make_doc\nfrom label_types.tests.utils import make_label\nfrom projects.models import Member, Project, ProjectType\nfrom projects.tests.utils import prepare_project\nfrom roles.tests.utils import create_default_roles\nfrom users.tests.utils import make_user\n\n\nclass TestProjectList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n\n    def test_return_projects_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            project = response.data[\"results\"][0]\n            self.assertEqual(response.data[\"count\"], 1)\n            self.assertEqual(project[\"id\"], self.project.item.id)\n\n    def test_does_not_return_project_to_non_member(self):\n        response = self.assert_fetch(self.non_member, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"count\"], 0)\n\n\nclass TestProjectCreate(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"DocumentClassification\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"resourcetype\": \"TextClassificationProject\",\n        }\n\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"name\"], self.data[\"name\"])\n\n    def test_exists_project_administrator(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        members = Member.objects.filter(project=response.data[\"id\"])\n        self.assertEqual(members.count(), 1)\n        member = members.first()\n        self.assertEqual(member.role.name, settings.ROLE_PROJECT_ADMIN)\n\n    def test_denies_non_staff_user_to_create_project(self):\n        self.assert_create(self.user, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_project(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestSequenceLabelingProjectCreation(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"project_list\")\n        cls.data = {\n            \"name\": \"example\",\n            \"project_type\": \"SequenceLabeling\",\n            \"description\": \"example\",\n            \"guideline\": \"example\",\n            \"allow_overlapping\": True,\n            \"grapheme_mode\": True,\n            \"resourcetype\": \"SequenceLabelingProject\",\n        }\n\n    def test_allows_staff_user_to_create_project(self):\n        self.user.is_staff = True\n        self.user.save()\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"allow_overlapping\"], self.data[\"allow_overlapping\"])\n        self.assertEqual(response.data[\"grapheme_mode\"], self.data[\"grapheme_mode\"])\n\n\nclass TestProjectDetailAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project(\"SequenceLabeling\")\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"project_detail\", args=[cls.project.item.id])\n        cls.data = {\"description\": \"lorem\", \"resourcetype\": \"SequenceLabelingProject\"}\n\n    def test_return_project_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(response.data[\"id\"], self.project.item.id)\n\n    def test_does_not_return_project_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_update_project(self):\n        response = self.assert_update(self.project.admin, status.HTTP_200_OK)\n        self.assertEqual(response.data[\"description\"], self.data[\"description\"])\n\n    def test_denies_project_staff_to_update_project(self):\n        for member in self.project.staffs:\n            self.assert_update(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_member_to_update_project(self):\n        self.assert_update(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_allows_admin_to_delete_project(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_project(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_non_member_to_delete_project(self):\n        self.assert_delete(self.non_member, status.HTTP_403_FORBIDDEN)\n\n\nclass TestProjectModel(TestCase):\n    def setUp(self):\n        self.project = prepare_project().item\n\n    def test_clone_project(self):\n        project = self.project.clone()\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n        self.assertEqual(project.role_mappings.count(), self.project.role_mappings.count())\n\n\nclass TestCloneProject(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        project = prepare_project(task=ProjectType.DOCUMENT_CLASSIFICATION)\n        cls.project = project.item\n        cls.user = project.admin\n        make_doc(cls.project)\n        cls.category_type = make_label(cls.project)\n        cls.url = reverse(viewname=\"clone_project\", args=[cls.project.id])\n\n    def test_clone_project(self):\n        response = self.assert_create(self.user, status.HTTP_201_CREATED)\n\n        project = Project.objects.get(id=response.data[\"id\"])\n\n        # assert project\n        self.assertNotEqual(project.id, self.project.id)\n        self.assertEqual(project.name, self.project.name)\n\n        # assert category type\n        category_type = project.categorytype_set.first()\n        self.assertEqual(category_type.text, self.category_type.text)\n\n        # assert example\n        example = self.project.examples.first()\n        cloned_example = project.examples.first()\n        self.assertEqual(example.text, cloned_example.text)\n",
                                    "summary": "Comprehensive test suite for project management functionality, validating access permissions and CRUD operations for members and non-members, ensuring proper project creation, detail retrieval, updates, deletions, and cloning processes while enforcing role-based access control.",
                                    "code_element_summaries": [
                                        "Class `TestProjectList`: A test case for verifying that project listings are correctly returned to members and not to non-members in a CRUD context.",
                                        "Function `setUpTestData`: A class method that prepares test data by creating a project, a non-member user, and defining the URL for the project list view.",
                                        "Function `test_return_projects_to_member`: A test that verifies a member can successfully fetch their associated project, ensuring the response is correct and contains the expected project ID.",
                                        "Function `test_does_not_return_project_to_non_member`: A test case that verifies a non-member does not receive any project data, expecting a count of zero in the response.",
                                        "Class `TestProjectCreate`: A test case for verifying the project creation functionality, ensuring that only staff users can create projects while non-staff and unauthenticated users are denied access.",
                                        "Function `setUpTestData`: A class method that initializes test data by creating default roles, a user, a URL for the project list view, and a dictionary containing project details.",
                                        "Function `test_allows_staff_user_to_create_project`: A test function that verifies that a staff user can successfully create a project and that the project's name matches the expected data.",
                                        "Function `test_exists_project_administrator`: A test case that verifies a user with staff status is successfully created as a project administrator in the system.",
                                        "Function `test_denies_non_staff_user_to_create_project`: A test case that verifies non-staff users are forbidden from creating a project, expecting a 403 Forbidden status.",
                                        "Function `test_denies_unauthenticated_user_to_create_project`: A test that asserts an unauthenticated user receives a 403 Forbidden status when attempting to create a project.",
                                        "Class `TestSequenceLabelingProjectCreation`: A test case for verifying that staff users can successfully create a Sequence Labeling project with specified parameters.",
                                        "Function `setUpTestData`: A class method that initializes test data by creating default roles, a user, a URL for the project list view, and a dictionary containing project attributes.",
                                        "Function `test_allows_staff_user_to_create_project`: A test case that verifies a staff user can successfully create a project and checks the response for specific attributes related to overlapping and grapheme mode.",
                                        "Class `TestProjectDetailAPI`: A test suite for verifying the permissions and functionalities of project detail operations, ensuring that access is correctly granted to members and admins while denied to non-members and project staff for updates and deletions.",
                                        "Function `setUpTestData`: A class method that prepares test data for a sequence labeling project, including a project instance, a non-member user, a URL for project detail, and associated data.",
                                        "Function `test_return_project_to_member`: A test that verifies each member of a project can successfully fetch project details, ensuring the returned ID matches the project's item ID.",
                                        "Function `test_does_not_return_project_to_non_member`: A test case that verifies a non-member receives a 403 Forbidden status when attempting to fetch a project.",
                                        "Function `test_allows_admin_to_update_project`: A test case that verifies an admin user can successfully update a project and checks if the updated description matches the expected data.",
                                        "Function `test_denies_project_staff_to_update_project`: A test function that asserts project staff members receive a 403 Forbidden status when attempting to update a project.",
                                        "Function `test_denies_non_member_to_update_project`: A test case that verifies a non-member receives a 403 Forbidden status when attempting to update a project.",
                                        "Function `test_allows_admin_to_delete_project`: A test case that verifies an admin user has permission to delete a project, expecting a successful deletion response.",
                                        "Function `test_denies_project_staff_to_delete_project`: A test case that verifies project staff members are forbidden from deleting the project, expecting a 403 Forbidden status for each member.",
                                        "Function `test_denies_non_member_to_delete_project`: A test case that asserts a non-member user receives a 403 Forbidden status when attempting to delete a project.",
                                        "Class TestProjectModel: A test case that verifies the cloning functionality of a project, ensuring the cloned project has a different ID but retains the same name and role mappings count.",
                                        "Function `setUp`: Initializes a project by preparing it and assigning the result to `self.project`.",
                                        "Function `test_clone_project`: A test that verifies the cloning functionality of a project by checking that the cloned project's ID is different while ensuring the name and role mappings count remain the same.",
                                        "Class TestCloneProject: A test case for verifying the cloning functionality of a project, ensuring that the cloned project retains the original project's name and category type while having a different ID.",
                                        "Function `setUpTestData`: A class method that prepares test data for a document classification project, including a project instance, user, document, label category, and the URL for cloning the project.",
                                        "Function `test_clone_project`: A test case that verifies the successful cloning of a project by checking the uniqueness of the project ID, the preservation of the project name, the correctness of the category type, and the consistency of example texts between the original and cloned projects."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "test_tag.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests\\test_tag.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestTagList`\nCode:\nclass TestTagList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        make_tag(project=cls.project.item)\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])\n\n    def test_return_tags_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)\n\n    def test_does_not_return_tags_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_tags_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        make_tag(project=cls.project.item)\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])",
                                        "Function `test_return_tags_to_member`\nCode:\n    def test_return_tags_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)",
                                        "Function `test_does_not_return_tags_to_non_member`\nCode:\n    def test_does_not_return_tags_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_does_not_return_tags_to_unauthenticated_user`\nCode:\n    def test_does_not_return_tags_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestTagCreate`\nCode:\nclass TestTagCreate(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_allows_admin_to_create_tag(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_project_staff_to_create_tag(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_tag(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}",
                                        "Function `test_allows_admin_to_create_tag`\nCode:\n    def test_allows_admin_to_create_tag(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])",
                                        "Function `test_denies_project_staff_to_create_tag`\nCode:\n    def test_denies_project_staff_to_create_tag(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_create_tag`\nCode:\n    def test_denies_unauthenticated_user_to_create_tag(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)",
                                        "Class `TestTagDelete`\nCode:\nclass TestTagDelete(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n\n    def setUp(self):\n        tag = make_tag(project=self.project.item)\n        self.url = reverse(viewname=\"tag_detail\", args=[self.project.item.id, tag.id])\n\n    def test_allows_admin_to_delete_tag(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_tag(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_tag(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()",
                                        "Function `setUp`\nCode:\n    def setUp(self):\n        tag = make_tag(project=self.project.item)\n        self.url = reverse(viewname=\"tag_detail\", args=[self.project.item.id, tag.id])",
                                        "Function `test_allows_admin_to_delete_tag`\nCode:\n    def test_allows_admin_to_delete_tag(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)",
                                        "Function `test_denies_project_staff_to_delete_tag`\nCode:\n    def test_denies_project_staff_to_delete_tag(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)",
                                        "Function `test_denies_unauthenticated_user_to_delete_tag`\nCode:\n    def test_denies_unauthenticated_user_to_delete_tag(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom api.tests.utils import CRUDMixin\nfrom projects.tests.utils import make_tag, prepare_project\nfrom users.tests.utils import make_user\n\n\nclass TestTagList(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        make_tag(project=cls.project.item)\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])\n\n    def test_return_tags_to_member(self):\n        for member in self.project.members:\n            response = self.assert_fetch(member, status.HTTP_200_OK)\n            self.assertEqual(len(response.data), 1)\n\n    def test_does_not_return_tags_to_non_member(self):\n        self.assert_fetch(self.non_member, status.HTTP_403_FORBIDDEN)\n\n    def test_does_not_return_tags_to_unauthenticated_user(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestTagCreate(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n        cls.url = reverse(viewname=\"tag_list\", args=[cls.project.item.id])\n        cls.data = {\"text\": \"example\"}\n\n    def test_allows_admin_to_create_tag(self):\n        response = self.assert_create(self.project.admin, status.HTTP_201_CREATED)\n        self.assertEqual(response.data[\"text\"], self.data[\"text\"])\n\n    def test_denies_project_staff_to_create_tag(self):\n        for member in self.project.staffs:\n            self.assert_create(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_create_tag(self):\n        self.assert_create(expected=status.HTTP_403_FORBIDDEN)\n\n\nclass TestTagDelete(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        cls.project = prepare_project()\n        cls.non_member = make_user()\n\n    def setUp(self):\n        tag = make_tag(project=self.project.item)\n        self.url = reverse(viewname=\"tag_detail\", args=[self.project.item.id, tag.id])\n\n    def test_allows_admin_to_delete_tag(self):\n        self.assert_delete(self.project.admin, status.HTTP_204_NO_CONTENT)\n\n    def test_denies_project_staff_to_delete_tag(self):\n        for member in self.project.staffs:\n            self.assert_delete(member, status.HTTP_403_FORBIDDEN)\n\n    def test_denies_unauthenticated_user_to_delete_tag(self):\n        self.assert_delete(expected=status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Classes TestTagList, TestTagCreate, and TestTagDelete: Test suites that verify tag retrieval, creation, and deletion permissions, ensuring only authorized users (admins and project members) can perform these actions while correctly denying access to non-members and unauthenticated users.",
                                    "code_element_summaries": [
                                        "Class TestTagList: A test case for verifying the tag retrieval functionality, ensuring that only project members can access tags while non-members and unauthenticated users receive appropriate access restrictions.",
                                        "Function `setUpTestData`: A class method that prepares test data by creating a project, a non-member user, a tag associated with the project, and generates the URL for the tag list view.",
                                        "Function `test_return_tags_to_member`: A test that verifies each member of the project returns a response with a single tag when fetched.",
                                        "Function `test_does_not_return_tags_to_non_member`: A test case that verifies a non-member user receives a 403 Forbidden status when attempting to fetch tags.",
                                        "Function `test_does_not_return_tags_to_unauthenticated_user`: A test function that asserts an unauthenticated user receives a 403 Forbidden status when attempting to fetch tags.",
                                        "Class TestTagCreate: A test suite for verifying tag creation permissions, allowing only admins to create tags while denying access to project staff and unauthenticated users.",
                                        "Function `setUpTestData`: A class method that prepares test data by creating a project, a non-member user, and defining a URL and data dictionary for testing purposes.",
                                        "Function `test_allows_admin_to_create_tag`: A test case that verifies an admin user can successfully create a tag and checks that the returned tag text matches the expected data.",
                                        "Function `test_denies_project_staff_to_create_tag`: A test case that verifies project staff members are forbidden from creating tags, expecting a 403 Forbidden status.",
                                        "Function `test_denies_unauthenticated_user_to_create_tag`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to create a tag.",
                                        "Class TestTagDelete: A test case for verifying the deletion permissions of tags, ensuring that only admins can delete tags while project staff and unauthenticated users are denied access.",
                                        "Function `setUpTestData`: A class method that initializes test data by preparing a project and creating a non-member user.",
                                        "Function `setUp`: Prepares the test environment by creating a tag associated with the project and generating the URL for the tag detail view.",
                                        "Function `test_allows_admin_to_delete_tag`: A test case that verifies an admin user can successfully delete a tag, expecting a 204 No Content status response.",
                                        "Function `test_denies_project_staff_to_delete_tag`: A test that verifies project staff members are forbidden from deleting a tag, asserting a 403 Forbidden status for each staff member.",
                                        "Function `test_denies_unauthenticated_user_to_delete_tag`: A test case that asserts an unauthenticated user receives a 403 Forbidden status when attempting to delete a tag."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ProjectData`\nCode:\nclass ProjectData:\n    def __init__(self, item, members):\n        self.item = item\n        self.members = members\n\n    @property\n    def id(self):\n        return self.item.id\n\n    @property\n    def admin(self):\n        return self.members[0]\n\n    @property\n    def approver(self):\n        return self.members[1]\n\n    @property\n    def annotator(self):\n        return self.members[2]\n\n    @property\n    def staffs(self):\n        return [self.approver, self.annotator]",
                                        "Function `__init__`\nCode:\n    def __init__(self, item, members):\n        self.item = item\n        self.members = members",
                                        "Function `id`\nCode:\n    def id(self):\n        return self.item.id",
                                        "Function `admin`\nCode:\n    def admin(self):\n        return self.members[0]",
                                        "Function `approver`\nCode:\n    def approver(self):\n        return self.members[1]",
                                        "Function `annotator`\nCode:\n    def annotator(self):\n        return self.members[2]",
                                        "Function `staffs`\nCode:\n    def staffs(self):\n        return [self.approver, self.annotator]",
                                        "Function `assign_user_to_role`\nCode:\ndef assign_user_to_role(project_member, project, role_name):\n    role, _ = Role.objects.get_or_create(name=role_name)\n    if Member.objects.filter(user=project_member, project=project).exists():\n        mapping = Member.objects.get(user=project_member, project=project)\n        mapping.role = role\n        mapping.save()\n    else:\n        mapping = Member.objects.get_or_create(role_id=role.id, user_id=project_member.id, project_id=project.id)\n    return mapping",
                                        "Function `make_project`\nCode:\ndef make_project(task: str, users: List[str], roles: List[str], collaborative_annotation=False, **kwargs):\n    create_default_roles()\n\n    # create users.\n    users = [make_user(name) for name in users]\n\n    # create a project.\n    project_model = {\n        ProjectType.DOCUMENT_CLASSIFICATION: \"TextClassificationProject\",\n        ProjectType.SEQUENCE_LABELING: \"SequenceLabelingProject\",\n        ProjectType.SEQ2SEQ: \"Seq2seqProject\",\n        ProjectType.SPEECH2TEXT: \"Speech2TextProject\",\n        ProjectType.IMAGE_CLASSIFICATION: \"ImageClassificationProject\",\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: \"IntentDetectionAndSlotFillingProject\",\n        ProjectType.BOUNDING_BOX: \"BoundingBoxProject\",\n        ProjectType.SEGMENTATION: \"SegmentationProject\",\n        ProjectType.IMAGE_CAPTIONING: \"ImageCaptioningProject\",\n    }.get(task, \"Project\")\n    project = mommy.make(\n        _model=project_model,\n        project_type=task,\n        collaborative_annotation=collaborative_annotation,\n        created_by=users[0],\n        **kwargs,\n    )\n\n    # assign roles to the users.\n    for user, role in zip(users, roles):\n        assign_user_to_role(user, project, role)\n\n    return ProjectData(item=project, members=users)",
                                        "Function `make_tag`\nCode:\ndef make_tag(project):\n    return mommy.make(\"Tag\", project=project)",
                                        "Function `prepare_project`\nCode:\ndef prepare_project(task: str = \"Any\", collaborative_annotation=False, **kwargs):\n    return make_project(\n        task=task,\n        users=[\"admin\", \"approver\", \"annotator\"],\n        roles=[\n            settings.ROLE_PROJECT_ADMIN,\n            settings.ROLE_ANNOTATION_APPROVER,\n            settings.ROLE_ANNOTATOR,\n        ],\n        collaborative_annotation=collaborative_annotation,\n        **kwargs,\n    )"
                                    ],
                                    "code": "from typing import List\n\nfrom django.conf import settings\nfrom model_mommy import mommy\n\nfrom projects.models import Member, ProjectType, Role\nfrom roles.tests.utils import create_default_roles\nfrom users.tests.utils import make_user\n\n\nclass ProjectData:\n    def __init__(self, item, members):\n        self.item = item\n        self.members = members\n\n    @property\n    def id(self):\n        return self.item.id\n\n    @property\n    def admin(self):\n        return self.members[0]\n\n    @property\n    def approver(self):\n        return self.members[1]\n\n    @property\n    def annotator(self):\n        return self.members[2]\n\n    @property\n    def staffs(self):\n        return [self.approver, self.annotator]\n\n\ndef assign_user_to_role(project_member, project, role_name):\n    role, _ = Role.objects.get_or_create(name=role_name)\n    if Member.objects.filter(user=project_member, project=project).exists():\n        mapping = Member.objects.get(user=project_member, project=project)\n        mapping.role = role\n        mapping.save()\n    else:\n        mapping = Member.objects.get_or_create(role_id=role.id, user_id=project_member.id, project_id=project.id)\n    return mapping\n\n\ndef make_project(task: str, users: List[str], roles: List[str], collaborative_annotation=False, **kwargs):\n    create_default_roles()\n\n    # create users.\n    users = [make_user(name) for name in users]\n\n    # create a project.\n    project_model = {\n        ProjectType.DOCUMENT_CLASSIFICATION: \"TextClassificationProject\",\n        ProjectType.SEQUENCE_LABELING: \"SequenceLabelingProject\",\n        ProjectType.SEQ2SEQ: \"Seq2seqProject\",\n        ProjectType.SPEECH2TEXT: \"Speech2TextProject\",\n        ProjectType.IMAGE_CLASSIFICATION: \"ImageClassificationProject\",\n        ProjectType.INTENT_DETECTION_AND_SLOT_FILLING: \"IntentDetectionAndSlotFillingProject\",\n        ProjectType.BOUNDING_BOX: \"BoundingBoxProject\",\n        ProjectType.SEGMENTATION: \"SegmentationProject\",\n        ProjectType.IMAGE_CAPTIONING: \"ImageCaptioningProject\",\n    }.get(task, \"Project\")\n    project = mommy.make(\n        _model=project_model,\n        project_type=task,\n        collaborative_annotation=collaborative_annotation,\n        created_by=users[0],\n        **kwargs,\n    )\n\n    # assign roles to the users.\n    for user, role in zip(users, roles):\n        assign_user_to_role(user, project, role)\n\n    return ProjectData(item=project, members=users)\n\n\ndef make_tag(project):\n    return mommy.make(\"Tag\", project=project)\n\n\ndef prepare_project(task: str = \"Any\", collaborative_annotation=False, **kwargs):\n    return make_project(\n        task=task,\n        users=[\"admin\", \"approver\", \"annotator\"],\n        roles=[\n            settings.ROLE_PROJECT_ADMIN,\n            settings.ROLE_ANNOTATION_APPROVER,\n            settings.ROLE_ANNOTATOR,\n        ],\n        collaborative_annotation=collaborative_annotation,\n        **kwargs,\n    )\n",
                                    "summary": "Class `ProjectData`: A representation of project information that encapsulates an item and its members, providing various methods to access project roles, manage user assignments, and facilitate project creation and preparation for collaborative annotation.",
                                    "code_element_summaries": [
                                        "Class `ProjectData`: A representation of project information that encapsulates an item and its members, providing properties to access the project's ID and roles such as admin, approver, annotator, and staff.",
                                        "Function `__init__`: Initializes an instance with the specified item and members attributes.",
                                        "Function `id`: Retrieves the identifier of the associated item.",
                                        "Function `admin`: Returns the first member from the members list.",
                                        "Function `approver`: Returns the second member from the members list.",
                                        "Function `annotator`: A method that returns the third member of a collection.",
                                        "Function `staffs`: Returns a list containing the approver and annotator associated with the instance.",
                                        "Function `assign_user_to_role`: Assigns a specified role to a project member, creating a new mapping if none exists or updating the existing role if it does.",
                                        "Function `make_project`: Creates a project of a specified type with assigned users and roles, optionally enabling collaborative annotation.",
                                        "Function `make_tag`: A utility function that creates and returns a new Tag instance associated with a specified project using the `mommy` library.",
                                        "Function `prepare_project`: A utility function that creates a project with specified task parameters and predefined user roles for collaborative annotation."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views.member import MemberDetail, MemberList, MyRole\nfrom .views.project import CloneProject, ProjectDetail, ProjectList\nfrom .views.tag import TagDetail, TagList\n\nurlpatterns = [\n    path(route=\"projects\", view=ProjectList.as_view(), name=\"project_list\"),\n    path(route=\"projects/<int:project_id>\", view=ProjectDetail.as_view(), name=\"project_detail\"),\n    path(route=\"projects/<int:project_id>/my-role\", view=MyRole.as_view(), name=\"my_role\"),\n    path(route=\"projects/<int:project_id>/tags\", view=TagList.as_view(), name=\"tag_list\"),\n    path(route=\"projects/<int:project_id>/tags/<int:tag_id>\", view=TagDetail.as_view(), name=\"tag_detail\"),\n    path(route=\"projects/<int:project_id>/members\", view=MemberList.as_view(), name=\"member_list\"),\n    path(route=\"projects/<int:project_id>/clone\", view=CloneProject.as_view(), name=\"clone_project\"),\n    path(route=\"projects/<int:project_id>/members/<int:member_id>\", view=MemberDetail.as_view(), name=\"member_detail\"),\n]\n",
                            "summary": "URL patterns for a Django application defining routes for project management, including project lists, details, roles, tags, and member management.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\views",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Classes MemberList, MemberDetail, MyRole, ProjectList, ProjectDetail, TagList, and TagDetail: A set of views for managing project members, projects, and tags, incorporating authentication, permission checks, and various methods for filtering, creating, updating, and deleting resources while ensuring proper access control.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "member.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\views\\member.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `MemberList`\nCode:\nclass MemberList(generics.ListCreateAPIView):\n    filter_backends = [DjangoFilterBackend]\n    filterset_fields = [\"user\"]\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def filter_queryset(self, queryset):\n        queryset = queryset.filter(project=self.kwargs[\"project_id\"])\n        return super().filter_queryset(queryset)\n\n    def perform_create(self, serializer):\n        try:\n            serializer.save(project_id=self.kwargs[\"project_id\"])\n        except IntegrityError:\n            raise RoleAlreadyAssignedException\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        project_id = self.kwargs[\"project_id\"]\n        Member.objects.filter(project=project_id, pk__in=delete_ids).exclude(user=self.request.user).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Function `filter_queryset`\nCode:\n    def filter_queryset(self, queryset):\n        queryset = queryset.filter(project=self.kwargs[\"project_id\"])\n        return super().filter_queryset(queryset)",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        try:\n            serializer.save(project_id=self.kwargs[\"project_id\"])\n        except IntegrityError:\n            raise RoleAlreadyAssignedException",
                                        "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        project_id = self.kwargs[\"project_id\"]\n        Member.objects.filter(project=project_id, pk__in=delete_ids).exclude(user=self.request.user).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Class `MemberDetail`\nCode:\nclass MemberDetail(generics.RetrieveUpdateAPIView):\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    lookup_url_kwarg = \"member_id\"\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def perform_update(self, serializer):\n        project_id = self.kwargs[\"project_id\"]\n        member_id = self.kwargs[\"member_id\"]\n        role = serializer.validated_data[\"role\"]\n        if not Member.objects.can_update(project_id, member_id, role.name):\n            raise RoleConstraintException\n        try:\n            super().perform_update(serializer)\n        except IntegrityError:\n            raise RoleAlreadyAssignedException",
                                        "Function `perform_update`\nCode:\n    def perform_update(self, serializer):\n        project_id = self.kwargs[\"project_id\"]\n        member_id = self.kwargs[\"member_id\"]\n        role = serializer.validated_data[\"role\"]\n        if not Member.objects.can_update(project_id, member_id, role.name):\n            raise RoleConstraintException\n        try:\n            super().perform_update(serializer)\n        except IntegrityError:\n            raise RoleAlreadyAssignedException",
                                        "Class `MyRole`\nCode:\nclass MyRole(generics.RetrieveAPIView):\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    permission_classes = [IsAuthenticated & IsProjectMember]\n\n    def get_object(self):\n        kwargs = {\"user\": self.request.user, \"project_id\": self.kwargs[\"project_id\"]}\n        return get_object_or_404(self.queryset, **kwargs)",
                                        "Function `get_object`\nCode:\n    def get_object(self):\n        kwargs = {\"user\": self.request.user, \"project_id\": self.kwargs[\"project_id\"]}\n        return get_object_or_404(self.queryset, **kwargs)"
                                    ],
                                    "code": "from django.db import IntegrityError\nfrom django.shortcuts import get_object_or_404\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import generics, status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom projects.exceptions import RoleAlreadyAssignedException, RoleConstraintException\nfrom projects.models import Member\nfrom projects.permissions import IsProjectAdmin, IsProjectMember\nfrom projects.serializers import MemberSerializer\n\n\nclass MemberList(generics.ListCreateAPIView):\n    filter_backends = [DjangoFilterBackend]\n    filterset_fields = [\"user\"]\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def filter_queryset(self, queryset):\n        queryset = queryset.filter(project=self.kwargs[\"project_id\"])\n        return super().filter_queryset(queryset)\n\n    def perform_create(self, serializer):\n        try:\n            serializer.save(project_id=self.kwargs[\"project_id\"])\n        except IntegrityError:\n            raise RoleAlreadyAssignedException\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        project_id = self.kwargs[\"project_id\"]\n        Member.objects.filter(project=project_id, pk__in=delete_ids).exclude(user=self.request.user).delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass MemberDetail(generics.RetrieveUpdateAPIView):\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    lookup_url_kwarg = \"member_id\"\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    def perform_update(self, serializer):\n        project_id = self.kwargs[\"project_id\"]\n        member_id = self.kwargs[\"member_id\"]\n        role = serializer.validated_data[\"role\"]\n        if not Member.objects.can_update(project_id, member_id, role.name):\n            raise RoleConstraintException\n        try:\n            super().perform_update(serializer)\n        except IntegrityError:\n            raise RoleAlreadyAssignedException\n\n\nclass MyRole(generics.RetrieveAPIView):\n    queryset = Member.objects.all()\n    serializer_class = MemberSerializer\n    permission_classes = [IsAuthenticated & IsProjectMember]\n\n    def get_object(self):\n        kwargs = {\"user\": self.request.user, \"project_id\": self.kwargs[\"project_id\"]}\n        return get_object_or_404(self.queryset, **kwargs)\n",
                                    "summary": "Class MemberList: A view for managing project members that includes authentication, permission checks, and methods for filtering, creating, and deleting members; Class MemberDetail: A view for retrieving and updating member details with role enforcement; Class MyRole: A view that retrieves a Member object for authenticated users within a project, ensuring proper access control.",
                                    "code_element_summaries": [
                                        "Class `MemberList`: A view that handles listing and creating members associated with a specific project, while enforcing authentication and project admin permissions, and includes methods for filtering and deleting members.",
                                        "Function `filter_queryset`: A method that filters a given queryset to include only those items associated with a specific project ID before passing it to the superclass's filter method.",
                                        "Function `perform_create`: Saves a serializer with a specified project ID and raises a RoleAlreadyAssignedException if an IntegrityError occurs.",
                                        "Function `delete`: A method that removes specified members from a project while excluding the requesting user, returning a 204 No Content response.",
                                        "Class MemberDetail: A view that handles retrieving and updating member details, enforcing role constraints and permissions for authenticated project administrators.",
                                        "Function `perform_update`: Updates a member's role in a project while enforcing role constraints and handling potential integrity errors.",
                                        "Class MyRole: A Django API view that retrieves a Member object for authenticated users who are members of a specific project.",
                                        "Function `get_object`: Retrieves an object from the queryset based on the current user and project ID, returning a 404 error if not found."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "project.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\views\\project.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `ProjectList`\nCode:\nclass ProjectList(generics.ListCreateAPIView):\n    serializer_class = ProjectPolymorphicSerializer\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    search_fields = (\"name\", \"description\")\n    ordering_fields = [\"name\", \"created_at\", \"created_by\", \"project_type\"]\n    ordering = [\"-created_at\"]\n\n    def get_permissions(self):\n        if self.request.method == \"GET\":\n            self.permission_classes = [\n                IsAuthenticated,\n            ]\n        else:\n            self.permission_classes = [IsAuthenticated & IsAdminUser]\n        return super().get_permissions()\n\n    def get_queryset(self):\n        return Project.objects.filter(role_mappings__user=self.request.user)\n\n    def perform_create(self, serializer):\n        project = serializer.save(created_by=self.request.user)\n        project.add_admin()\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        projects = Project.objects.filter(\n            role_mappings__user=self.request.user,\n            role_mappings__role__name=settings.ROLE_PROJECT_ADMIN,\n            pk__in=delete_ids,\n        )\n        # Todo: I want to use bulk delete.\n        # But it causes the constraint error.\n        # See https://github.com/django-polymorphic/django-polymorphic/issues/229\n        for project in projects:\n            project.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Function `get_permissions`\nCode:\n    def get_permissions(self):\n        if self.request.method == \"GET\":\n            self.permission_classes = [\n                IsAuthenticated,\n            ]\n        else:\n            self.permission_classes = [IsAuthenticated & IsAdminUser]\n        return super().get_permissions()",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        return Project.objects.filter(role_mappings__user=self.request.user)",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        project = serializer.save(created_by=self.request.user)\n        project.add_admin()",
                                        "Function `delete`\nCode:\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        projects = Project.objects.filter(\n            role_mappings__user=self.request.user,\n            role_mappings__role__name=settings.ROLE_PROJECT_ADMIN,\n            pk__in=delete_ids,\n        )\n        # Todo: I want to use bulk delete.\n        # But it causes the constraint error.\n        # See https://github.com/django-polymorphic/django-polymorphic/issues/229\n        for project in projects:\n            project.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)",
                                        "Class `ProjectDetail`\nCode:\nclass ProjectDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Project.objects.all()\n    serializer_class = ProjectPolymorphicSerializer\n    lookup_url_kwarg = \"project_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]",
                                        "Class `CloneProject`\nCode:\nclass CloneProject(views.APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @transaction.atomic\n    def post(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        cloned_project = project.clone()\n        serializer = ProjectPolymorphicSerializer(cloned_project)\n        return Response(serializer.data, status=status.HTTP_201_CREATED)",
                                        "Function `post`\nCode:\n    def post(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        cloned_project = project.clone()\n        serializer = ProjectPolymorphicSerializer(cloned_project)\n        return Response(serializer.data, status=status.HTTP_201_CREATED)"
                                    ],
                                    "code": "from django.conf import settings\nfrom django.db import transaction\nfrom django.shortcuts import get_object_or_404\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import filters, generics, status, views\nfrom rest_framework.permissions import IsAdminUser, IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom projects.models import Project\nfrom projects.permissions import IsProjectAdmin, IsProjectStaffAndReadOnly\nfrom projects.serializers import ProjectPolymorphicSerializer\n\n\nclass ProjectList(generics.ListCreateAPIView):\n    serializer_class = ProjectPolymorphicSerializer\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter)\n    search_fields = (\"name\", \"description\")\n    ordering_fields = [\"name\", \"created_at\", \"created_by\", \"project_type\"]\n    ordering = [\"-created_at\"]\n\n    def get_permissions(self):\n        if self.request.method == \"GET\":\n            self.permission_classes = [\n                IsAuthenticated,\n            ]\n        else:\n            self.permission_classes = [IsAuthenticated & IsAdminUser]\n        return super().get_permissions()\n\n    def get_queryset(self):\n        return Project.objects.filter(role_mappings__user=self.request.user)\n\n    def perform_create(self, serializer):\n        project = serializer.save(created_by=self.request.user)\n        project.add_admin()\n\n    def delete(self, request, *args, **kwargs):\n        delete_ids = request.data[\"ids\"]\n        projects = Project.objects.filter(\n            role_mappings__user=self.request.user,\n            role_mappings__role__name=settings.ROLE_PROJECT_ADMIN,\n            pk__in=delete_ids,\n        )\n        # Todo: I want to use bulk delete.\n        # But it causes the constraint error.\n        # See https://github.com/django-polymorphic/django-polymorphic/issues/229\n        for project in projects:\n            project.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n\nclass ProjectDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Project.objects.all()\n    serializer_class = ProjectPolymorphicSerializer\n    lookup_url_kwarg = \"project_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n\nclass CloneProject(views.APIView):\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n\n    @transaction.atomic\n    def post(self, request, *args, **kwargs):\n        project = get_object_or_404(Project, pk=self.kwargs[\"project_id\"])\n        cloned_project = project.clone()\n        serializer = ProjectPolymorphicSerializer(cloned_project)\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n",
                                    "summary": "Class ProjectList: A view for listing and creating projects with user role-based filtering and permission management, complemented by functions for permission assignment, queryset retrieval, project creation, and bulk deletion; along with the ProjectDetail view for managing individual projects and the CloneProject API view for cloning projects by authenticated administrators.",
                                    "code_element_summaries": [
                                        "Class `ProjectList`: A view that handles listing and creating projects with filtering and permission management based on user roles, allowing authenticated users to view their projects and admins to create or delete them.",
                                        "Function `get_permissions`: Determines and assigns permission classes based on the request method, allowing only authenticated users for GET requests and requiring both authentication and admin status for other methods.",
                                        "Function `get_queryset`: Retrieves a queryset of Project objects filtered by the current user's role mappings.",
                                        "Function `perform_create`: A method that saves a new project with the current user as the creator and assigns them as an admin.",
                                        "Function `delete`: A method that deletes multiple Project instances associated with the current user, identified by IDs in the request data, while noting a future intention to implement bulk deletion despite encountering constraint errors.",
                                        "Class `ProjectDetail`: A view that handles retrieving, updating, and deleting project instances with specific permissions and a defined serializer.",
                                        "Class `CloneProject`: An API view that allows authenticated project administrators to clone a project and return the serialized data of the cloned project.",
                                        "Function `post`: Handles POST requests to clone a project identified by its ID and returns the serialized data of the cloned project with a 201 Created status."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "tag.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\views\\tag.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TagList`\nCode:\nclass TagList(generics.ListCreateAPIView):\n    serializer_class = TagSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get_queryset(self):\n        return Tag.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])",
                                        "Function `get_queryset`\nCode:\n    def get_queryset(self):\n        return Tag.objects.filter(project=self.kwargs[\"project_id\"])",
                                        "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])",
                                        "Class `TagDetail`\nCode:\nclass TagDetail(generics.DestroyAPIView):\n    queryset = Tag.objects.all()\n    serializer_class = TagSerializer\n    lookup_url_kwarg = \"tag_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]"
                                    ],
                                    "code": "from rest_framework import generics\nfrom rest_framework.permissions import IsAuthenticated\n\nfrom projects.models import Tag\nfrom projects.permissions import IsProjectAdmin, IsProjectStaffAndReadOnly\nfrom projects.serializers import TagSerializer\n\n\nclass TagList(generics.ListCreateAPIView):\n    serializer_class = TagSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n\n    def get_queryset(self):\n        return Tag.objects.filter(project=self.kwargs[\"project_id\"])\n\n    def perform_create(self, serializer):\n        serializer.save(project_id=self.kwargs[\"project_id\"])\n\n\nclass TagDetail(generics.DestroyAPIView):\n    queryset = Tag.objects.all()\n    serializer_class = TagSerializer\n    lookup_url_kwarg = \"tag_id\"\n    permission_classes = [IsAuthenticated & (IsProjectAdmin | IsProjectStaffAndReadOnly)]\n",
                                    "summary": "Class TagList and TagDetail: Views that enable authenticated users with specific permissions to list, create, and delete tags associated with a given project, with methods for retrieving filtered tag data and saving new tags.",
                                    "code_element_summaries": [
                                        "Class TagList: A view that allows authenticated users with specific permissions to list and create tags associated with a given project.",
                                        "Function `get_queryset`: Retrieves a filtered queryset of Tag objects associated with a specific project identified by the project ID in the URL parameters.",
                                        "Function `perform_create`: A method that saves a serializer with an additional project ID from the keyword arguments.",
                                        "Class TagDetail: A view that handles the deletion of Tag instances, requiring authentication and specific project-related permissions."
                                    ],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\projects\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "roles",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "Classes and components related to role management in a Django application, including admin customization, application configuration, management commands, migrations, model definitions, serializers, API testing, and URL routing for role retrieval.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\admin.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RoleAdmin`\nCode:\nclass RoleAdmin(admin.ModelAdmin):\n    list_display = (\"name\", \"description\")\n    ordering = (\"name\",)\n    search_fields = (\"name\",)"
                            ],
                            "code": "from django.contrib import admin\n\nfrom .models import Role\n\n\nclass RoleAdmin(admin.ModelAdmin):\n    list_display = (\"name\", \"description\")\n    ordering = (\"name\",)\n    search_fields = (\"name\",)\n\n\nadmin.site.register(Role, RoleAdmin)\n",
                            "summary": "Class RoleAdmin: A Django admin model that customizes the display, ordering, and search capabilities for managing roles in the admin interface.",
                            "code_element_summaries": [
                                "Class RoleAdmin: A Django admin model that configures the display, ordering, and search functionality for role management within the admin interface."
                            ],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RolesConfig`\nCode:\nclass RolesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"roles\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass RolesConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"roles\"\n",
                            "summary": "Class RolesConfig: A Django application configuration class that defines the default auto field type and sets the application name to \"roles.\"",
                            "code_element_summaries": [
                                "Class RolesConfig: A Django application configuration class that sets the default auto field type and specifies the application name as \"roles.\""
                            ],
                            "children": []
                        },
                        {
                            "name": "management",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\management",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Command: A Django management command designed to non-interactively create default user roles, incorporating error handling for missing keys and database issues.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "commands",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\management\\commands",
                                    "is_dir": true,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "Class Command: A Django management command that non-interactively creates default user roles while handling potential missing keys and database errors.",
                                    "code_element_summaries": [],
                                    "children": [
                                        {
                                            "name": "create_roles.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\management\\commands\\create_roles.py",
                                            "is_dir": false,
                                            "code_elements": [
                                                "Class `Command`\nCode:\nclass Command(BaseCommand):\n    help = \"Non-interactively create default roles\"\n\n    def handle(self, *args, **options):\n        try:\n            role_names = [settings.ROLE_PROJECT_ADMIN, settings.ROLE_ANNOTATOR, settings.ROLE_ANNOTATION_APPROVER]\n        except KeyError as key_error:\n            self.stderr.write(self.style.ERROR(f'Missing Key: \"{key_error}\"'))\n        for role_name in role_names:\n            if Role.objects.filter(name=role_name).exists():\n                continue\n            role = Role()\n            role.name = role_name\n            try:\n                role.save()\n            except DatabaseError as db_error:\n                self.stderr.write(self.style.ERROR(f'Database Error: \"{db_error}\"'))\n            else:\n                self.stdout.write(self.style.SUCCESS(f'Role created successfully \"{role_name}\"'))",
                                                "Function `handle`\nCode:\n    def handle(self, *args, **options):\n        try:\n            role_names = [settings.ROLE_PROJECT_ADMIN, settings.ROLE_ANNOTATOR, settings.ROLE_ANNOTATION_APPROVER]\n        except KeyError as key_error:\n            self.stderr.write(self.style.ERROR(f'Missing Key: \"{key_error}\"'))\n        for role_name in role_names:\n            if Role.objects.filter(name=role_name).exists():\n                continue\n            role = Role()\n            role.name = role_name\n            try:\n                role.save()\n            except DatabaseError as db_error:\n                self.stderr.write(self.style.ERROR(f'Database Error: \"{db_error}\"'))\n            else:\n                self.stdout.write(self.style.SUCCESS(f'Role created successfully \"{role_name}\"'))"
                                            ],
                                            "code": "from django.conf import settings\nfrom django.core.management.base import BaseCommand\nfrom django.db import DatabaseError\n\nfrom ...models import Role\n\n\nclass Command(BaseCommand):\n    help = \"Non-interactively create default roles\"\n\n    def handle(self, *args, **options):\n        try:\n            role_names = [settings.ROLE_PROJECT_ADMIN, settings.ROLE_ANNOTATOR, settings.ROLE_ANNOTATION_APPROVER]\n        except KeyError as key_error:\n            self.stderr.write(self.style.ERROR(f'Missing Key: \"{key_error}\"'))\n        for role_name in role_names:\n            if Role.objects.filter(name=role_name).exists():\n                continue\n            role = Role()\n            role.name = role_name\n            try:\n                role.save()\n            except DatabaseError as db_error:\n                self.stderr.write(self.style.ERROR(f'Database Error: \"{db_error}\"'))\n            else:\n                self.stdout.write(self.style.SUCCESS(f'Role created successfully \"{role_name}\"'))\n",
                                            "summary": "Class Command: A Django management command that non-interactively creates default user roles, managing potential missing keys and database errors during the process.",
                                            "code_element_summaries": [
                                                "Class Command: A Django management command that non-interactively creates default roles while handling potential missing keys and database errors.",
                                                "Function `handle`: A method that attempts to create specific user roles in the database, handling missing keys and database errors while providing feedback on successful role creation."
                                            ],
                                            "children": []
                                        },
                                        {
                                            "name": "__init__.py",
                                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\management\\commands\\__init__.py",
                                            "is_dir": false,
                                            "code_elements": [],
                                            "code": "",
                                            "summary": "",
                                            "code_element_summaries": [],
                                            "children": []
                                        }
                                    ]
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\management\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class Migration: A series of Django migrations that manage user roles through the Role and RoleMapping models, rename RoleMapping to Member, and ultimately remove the Member model while renaming its database table.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "0001_initial.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\migrations\\0001_initial.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Role\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"name\", models.CharField(max_length=100, unique=True)),\n                        (\"description\", models.TextField(default=\"\")),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"RoleMapping\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\"role\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"roles.role\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"user\", \"project\")},\n                    },\n                ),\n            ],\n            database_operations=[],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-11 06:55\n\nfrom django.conf import settings\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\n\nclass Migration(migrations.Migration):\n\n    initial = True\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name=\"Role\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"name\", models.CharField(max_length=100, unique=True)),\n                        (\"description\", models.TextField(default=\"\")),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                    ],\n                ),\n                migrations.CreateModel(\n                    name=\"RoleMapping\",\n                    fields=[\n                        (\n                            \"id\",\n                            models.BigAutoField(\n                                auto_created=True, primary_key=True, serialize=False, verbose_name=\"ID\"\n                            ),\n                        ),\n                        (\"created_at\", models.DateTimeField(auto_now_add=True)),\n                        (\"updated_at\", models.DateTimeField(auto_now=True)),\n                        (\n                            \"project\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=\"api.project\",\n                            ),\n                        ),\n                        (\"role\", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=\"roles.role\")),\n                        (\n                            \"user\",\n                            models.ForeignKey(\n                                on_delete=django.db.models.deletion.CASCADE,\n                                related_name=\"role_mappings\",\n                                to=settings.AUTH_USER_MODEL,\n                            ),\n                        ),\n                    ],\n                    options={\n                        \"unique_together\": {(\"user\", \"project\")},\n                    },\n                ),\n            ],\n            database_operations=[],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that defines the Role and RoleMapping models for managing user roles in projects, including their relationships and constraints.",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that creates two models, Role and RoleMapping, to manage user roles within projects, establishing relationships and constraints."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0002_rename_rolemapping_member.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\migrations\\0002_rename_rolemapping_member.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n        (\"roles\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RoleMapping\",\n            new_name=\"Member\",\n        ),\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-12 23:06\n\nfrom django.conf import settings\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        migrations.swappable_dependency(settings.AUTH_USER_MODEL),\n        (\"api\", \"0028_auto_20220111_0655\"),\n        (\"roles\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.RenameModel(\n            old_name=\"RoleMapping\",\n            new_name=\"Member\",\n        ),\n    ]\n",
                                    "summary": "Class Migration: A Django migration that renames the `RoleMapping` model to `Member` and sets up dependencies on user and other application models.",
                                    "code_element_summaries": [
                                        "Class `Migration`: A Django migration that renames the model `RoleMapping` to `Member` while establishing dependencies on user and other application models."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "0003_delete_member.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\migrations\\0003_delete_member.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `Migration`\nCode:\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"roles\", \"0002_rename_rolemapping_member\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Member\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(\n                    name=\"Member\",\n                    table=\"members_member\",\n                ),\n            ],\n        )\n    ]"
                                    ],
                                    "code": "# Generated by Django 3.2.8 on 2022-01-13 01:54\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        (\"roles\", \"0002_rename_rolemapping_member\"),\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name=\"Member\",\n                ),\n            ],\n            database_operations=[\n                migrations.AlterModelTable(\n                    name=\"Member\",\n                    table=\"members_member\",\n                ),\n            ],\n        )\n    ]\n",
                                    "summary": "Class Migration: A Django migration that removes the \"Member\" model and renames its corresponding database table to \"members_member\".",
                                    "code_element_summaries": [
                                        "Class Migration: A Django migration that deletes the \"Member\" model and alters its database table name to \"members_member\"."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\models.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Role`\nCode:\nclass Role(models.Model):\n    name = models.CharField(max_length=100, unique=True)\n    description = models.TextField(default=\"\")\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.name",
                                "Function `__str__`\nCode:\n    def __str__(self):\n        return self.name"
                            ],
                            "code": "from django.db import models\n\n\nclass Role(models.Model):\n    name = models.CharField(max_length=100, unique=True)\n    description = models.TextField(default=\"\")\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.name\n",
                            "summary": "Class Role: A Django model that defines a user role with a unique name, description, and timestamps, along with a method to return its string representation.",
                            "code_element_summaries": [
                                "Class `Role`: A Django model that represents a user role with a unique name, description, and timestamps for creation and updates.",
                                "Function `__str__`: Returns the string representation of the object by providing its name."
                            ],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `RoleSerializer`\nCode:\nclass RoleSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Role\n        fields = (\"id\", \"name\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = Role\n        fields = (\"id\", \"name\")"
                            ],
                            "code": "from rest_framework import serializers\n\nfrom .models import Role\n\n\nclass RoleSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Role\n        fields = (\"id\", \"name\")\n",
                            "summary": "Class RoleSerializer: A serializer for the Role model that formats data representation to include the \"id\" and \"name\" fields.",
                            "code_element_summaries": [
                                "Class RoleSerializer: A serializer for the Role model that includes the fields \"id\" and \"name\" for data representation.",
                                "Class Meta: A configuration class that specifies the model as Role and defines the fields to be included as \"id\" and \"name\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class TestRoleAPI: A test case that checks role access permissions for authenticated and unauthenticated users, including methods for setting up test data and verifying outcomes, along with a function `create_default_roles` that initializes default roles for project administrators, annotators, and annotation approvers.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestRoleAPI`\nCode:\nclass TestRoleAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"roles\")\n\n    def test_allows_authenticated_user_to_get_roles(self):\n        self.assert_fetch(self.user, status.HTTP_200_OK)\n\n    def test_denies_unauthenticated_user_to_get_roles(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"roles\")",
                                        "Function `test_allows_authenticated_user_to_get_roles`\nCode:\n    def test_allows_authenticated_user_to_get_roles(self):\n        self.assert_fetch(self.user, status.HTTP_200_OK)",
                                        "Function `test_denies_unauthenticated_user_to_get_roles`\nCode:\n    def test_denies_unauthenticated_user_to_get_roles(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\n\nfrom .utils import create_default_roles\nfrom api.tests.utils import CRUDMixin\nfrom users.tests.utils import make_user\n\n\nclass TestRoleAPI(CRUDMixin):\n    @classmethod\n    def setUpTestData(cls):\n        create_default_roles()\n        cls.user = make_user()\n        cls.url = reverse(viewname=\"roles\")\n\n    def test_allows_authenticated_user_to_get_roles(self):\n        self.assert_fetch(self.user, status.HTTP_200_OK)\n\n    def test_denies_unauthenticated_user_to_get_roles(self):\n        self.assert_fetch(expected=status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Class TestRoleAPI: A test case designed to validate role access permissions, ensuring that authenticated users can retrieve roles while unauthenticated users are denied access, with methods for setting up test data and verifying the expected outcomes for both user types.",
                                    "code_element_summaries": [
                                        "Class TestRoleAPI: A test case for verifying role access permissions, ensuring authenticated users can retrieve roles while unauthenticated users are denied access.",
                                        "Function `setUpTestData`: A class method that initializes test data by creating default roles and a user, and sets the URL for the roles view.",
                                        "Function `test_allows_authenticated_user_to_get_roles`: A test that verifies an authenticated user can successfully fetch roles with a 200 OK status.",
                                        "Function `test_denies_unauthenticated_user_to_get_roles`: A test function that verifies that unauthenticated users receive a 403 Forbidden status when attempting to fetch roles."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `create_default_roles`\nCode:\ndef create_default_roles():\n    Role.objects.get_or_create(name=settings.ROLE_PROJECT_ADMIN)\n    Role.objects.get_or_create(name=settings.ROLE_ANNOTATOR)\n    Role.objects.get_or_create(name=settings.ROLE_ANNOTATION_APPROVER)"
                                    ],
                                    "code": "from django.conf import settings\n\nfrom roles.models import Role\n\n\ndef create_default_roles():\n    Role.objects.get_or_create(name=settings.ROLE_PROJECT_ADMIN)\n    Role.objects.get_or_create(name=settings.ROLE_ANNOTATOR)\n    Role.objects.get_or_create(name=settings.ROLE_ANNOTATION_APPROVER)\n",
                                    "summary": "Function `create_default_roles`: Initializes the system with default roles for project administrators, annotators, and annotation approvers by retrieving or creating them according to the specified settings.",
                                    "code_element_summaries": [
                                        "Function `create_default_roles`: Initializes default roles in the system by retrieving or creating roles for project administrators, annotators, and annotation approvers based on settings."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import Roles\n\nurlpatterns = [path(route=\"roles\", view=Roles.as_view(), name=\"roles\")]\n",
                            "summary": "URL Configuration: Defines a URL pattern that maps the route \"roles\" to the Roles view in a Django application.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Roles`\nCode:\nclass Roles(generics.ListAPIView):\n    serializer_class = RoleSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated]\n    queryset = Role.objects.all()"
                            ],
                            "code": "from rest_framework import generics\nfrom rest_framework.permissions import IsAuthenticated\n\nfrom .models import Role\nfrom .serializers import RoleSerializer\n\n\nclass Roles(generics.ListAPIView):\n    serializer_class = RoleSerializer\n    pagination_class = None\n    permission_classes = [IsAuthenticated]\n    queryset = Role.objects.all()\n",
                            "summary": "Class Roles: A ListAPIView that provides an authenticated endpoint to retrieve a list of Role objects serialized with RoleSerializer, without pagination.",
                            "code_element_summaries": [
                                "Class Roles: A ListAPIView that returns a list of Role objects, requiring authentication and using RoleSerializer for serialization without pagination."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\roles\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "social",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content describes various classes and configurations in a Django application, including a proxy model for bounding boxes, application configuration for the social app, a view for managing Okta social login, URL mappings for the login view, and an API view for retrieving OAuth2 configuration details.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\admin.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class ExportedBoundingBox: A proxy model of BoundingBox that provides methods to convert bounding box attributes into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `SocialConfig`\nCode:\nclass SocialConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"social\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass SocialConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"social\"\n",
                            "summary": "Class SocialConfig: A Django application configuration class for the \"social\" app that sets the default auto field type for database models.",
                            "code_element_summaries": [
                                "Class SocialConfig: A Django application configuration class for the \"social\" app, specifying the default auto field type."
                            ],
                            "children": []
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\models.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class ExportedBoundingBox: A proxy model of BoundingBox that provides methods to convert bounding box data into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "okta.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\okta.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `OktaLogin`\nCode:\nclass OktaLogin(SocialLoginView):\n    adapter_class = OktaOAuth2Adapter\n    callback_url = \"/projects\"\n    client_class = OAuth2Client"
                            ],
                            "code": "from allauth.socialaccount.providers.oauth2.client import OAuth2Client\nfrom allauth.socialaccount.providers.okta.views import OktaOAuth2Adapter\nfrom dj_rest_auth.registration.views import SocialLoginView\n\n\nclass OktaLogin(SocialLoginView):\n    adapter_class = OktaOAuth2Adapter\n    callback_url = \"/projects\"\n    client_class = OAuth2Client\n",
                            "summary": "Class OktaLogin: A view designed to manage social login through Okta using an OAuth2 adapter, with defined callback URL and client class.",
                            "code_element_summaries": [
                                "Class OktaLogin: A view for handling social login via Okta, utilizing an OAuth2 adapter and specifying a callback URL and client class."
                            ],
                            "children": []
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .okta import OktaLogin\n\nurlpatterns = [\n    path(\"complete/okta-oauth2/\", OktaLogin.as_view(), name=\"okta_login\"),\n]\n",
                            "summary": "URL Configuration: Defines a URL pattern for the Okta OAuth2 login view in a Django application.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "v1_urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\v1_urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import path\n\nfrom .views import Social\n\nurlpatterns = [\n    path(\"links/\", Social.as_view()),\n]\n",
                            "summary": "URL configuration for the Django application that maps the \"links/\" path to the Social view.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Social`\nCode:\nclass Social(APIView):\n    permission_classes = ()\n\n    def get(self, request, *args, **kwargs):\n        return Response(\n            {\n                \"okta\": {\n                    \"type\": \"oauth2\",\n                    \"base_url\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\"),\n                    \"client_id\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\"),\n                    \"redirect_path\": \"/social/complete/okta-oauth2\",\n                    \"authorize_url\": \"https://\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                    + \"/oauth2/v1/authorize?response_type=code&client_id=\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\")\n                    + \"&scope=openid&state=unknown&response_mode=form_post\",\n                }\n                if settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                else {},\n            }\n        )",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        return Response(\n            {\n                \"okta\": {\n                    \"type\": \"oauth2\",\n                    \"base_url\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\"),\n                    \"client_id\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\"),\n                    \"redirect_path\": \"/social/complete/okta-oauth2\",\n                    \"authorize_url\": \"https://\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                    + \"/oauth2/v1/authorize?response_type=code&client_id=\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\")\n                    + \"&scope=openid&state=unknown&response_mode=form_post\",\n                }\n                if settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                else {},\n            }\n        )"
                            ],
                            "code": "from django.conf import settings\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\n\nclass Social(APIView):\n    permission_classes = ()\n\n    def get(self, request, *args, **kwargs):\n        return Response(\n            {\n                \"okta\": {\n                    \"type\": \"oauth2\",\n                    \"base_url\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\"),\n                    \"client_id\": settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\"),\n                    \"redirect_path\": \"/social/complete/okta-oauth2\",\n                    \"authorize_url\": \"https://\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                    + \"/oauth2/v1/authorize?response_type=code&client_id=\"\n                    + settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"APP\").get(\"client_id\")\n                    + \"&scope=openid&state=unknown&response_mode=form_post\",\n                }\n                if settings.SOCIALACCOUNT_PROVIDERS.get(\"okta\").get(\"OKTA_BASE_URL\")\n                else {},\n            }\n        )\n",
                            "summary": "Class `Social`: An API view that retrieves and returns OAuth2 configuration details for the Okta social authentication provider in JSON format.",
                            "code_element_summaries": [
                                "Class `Social`: An API view that provides OAuth2 configuration details for the Okta social authentication provider.",
                                "Function `get`: Returns a JSON response containing OAuth2 configuration details for Okta, including the base URL, client ID, redirect path, and authorization URL, based on the settings provided."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\social\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "users",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users",
                    "is_dir": true,
                    "code_elements": [],
                    "code": "",
                    "summary": "The content describes various classes and configurations for a Django API that manage user data, including a proxy model for bounding boxes, application configuration, user serialization, test cases for API functionality, and URL patterns for user-related views.",
                    "code_element_summaries": [],
                    "children": [
                        {
                            "name": "admin.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\admin.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class ExportedBoundingBox: A proxy model of BoundingBox that provides methods to convert bounding box data into dictionary and tuple formats.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "apps.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\apps.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `UsersConfig`\nCode:\nclass UsersConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"users\""
                            ],
                            "code": "from django.apps import AppConfig\n\n\nclass UsersConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"users\"\n",
                            "summary": "Class UsersConfig: A Django application configuration class that defines the default auto field type and sets the application name to \"users\".",
                            "code_element_summaries": [
                                "Class UsersConfig: A Django application configuration class that sets the default auto field type and specifies the application name as \"users\"."
                            ],
                            "children": []
                        },
                        {
                            "name": "migrations",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\migrations",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\migrations\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "models.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\models.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "Class ExportedBoundingBox: A proxy model of BoundingBox that provides methods to convert bounding box data into dictionary and tuple formats for easier manipulation and access.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "serializers.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\serializers.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `UserSerializer`\nCode:\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = get_user_model()\n        fields = (\"id\", \"username\", \"is_superuser\", \"is_staff\")",
                                "Class `Meta`\nCode:\n    class Meta:\n        model = get_user_model()\n        fields = (\"id\", \"username\", \"is_superuser\", \"is_staff\")"
                            ],
                            "code": "from django.contrib.auth import get_user_model\nfrom rest_framework import serializers\n\n\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = get_user_model()\n        fields = (\"id\", \"username\", \"is_superuser\", \"is_staff\")\n",
                            "summary": "Class UserSerializer: A serializer for the user model that includes and configures fields for the user's ID, username, superuser status, and staff status.",
                            "code_element_summaries": [
                                "Class `UserSerializer`: A serializer for the user model that includes fields for the user's ID, username, superuser status, and staff status.",
                                "Class Meta: A configuration class that defines the model and fields for user-related data, specifying the user model and including fields for id, username, superuser status, and staff status."
                            ],
                            "children": []
                        },
                        {
                            "name": "tests",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\tests",
                            "is_dir": true,
                            "code_elements": [],
                            "code": "",
                            "summary": "Classes TestUserAPI, TestMeAPI, and TestUserCreationAPI: Test cases that ensure proper functionality and access control for user retrieval and creation in an API, along with a utility function `make_user` for user creation or retrieval based on specified parameters.",
                            "code_element_summaries": [],
                            "children": [
                                {
                                    "name": "test_views.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\tests\\test_views.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Class `TestUserAPI`\nCode:\nclass TestUserAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"user_list\")\n\n    def test_allows_authenticated_user_to_get_users(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertEqual(response.data[0][\"username\"], self.user.username)\n\n    def test_denies_unauthenticated_user_to_get_users(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"user_list\")",
                                        "Function `test_allows_authenticated_user_to_get_users`\nCode:\n    def test_allows_authenticated_user_to_get_users(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertEqual(response.data[0][\"username\"], self.user.username)",
                                        "Function `test_denies_unauthenticated_user_to_get_users`\nCode:\n    def test_denies_unauthenticated_user_to_get_users(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)",
                                        "Class `TestMeAPI`\nCode:\nclass TestMeAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"me\")\n\n    def test_return_own_information(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.data[\"id\"], self.user.id)\n        self.assertEqual(response.data[\"username\"], self.user.username)\n\n    def test_does_not_return_information_to_unauthenticated_user(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"me\")",
                                        "Function `test_return_own_information`\nCode:\n    def test_return_own_information(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.data[\"id\"], self.user.id)\n        self.assertEqual(response.data[\"username\"], self.user.username)",
                                        "Function `test_does_not_return_information_to_unauthenticated_user`\nCode:\n    def test_does_not_return_information_to_unauthenticated_user(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)",
                                        "Class `TestUserCreationAPI`\nCode:\nclass TestUserCreationAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.staff = make_user(username=\"bob\", is_staff=True)\n        cls.non_staff = make_user(username=\"tom\", is_staff=False)\n        cls.url = reverse(viewname=\"user_create\")\n        cls.payload = {\"username\": \"hironsan\", \"password1\": \"foobarbaz\", \"password2\": \"foobarbaz\"}\n\n    def test_staff_can_create_user(self):\n        self.client.force_login(self.staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.data[\"username\"], \"hironsan\")\n\n    def test_non_staff_cannot_create_user(self):\n        self.client.force_login(self.non_staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)",
                                        "Function `setUpTestData`\nCode:\n    def setUpTestData(cls):\n        cls.staff = make_user(username=\"bob\", is_staff=True)\n        cls.non_staff = make_user(username=\"tom\", is_staff=False)\n        cls.url = reverse(viewname=\"user_create\")\n        cls.payload = {\"username\": \"hironsan\", \"password1\": \"foobarbaz\", \"password2\": \"foobarbaz\"}",
                                        "Function `test_staff_can_create_user`\nCode:\n    def test_staff_can_create_user(self):\n        self.client.force_login(self.staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.data[\"username\"], \"hironsan\")",
                                        "Function `test_non_staff_cannot_create_user`\nCode:\n    def test_non_staff_cannot_create_user(self):\n        self.client.force_login(self.non_staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)"
                                    ],
                                    "code": "from rest_framework import status\nfrom rest_framework.reverse import reverse\nfrom rest_framework.test import APITestCase\n\nfrom .utils import make_user\n\n\nclass TestUserAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"user_list\")\n\n    def test_allows_authenticated_user_to_get_users(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n        self.assertEqual(response.data[0][\"username\"], self.user.username)\n\n    def test_denies_unauthenticated_user_to_get_users(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\n\n\nclass TestMeAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.user = make_user(username=\"bob\")\n        cls.url = reverse(viewname=\"me\")\n\n    def test_return_own_information(self):\n        self.client.force_login(self.user)\n        response = self.client.get(self.url)\n        self.assertEqual(response.data[\"id\"], self.user.id)\n        self.assertEqual(response.data[\"username\"], self.user.username)\n\n    def test_does_not_return_information_to_unauthenticated_user(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\n\n\nclass TestUserCreationAPI(APITestCase):\n    @classmethod\n    def setUpTestData(cls):\n        cls.staff = make_user(username=\"bob\", is_staff=True)\n        cls.non_staff = make_user(username=\"tom\", is_staff=False)\n        cls.url = reverse(viewname=\"user_create\")\n        cls.payload = {\"username\": \"hironsan\", \"password1\": \"foobarbaz\", \"password2\": \"foobarbaz\"}\n\n    def test_staff_can_create_user(self):\n        self.client.force_login(self.staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.data[\"username\"], \"hironsan\")\n\n    def test_non_staff_cannot_create_user(self):\n        self.client.force_login(self.non_staff)\n        response = self.client.post(self.url, data=self.payload)\n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\n",
                                    "summary": "Classes TestUserAPI, TestMeAPI, and TestUserCreationAPI: Test cases that validate user retrieval and creation functionalities in an API, ensuring proper access for authenticated users and restrictions for unauthenticated or non-staff users.",
                                    "code_element_summaries": [
                                        "Class TestUserAPI: A test case that verifies the user retrieval functionality, ensuring authenticated users can access user data while unauthenticated users are denied access.",
                                        "Function `setUpTestData`: A class method that initializes test data by creating a user with the username \"bob\" and generating a URL for the user list view.",
                                        "Function `test_allows_authenticated_user_to_get_users`: A test that verifies an authenticated user can successfully retrieve their own user information with a 200 OK status and correct username in the response.",
                                        "Function `test_denies_unauthenticated_user_to_get_users`: A test that verifies an unauthenticated user receives a 403 Forbidden status when attempting to access the users endpoint.",
                                        "Class TestMeAPI: A test case for the API that verifies user information retrieval for authenticated users and ensures access is forbidden for unauthenticated users.",
                                        "Function `setUpTestData`: A class method that initializes test data by creating a user with the username \"bob\" and defining a URL for the view named \"me\".",
                                        "Function `test_return_own_information`: A test case that verifies a logged-in user can retrieve their own ID and username from the API response.",
                                        "Function `test_does_not_return_information_to_unauthenticated_user`: A test case that verifies an unauthenticated user receives a 403 Forbidden status when attempting to access a specific URL.",
                                        "Class TestUserCreationAPI: A test case that verifies user creation functionality, ensuring that staff users can create new users while non-staff users are forbidden from doing so.",
                                        "Function `setUpTestData`: A class method that initializes test data by creating a staff user, a non-staff user, and setting up a URL and payload for user creation.",
                                        "Function `test_staff_can_create_user`: A test case that verifies a staff member can successfully create a user by checking the returned username in the response.",
                                        "Function `test_non_staff_cannot_create_user`: A test case that verifies non-staff users are forbidden from creating a new user, expecting a 403 Forbidden response."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "utils.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\tests\\utils.py",
                                    "is_dir": false,
                                    "code_elements": [
                                        "Function `make_user`\nCode:\ndef make_user(username: str = \"bob\", is_staff: bool = False):\n    user_model = get_user_model()\n    user, _ = user_model.objects.get_or_create(username=username, password=\"pass\", is_staff=is_staff)\n    return user"
                                    ],
                                    "code": "from django.contrib.auth import get_user_model\n\n\ndef make_user(username: str = \"bob\", is_staff: bool = False):\n    user_model = get_user_model()\n    user, _ = user_model.objects.get_or_create(username=username, password=\"pass\", is_staff=is_staff)\n    return user\n",
                                    "summary": "Function `make_user`: A utility function that creates or retrieves a user based on a given username and staff status, with default values set to \"bob\" and non-staff.",
                                    "code_element_summaries": [
                                        "Function `make_user`: A utility function that creates or retrieves a user with a specified username and staff status, defaulting to \"bob\" and non-staff."
                                    ],
                                    "children": []
                                },
                                {
                                    "name": "__init__.py",
                                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\tests\\__init__.py",
                                    "is_dir": false,
                                    "code_elements": [],
                                    "code": "",
                                    "summary": "",
                                    "code_element_summaries": [],
                                    "children": []
                                }
                            ]
                        },
                        {
                            "name": "urls.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\urls.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "from django.urls import include, path\n\nfrom .views import Me, UserCreation, Users\n\nurlpatterns = [\n    path(route=\"me\", view=Me.as_view(), name=\"me\"),\n    path(route=\"users\", view=Users.as_view(), name=\"user_list\"),\n    path(route=\"users/create\", view=UserCreation.as_view(), name=\"user_create\"),\n    path(\"auth/\", include(\"dj_rest_auth.urls\")),\n]\n",
                            "summary": "URL Configuration: Defines URL patterns for user-related views, including retrieving user information, listing users, creating new users, and authentication endpoints.",
                            "code_element_summaries": [],
                            "children": []
                        },
                        {
                            "name": "views.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\views.py",
                            "is_dir": false,
                            "code_elements": [
                                "Class `Me`\nCode:\nclass Me(APIView):\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, *args, **kwargs):\n        serializer = UserSerializer(request.user, context={\"request\": request})\n        return Response(serializer.data)",
                                "Function `get`\nCode:\n    def get(self, request, *args, **kwargs):\n        serializer = UserSerializer(request.user, context={\"request\": request})\n        return Response(serializer.data)",
                                "Class `Users`\nCode:\nclass Users(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n    pagination_class = None\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter)\n    search_fields = (\"username\",)",
                                "Class `UserCreation`\nCode:\nclass UserCreation(generics.CreateAPIView):\n    serializer_class = RegisterSerializer\n    permission_classes = [IsAuthenticated & IsAdminUser]\n\n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        user = self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        return Response(UserSerializer(user).data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def perform_create(self, serializer):\n        user = serializer.save(self.request)\n        return user",
                                "Function `create`\nCode:\n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        user = self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        return Response(UserSerializer(user).data, status=status.HTTP_201_CREATED, headers=headers)",
                                "Function `perform_create`\nCode:\n    def perform_create(self, serializer):\n        user = serializer.save(self.request)\n        return user"
                            ],
                            "code": "from dj_rest_auth.registration.serializers import RegisterSerializer\nfrom django.contrib.auth.models import User\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import filters, generics, status\nfrom rest_framework.permissions import IsAdminUser, IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nfrom .serializers import UserSerializer\nfrom projects.permissions import IsProjectAdmin\n\n\nclass Me(APIView):\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, *args, **kwargs):\n        serializer = UserSerializer(request.user, context={\"request\": request})\n        return Response(serializer.data)\n\n\nclass Users(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    permission_classes = [IsAuthenticated & IsProjectAdmin]\n    pagination_class = None\n    filter_backends = (DjangoFilterBackend, filters.SearchFilter)\n    search_fields = (\"username\",)\n\n\nclass UserCreation(generics.CreateAPIView):\n    serializer_class = RegisterSerializer\n    permission_classes = [IsAuthenticated & IsAdminUser]\n\n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        user = self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        return Response(UserSerializer(user).data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def perform_create(self, serializer):\n        user = serializer.save(self.request)\n        return user\n",
                            "summary": "Classes and functions for a Django API that manage user data, including retrieving authenticated user information, listing users with filtering for project admins, and creating new users with validation and response formatting.",
                            "code_element_summaries": [
                                "Class `Me`: An API view that returns the serialized data of the authenticated user.",
                                "Function `get`: Retrieves user data by serializing the authenticated user and returning it in the response.",
                                "Class `Users`: A ListAPIView that retrieves a list of User objects with filtering and search capabilities, restricted to authenticated users with project admin permissions.",
                                "Class `UserCreation`: A Django API view that handles the creation of new users with authentication and admin permissions, utilizing a serializer for validation and response formatting.",
                                "Function `create`: A method that validates incoming data, creates a new user, and returns the serialized user data along with a 201 HTTP status and appropriate headers.",
                                "Function `perform_create`: A method that saves a user object from the serializer and returns the created user instance."
                            ],
                            "children": []
                        },
                        {
                            "name": "__init__.py",
                            "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\users\\__init__.py",
                            "is_dir": false,
                            "code_elements": [],
                            "code": "",
                            "summary": "",
                            "code_element_summaries": [],
                            "children": []
                        }
                    ]
                },
                {
                    "name": "__init__.py",
                    "path": "C:\\Users\\Yifan\\Desktop\\839\\839-project\\dataset\\doccano-master\\backend\\__init__.py",
                    "is_dir": false,
                    "code_elements": [],
                    "code": "",
                    "summary": "",
                    "code_element_summaries": [],
                    "children": []
                }
            ]
        }
    ]
}